        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/LLVMIR/IR/LLVMDialect.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMDialect.dir/IR/LLVMDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMDialect.dir/IR/LLVMDialect.cpp.gcda
        -:    0:Runs:128628
        -:    1://===- LLVMDialect.cpp - LLVM IR Ops and Dialect registration -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the types and operation details for the LLVM IR dialect in
        -:   10:// MLIR, and the LLVM IR dialect.  It also registers the dialect.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   14:#include "TypeDetail.h"
        -:   15:#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
        -:   16:#include "mlir/IR/Builders.h"
        -:   17:#include "mlir/IR/BuiltinOps.h"
        -:   18:#include "mlir/IR/BuiltinTypes.h"
        -:   19:#include "mlir/IR/DialectImplementation.h"
        -:   20:#include "mlir/IR/FunctionImplementation.h"
        -:   21:#include "mlir/IR/MLIRContext.h"
        -:   22:#include "mlir/IR/Matchers.h"
        -:   23:
        -:   24:#include "llvm/ADT/TypeSwitch.h"
        -:   25:#include "llvm/AsmParser/Parser.h"
        -:   26:#include "llvm/Bitcode/BitcodeReader.h"
        -:   27:#include "llvm/Bitcode/BitcodeWriter.h"
        -:   28:#include "llvm/IR/Attributes.h"
        -:   29:#include "llvm/IR/Function.h"
        -:   30:#include "llvm/IR/Type.h"
        -:   31:#include "llvm/Support/Error.h"
        -:   32:#include "llvm/Support/Mutex.h"
        -:   33:#include "llvm/Support/SourceMgr.h"
        -:   34:
        -:   35:#include <numeric>
        -:   36:
        -:   37:using namespace mlir;
        -:   38:using namespace mlir::LLVM;
        -:   39:using mlir::LLVM::cconv::getMaxEnumValForCConv;
        -:   40:using mlir::LLVM::linkage::getMaxEnumValForLinkage;
        -:   41:
        -:   42:#include "mlir/Dialect/LLVMIR/LLVMOpsDialect.cpp.inc"
        -:   43:
        -:   44:static constexpr const char kVolatileAttrName[] = "volatile_";
        -:   45:static constexpr const char kNonTemporalAttrName[] = "nontemporal";
        -:   46:static constexpr const char kElemTypeAttrName[] = "elem_type";
        -:   47:
        -:   48:#include "mlir/Dialect/LLVMIR/LLVMOpsInterfaces.cpp.inc"
        -:   49:
function _ZL14processFMFAttrN4llvm8ArrayRefIN4mlir14NamedAttributeEEE called 26916906 returned 100% blocks executed 100%
 26916906:   50:static auto processFMFAttr(ArrayRef<NamedAttribute> attrs) {
 26916906:   51:  SmallVector<NamedAttribute, 8> filteredAttrs(
function _ZZL14processFMFAttrN4llvm8ArrayRefIN4mlir14NamedAttributeEEEENKUlS2_E_clES2_.isra.0 called 17312769 returned 100% blocks executed 100%
 17312769:   52:      llvm::make_filter_range(attrs, [&](NamedAttribute attr) {
 17312769:   53:        if (attr.getName() == "fastmathFlags") {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
 11542245:   54:          auto defAttr =
 11542245:   55:              FastmathFlagsAttr::get(attr.getValue().getContext(), {});
call    0 returned 100%
call    1 returned 100%
 11542245:   56:          return defAttr != attr.getValue();
        -:   57:        }
        -:   58:        return true;
 26916906:   59:      }));
call    0 returned 100%
call    1 returned 100%
 26916906:   60:  return filteredAttrs;
        -:   61:}
        -:   62:
11119439*:   63:static ParseResult parseLLVMOpAttrs(OpAsmParser &parser,
        -:   64:                                    NamedAttrList &result) {
11119439*:   65:  return parser.parseOptionalAttrDict(result);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 returned 100%
call   11 never executed
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 never executed
        -:   66:}
        -:   67:
        -:   68:static void printLLVMOpAttrs(OpAsmPrinter &printer, Operation *op,
        -:   69:                             DictionaryAttr attrs) {
        -:   70:  printer.printOptionalAttrDict(processFMFAttr(attrs.getValue()));
        -:   71:}
        -:   72:
        -:   73:/// Verifies `symbol`'s use in `op` to ensure the symbol is a valid and
        -:   74:/// fully defined llvm.func.
function _ZL19verifySymbolAttrUseN4mlir17FlatSymbolRefAttrEPNS_9OperationERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####:   75:static LogicalResult verifySymbolAttrUse(FlatSymbolRefAttr symbol,
        -:   76:                                         Operation *op,
        -:   77:                                         SymbolTableCollection &symbolTable) {
    #####:   78:  StringRef name = symbol.getValue();
call    0 never executed
    #####:   79:  auto func =
call    0 never executed
    #####:   80:      symbolTable.lookupNearestSymbolFrom<LLVMFuncOp>(op, symbol.getAttr());
call    0 never executed
    #####:   81:  if (!func)
branch  0 never executed
branch  1 never executed
    #####:   82:    return op->emitOpError("'")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   83:           << name << "' does not reference a valid LLVM function";
call    0 never executed
call    1 never executed
    #####:   84:  if (func.isExternal())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   85:    return op->emitOpError("'") << name << "' does not have a definition";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:   86:  return success();
        -:   87:}
        -:   88:
        -:   89:/// Returns a boolean type that has the same shape as `type`. It supports both
        -:   90:/// fixed size vectors as well as scalable vectors.
function _ZL14getI1SameShapeN4mlir4TypeE called 35469892 returned 100% blocks executed 67%
 35469892:   91:static Type getI1SameShape(Type type) {
 35469892:   92:  Type i1Type = IntegerType::get(type.getContext(), 1);
call    0 returned 100%
call    1 returned 100%
 35470943:   93:  if (LLVM::isCompatibleVectorType(type))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   94:    return LLVM::getVectorType(i1Type, LLVM::getVectorNumElements(type));
call    0 never executed
call    1 never executed
 35471246:   95:  return i1Type;
        -:   96:}
        -:   97:
        -:   98://===----------------------------------------------------------------------===//
        -:   99:// Printing, parsing and builder for LLVM::CmpOp.
        -:  100://===----------------------------------------------------------------------===//
        -:  101:
function _ZN4mlir4LLVM6ICmpOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_13ICmpPredicateENS_5ValueES7_ called 0 returned 0% blocks executed 0%
    #####:  102:void ICmpOp::build(OpBuilder &builder, OperationState &result,
        -:  103:                   ICmpPredicate predicate, Value lhs, Value rhs) {
    #####:  104:  build(builder, result, getI1SameShape(lhs.getType()), predicate, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  105:}
        -:  106:
function _ZN4mlir4LLVM6FCmpOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_13FCmpPredicateENS_5ValueES7_ called 0 returned 0% blocks executed 0%
    #####:  107:void FCmpOp::build(OpBuilder &builder, OperationState &result,
        -:  108:                   FCmpPredicate predicate, Value lhs, Value rhs) {
    #####:  109:  build(builder, result, getI1SameShape(lhs.getType()), predicate, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  110:}
        -:  111:
function _ZN4mlir4LLVM6ICmpOp5printERNS_12OpAsmPrinterE called 5862468 returned 100% blocks executed 100%
  5862468:  112:void ICmpOp::print(OpAsmPrinter &p) {
 29312340:  113:  p << " \"" << stringifyICmpPredicate(getPredicate()) << "\" " << getOperand(0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
 11724936:  114:    << ", " << getOperand(1);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  5862468:  115:  p.printOptionalAttrDict((*this)->getAttrs(), {"predicate"});
call    0 returned 100%
call    1 returned 100%
 11724936:  116:  p << " : " << getLhs().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  5862468:  117:}
        -:  118:
function _ZN4mlir4LLVM6FCmpOp5printERNS_12OpAsmPrinterE called 5596 returned 100% blocks executed 96%
     5596:  119:void FCmpOp::print(OpAsmPrinter &p) {
    27980:  120:  p << " \"" << stringifyFCmpPredicate(getPredicate()) << "\" " << getOperand(0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
    11192:  121:    << ", " << getOperand(1);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     5596:  122:  p.printOptionalAttrDict(processFMFAttr((*this)->getAttrs()), {"predicate"});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    11192:  123:  p << " : " << getLhs().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     5596:  124:}
        -:  125:
        -:  126:// <operation> ::= `llvm.icmp` string-literal ssa-use `,` ssa-use
        -:  127://                 attribute-dict? `:` type
        -:  128:// <operation> ::= `llvm.fcmp` string-literal ssa-use `,` ssa-use
        -:  129://                 attribute-dict? `:` type
        -:  130:template <typename CmpPredicateType>
  3078117:  131:static ParseResult parseCmpOp(OpAsmParser &parser, OperationState &result) {
  3078117:  132:  StringAttr predicateAttr;
  3078117:  133:  OpAsmParser::UnresolvedOperand lhs, rhs;
  3078117:  134:  Type type;
        -:  135:  SMLoc predicateLoc, trailingTypeLoc;
  3078117:  136:  if (parser.getCurrentLocation(&predicateLoc) ||
  6156234:  137:      parser.parseAttribute(predicateAttr, "predicate", result.attributes) ||
 6156234*:  138:      parser.parseOperand(lhs) || parser.parseComma() ||
 6156234*:  139:      parser.parseOperand(rhs) ||
 6156234*:  140:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
 6156234*:  141:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type) ||
 6156234*:  142:      parser.resolveOperand(lhs, type, result.operands) ||
 3078117*:  143:      parser.resolveOperand(rhs, type, result.operands))
    #####:  144:    return failure();
        -:  145:
        -:  146:  // Replace the string attribute `predicate` with an integer attribute.
  3078117:  147:  int64_t predicateValue = 0;
        -:  148:  if (std::is_same<CmpPredicateType, ICmpPredicate>()) {
        -:  149:    Optional<ICmpPredicate> predicate =
  3074380:  150:        symbolizeICmpPredicate(predicateAttr.getValue());
  3074380:  151:    if (!predicate)
    #####:  152:      return parser.emitError(predicateLoc)
    #####:  153:             << "'" << predicateAttr.getValue()
    #####:  154:             << "' is an incorrect value of the 'predicate' attribute";
  3074380:  155:    predicateValue = static_cast<int64_t>(*predicate);
        -:  156:  } else {
        -:  157:    Optional<FCmpPredicate> predicate =
     3737:  158:        symbolizeFCmpPredicate(predicateAttr.getValue());
     3737:  159:    if (!predicate)
    #####:  160:      return parser.emitError(predicateLoc)
    #####:  161:             << "'" << predicateAttr.getValue()
    #####:  162:             << "' is an incorrect value of the 'predicate' attribute";
     3737:  163:    predicateValue = static_cast<int64_t>(*predicate);
        -:  164:  }
        -:  165:
  3078117:  166:  result.attributes.set("predicate",
  3078117:  167:                        parser.getBuilder().getI64IntegerAttr(predicateValue));
        -:  168:
        -:  169:  // The result type is either i1 or a vector type <? x i1> if the inputs are
        -:  170:  // vectors.
  3078117:  171:  if (!isCompatibleType(type))
    #####:  172:    return parser.emitError(trailingTypeLoc,
    #####:  173:                            "expected LLVM dialect-compatible type");
  3078117:  174:  result.addTypes(getI1SameShape(type));
  3078117:  175:  return success();
        -:  176:}
------------------
_Z10parseCmpOpIN4mlir4LLVM13FCmpPredicateEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE:
function _Z10parseCmpOpIN4mlir4LLVM13FCmpPredicateEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE called 3737 returned 100% blocks executed 68%
     3737:  131:static ParseResult parseCmpOp(OpAsmParser &parser, OperationState &result) {
     3737:  132:  StringAttr predicateAttr;
call    0 returned 100%
     3737:  133:  OpAsmParser::UnresolvedOperand lhs, rhs;
     3737:  134:  Type type;
        -:  135:  SMLoc predicateLoc, trailingTypeLoc;
     3737:  136:  if (parser.getCurrentLocation(&predicateLoc) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     7474:  137:      parser.parseAttribute(predicateAttr, "predicate", result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    7474*:  138:      parser.parseOperand(lhs) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
    7474*:  139:      parser.parseOperand(rhs) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    7474*:  140:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
    7474*:  141:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    7474*:  142:      parser.resolveOperand(lhs, type, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    3737*:  143:      parser.resolveOperand(rhs, type, result.operands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  144:    return failure();
        -:  145:
        -:  146:  // Replace the string attribute `predicate` with an integer attribute.
     3737:  147:  int64_t predicateValue = 0;
        -:  148:  if (std::is_same<CmpPredicateType, ICmpPredicate>()) {
        -:  149:    Optional<ICmpPredicate> predicate =
        -:  150:        symbolizeICmpPredicate(predicateAttr.getValue());
        -:  151:    if (!predicate)
        -:  152:      return parser.emitError(predicateLoc)
        -:  153:             << "'" << predicateAttr.getValue()
        -:  154:             << "' is an incorrect value of the 'predicate' attribute";
        -:  155:    predicateValue = static_cast<int64_t>(*predicate);
        -:  156:  } else {
        -:  157:    Optional<FCmpPredicate> predicate =
     3737:  158:        symbolizeFCmpPredicate(predicateAttr.getValue());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     3737:  159:    if (!predicate)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  160:      return parser.emitError(predicateLoc)
    #####:  161:             << "'" << predicateAttr.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  162:             << "' is an incorrect value of the 'predicate' attribute";
call    0 never executed
call    1 never executed
     3737:  163:    predicateValue = static_cast<int64_t>(*predicate);
        -:  164:  }
        -:  165:
     3737:  166:  result.attributes.set("predicate",
call    0 returned 100%
     3737:  167:                        parser.getBuilder().getI64IntegerAttr(predicateValue));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  168:
        -:  169:  // The result type is either i1 or a vector type <? x i1> if the inputs are
        -:  170:  // vectors.
     3737:  171:  if (!isCompatibleType(type))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  172:    return parser.emitError(trailingTypeLoc,
    #####:  173:                            "expected LLVM dialect-compatible type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     3737:  174:  result.addTypes(getI1SameShape(type));
call    0 returned 100%
call    1 returned 100%
     3737:  175:  return success();
        -:  176:}
------------------
_Z10parseCmpOpIN4mlir4LLVM13ICmpPredicateEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE:
function _Z10parseCmpOpIN4mlir4LLVM13ICmpPredicateEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE called 3074380 returned 100% blocks executed 68%
  3074380:  131:static ParseResult parseCmpOp(OpAsmParser &parser, OperationState &result) {
  3074380:  132:  StringAttr predicateAttr;
call    0 returned 100%
  3074380:  133:  OpAsmParser::UnresolvedOperand lhs, rhs;
  3074380:  134:  Type type;
        -:  135:  SMLoc predicateLoc, trailingTypeLoc;
  3074380:  136:  if (parser.getCurrentLocation(&predicateLoc) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  6148760:  137:      parser.parseAttribute(predicateAttr, "predicate", result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 6148760*:  138:      parser.parseOperand(lhs) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 6148760*:  139:      parser.parseOperand(rhs) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 6148760*:  140:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
 6148760*:  141:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
 6148760*:  142:      parser.resolveOperand(lhs, type, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 3074380*:  143:      parser.resolveOperand(rhs, type, result.operands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  144:    return failure();
        -:  145:
        -:  146:  // Replace the string attribute `predicate` with an integer attribute.
  3074380:  147:  int64_t predicateValue = 0;
        -:  148:  if (std::is_same<CmpPredicateType, ICmpPredicate>()) {
        -:  149:    Optional<ICmpPredicate> predicate =
  3074380:  150:        symbolizeICmpPredicate(predicateAttr.getValue());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  3074380:  151:    if (!predicate)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  152:      return parser.emitError(predicateLoc)
    #####:  153:             << "'" << predicateAttr.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  154:             << "' is an incorrect value of the 'predicate' attribute";
call    0 never executed
call    1 never executed
  3074380:  155:    predicateValue = static_cast<int64_t>(*predicate);
        -:  156:  } else {
        -:  157:    Optional<FCmpPredicate> predicate =
        -:  158:        symbolizeFCmpPredicate(predicateAttr.getValue());
        -:  159:    if (!predicate)
        -:  160:      return parser.emitError(predicateLoc)
        -:  161:             << "'" << predicateAttr.getValue()
        -:  162:             << "' is an incorrect value of the 'predicate' attribute";
        -:  163:    predicateValue = static_cast<int64_t>(*predicate);
        -:  164:  }
        -:  165:
  3074380:  166:  result.attributes.set("predicate",
call    0 returned 100%
  3074380:  167:                        parser.getBuilder().getI64IntegerAttr(predicateValue));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  168:
        -:  169:  // The result type is either i1 or a vector type <? x i1> if the inputs are
        -:  170:  // vectors.
  3074380:  171:  if (!isCompatibleType(type))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  172:    return parser.emitError(trailingTypeLoc,
    #####:  173:                            "expected LLVM dialect-compatible type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  3074380:  174:  result.addTypes(getI1SameShape(type));
call    0 returned 100%
call    1 returned 100%
  3074380:  175:  return success();
        -:  176:}
------------------
        -:  177:
function _ZN4mlir4LLVM6ICmpOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 3074380 returned 100% blocks executed 100%
  3074380:  178:ParseResult ICmpOp::parse(OpAsmParser &parser, OperationState &result) {
  3074380:  179:  return parseCmpOp<ICmpPredicate>(parser, result);
call    0 returned 100%
        -:  180:}
        -:  181:
function _ZN4mlir4LLVM6FCmpOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 3737 returned 100% blocks executed 100%
     3737:  182:ParseResult FCmpOp::parse(OpAsmParser &parser, OperationState &result) {
     3737:  183:  return parseCmpOp<FCmpPredicate>(parser, result);
call    0 returned 100%
        -:  184:}
        -:  185:
        -:  186://===----------------------------------------------------------------------===//
        -:  187:// Printing, parsing and verification for LLVM::AllocaOp.
        -:  188://===----------------------------------------------------------------------===//
        -:  189:
function _ZN4mlir4LLVM8AllocaOp5printERNS_12OpAsmPrinterE called 557859 returned 100% blocks executed 70%
   557859:  190:void AllocaOp::print(OpAsmPrinter &p) {
   557859:  191:  Type elemTy = getType().cast<LLVM::LLVMPointerType>().getElementType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   557859:  192:  if (!elemTy)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  193:    elemTy = *getElemType();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  194:
   557859:  195:  auto funcTy =
call    0 returned 100%
   557859:  196:      FunctionType::get(getContext(), {getArraySize().getType()}, {getType()});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  197:
  1115718:  198:  p << ' ' << getArraySize() << " x " << elemTy;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
  557859*:  199:  if (getAlignment() && *getAlignment() != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  200:    p.printOptionalAttrDict((*this)->getAttrs(), {kElemTypeAttrName});
call    0 never executed
call    1 never executed
        -:  201:  else
   557859:  202:    p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
   557859:  203:                            {"alignment", kElemTypeAttrName});
call    0 returned 100%
  1115718:  204:  p << " : " << funcTy;
call    0 returned 100%
call    1 returned 100%
   557859:  205:}
        -:  206:
        -:  207:// <operation> ::= `llvm.alloca` ssa-use `x` type attribute-dict?
        -:  208://                 `:` type `,` type
function _ZN4mlir4LLVM8AllocaOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 285078 returned 100% blocks executed 53%
   285078:  209:ParseResult AllocaOp::parse(OpAsmParser &parser, OperationState &result) {
   285078:  210:  OpAsmParser::UnresolvedOperand arraySize;
call    0 returned 100%
   285078:  211:  Type type, elemType;
   285078:  212:  SMLoc trailingTypeLoc;
  570156*:  213:  if (parser.parseOperand(arraySize) || parser.parseKeyword("x") ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
  570156*:  214:      parser.parseType(elemType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  285078*:  215:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
  570156*:  216:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  217:    return failure();
        -:  218:
   285078:  219:  Optional<NamedAttribute> alignmentAttr =
   285078:  220:      result.attributes.getNamed("alignment");
call    0 returned 100%
   285078:  221:  if (alignmentAttr.has_value()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  222:    auto alignmentInt =
call    0 never executed
    #####:  223:        alignmentAttr.value().getValue().dyn_cast<IntegerAttr>();
call    0 never executed
    #####:  224:    if (!alignmentInt)
branch  0 never executed
branch  1 never executed
    #####:  225:      return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  226:                              "expected integer alignment");
call    0 never executed
call    1 never executed
    #####:  227:    if (alignmentInt.getValue().isNullValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  228:      result.attributes.erase("alignment");
call    0 never executed
        -:  229:  }
        -:  230:
        -:  231:  // Extract the result type from the trailing function type.
   285078:  232:  auto funcType = type.dyn_cast<FunctionType>();
call    0 returned 100%
   570156:  233:  if (!funcType || funcType.getNumInputs() != 1 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
   285078:  234:      funcType.getNumResults() != 1)
call    0 returned 100%
    #####:  235:    return parser.emitError(
call    0 never executed
call    1 never executed
        -:  236:        trailingTypeLoc,
    #####:  237:        "expected trailing function type with one argument and one result");
call    0 never executed
call    1 never executed
        -:  238:
   285078:  239:  if (parser.resolveOperand(arraySize, funcType.getInput(0), result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
    #####:  240:    return failure();
        -:  241:
   285078:  242:  Type resultType = funcType.getResult(0);
call    0 returned 100%
   285078:  243:  if (auto ptrResultType = resultType.dyn_cast<LLVMPointerType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   285078:  244:    if (ptrResultType.isOpaque())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  245:      result.addAttribute(kElemTypeAttrName, TypeAttr::get(elemType));
call    0 never executed
call    1 never executed
        -:  246:  }
        -:  247:
   285078:  248:  result.addTypes({funcType.getResult(0)});
call    0 returned 100%
call    1 returned 100%
   285078:  249:  return success();
        -:  250:}
        -:  251:
        -:  252:/// Checks that the elemental type is present in either the pointer type or
        -:  253:/// the attribute, but not both.
        -:  254:static LogicalResult verifyOpaquePtr(Operation *op, LLVMPointerType ptrType,
        -:  255:                                     Optional<Type> ptrElementType) {
        -:  256:  if (ptrType.isOpaque() && !ptrElementType.has_value()) {
        -:  257:    return op->emitOpError() << "expected '" << kElemTypeAttrName
        -:  258:                             << "' attribute if opaque pointer type is used";
        -:  259:  }
        -:  260:  if (!ptrType.isOpaque() && ptrElementType.has_value()) {
        -:  261:    return op->emitOpError()
        -:  262:           << "unexpected '" << kElemTypeAttrName
        -:  263:           << "' attribute when non-opaque pointer type is used";
        -:  264:  }
        -:  265:  return success();
        -:  266:}
        -:  267:
function _ZN4mlir4LLVM8AllocaOp6verifyEv called 1640206 returned 100% blocks executed 100%
  1640206:  268:LogicalResult AllocaOp::verify() {
  1640206:  269:  return verifyOpaquePtr(getOperation(), getType().cast<LLVMPointerType>(),
call    0 returned 100%
  3280412:  270:                         getElemType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  271:}
        -:  272:
        -:  273://===----------------------------------------------------------------------===//
        -:  274:// LLVM::BrOp
        -:  275://===----------------------------------------------------------------------===//
        -:  276:
function _ZN4mlir4LLVM4BrOp20getSuccessorOperandsEj called 64470182 returned 100% blocks executed 71%
 64470182:  277:SuccessorOperands BrOp::getSuccessorOperands(unsigned index) {
64470182*:  278:  assert(index == 0 && "invalid successor index");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 64470182:  279:  return SuccessorOperands(getDestOperandsMutable());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  280:}
        -:  281:
        -:  282://===----------------------------------------------------------------------===//
        -:  283:// LLVM::CondBrOp
        -:  284://===----------------------------------------------------------------------===//
        -:  285:
function _ZN4mlir4LLVM8CondBrOp20getSuccessorOperandsEj called 66714271 returned 100% blocks executed 78%
 66714271:  286:SuccessorOperands CondBrOp::getSuccessorOperands(unsigned index) {
66714271*:  287:  assert(index < getNumSuccessors() && "invalid successor index");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 66714271:  288:  return SuccessorOperands(index == 0 ? getTrueDestOperandsMutable()
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
 66718931:  289:                                      : getFalseDestOperandsMutable());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  290:}
        -:  291:
        -:  292://===----------------------------------------------------------------------===//
        -:  293:// LLVM::SwitchOp
        -:  294://===----------------------------------------------------------------------===//
        -:  295:
function _ZN4mlir4LLVM8SwitchOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEPNS_5BlockENS_10ValueRangeEN4llvm8ArrayRefIiEENS_10BlockRangeENSB_IS9_EESC_ called 0 returned 0% blocks executed 0%
    #####:  296:void SwitchOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  297:                     Block *defaultDestination, ValueRange defaultOperands,
        -:  298:                     ArrayRef<int32_t> caseValues, BlockRange caseDestinations,
        -:  299:                     ArrayRef<ValueRange> caseOperands,
        -:  300:                     ArrayRef<int32_t> branchWeights) {
    #####:  301:  ElementsAttr caseValuesAttr;
call    0 never executed
    #####:  302:  if (!caseValues.empty())
branch  0 never executed
branch  1 never executed
    #####:  303:    caseValuesAttr = builder.getI32VectorAttr(caseValues);
call    0 never executed
call    1 never executed
        -:  304:
    #####:  305:  ElementsAttr weightsAttr;
call    0 never executed
    #####:  306:  if (!branchWeights.empty())
branch  0 never executed
branch  1 never executed
    #####:  307:    weightsAttr = builder.getI32VectorAttr(llvm::to_vector<4>(branchWeights));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  308:
    #####:  309:  build(builder, result, value, defaultOperands, caseOperands, caseValuesAttr,
call    0 never executed
        -:  310:        weightsAttr, defaultDestination, caseDestinations);
    #####:  311:}
        -:  312:
        -:  313:/// <cases> ::= integer `:` bb-id (`(` ssa-use-and-type-list `)`)?
        -:  314:///             ( `,` integer `:` bb-id (`(` ssa-use-and-type-list `)`)? )?
function _ZL18parseSwitchOpCasesRN4mlir11OpAsmParserENS_4TypeERNS_12ElementsAttrERN4llvm15SmallVectorImplIPNS_5BlockEEERNS6_INS5_11SmallVectorINS0_17UnresolvedOperandELj1EEEEERNS6_INSB_IS2_Lj6EEEEE called 0 returned 0% blocks executed 0%
    #####:  315:static ParseResult parseSwitchOpCases(
        -:  316:    OpAsmParser &parser, Type flagType, ElementsAttr &caseValues,
        -:  317:    SmallVectorImpl<Block *> &caseDestinations,
        -:  318:    SmallVectorImpl<SmallVector<OpAsmParser::UnresolvedOperand>> &caseOperands,
        -:  319:    SmallVectorImpl<SmallVector<Type>> &caseOperandTypes) {
    #####:  320:  SmallVector<APInt> values;
call    0 never executed
call    1 never executed
    #####:  321:  unsigned bitWidth = flagType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  322:  do {
    #####:  323:    int64_t value = 0;
    #####:  324:    OptionalParseResult integerParseResult = parser.parseOptionalInteger(value);
call    0 never executed
    #####:  325:    if (values.empty() && !integerParseResult.has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  326:      return success();
        -:  327:
    #####:  328:    if (!integerParseResult.has_value() || integerParseResult.value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  329:      return failure();
    #####:  330:    values.push_back(APInt(bitWidth, value));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  331:
    #####:  332:    Block *destination;
    #####:  333:    SmallVector<OpAsmParser::UnresolvedOperand> operands;
call    0 never executed
    #####:  334:    SmallVector<Type> operandTypes;
branch  0 never executed
branch  1 never executed
    #####:  335:    if (parser.parseColon() || parser.parseSuccessor(destination))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  336:      return failure();
    #####:  337:    if (!parser.parseOptionalLParen()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  338:      if (parser.parseOperandList(operands, OpAsmParser::Delimiter::None,
    #####:  339:                                  /*allowResultNumber=*/false) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  340:          parser.parseColonTypeList(operandTypes) || parser.parseRParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  341:        return failure();
        -:  342:    }
    #####:  343:    caseDestinations.push_back(destination);
call    0 never executed
    #####:  344:    caseOperands.emplace_back(operands);
call    0 never executed
    #####:  345:    caseOperandTypes.emplace_back(operandTypes);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  346:  } while (!parser.parseOptionalComma());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  347:
    #####:  348:  ShapedType caseValueType =
    #####:  349:      VectorType::get(static_cast<int64_t>(values.size()), flagType);
call    0 never executed
call    1 never executed
    #####:  350:  caseValues = DenseIntElementsAttr::get(caseValueType, values);
call    0 never executed
call    1 never executed
    #####:  351:  return success();
        -:  352:}
        -:  353:
        -:  354:static void printSwitchOpCases(OpAsmPrinter &p, SwitchOp op, Type flagType,
        -:  355:                               ElementsAttr caseValues,
        -:  356:                               SuccessorRange caseDestinations,
        -:  357:                               OperandRangeRange caseOperands,
        -:  358:                               const TypeRangeRange &caseOperandTypes) {
        -:  359:  if (!caseValues)
        -:  360:    return;
        -:  361:
        -:  362:  size_t index = 0;
        -:  363:  llvm::interleave(
        -:  364:      llvm::zip(caseValues.cast<DenseIntElementsAttr>(), caseDestinations),
function _ZZL18printSwitchOpCasesRN4mlir12OpAsmPrinterENS_4LLVM8SwitchOpENS_4TypeENS_12ElementsAttrENS_14SuccessorRangeENS_17OperandRangeRangeERKNS_14TypeRangeRangeEENKUlT_E_clISt5tupleIJN4llvm5APIntEPNS_5BlockEEEEEDaSB_ called 0 returned 0% blocks executed 0%
    #####:  365:      [&](auto i) {
    #####:  366:        p << "  ";
call    0 never executed
call    1 never executed
    #####:  367:        p << std::get<0>(i).getLimitedValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  368:        p << ": ";
    #####:  369:        p.printSuccessorAndUseList(std::get<1>(i), caseOperands[index++]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  370:      },
function _ZZL18printSwitchOpCasesRN4mlir12OpAsmPrinterENS_4LLVM8SwitchOpENS_4TypeENS_12ElementsAttrENS_14SuccessorRangeENS_17OperandRangeRangeERKNS_14TypeRangeRangeEENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  371:      [&] {
    #####:  372:        p << ',';
call    0 never executed
    #####:  373:        p.printNewline();
call    0 never executed
    #####:  374:      });
        -:  375:  p.printNewline();
        -:  376:}
        -:  377:
function _ZN4mlir4LLVM8SwitchOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  378:LogicalResult SwitchOp::verify() {
    #####:  379:  if ((!getCaseValues() && !getCaseDestinations().empty()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  380:      (getCaseValues() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  381:       getCaseValues()->size() !=
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  382:           static_cast<int64_t>(getCaseDestinations().size())))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  383:    return emitOpError("expects number of case values to match number of "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  384:                       "case destinations");
call    0 never executed
    #####:  385:  if (getBranchWeights() && getBranchWeights()->size() != getNumSuccessors())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  386:    return emitError("expects number of branch weights to match number of "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  387:                     "successors: ")
    #####:  388:           << getBranchWeights()->size() << " vs " << getNumSuccessors();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  389:  return success();
        -:  390:}
        -:  391:
function _ZN4mlir4LLVM8SwitchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  392:SuccessorOperands SwitchOp::getSuccessorOperands(unsigned index) {
    #####:  393:  assert(index < getNumSuccessors() && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  394:  return SuccessorOperands(index == 0 ? getDefaultOperandsMutable()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  395:                                      : getCaseOperandsMutable(index - 1));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  396:}
        -:  397:
        -:  398://===----------------------------------------------------------------------===//
        -:  399:// Code for LLVM::GEPOp.
        -:  400://===----------------------------------------------------------------------===//
        -:  401:
        -:  402:constexpr int32_t GEPOp::kDynamicIndex;
        -:  403:
function _ZN4mlir4LLVM5GEPOp10getIndicesEv called 46078082 returned 100% blocks executed 100%
 46078082:  404:GEPIndicesAdaptor<ValueRange> GEPOp::getIndices() {
 46078082:  405:  return GEPIndicesAdaptor<ValueRange>(getRawConstantIndicesAttr(),
call    0 returned 100%
 46055048:  406:                                       getDynamicIndices());
call    0 returned 100%
call    1 returned 100%
        -:  407:}
        -:  408:
        -:  409:/// Returns the elemental type of any LLVM-compatible vector type or self.
function _ZL24extractVectorElementTypeN4mlir4TypeE called 88642909 returned 100% blocks executed 57%
 88642909:  410:static Type extractVectorElementType(Type type) {
 88642909:  411:  if (auto vectorType = type.dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  412:    return vectorType.getElementType();
call    0 never executed
 88642374:  413:  if (auto scalableVectorType = type.dyn_cast<LLVMScalableVectorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  414:    return scalableVectorType.getElementType();
call    0 never executed
 88643182:  415:  if (auto fixedVectorType = type.dyn_cast<LLVMFixedVectorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  416:    return fixedVectorType.getElementType();
call    0 never executed
 88640581:  417:  return type;
        -:  418:}
        -:  419:
function _ZN4mlir4LLVM5GEPOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_5ValueEN4llvm8ArrayRefINS0_6GEPArgEEENS9_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  420:void GEPOp::build(OpBuilder &builder, OperationState &result, Type resultType,
        -:  421:                  Value basePtr, ArrayRef<GEPArg> indices,
        -:  422:                  ArrayRef<NamedAttribute> attributes) {
    #####:  423:  auto ptrType =
    #####:  424:      extractVectorElementType(basePtr.getType()).cast<LLVMPointerType>();
call    0 never executed
call    1 never executed
    #####:  425:  assert(!ptrType.isOpaque() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  426:         "expected non-opaque pointer, provide elementType explicitly when "
        -:  427:         "opaque pointers are used");
    #####:  428:  build(builder, result, resultType, ptrType.getElementType(), basePtr, indices,
call    0 never executed
call    1 never executed
        -:  429:        attributes);
    #####:  430:}
        -:  431:
        -:  432:/// Destructures the 'indices' parameter into 'rawConstantIndices' and
        -:  433:/// 'dynamicIndices', encoding the former in the process. In the process,
        -:  434:/// dynamic indices which are used to index into a structure type are converted
        -:  435:/// to constant indices when possible. To do this, the GEPs element type should
        -:  436:/// be passed as first parameter.
function _ZL18destructureIndicesN4mlir4TypeEN4llvm8ArrayRefINS_4LLVM6GEPArgEEERNS1_15SmallVectorImplIiEERNS6_INS_5ValueEEE called 863046 returned 100% blocks executed 66%
   863046:  437:static void destructureIndices(Type currType, ArrayRef<GEPArg> indices,
        -:  438:                               SmallVectorImpl<int32_t> &rawConstantIndices,
        -:  439:                               SmallVectorImpl<Value> &dynamicIndices) {
  1807156:  440:  for (const GEPArg &iter : indices) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -:  441:    // If the thing we are currently indexing into is a struct we must turn
        -:  442:    // any integer constants into constant indices. If this is not possible
        -:  443:    // we don't do anything here. The verifier will catch it and emit a proper
        -:  444:    // error. All other canonicalization is done in the fold method.
   944110:  445:    bool requiresConst = !rawConstantIndices.empty() &&
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
    81064:  446:                         currType.isa_and_nonnull<LLVMStructType>();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   944110:  447:    if (Value val = iter.dyn_cast<Value>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  448:      APInt intC;
branch  0 never executed
branch  1 never executed
    #####:  449:      if (requiresConst && matchPattern(val, m_ConstantInt(&intC)) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  450:          intC.isSignedIntN(kGEPConstantBitWidth)) {
branch  0 never executed
branch  1 never executed
    #####:  451:        rawConstantIndices.push_back(intC.getSExtValue());
call    0 never executed
call    1 never executed
        -:  452:      } else {
    #####:  453:        rawConstantIndices.push_back(GEPOp::kDynamicIndex);
call    0 never executed
    #####:  454:        dynamicIndices.push_back(val);
call    0 never executed
        -:  455:      }
        -:  456:    } else {
   944110:  457:      rawConstantIndices.push_back(iter.get<GEPConstantIndex>());
call    0 returned 100%
call    1 returned 100%
        -:  458:    }
        -:  459:
        -:  460:    // Skip for very first iteration of this loop. First index does not index
        -:  461:    // within the aggregates, but is just a pointer offset.
   944110:  462:    if (rawConstantIndices.size() == 1 || !currType)
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   863046:  463:      continue;
        -:  464:
    81064:  465:    currType =
call    0 returned 100%
    81064:  466:        TypeSwitch<Type, Type>(currType)
call    0 returned 100%
        -:  467:            .Case<VectorType, LLVMScalableVectorType, LLVMFixedVectorType,
        -:  468:                  LLVMArrayType>([](auto containerType) {
        -:  469:              return containerType.getElementType();
    81064:  470:            })
function _ZZL18destructureIndicesN4mlir4TypeEN4llvm8ArrayRefINS_4LLVM6GEPArgEEERNS1_15SmallVectorImplIiEERNS6_INS_5ValueEEEENKUlNS3_14LLVMStructTypeEE0_clESC_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  471:            .Case([&](LLVMStructType structType) -> Type {
    #####:  472:              int64_t memberIndex = rawConstantIndices.back();
call    0 never executed
    #####:  473:              if (memberIndex >= 0 && static_cast<size_t>(memberIndex) <
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  474:                                          structType.getBody().size())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  475:                return structType.getBody()[memberIndex];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  476:              return nullptr;
    81064:  477:            })
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
   162128:  478:            .Default(Type(nullptr));
branch  0 taken 100%
branch  1 taken 0%
        -:  479:  }
   863046:  480:}
        -:  481:
function _ZN4mlir4LLVM5GEPOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeES6_NS_5ValueEN4llvm8ArrayRefINS0_6GEPArgEEENS9_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  482:void GEPOp::build(OpBuilder &builder, OperationState &result, Type resultType,
        -:  483:                  Type elementType, Value basePtr, ArrayRef<GEPArg> indices,
        -:  484:                  ArrayRef<NamedAttribute> attributes) {
    #####:  485:  SmallVector<int32_t> rawConstantIndices;
call    0 never executed
    #####:  486:  SmallVector<Value> dynamicIndices;
branch  0 never executed
branch  1 never executed
    #####:  487:  destructureIndices(elementType, indices, rawConstantIndices, dynamicIndices);
call    0 never executed
        -:  488:
    #####:  489:  result.addTypes(resultType);
call    0 never executed
    #####:  490:  result.addAttributes(attributes);
call    0 never executed
    #####:  491:  result.addAttribute(getRawConstantIndicesAttrName(result.name),
call    0 never executed
    #####:  492:                      builder.getDenseI32ArrayAttr(rawConstantIndices));
call    0 never executed
    #####:  493:  if (extractVectorElementType(basePtr.getType())
call    0 never executed
call    1 never executed
    #####:  494:          .cast<LLVMPointerType>()
call    0 never executed
    #####:  495:          .isOpaque())
branch  0 never executed
branch  1 never executed
    #####:  496:    result.addAttribute(kElemTypeAttrName, TypeAttr::get(elementType));
call    0 never executed
call    1 never executed
    #####:  497:  result.addOperands(basePtr);
call    0 never executed
call    1 never executed
    #####:  498:  result.addOperands(dynamicIndices);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  499:}
        -:  500:
function _ZN4mlir4LLVM5GEPOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_5ValueENS_10ValueRangeEN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  501:void GEPOp::build(OpBuilder &builder, OperationState &result, Type resultType,
        -:  502:                  Value basePtr, ValueRange indices,
        -:  503:                  ArrayRef<NamedAttribute> attributes) {
    #####:  504:  build(builder, result, resultType, basePtr, SmallVector<GEPArg>(indices),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  505:        attributes);
    #####:  506:}
        -:  507:
function _ZN4mlir4LLVM5GEPOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeES6_NS_5ValueENS_10ValueRangeEN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  508:void GEPOp::build(OpBuilder &builder, OperationState &result, Type resultType,
        -:  509:                  Type elementType, Value basePtr, ValueRange indices,
        -:  510:                  ArrayRef<NamedAttribute> attributes) {
    #####:  511:  build(builder, result, resultType, elementType, basePtr,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  512:        SmallVector<GEPArg>(indices), attributes);
call    0 never executed
    #####:  513:}
        -:  514:
        -:  515:static ParseResult
function _ZL15parseGEPIndicesRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS_6detail18DenseArrayAttrImplIiEE called 6070851 returned 100% blocks executed 78%
  6070851:  516:parseGEPIndices(OpAsmParser &parser,
        -:  517:                SmallVectorImpl<OpAsmParser::UnresolvedOperand> &indices,
        -:  518:                DenseI32ArrayAttr &rawConstantIndices) {
  6070851:  519:  SmallVector<int32_t> constantIndices;
call    0 returned 100%
        -:  520:
function _ZZL15parseGEPIndicesRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS_6detail18DenseArrayAttrImplIiEEENKUlvE_clEv called 6368817 returned 100% blocks executed 60%
 12439668:  521:  auto idxParser = [&]() -> ParseResult {
  6368817:  522:    int32_t constantIndex;
  6368817:  523:    OptionalParseResult parsedInteger =
  6368817:  524:        parser.parseOptionalInteger(constantIndex);
call    0 returned 100%
  6368817:  525:    if (parsedInteger.has_value()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  526:      if (failed(parsedInteger.value()))
branch  0 never executed
branch  1 never executed
    #####:  527:        return failure();
    #####:  528:      constantIndices.push_back(constantIndex);
call    0 never executed
    #####:  529:      return success();
        -:  530:    }
        -:  531:
  6368817:  532:    constantIndices.push_back(LLVM::GEPOp::kDynamicIndex);
call    0 returned 100%
  6368817:  533:    return parser.parseOperand(indices.emplace_back());
call    0 returned 100%
call    1 returned 100%
  6070851:  534:  };
  6070851:  535:  if (parser.parseCommaSeparatedList(idxParser))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  536:    return failure();
        -:  537:
  6070851:  538:  rawConstantIndices =
call    0 returned 100%
  6070851:  539:      DenseI32ArrayAttr::get(parser.getContext(), constantIndices);
call    0 returned 100%
call    1 returned 100%
  6070851:  540:  return success();
        -:  541:}
        -:  542:
 11133884:  543:static void printGEPIndices(OpAsmPrinter &printer, LLVM::GEPOp gepOp,
        -:  544:                            OperandRange indices,
        -:  545:                            DenseI32ArrayAttr rawConstantIndices) {
 11133884:  546:  llvm::interleaveComma(
call    0 returned 100%
 11133884:  547:      GEPIndicesAdaptor<OperandRange>(rawConstantIndices, indices), printer,
call    0 returned 100%
call    1 returned 100%
function _ZZL15printGEPIndicesRN4mlir12OpAsmPrinterENS_4LLVM5GEPOpENS_12OperandRangeENS_6detail18DenseArrayAttrImplIiEEENKUlN4llvm12PointerUnionIJNS_11IntegerAttrENS_5ValueEEEEE_clESC_.isra.0 called 11716887 returned 100% blocks executed 100%
 11716887:  548:      [&](PointerUnion<IntegerAttr, Value> cst) {
 23433774:  549:        if (Value val = cst.dyn_cast<Value>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 83% (fallthrough)
branch  3 taken 17%
  9670806:  550:          printer.printOperand(val);
call    0 returned 100%
        -:  551:        else
  4092162:  552:          printer << cst.get<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 11716887:  553:      });
        -:  554:}
        -:  555:
        -:  556:namespace {
        -:  557:/// Base class for llvm::Error related to GEP index.
        -:  558:class GEPIndexError : public llvm::ErrorInfo<GEPIndexError> {
        -:  559:protected:
        -:  560:  unsigned indexPos;
        -:  561:
        -:  562:public:
        -:  563:  static char ID;
        -:  564:
function _ZNK12_GLOBAL__N_113GEPIndexError18convertToErrorCodeEv called 0 returned 0% blocks executed 0%
    #####:  565:  std::error_code convertToErrorCode() const override {
    #####:  566:    return llvm::inconvertibleErrorCode();
call    0 never executed
        -:  567:  }
        -:  568:
    #####:  569:  explicit GEPIndexError(unsigned pos) : indexPos(pos) {}
        -:  570:};
        -:  571:
        -:  572:/// llvm::Error for out-of-bound GEP index.
        -:  573:struct GEPIndexOutOfBoundError
        -:  574:    : public llvm::ErrorInfo<GEPIndexOutOfBoundError, GEPIndexError> {
        -:  575:  static char ID;
        -:  576:
    #####:  577:  using ErrorInfo::ErrorInfo;
        -:  578:
function _ZNK12_GLOBAL__N_123GEPIndexOutOfBoundError3logERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  579:  void log(llvm::raw_ostream &os) const override {
    #####:  580:    os << "index " << indexPos << " indexing a struct is out of bounds";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  581:  }
        -:  582:};
        -:  583:
        -:  584:/// llvm::Error for non-static GEP index indexing a struct.
        -:  585:struct GEPStaticIndexError
        -:  586:    : public llvm::ErrorInfo<GEPStaticIndexError, GEPIndexError> {
        -:  587:  static char ID;
        -:  588:
    #####:  589:  using ErrorInfo::ErrorInfo;
        -:  590:
function _ZNK12_GLOBAL__N_119GEPStaticIndexError3logERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  591:  void log(llvm::raw_ostream &os) const override {
    #####:  592:    os << "expected index " << indexPos << " indexing a struct "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  593:       << "to be constant";
call    0 never executed
    #####:  594:  }
        -:  595:};
        -:  596:} // end anonymous namespace
        -:  597:
        -:  598:char GEPIndexError::ID = 0;
        -:  599:char GEPIndexOutOfBoundError::ID = 0;
        -:  600:char GEPStaticIndexError::ID = 0;
        -:  601:
        -:  602:/// For the given `structIndices` and `indices`, check if they're complied
        -:  603:/// with `baseGEPType`, especially check against LLVMStructTypes nested within.
function _ZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEE called 44839760 returned 100% blocks executed 100%
 44839760:  604:static llvm::Error verifyStructIndices(Type baseGEPType, unsigned indexPos,
        -:  605:                                       GEPIndicesAdaptor<ValueRange> indices) {
 89745589:  606:  if (indexPos >= indices.size())
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
        -:  607:    // Stop searching
 43965633:  608:    return llvm::Error::success();
call    0 returned 100%
call    1 returned 100%
        -:  609:
  1877866:  610:  return llvm::TypeSwitch<Type, llvm::Error>(baseGEPType)
call    0 returned 100%
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlNS1_14LLVMStructTypeEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  611:      .Case<LLVMStructType>([&](LLVMStructType structType) -> llvm::Error {
    #####:  612:        if (!indices[indexPos].is<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  613:          return llvm::make_error<GEPStaticIndexError>(indexPos);
call    0 never executed
        -:  614:
    #####:  615:        int32_t gepIndex = indices[indexPos].get<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  616:        ArrayRef<Type> elementTypes = structType.getBody();
call    0 never executed
    #####:  617:        if (gepIndex < 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  618:            static_cast<size_t>(gepIndex) >= elementTypes.size())
branch  0 never executed
branch  1 never executed
    #####:  619:          return llvm::make_error<GEPIndexOutOfBoundError>(indexPos);
call    0 never executed
        -:  620:
        -:  621:        // Instead of recursively going into every children types, we only
        -:  622:        // dive into the one indexed by gepIndex.
    #####:  623:        return verifyStructIndices(elementTypes[gepIndex], indexPos + 1,
    #####:  624:                                   indices);
call    0 never executed
   940196:  625:      })
call    0 returned 100%
        -:  626:      .Case<VectorType, LLVMScalableVectorType, LLVMFixedVectorType,
  932558*:  627:            LLVMArrayType>([&](auto containerType) -> llvm::Error {
  932558*:  628:        return verifyStructIndices(containerType.getElementType(), indexPos + 1,
  932558*:  629:                                   indices);
  1877434:  630:      })
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
------------------
_ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_13LLVMArrayTypeEEEN4llvm5ErrorES5_.isra.0:
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_13LLVMArrayTypeEEEN4llvm5ErrorES5_.isra.0 called 932558 returned 101% blocks executed 100%
   932558:  627:            LLVMArrayType>([&](auto containerType) -> llvm::Error {
   932558:  628:        return verifyStructIndices(containerType.getElementType(), indexPos + 1,
   932558:  629:                                   indices);
call    0 returned 100%
call    1 returned 101%
        -:  630:      })
------------------
_ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_19LLVMFixedVectorTypeEEEN4llvm5ErrorES5_.isra.0:
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_19LLVMFixedVectorTypeEEEN4llvm5ErrorES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  627:            LLVMArrayType>([&](auto containerType) -> llvm::Error {
    #####:  628:        return verifyStructIndices(containerType.getElementType(), indexPos + 1,
    #####:  629:                                   indices);
call    0 never executed
call    1 never executed
        -:  630:      })
------------------
_ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_22LLVMScalableVectorTypeEEEN4llvm5ErrorES5_.isra.0:
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS1_22LLVMScalableVectorTypeEEEN4llvm5ErrorES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  627:            LLVMArrayType>([&](auto containerType) -> llvm::Error {
    #####:  628:        return verifyStructIndices(containerType.getElementType(), indexPos + 1,
    #####:  629:                                   indices);
call    0 never executed
call    1 never executed
        -:  630:      })
------------------
_ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS_10VectorTypeEEEN4llvm5ErrorES5_.isra.0:
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E0_clINS_10VectorTypeEEEN4llvm5ErrorES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  627:            LLVMArrayType>([&](auto containerType) -> llvm::Error {
    #####:  628:        return verifyStructIndices(containerType.getElementType(), indexPos + 1,
    #####:  629:                                   indices);
call    0 never executed
call    1 never executed
        -:  630:      })
------------------
        -:  631:      .Default(
function _ZZL19verifyStructIndicesN4mlir4TypeEjNS_4LLVM17GEPIndicesAdaptorINS_10ValueRangeEEEENKUlT_E1_clIS0_EEN4llvm5ErrorES5_.isra.0 called 0 returned 0% blocks executed 0%
  939520*:  632:          [](auto otherType) -> llvm::Error { return llvm::Error::success(); });
call    0 never executed
call    1 never executed
call    2 returned 100%
        -:  633:}
        -:  634:
        -:  635:/// Driver function around `recordStructIndices`. Note that we always check
        -:  636:/// from the second GEP index since the first one is always dynamic.
 43927978:  637:static llvm::Error verifyStructIndices(Type baseGEPType,
        -:  638:                                       GEPIndicesAdaptor<ValueRange> indices) {
 43927978:  639:  return verifyStructIndices(baseGEPType, /*indexPos=*/1, indices);
call    0 returned 100%
        -:  640:}
        -:  641:
function _ZN4mlir4LLVM5GEPOp6verifyEv called 43950230 returned 100% blocks executed 48%
 43950230:  642:LogicalResult LLVM::GEPOp::verify() {
 87881235:  643:  if (failed(verifyOpaquePtr(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  644:          getOperation(),
 87858677:  645:          extractVectorElementType(getType()).cast<LLVMPointerType>(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  646:          getElemType())))
    #####:  647:    return failure();
        -:  648:
 87891164:  649:  if (static_cast<size_t>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 87947814:  650:          llvm::count(getRawConstantIndices(), kDynamicIndex)) !=
call    0 returned 100%
 43964355:  651:      getDynamicIndices().size())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  652:    return emitOpError("expected as many dynamic indices as specified in '")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  653:           << getRawConstantIndicesAttrName().getValue() << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  654:
 87924306:  655:  if (llvm::Error err =
 87924306:  656:          verifyStructIndices(getSourceElementType(), getIndices()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 returned 100%
    #####:  657:    return emitOpError() << llvm::toString(std::move(err));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  658:
 43957694:  659:  return success();
        -:  660:}
        -:  661:
function _ZN4mlir4LLVM5GEPOp20getSourceElementTypeEv called 44830670 returned 100% blocks executed 89%
 44830670:  662:Type LLVM::GEPOp::getSourceElementType() {
 44830670:  663:  if (Optional<Type> elemType = getElemType())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  664:    return *elemType;
        -:  665:
 44799228:  666:  return extractVectorElementType(getBase().getType())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 44790772:  667:      .cast<LLVMPointerType>()
 44791608:  668:      .getElementType();
call    0 returned 100%
        -:  669:}
        -:  670:
        -:  671://===----------------------------------------------------------------------===//
        -:  672:// Builder, printer and parser for for LLVM::LoadOp.
        -:  673://===----------------------------------------------------------------------===//
        -:  674:
function _Z21verifySymbolAttributePN4mlir9OperationEN4llvm9StringRefENS2_12function_refIFNS_13LogicalResultES1_NS_13SymbolRefAttrEEEE called 130448137 returned 100% blocks executed 8%
130448137:  675:LogicalResult verifySymbolAttribute(
        -:  676:    Operation *op, StringRef attributeName,
        -:  677:    llvm::function_ref<LogicalResult(Operation *, SymbolRefAttr)>
        -:  678:        verifySymbolType) {
130448137:  679:  if (Attribute attribute = op->getAttr(attributeName)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  680:    // The attribute is already verified to be a symbol ref array attribute via
        -:  681:    // a constraint in the operation definition.
    #####:  682:    for (SymbolRefAttr symbolRef :
call    0 never executed
    #####:  683:         attribute.cast<ArrayAttr>().getAsRange<SymbolRefAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  684:      StringAttr metadataName = symbolRef.getRootReference();
call    0 never executed
    #####:  685:      StringAttr symbolName = symbolRef.getLeafReference();
call    0 never executed
        -:  686:      // We want @metadata::@symbol, not just @symbol
    #####:  687:      if (metadataName == symbolName) {
branch  0 never executed
branch  1 never executed
    #####:  688:        return op->emitOpError() << "expected '" << symbolRef
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  689:                                 << "' to specify a fully qualified reference";
call    0 never executed
        -:  690:      }
    #####:  691:      auto metadataOp = SymbolTable::lookupNearestSymbolFrom<LLVM::MetadataOp>(
    #####:  692:          op->getParentOp(), metadataName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  693:      if (!metadataOp)
branch  0 never executed
branch  1 never executed
    #####:  694:        return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  695:               << "expected '" << symbolRef << "' to reference a metadata op";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  696:      Operation *symbolOp =
    #####:  697:          SymbolTable::lookupNearestSymbolFrom(metadataOp, symbolName);
call    0 never executed
    #####:  698:      if (!symbolOp)
branch  0 never executed
branch  1 never executed
    #####:  699:        return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  700:               << "expected '" << symbolRef << "' to be a valid reference";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  701:      if (failed(verifySymbolType(symbolOp, symbolRef))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  702:        return failure();
        -:  703:      }
        -:  704:    }
        -:  705:  }
130476970:  706:  return success();
        -:  707:}
        -:  708:
        -:  709:// Verifies that metadata ops are wired up properly.
        -:  710:template <typename OpTy>
130500567:  711:static LogicalResult verifyOpMetadata(Operation *op, StringRef attributeName) {
130500567*:  712:  auto verifySymbolType = [op](Operation *symbolOp,
------------------
_ZZ16verifyOpMetadataIN4mlir4LLVM20AliasScopeMetadataOpEENS0_13LogicalResultEPNS0_9OperationEN4llvm9StringRefEENKUlS5_NS0_13SymbolRefAttrEE_clES5_S8_.isra.0:
function _ZZ16verifyOpMetadataIN4mlir4LLVM20AliasScopeMetadataOpEENS0_13LogicalResultEPNS0_9OperationEN4llvm9StringRefEENKUlS5_NS0_13SymbolRefAttrEE_clES5_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  712:  auto verifySymbolType = [op](Operation *symbolOp,
------------------
_ZZ16verifyOpMetadataIN4mlir4LLVM21AccessGroupMetadataOpEENS0_13LogicalResultEPNS0_9OperationEN4llvm9StringRefEENKUlS5_NS0_13SymbolRefAttrEE_clES5_S8_.isra.0:
function _ZZ16verifyOpMetadataIN4mlir4LLVM21AccessGroupMetadataOpEENS0_13LogicalResultEPNS0_9OperationEN4llvm9StringRefEENKUlS5_NS0_13SymbolRefAttrEE_clES5_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  712:  auto verifySymbolType = [op](Operation *symbolOp,
------------------
        -:  713:                               SymbolRefAttr symbolRef) -> LogicalResult {
    #####:  714:    if (!isa<OpTy>(symbolOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  715:      return op->emitOpError()
    #####:  716:             << "expected '" << symbolRef << "' to resolve to a "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
    #####:  717:             << OpTy::getOperationName();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  718:    }
    #####:  719:    return success();
        -:  720:  };
        -:  721:
130500567:  722:  return verifySymbolAttribute(op, attributeName, verifySymbolType);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  723:}
        -:  724:
function _ZL22verifyMemoryOpMetadataPN4mlir9OperationE called 43486161 returned 100% blocks executed 73%
 43486161:  725:static LogicalResult verifyMemoryOpMetadata(Operation *op) {
        -:  726:  // access_groups
 43486161:  727:  if (failed(verifyOpMetadata<LLVM::AccessGroupMetadataOp>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  728:          op, LLVMDialect::getAccessGroupsAttrName())))
    #####:  729:    return failure();
        -:  730:
        -:  731:  // alias_scopes
 43505303:  732:  if (failed(verifyOpMetadata<LLVM::AliasScopeMetadataOp>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  733:          op, LLVMDialect::getAliasScopesAttrName())))
    #####:  734:    return failure();
        -:  735:
        -:  736:  // noalias_scopes
 43509103:  737:  if (failed(verifyOpMetadata<LLVM::AliasScopeMetadataOp>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  738:          op, LLVMDialect::getNoAliasScopesAttrName())))
    #####:  739:    return failure();
        -:  740:
 43508314:  741:  return success();
        -:  742:}
        -:  743:
function _ZN4mlir4LLVM6LoadOp6verifyEv called 0 returned 0% blocks executed 0%
22490274*:  744:LogicalResult LoadOp::verify() { return verifyMemoryOpMetadata(*this); }
call    0 returned 100%
call    1 never executed
call    2 never executed
        -:  745:
function _ZN4mlir4LLVM6LoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_5ValueEjbb called 0 returned 0% blocks executed 0%
    #####:  746:void LoadOp::build(OpBuilder &builder, OperationState &result, Type t,
        -:  747:                   Value addr, unsigned alignment, bool isVolatile,
        -:  748:                   bool isNonTemporal) {
    #####:  749:  result.addOperands(addr);
call    0 never executed
call    1 never executed
    #####:  750:  result.addTypes(t);
call    0 never executed
    #####:  751:  if (isVolatile)
branch  0 never executed
branch  1 never executed
    #####:  752:    result.addAttribute(kVolatileAttrName, builder.getUnitAttr());
call    0 never executed
call    1 never executed
    #####:  753:  if (isNonTemporal)
branch  0 never executed
branch  1 never executed
    #####:  754:    result.addAttribute(kNonTemporalAttrName, builder.getUnitAttr());
call    0 never executed
call    1 never executed
    #####:  755:  if (alignment != 0)
branch  0 never executed
branch  1 never executed
    #####:  756:    result.addAttribute("alignment", builder.getI64IntegerAttr(alignment));
call    0 never executed
call    1 never executed
    #####:  757:}
        -:  758:
function _ZN4mlir4LLVM6LoadOp5printERNS_12OpAsmPrinterE called 5571614 returned 100% blocks executed 72%
  5571614:  759:void LoadOp::print(OpAsmPrinter &p) {
  5571614:  760:  p << ' ';
call    0 returned 100%
 5571614*:  761:  if (getVolatile_())
call    0 returned 100%
    #####:  762:    p << "volatile ";
call    0 never executed
  5571614:  763:  p << getAddr();
call    0 returned 100%
call    1 returned 100%
  5571614:  764:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
  5571614:  765:                          {kVolatileAttrName, kElemTypeAttrName});
call    0 returned 100%
 11143228:  766:  p << " : " << getAddr().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  5571614:  767:  if (getAddr().getType().cast<LLVMPointerType>().isOpaque())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  768:    p << " -> " << getType();
call    0 never executed
call    1 never executed
  5571614:  769:}
        -:  770:
        -:  771:// Extract the pointee type from the LLVM pointer type wrapped in MLIR. Return
        -:  772:// the resulting type if any, null type if opaque pointers are used, and None
        -:  773:// if the given type is not the pointer type.
function _ZL23getLoadStoreElementTypeRN4mlir11OpAsmParserENS_4TypeEN4llvm5SMLocE called 5880903 returned 100% blocks executed 56%
  5880903:  774:static Optional<Type> getLoadStoreElementType(OpAsmParser &parser, Type type,
        -:  775:                                              SMLoc trailingTypeLoc) {
  5880903:  776:  auto llvmTy = type.dyn_cast<LLVM::LLVMPointerType>();
call    0 returned 100%
  5880903:  777:  if (!llvmTy) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  778:    parser.emitError(trailingTypeLoc, "expected LLVM pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  779:    return llvm::None;
        -:  780:  }
  5880903:  781:  return llvmTy.getElementType();
call    0 returned 100%
        -:  782:}
        -:  783:
        -:  784:// <operation> ::= `llvm.load` `volatile` ssa-use attribute-dict? `:` type
        -:  785://                 (`->` type)?
function _ZN4mlir4LLVM6LoadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 2870242 returned 100% blocks executed 59%
  2870242:  786:ParseResult LoadOp::parse(OpAsmParser &parser, OperationState &result) {
  2870242:  787:  OpAsmParser::UnresolvedOperand addr;
call    0 returned 100%
  2870242:  788:  Type type;
  2870242:  789:  SMLoc trailingTypeLoc;
        -:  790:
  2870242:  791:  if (succeeded(parser.parseOptionalKeyword("volatile")))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  792:    result.addAttribute(kVolatileAttrName, parser.getBuilder().getUnitAttr());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  793:
 5740484*:  794:  if (parser.parseOperand(addr) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2870242*:  795:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
 8610726*:  796:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
 2870242*:  797:      parser.resolveOperand(addr, type, result.operands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  798:    return failure();
        -:  799:
  2870242:  800:  Optional<Type> elemTy =
  2870242:  801:      getLoadStoreElementType(parser, type, trailingTypeLoc);
call    0 returned 100%
  2870242:  802:  if (!elemTy)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  803:    return failure();
  2870242:  804:  if (*elemTy) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2870242:  805:    result.addTypes(*elemTy);
call    0 returned 100%
  2870242:  806:    return success();
        -:  807:  }
        -:  808:
    #####:  809:  Type trailingType;
    #####:  810:  if (parser.parseArrow() || parser.parseType(trailingType))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  811:    return failure();
    #####:  812:  result.addTypes(trailingType);
call    0 never executed
    #####:  813:  return success();
        -:  814:}
        -:  815:
        -:  816://===----------------------------------------------------------------------===//
        -:  817:// Builder, printer and parser for LLVM::StoreOp.
        -:  818://===----------------------------------------------------------------------===//
        -:  819:
function _ZN4mlir4LLVM7StoreOp6verifyEv called 0 returned 0% blocks executed 0%
21023888*:  820:LogicalResult StoreOp::verify() { return verifyMemoryOpMetadata(*this); }
call    0 returned 100%
call    1 never executed
call    2 never executed
        -:  821:
function _ZN4mlir4LLVM7StoreOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_jbb called 0 returned 0% blocks executed 0%
    #####:  822:void StoreOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  823:                    Value addr, unsigned alignment, bool isVolatile,
        -:  824:                    bool isNonTemporal) {
    #####:  825:  result.addOperands({value, addr});
call    0 never executed
call    1 never executed
    #####:  826:  result.addTypes({});
call    0 never executed
    #####:  827:  if (isVolatile)
branch  0 never executed
branch  1 never executed
    #####:  828:    result.addAttribute(kVolatileAttrName, builder.getUnitAttr());
call    0 never executed
call    1 never executed
    #####:  829:  if (isNonTemporal)
branch  0 never executed
branch  1 never executed
    #####:  830:    result.addAttribute(kNonTemporalAttrName, builder.getUnitAttr());
call    0 never executed
call    1 never executed
    #####:  831:  if (alignment != 0)
branch  0 never executed
branch  1 never executed
    #####:  832:    result.addAttribute("alignment", builder.getI64IntegerAttr(alignment));
call    0 never executed
call    1 never executed
    #####:  833:}
        -:  834:
function _ZN4mlir4LLVM7StoreOp5printERNS_12OpAsmPrinterE called 5873273 returned 100% blocks executed 76%
  5873273:  835:void StoreOp::print(OpAsmPrinter &p) {
  5873273:  836:  p << ' ';
call    0 returned 100%
 5873273*:  837:  if (getVolatile_())
call    0 returned 100%
    #####:  838:    p << "volatile ";
call    0 never executed
 11746546:  839:  p << getValue() << ", " << getAddr();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
  5873273:  840:  p.printOptionalAttrDict((*this)->getAttrs(), {kVolatileAttrName});
call    0 returned 100%
call    1 returned 100%
  5873273:  841:  p << " : ";
call    0 returned 100%
  5873273:  842:  if (getAddr().getType().cast<LLVMPointerType>().isOpaque())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  843:    p << getValue().getType() << ", ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  5873273:  844:  p << getAddr().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  5873273:  845:}
        -:  846:
        -:  847:// <operation> ::= `llvm.store` `volatile` ssa-use `,` ssa-use
        -:  848://                 attribute-dict? `:` type (`,` type)?
function _ZN4mlir4LLVM7StoreOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 3010661 returned 100% blocks executed 72%
  3010661:  849:ParseResult StoreOp::parse(OpAsmParser &parser, OperationState &result) {
  3010661:  850:  OpAsmParser::UnresolvedOperand addr, value;
call    0 returned 100%
  3010661:  851:  Type type;
  3010661:  852:  SMLoc trailingTypeLoc;
        -:  853:
  3010661:  854:  if (succeeded(parser.parseOptionalKeyword("volatile")))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  855:    result.addAttribute(kVolatileAttrName, parser.getBuilder().getUnitAttr());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  856:
 6021322*:  857:  if (parser.parseOperand(value) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 6021322*:  858:      parser.parseOperand(addr) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 3010661*:  859:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
 6021322*:  860:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  861:    return failure();
        -:  862:
  3010661:  863:  Type operandType;
  3010661:  864:  if (succeeded(parser.parseOptionalComma())) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  865:    operandType = type;
    #####:  866:    if (parser.parseType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  867:      return failure();
        -:  868:  } else {
  3010661:  869:    Optional<Type> maybeOperandType =
  3010661:  870:        getLoadStoreElementType(parser, type, trailingTypeLoc);
call    0 returned 100%
  3010661:  871:    if (!maybeOperandType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  872:      return failure();
  3010661:  873:    operandType = *maybeOperandType;
        -:  874:  }
        -:  875:
 6021322*:  876:  if (parser.resolveOperand(value, operandType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 3010661*:  877:      parser.resolveOperand(addr, type, result.operands))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####:  878:    return failure();
        -:  879:
  3010661:  880:  return success();
        -:  881:}
        -:  882:
        -:  883:///===---------------------------------------------------------------------===//
        -:  884:/// LLVM::InvokeOp
        -:  885:///===---------------------------------------------------------------------===//
        -:  886:
function _ZN4mlir4LLVM8InvokeOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  887:SuccessorOperands InvokeOp::getSuccessorOperands(unsigned index) {
    #####:  888:  assert(index < getNumSuccessors() && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  889:  return SuccessorOperands(index == 0 ? getNormalDestOperandsMutable()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  890:                                      : getUnwindDestOperandsMutable());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  891:}
        -:  892:
function _ZN4mlir4LLVM8InvokeOp20getCallableForCalleeEv called 0 returned 0% blocks executed 0%
    #####:  893:CallInterfaceCallable InvokeOp::getCallableForCallee() {
        -:  894:  // Direct call.
    #####:  895:  if (FlatSymbolRefAttr calleeAttr = getCalleeAttr())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  896:    return calleeAttr;
call    0 never executed
        -:  897:  // Indirect call, callee Value is the first operand.
    #####:  898:  return getOperand(0);
call    0 never executed
call    1 never executed
        -:  899:}
        -:  900:
function _ZN4mlir4LLVM8InvokeOp14getArgOperandsEv called 0 returned 0% blocks executed 0%
    #####:  901:Operation::operand_range InvokeOp::getArgOperands() {
    #####:  902:  return getOperands().drop_front(getCallee().has_value() ? 0 : 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  903:}
        -:  904:
function _ZN4mlir4LLVM8InvokeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  905:LogicalResult InvokeOp::verify() {
    #####:  906:  if (getNumResults() > 1)
branch  0 never executed
branch  1 never executed
    #####:  907:    return emitOpError("must have 0 or 1 result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  908:
    #####:  909:  Block *unwindDest = getUnwindDest();
call    0 never executed
    #####:  910:  if (unwindDest->empty())
branch  0 never executed
branch  1 never executed
    #####:  911:    return emitError("must have at least one operation in unwind destination");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  912:
        -:  913:  // In unwind destination, first operation must be LandingpadOp
    #####:  914:  if (!isa<LandingpadOp>(unwindDest->front()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  915:    return emitError("first operation in unwind destination should be a "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  916:                     "llvm.landingpad operation");
call    0 never executed
        -:  917:
    #####:  918:  return success();
        -:  919:}
        -:  920:
function _ZN4mlir4LLVM8InvokeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  921:void InvokeOp::print(OpAsmPrinter &p) {
    #####:  922:  auto callee = getCallee();
call    0 never executed
    #####:  923:  bool isDirect = callee.has_value();
call    0 never executed
        -:  924:
    #####:  925:  p << ' ';
call    0 never executed
        -:  926:
        -:  927:  // Either function name or pointer
    #####:  928:  if (isDirect)
branch  0 never executed
branch  1 never executed
    #####:  929:    p.printSymbolName(callee.value());
call    0 never executed
        -:  930:  else
    #####:  931:    p << getOperand(0);
call    0 never executed
call    1 never executed
        -:  932:
    #####:  933:  p << '(' << getOperands().drop_front(isDirect ? 0 : 1) << ')';
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  934:  p << " to ";
call    0 never executed
    #####:  935:  p.printSuccessorAndUseList(getNormalDest(), getNormalDestOperands());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  936:  p << " unwind ";
call    0 never executed
    #####:  937:  p.printSuccessorAndUseList(getUnwindDest(), getUnwindDestOperands());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  938:
    #####:  939:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 never executed
    #####:  940:                          {InvokeOp::getOperandSegmentSizeAttr(), "callee"});
call    0 never executed
    #####:  941:  p << " : ";
call    0 never executed
    #####:  942:  p.printFunctionalType(llvm::drop_begin(getOperandTypes(), isDirect ? 0 : 1),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  943:                        getResultTypes());
call    0 never executed
    #####:  944:}
        -:  945:
        -:  946:/// <operation> ::= `llvm.invoke` (function-id | ssa-use) `(` ssa-use-list `)`
        -:  947:///                  `to` bb-id (`[` ssa-use-and-type-list `]`)?
        -:  948:///                  `unwind` bb-id (`[` ssa-use-and-type-list `]`)?
        -:  949:///                  attribute-dict? `:` function-type
function _ZN4mlir4LLVM8InvokeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  950:ParseResult InvokeOp::parse(OpAsmParser &parser, OperationState &result) {
    #####:  951:  SmallVector<OpAsmParser::UnresolvedOperand, 8> operands;
call    0 never executed
    #####:  952:  FunctionType funcType;
    #####:  953:  SymbolRefAttr funcAttr;
    #####:  954:  SMLoc trailingTypeLoc;
    #####:  955:  Block *normalDest, *unwindDest;
    #####:  956:  SmallVector<Value, 4> normalOperands, unwindOperands;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  957:  Builder &builder = parser.getBuilder();
call    0 never executed
        -:  958:
        -:  959:  // Parse an operand list that will, in practice, contain 0 or 1 operand.  In
        -:  960:  // case of an indirect call, there will be 1 operand before `(`.  In case of a
        -:  961:  // direct call, there will be no operands and the parser will stop at the
        -:  962:  // function identifier without complaining.
    #####:  963:  if (parser.parseOperandList(operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  964:    return failure();
    #####:  965:  bool isDirect = operands.empty();
branch  0 never executed
branch  1 never executed
        -:  966:
        -:  967:  // Optionally parse a function identifier.
    #####:  968:  if (isDirect && parser.parseAttribute(funcAttr, "callee", result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  969:    return failure();
        -:  970:
    #####:  971:  if (parser.parseOperandList(operands, OpAsmParser::Delimiter::Paren) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  972:      parser.parseKeyword("to") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  973:      parser.parseSuccessorAndUseList(normalDest, normalOperands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  974:      parser.parseKeyword("unwind") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  975:      parser.parseSuccessorAndUseList(unwindDest, unwindOperands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  976:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  977:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(funcType))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  978:    return failure();
        -:  979:
    #####:  980:  if (isDirect) {
branch  0 never executed
branch  1 never executed
        -:  981:    // Make sure types match.
    #####:  982:    if (parser.resolveOperands(operands, funcType.getInputs(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  983:                               parser.getNameLoc(), result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  984:      return failure();
    #####:  985:    result.addTypes(funcType.getResults());
call    0 never executed
call    1 never executed
        -:  986:  } else {
        -:  987:    // Construct the LLVM IR Dialect function type that the first operand
        -:  988:    // should match.
    #####:  989:    if (funcType.getNumResults() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  990:      return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####:  991:                              "expected function with 0 or 1 result");
call    0 never executed
call    1 never executed
        -:  992:
    #####:  993:    Type llvmResultType;
    #####:  994:    if (funcType.getNumResults() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  995:      llvmResultType = LLVM::LLVMVoidType::get(builder.getContext());
call    0 never executed
        -:  996:    } else {
    #####:  997:      llvmResultType = funcType.getResult(0);
call    0 never executed
    #####:  998:      if (!isCompatibleType(llvmResultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  999:        return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####: 1000:                                "expected result to have LLVM type");
call    0 never executed
call    1 never executed
        -: 1001:    }
        -: 1002:
    #####: 1003:    SmallVector<Type, 8> argTypes;
call    0 never executed
    #####: 1004:    argTypes.reserve(funcType.getNumInputs());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1005:    for (Type ty : funcType.getInputs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1006:      if (isCompatibleType(ty))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1007:        argTypes.push_back(ty);
call    0 never executed
        -: 1008:      else
    #####: 1009:        return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####: 1010:                                "expected LLVM types as inputs");
call    0 never executed
call    1 never executed
        -: 1011:    }
        -: 1012:
    #####: 1013:    auto llvmFuncType = LLVM::LLVMFunctionType::get(llvmResultType, argTypes);
call    0 never executed
    #####: 1014:    auto wrappedFuncType = LLVM::LLVMPointerType::get(llvmFuncType);
call    0 never executed
        -: 1015:
    #####: 1016:    auto funcArguments = llvm::makeArrayRef(operands).drop_front();
call    0 never executed
        -: 1017:
        -: 1018:    // Make sure that the first operand (indirect callee) matches the wrapped
        -: 1019:    // LLVM IR function type, and that the types of the other call operands
        -: 1020:    // match the types of the function arguments.
    #####: 1021:    if (parser.resolveOperand(operands[0], wrappedFuncType, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1022:        parser.resolveOperands(funcArguments, funcType.getInputs(),
call    0 never executed
    #####: 1023:                               parser.getNameLoc(), result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1024:      return failure();
        -: 1025:
    #####: 1026:    result.addTypes(llvmResultType);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1027:  }
    #####: 1028:  result.addSuccessors({normalDest, unwindDest});
call    0 never executed
call    1 never executed
    #####: 1029:  result.addOperands(normalOperands);
call    0 never executed
call    1 never executed
    #####: 1030:  result.addOperands(unwindOperands);
call    0 never executed
call    1 never executed
        -: 1031:
    #####: 1032:  result.addAttribute(InvokeOp::getOperandSegmentSizeAttr(),
call    0 never executed
    #####: 1033:                      builder.getDenseI32ArrayAttr(
    #####: 1034:                          {static_cast<int32_t>(operands.size()),
call    0 never executed
    #####: 1035:                           static_cast<int32_t>(normalOperands.size()),
    #####: 1036:                           static_cast<int32_t>(unwindOperands.size())}));
call    0 never executed
    #####: 1037:  return success();
        -: 1038:}
        -: 1039:
        -: 1040:///===----------------------------------------------------------------------===//
        -: 1041:/// Verifying/Printing/Parsing for LLVM::LandingpadOp.
        -: 1042:///===----------------------------------------------------------------------===//
        -: 1043:
function _ZN4mlir4LLVM12LandingpadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1044:LogicalResult LandingpadOp::verify() {
    #####: 1045:  Value value;
    #####: 1046:  if (LLVMFuncOp func = (*this)->getParentOfType<LLVMFuncOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1047:    if (!func.getPersonality())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1048:      return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1049:          "llvm.landingpad needs to be in a function with a personality");
call    0 never executed
        -: 1050:  }
        -: 1051:
    #####: 1052:  if (!getCleanup() && getOperands().empty())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1053:    return emitError("landingpad instruction expects at least one clause or "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1054:                     "cleanup attribute");
call    0 never executed
        -: 1055:
    #####: 1056:  for (unsigned idx = 0, ie = getNumOperands(); idx < ie; idx++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1057:    value = getOperand(idx);
call    0 never executed
    #####: 1058:    bool isFilter = value.getType().isa<LLVMArrayType>();
call    0 never executed
    #####: 1059:    if (isFilter) {
branch  0 never executed
branch  1 never executed
        -: 1060:      // FIXME: Verify filter clauses when arrays are appropriately handled
        -: 1061:    } else {
        -: 1062:      // catch - global addresses only.
        -: 1063:      // Bitcast ops should have global addresses as their args.
    #####: 1064:      if (auto bcOp = value.getDefiningOp<BitcastOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1065:        if (auto addrOp = bcOp.getArg().getDefiningOp<AddressOfOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1066:          continue;
    #####: 1067:        return emitError("constant clauses expected").attachNote(bcOp.getLoc())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1068:               << "global addresses expected as operand to "
    #####: 1069:                  "bitcast used in clauses for landingpad";
call    0 never executed
call    1 never executed
        -: 1070:      }
        -: 1071:      // NullOp and AddressOfOp allowed
    #####: 1072:      if (value.getDefiningOp<NullOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1073:        continue;
    #####: 1074:      if (value.getDefiningOp<AddressOfOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1075:        continue;
    #####: 1076:      return emitError("clause #")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1077:             << idx << " is not a known constant - null, addressof, bitcast";
call    0 never executed
call    1 never executed
        -: 1078:    }
        -: 1079:  }
    #####: 1080:  return success();
        -: 1081:}
        -: 1082:
function _ZN4mlir4LLVM12LandingpadOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1083:void LandingpadOp::print(OpAsmPrinter &p) {
    #####: 1084:  p << (getCleanup() ? " cleanup " : " ");
call    0 never executed
call    1 never executed
        -: 1085:
        -: 1086:  // Clauses
    #####: 1087:  for (auto value : getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1088:    // Similar to llvm - if clause is an array type then it is filter
        -: 1089:    // clause else catch clause
    #####: 1090:    bool isArrayTy = value.getType().isa<LLVMArrayType>();
call    0 never executed
    #####: 1091:    p << '(' << (isArrayTy ? "filter " : "catch ") << value << " : "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1092:      << value.getType() << ") ";
call    0 never executed
call    1 never executed
        -: 1093:  }
        -: 1094:
    #####: 1095:  p.printOptionalAttrDict((*this)->getAttrs(), {"cleanup"});
call    0 never executed
call    1 never executed
        -: 1096:
    #####: 1097:  p << ": " << getType();
call    0 never executed
call    1 never executed
    #####: 1098:}
        -: 1099:
        -: 1100:/// <operation> ::= `llvm.landingpad` `cleanup`?
        -: 1101:///                 ((`catch` | `filter`) operand-type ssa-use)* attribute-dict?
function _ZN4mlir4LLVM12LandingpadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1102:ParseResult LandingpadOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 1103:  // Check for cleanup
    #####: 1104:  if (succeeded(parser.parseOptionalKeyword("cleanup")))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1105:    result.addAttribute("cleanup", parser.getBuilder().getUnitAttr());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1106:
        -: 1107:  // Parse clauses with types
    #####: 1108:  while (succeeded(parser.parseOptionalLParen()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1109:         (succeeded(parser.parseOptionalKeyword("filter")) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1110:          succeeded(parser.parseOptionalKeyword("catch")))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1111:    OpAsmParser::UnresolvedOperand operand;
call    0 never executed
    #####: 1112:    Type ty;
    #####: 1113:    if (parser.parseOperand(operand) || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1114:        parser.parseType(ty) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1115:        parser.resolveOperand(operand, ty, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1116:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1117:      return failure();
        -: 1118:  }
        -: 1119:
    #####: 1120:  Type type;
    #####: 1121:  if (parser.parseColon() || parser.parseType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1122:    return failure();
        -: 1123:
    #####: 1124:  result.addTypes(type);
call    0 never executed
    #####: 1125:  return success();
        -: 1126:}
        -: 1127:
        -: 1128://===----------------------------------------------------------------------===//
        -: 1129:// CallOp
        -: 1130://===----------------------------------------------------------------------===//
        -: 1131:
function _ZN4mlir4LLVM6CallOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm9StringRefENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1132:void CallOp::build(OpBuilder &builder, OperationState &state, TypeRange results,
        -: 1133:                   StringRef callee, ValueRange args) {
    #####: 1134:  build(builder, state, results, builder.getStringAttr(callee), args);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1135:}
        -: 1136:
function _ZN4mlir4LLVM6CallOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_10StringAttrENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1137:void CallOp::build(OpBuilder &builder, OperationState &state, TypeRange results,
        -: 1138:                   StringAttr callee, ValueRange args) {
    #####: 1139:  build(builder, state, results, SymbolRefAttr::get(callee), args, nullptr);
call    0 never executed
call    1 never executed
    #####: 1140:}
        -: 1141:
function _ZN4mlir4LLVM6CallOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_10LLVMFuncOpENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1142:void CallOp::build(OpBuilder &builder, OperationState &state, LLVMFuncOp func,
        -: 1143:                   ValueRange args) {
    #####: 1144:  SmallVector<Type> results;
call    0 never executed
    #####: 1145:  Type resultType = func.getFunctionType().getReturnType();
call    0 never executed
call    1 never executed
    #####: 1146:  if (!resultType.isa<LLVM::LLVMVoidType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1147:    results.push_back(resultType);
call    0 never executed
    #####: 1148:  build(builder, state, results, SymbolRefAttr::get(func), args, nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1149:}
        -: 1150:
function _ZN4mlir4LLVM6CallOp20getCallableForCalleeEv called 136415 returned 100% blocks executed 62%
   136415: 1151:CallInterfaceCallable CallOp::getCallableForCallee() {
        -: 1152:  // Direct call.
   136415: 1153:  if (FlatSymbolRefAttr calleeAttr = getCalleeAttr())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   136415: 1154:    return calleeAttr;
call    0 returned 100%
        -: 1155:  // Indirect call, callee Value is the first operand.
    #####: 1156:  return getOperand(0);
call    0 never executed
call    1 never executed
        -: 1157:}
        -: 1158:
function _ZN4mlir4LLVM6CallOp14getArgOperandsEv called 1034 returned 100% blocks executed 83%
     1034: 1159:Operation::operand_range CallOp::getArgOperands() {
     1034: 1160:  return getOperands().drop_front(getCallee().has_value() ? 0 : 1);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -: 1161:}
        -: 1162:
function _ZN4mlir4LLVM6CallOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 10028654 returned 100% blocks executed 27%
 10028654: 1163:LogicalResult CallOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
 10028654: 1164:  if (getNumResults() > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1165:    return emitOpError("must have 0 or 1 result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1166:
        -: 1167:  // Type for the callee, we'll get it differently depending if it is a direct
        -: 1168:  // or indirect call.
 10028654: 1169:  Type fnType;
        -: 1170:
 10028654: 1171:  bool isIndirect = false;
        -: 1172:
        -: 1173:  // If this is an indirect call, the callee attribute is missing.
 10028654: 1174:  FlatSymbolRefAttr calleeName = getCalleeAttr();
call    0 returned 100%
 10028654: 1175:  if (!calleeName) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1176:    isIndirect = true;
    #####: 1177:    if (!getNumOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1178:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1179:          "must have either a `callee` attribute or at least an operand");
call    0 never executed
    #####: 1180:    auto ptrType = getOperand(0).getType().dyn_cast<LLVMPointerType>();
call    0 never executed
call    1 never executed
    #####: 1181:    if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 1182:      return emitOpError("indirect call expects a pointer as callee: ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1183:             << ptrType;
call    0 never executed
    #####: 1184:    fnType = ptrType.getElementType();
call    0 never executed
        -: 1185:  } else {
 10028654: 1186:    Operation *callee =
call    0 returned 100%
 10028654: 1187:        symbolTable.lookupNearestSymbolFrom(*this, calleeName.getAttr());
call    0 returned 100%
 10028654: 1188:    if (!callee)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1189:      return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1190:             << "'" << calleeName.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1191:             << "' does not reference a symbol in the current scope";
call    0 never executed
 10028654: 1192:    auto fn = dyn_cast<LLVMFuncOp>(callee);
call    0 returned 100%
 10028654: 1193:    if (!fn)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1194:      return emitOpError() << "'" << calleeName.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1195:                           << "' does not reference a valid LLVM function";
call    0 never executed
        -: 1196:
 10028654: 1197:    fnType = fn.getFunctionType();
call    0 returned 100%
        -: 1198:  }
        -: 1199:
 10028654: 1200:  LLVMFunctionType funcType = fnType.dyn_cast<LLVMFunctionType>();
call    0 returned 100%
 10028654: 1201:  if (!funcType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1202:    return emitOpError("callee does not have a functional type: ") << fnType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1203:
        -: 1204:  // Verify that the operand and result types match the callee.
        -: 1205:
 10028654: 1206:  if (!funcType.isVarArg() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 10028654: 1207:      funcType.getNumParams() != (getNumOperands() - isIndirect))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1208:    return emitOpError() << "incorrect number of operands ("
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1209:                         << (getNumOperands() - isIndirect)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1210:                         << ") for callee (expecting: "
call    0 never executed
    #####: 1211:                         << funcType.getNumParams() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1212:
 10028654: 1213:  if (funcType.getNumParams() > (getNumOperands() - isIndirect))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1214:    return emitOpError() << "incorrect number of operands ("
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1215:                         << (getNumOperands() - isIndirect)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1216:                         << ") for varargs callee (expecting at least: "
call    0 never executed
    #####: 1217:                         << funcType.getNumParams() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1218:
 31783551: 1219:  for (unsigned i = 0, e = funcType.getNumParams(); i != e; ++i)
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
 21754897: 1220:    if (getOperand(i + isIndirect).getType() != funcType.getParamType(i))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1221:      return emitOpError() << "operand type mismatch for operand " << i << ": "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1222:                           << getOperand(i + isIndirect).getType()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1223:                           << " != " << funcType.getParamType(i);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1224:
 10028654: 1225:  if (getNumResults() == 0 &&
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
 1919395*: 1226:      !funcType.getReturnType().isa<LLVM::LLVMVoidType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 1227:    return emitOpError() << "expected function call to produce a value";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1228:
 10028654: 1229:  if (getNumResults() != 0 &&
branch  0 taken 81%
branch  1 taken 19%
 8109259*: 1230:      funcType.getReturnType().isa<LLVM::LLVMVoidType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 1231:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1232:           << "calling function with void result must not produce values";
call    0 never executed
        -: 1233:
 10028654: 1234:  if (getNumResults() > 1)
branch  0 taken 0%
branch  1 taken 100%
    #####: 1235:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1236:           << "expected LLVM function call to produce 0 or 1 result";
call    0 never executed
        -: 1237:
10028654*: 1238:  if (getNumResults() && getResult().getType() != funcType.getReturnType())
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 1239:    return emitOpError() << "result type mismatch: " << getResult().getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1240:                         << " != " << funcType.getReturnType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1241:
 10028654: 1242:  return success();
        -: 1243:}
        -: 1244:
function _ZN4mlir4LLVM6CallOp5printERNS_12OpAsmPrinterE called 5764928 returned 100% blocks executed 81%
  5764928: 1245:void CallOp::print(OpAsmPrinter &p) {
  5764928: 1246:  auto callee = getCallee();
call    0 returned 100%
  5764928: 1247:  bool isDirect = callee.has_value();
call    0 returned 100%
        -: 1248:
        -: 1249:  // Print the direct callee if present as a function attribute, or an indirect
        -: 1250:  // callee (first operand) otherwise.
  5764928: 1251:  p << ' ';
call    0 returned 100%
  5764928: 1252:  if (isDirect)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  5764928: 1253:    p.printSymbolName(callee.value());
call    0 returned 100%
        -: 1254:  else
    #####: 1255:    p << getOperand(0);
call    0 never executed
call    1 never executed
        -: 1256:
  5764928: 1257:  auto args = getOperands().drop_front(isDirect ? 0 : 1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
  5764928: 1258:  p << '(' << args << ')';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  5764928: 1259:  p.printOptionalAttrDict(processFMFAttr((*this)->getAttrs()), {"callee"});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1260:
        -: 1261:  // Reconstruct the function MLIR function type from operand and result types.
  5764928: 1262:  p << " : ";
call    0 returned 100%
 11529856: 1263:  p.printFunctionalType(args.getTypes(), getResultTypes());
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
call    2 returned 100%
call    3 returned 100%
  5764928: 1264:}
        -: 1265:
        -: 1266:// <operation> ::= `llvm.call` (function-id | ssa-use) `(` ssa-use-list `)`
        -: 1267://                 attribute-dict? `:` function-type
function _ZN4mlir4LLVM6CallOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 2954380 returned 100% blocks executed 35%
  2954380: 1268:ParseResult CallOp::parse(OpAsmParser &parser, OperationState &result) {
  2954380: 1269:  SmallVector<OpAsmParser::UnresolvedOperand, 8> operands;
call    0 returned 100%
  2954380: 1270:  Type type;
  2954380: 1271:  SymbolRefAttr funcAttr;
  2954380: 1272:  SMLoc trailingTypeLoc;
        -: 1273:
        -: 1274:  // Parse an operand list that will, in practice, contain 0 or 1 operand.  In
        -: 1275:  // case of an indirect call, there will be 1 operand before `(`.  In case of a
        -: 1276:  // direct call, there will be no operands and the parser will stop at the
        -: 1277:  // function identifier without complaining.
  2954380: 1278:  if (parser.parseOperandList(operands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1279:    return failure();
  2954380: 1280:  bool isDirect = operands.empty();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1281:
        -: 1282:  // Optionally parse a function identifier.
  2954380: 1283:  if (isDirect)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2954380: 1284:    if (parser.parseAttribute(funcAttr, "callee", result.attributes))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1285:      return failure();
        -: 1286:
 5908760*: 1287:  if (parser.parseOperandList(operands, OpAsmParser::Delimiter::Paren) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2954380*: 1288:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
 5908760*: 1289:      parser.getCurrentLocation(&trailingTypeLoc) || parser.parseType(type))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 1290:    return failure();
        -: 1291:
  2954380: 1292:  auto funcType = type.dyn_cast<FunctionType>();
call    0 returned 100%
  2954380: 1293:  if (!funcType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1294:    return parser.emitError(trailingTypeLoc, "expected function type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  2954380: 1295:  if (funcType.getNumResults() > 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1296:    return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####: 1297:                            "expected function with 0 or 1 result");
call    0 never executed
call    1 never executed
  2954380: 1298:  if (isDirect) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1299:    // Make sure types match.
  5908760: 1300:    if (parser.resolveOperands(operands, funcType.getInputs(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  5908760: 1301:                               parser.getNameLoc(), result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1302:      return failure();
  2954380: 1303:    if (funcType.getNumResults() != 0 &&
call    0 returned 100%
branch  1 taken 81% (fallthrough)
branch  2 taken 19%
  2954380: 1304:        !funcType.getResult(0).isa<LLVM::LLVMVoidType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  2392064: 1305:      result.addTypes(funcType.getResults());
call    0 returned 100%
call    1 returned 100%
        -: 1306:  } else {
    #####: 1307:    Builder &builder = parser.getBuilder();
call    0 never executed
    #####: 1308:    Type llvmResultType;
    #####: 1309:    if (funcType.getNumResults() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1310:      llvmResultType = LLVM::LLVMVoidType::get(builder.getContext());
call    0 never executed
        -: 1311:    } else {
    #####: 1312:      llvmResultType = funcType.getResult(0);
call    0 never executed
    #####: 1313:      if (!isCompatibleType(llvmResultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1314:        return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####: 1315:                                "expected result to have LLVM type");
call    0 never executed
call    1 never executed
        -: 1316:    }
        -: 1317:
    #####: 1318:    SmallVector<Type, 8> argTypes;
call    0 never executed
    #####: 1319:    argTypes.reserve(funcType.getNumInputs());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1320:    for (int i = 0, e = funcType.getNumInputs(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1321:      auto argType = funcType.getInput(i);
call    0 never executed
    #####: 1322:      if (!isCompatibleType(argType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1323:        return parser.emitError(trailingTypeLoc,
call    0 never executed
call    1 never executed
    #####: 1324:                                "expected LLVM types as inputs");
call    0 never executed
call    1 never executed
    #####: 1325:      argTypes.push_back(argType);
call    0 never executed
        -: 1326:    }
    #####: 1327:    auto llvmFuncType = LLVM::LLVMFunctionType::get(llvmResultType, argTypes);
call    0 never executed
    #####: 1328:    auto wrappedFuncType = LLVM::LLVMPointerType::get(llvmFuncType);
call    0 never executed
        -: 1329:
    #####: 1330:    auto funcArguments =
call    0 never executed
    #####: 1331:        ArrayRef<OpAsmParser::UnresolvedOperand>(operands).drop_front();
call    0 never executed
        -: 1332:
        -: 1333:    // Make sure that the first operand (indirect callee) matches the wrapped
        -: 1334:    // LLVM IR function type, and that the types of the other call operands
        -: 1335:    // match the types of the function arguments.
    #####: 1336:    if (parser.resolveOperand(operands[0], wrappedFuncType, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1337:        parser.resolveOperands(funcArguments, funcType.getInputs(),
call    0 never executed
    #####: 1338:                               parser.getNameLoc(), result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1339:      return failure();
        -: 1340:
    #####: 1341:    if (!llvmResultType.isa<LLVM::LLVMVoidType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1342:      result.addTypes(llvmResultType);
call    0 never executed
        -: 1343:  }
        -: 1344:
  2954380: 1345:  return success();
        -: 1346:}
        -: 1347:
        -: 1348://===----------------------------------------------------------------------===//
        -: 1349:// ExtractElementOp
        -: 1350://===----------------------------------------------------------------------===//
        -: 1351:
        -: 1352:/// Expects vector to be an LLVM vector type and position to be an integer type.
function _ZN4mlir4LLVM16ExtractElementOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1353:void LLVM::ExtractElementOp::build(OpBuilder &b, OperationState &result,
        -: 1354:                                   Value vector, Value position,
        -: 1355:                                   ArrayRef<NamedAttribute> attrs) {
    #####: 1356:  auto vectorType = vector.getType();
call    0 never executed
    #####: 1357:  auto llvmType = LLVM::getVectorElementType(vectorType);
call    0 never executed
    #####: 1358:  build(b, result, llvmType, vector, position);
call    0 never executed
    #####: 1359:  result.addAttributes(attrs);
call    0 never executed
    #####: 1360:}
        -: 1361:
        -: 1362://===----------------------------------------------------------------------===//
        -: 1363:// ExtractValueOp
        -: 1364://===----------------------------------------------------------------------===//
        -: 1365:
        -: 1366:/// Extract the type at `position` in the LLVM IR aggregate type
        -: 1367:/// `containerType`. Each element of `position` is an index into a nested
        -: 1368:/// aggregate type. Return the resulting type or emit an error.
function _ZL32getInsertExtractValueElementTypeN4llvm12function_refIFN4mlir18InFlightDiagnosticENS_9StringRefEEEENS1_4TypeENS_8ArrayRefIlEE called 148154139 returned 100% blocks executed 52%
148154139: 1369:static Type getInsertExtractValueElementType(
        -: 1370:    function_ref<InFlightDiagnostic(StringRef)> emitError, Type containerType,
        -: 1371:    ArrayRef<int64_t> position) {
148154139: 1372:  Type llvmType = containerType;
148154139: 1373:  if (!isCompatibleType(containerType)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1374:    emitError("expected LLVM IR Dialect type, got ") << containerType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1375:    return {};
        -: 1376:  }
        -: 1377:
        -: 1378:  // Infer the element type from the structure type: iteratively step inside the
        -: 1379:  // type by taking the element type, indexed by the position attribute for
        -: 1380:  // structures.  Check the position index before accessing, it is supposed to
        -: 1381:  // be in bounds.
385696312: 1382:  for (int64_t idx : position) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
237774674: 1383:    if (auto arrayType = llvmType.dyn_cast<LLVMArrayType>()) {
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
 90406454: 1384:      if (idx < 0 || static_cast<unsigned>(idx) >= arrayType.getNumElements()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1385:        emitError("position out of bounds: ") << idx;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1386:        return {};
        -: 1387:      }
 90401050: 1388:      llvmType = arrayType.getElementType();
call    0 returned 100%
147491240: 1389:    } else if (auto structType = llvmType.dyn_cast<LLVMStructType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
294647416: 1390:      if (idx < 0 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
147332404*: 1391:          static_cast<unsigned>(idx) >= structType.getBody().size()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####: 1392:        emitError("position out of bounds: ") << idx;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1393:        return {};
        -: 1394:      }
147315012: 1395:      llvmType = structType.getBody()[idx];
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
        -: 1396:    } else {
    #####: 1397:      emitError("expected LLVM IR structure/array type, got: ") << llvmType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1398:      return {};
        -: 1399:    }
        -: 1400:  }
147921638: 1401:  return llvmType;
        -: 1402:}
        -: 1403:
        -: 1404:/// Extract the type at `position` in the wrapped LLVM IR aggregate type
        -: 1405:/// `containerType`.
function _ZL32getInsertExtractValueElementTypeN4mlir4TypeEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1406:static Type getInsertExtractValueElementType(Type llvmType,
        -: 1407:                                             ArrayRef<int64_t> position) {
    #####: 1408:  for (int64_t idx : position) {
branch  0 never executed
branch  1 never executed
    #####: 1409:    if (auto structType = llvmType.dyn_cast<LLVMStructType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1410:      llvmType = structType.getBody()[idx];
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1411:    else
    #####: 1412:      llvmType = llvmType.cast<LLVMArrayType>().getElementType();
call    0 never executed
call    1 never executed
        -: 1413:  }
    #####: 1414:  return llvmType;
        -: 1415:}
        -: 1416:
function _ZN4mlir4LLVM14ExtractValueOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 2835517 returned 100% blocks executed 90%
  2835517: 1417:OpFoldResult LLVM::ExtractValueOp::fold(ArrayRef<Attribute> operands) {
  2835517: 1418:  auto insertValueOp = getContainer().getDefiningOp<InsertValueOp>();
call    0 returned 100%
call    1 returned 100%
  2835517: 1419:  OpFoldResult result = {};
  6488690: 1420:  while (insertValueOp) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
 12584292: 1421:    if (getPosition() == insertValueOp.getPosition())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 13% (fallthrough)
branch  3 taken 87%
   541591: 1422:      return insertValueOp.getValue();
call    0 returned 100%
call    1 returned 100%
  3653173: 1423:    unsigned min =
call    0 returned 100%
  7306346: 1424:        std::min(getPosition().size(), insertValueOp.getPosition().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1425:    // If one is fully prefix of the other, stop propagating back as it will
        -: 1426:    // miss dependencies. For instance, %3 should not fold to %f0 in the
        -: 1427:    // following example:
        -: 1428:    // ```
        -: 1429:    //   %1 = llvm.insertvalue %f0, %0[0, 0] :
        -: 1430:    //     !llvm.array<4 x !llvm.array<4 x f32>>
        -: 1431:    //   %2 = llvm.insertvalue %arr, %1[0] :
        -: 1432:    //     !llvm.array<4 x !llvm.array<4 x f32>>
        -: 1433:    //   %3 = llvm.extractvalue %2[0, 0] : !llvm.array<4 x !llvm.array<4 x f32>>
        -: 1434:    // ```
 14612692: 1435:    if (getPosition().take_front(min) ==
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
  7306346: 1436:        insertValueOp.getPosition().take_front(min))
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1437:      return result;
        -: 1438:
        -: 1439:    // If neither a prefix, nor the exact position, we can extract out of the
        -: 1440:    // value being inserted into. Moreover, we can try again if that operand
        -: 1441:    // is itself an insertvalue expression.
  3653173: 1442:    getContainerMutable().assign(insertValueOp.getContainer());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  3653173: 1443:    result = getResult();
call    0 returned 100%
  3653173: 1444:    insertValueOp = insertValueOp.getContainer().getDefiningOp<InsertValueOp>();
call    0 returned 100%
call    1 returned 100%
        -: 1445:  }
  2293926: 1446:  return result;
        -: 1447:}
        -: 1448:
function _ZN4mlir4LLVM14ExtractValueOp6verifyEv called 28254311 returned 100% blocks executed 39%
 28254311: 1449:LogicalResult ExtractValueOp::verify() {
    #####: 1450:  auto emitError = [this](StringRef msg) { return emitOpError(msg); };
call    0 never executed
call    1 never executed
 28254311: 1451:  Type valueType = getInsertExtractValueElementType(
call    0 returned 100%
 28257987: 1452:      emitError, getContainer().getType(), getPosition());
call    0 returned 100%
call    1 returned 100%
 28252359: 1453:  if (!valueType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1454:    return failure();
        -: 1455:
 28252359: 1456:  if (getRes().getType() != valueType)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1457:    return emitOpError() << "Type mismatch: extracting from "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1458:                         << getContainer().getType() << " should produce "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1459:                         << valueType << " but this op returns "
call    0 never executed
    #####: 1460:                         << getRes().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 28251985: 1461:  return success();
        -: 1462:}
        -: 1463:
function _ZN4mlir4LLVM14ExtractValueOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1464:void ExtractValueOp::build(OpBuilder &builder, OperationState &state,
        -: 1465:                           Value container, ArrayRef<int64_t> position) {
    #####: 1466:  build(builder, state,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1467:        getInsertExtractValueElementType(container.getType(), position),
        -: 1468:        container, builder.getAttr<DenseI64ArrayAttr>(position));
    #####: 1469:}
        -: 1470:
        -: 1471://===----------------------------------------------------------------------===//
        -: 1472:// InsertValueOp
        -: 1473://===----------------------------------------------------------------------===//
        -: 1474:
        -: 1475:/// Infer the value type from the container type and position.
        -: 1476:static ParseResult
function _ZL34parseInsertExtractValueElementTypeRN4mlir9AsmParserERNS_4TypeES2_NS_6detail18DenseArrayAttrImplIlEE called 17346423 returned 100% blocks executed 100%
 17346423: 1477:parseInsertExtractValueElementType(AsmParser &parser, Type &valueType,
        -: 1478:                                   Type containerType,
        -: 1479:                                   DenseI64ArrayAttr position) {
 17346423: 1480:  valueType = getInsertExtractValueElementType(
call    0 returned 100%
function _ZZL34parseInsertExtractValueElementTypeRN4mlir9AsmParserERNS_4TypeES2_NS_6detail18DenseArrayAttrImplIlEEENKUlN4llvm9StringRefEE_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1481:      [&](StringRef msg) {
    #####: 1482:        return parser.emitError(parser.getCurrentLocation(), msg);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1483:      },
 17346423: 1484:      containerType, position.asArrayRef());
call    0 returned 100%
 17346423: 1485:  return success(!!valueType);
        -: 1486:}
        -: 1487:
        -: 1488:/// Nothing to print for an inferred type.
 30103634: 1489:static void printInsertExtractValueElementType(AsmPrinter &printer,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1490:                                               Operation *op, Type valueType,
        -: 1491:                                               Type containerType,
        -: 1492:                                               DenseI64ArrayAttr position) {}
        -: 1493:
function _ZN4mlir4LLVM13InsertValueOp6verifyEv called 102653936 returned 100% blocks executed 43%
102653936: 1494:LogicalResult InsertValueOp::verify() {
    #####: 1495:  auto emitError = [this](StringRef msg) { return emitOpError(msg); };
call    0 never executed
call    1 never executed
102653936: 1496:  Type valueType = getInsertExtractValueElementType(
call    0 returned 100%
102831752: 1497:      emitError, getContainer().getType(), getPosition());
call    0 returned 100%
call    1 returned 100%
102701409: 1498:  if (!valueType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1499:    return failure();
        -: 1500:
102701409: 1501:  if (getValue().getType() != valueType)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1502:    return emitOpError() << "Type mismatch: cannot insert "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1503:                         << getValue().getType() << " into "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1504:                         << getContainer().getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1505:
102698782: 1506:  return success();
        -: 1507:}
        -: 1508:
        -: 1509://===----------------------------------------------------------------------===//
        -: 1510:// ReturnOp
        -: 1511://===----------------------------------------------------------------------===//
        -: 1512:
function _ZN4mlir4LLVM8ReturnOp6verifyEv called 3728324 returned 100% blocks executed 42%
  3728324: 1513:LogicalResult ReturnOp::verify() {
  3728324: 1514:  auto parent = (*this)->getParentOfType<LLVMFuncOp>();
call    0 returned 100%
  3742167: 1515:  if (!parent)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
   304565: 1516:    return success();
        -: 1517:
  3437602: 1518:  Type expectedType = parent.getFunctionType().getReturnType();
call    0 returned 100%
call    1 returned 100%
  3434808: 1519:  if (expectedType.isa<LLVMVoidType>()) {
call    0 returned 100%
branch  1 taken 10% (fallthrough)
branch  2 taken 90%
   326985: 1520:    if (!getArg())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   326985: 1521:      return success();
    #####: 1522:    InFlightDiagnostic diag = emitOpError("expected no operands");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1523:    diag.attachNote(parent->getLoc()) << "when returning from function";
call    0 never executed
call    1 never executed
    #####: 1524:    return diag;
call    0 never executed
        -: 1525:  }
  3108959: 1526:  if (!getArg()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1527:    if (expectedType.isa<LLVMVoidType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1528:      return success();
    #####: 1529:    InFlightDiagnostic diag = emitOpError("expected 1 operand");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1530:    diag.attachNote(parent->getLoc()) << "when returning from function";
call    0 never executed
call    1 never executed
    #####: 1531:    return diag;
call    0 never executed
        -: 1532:  }
  3106508: 1533:  if (expectedType != getArg().getType()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1534:    InFlightDiagnostic diag = emitOpError("mismatching result types");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1535:    diag.attachNote(parent->getLoc()) << "when returning from function";
call    0 never executed
call    1 never executed
    #####: 1536:    return diag;
call    0 never executed
        -: 1537:  }
  3103018: 1538:  return success();
        -: 1539:}
        -: 1540:
        -: 1541://===----------------------------------------------------------------------===//
        -: 1542:// ResumeOp
        -: 1543://===----------------------------------------------------------------------===//
        -: 1544:
function _ZN4mlir4LLVM8ResumeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1545:LogicalResult ResumeOp::verify() {
    #####: 1546:  if (!getValue().getDefiningOp<LandingpadOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1547:    return emitOpError("expects landingpad value as operand");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1548:  // No check for personality of function - landingpad op verifies it.
    #####: 1549:  return success();
        -: 1550:}
        -: 1551:
        -: 1552://===----------------------------------------------------------------------===//
        -: 1553:// Verifier for LLVM::AddressOfOp.
        -: 1554://===----------------------------------------------------------------------===//
        -: 1555:
function _ZL16parentLLVMModulePN4mlir9OperationE called 2713400 returned 100% blocks executed 92%
  2713400: 1556:static Operation *parentLLVMModule(Operation *op) {
  2713400: 1557:  Operation *module = op->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  5426800: 1558:  while (module && !satisfiesLLVMModule(module))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
  2713400: 1559:    module = module->getParentOp();
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
call    2 returned 100%
 2713400*: 1560:  assert(module && "unexpected operation outside of a module");
branch  0 taken 0%
branch  1 taken 100%
call    2 never executed
  2713400: 1561:  return module;
        -: 1562:}
        -: 1563:
function _ZN4mlir4LLVM11AddressOfOp9getGlobalERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####: 1564:GlobalOp AddressOfOp::getGlobal(SymbolTableCollection &symbolTable) {
    #####: 1565:  return dyn_cast_or_null<GlobalOp>(
    #####: 1566:      symbolTable.lookupSymbolIn(parentLLVMModule(*this), getGlobalNameAttr()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1567:}
        -: 1568:
function _ZN4mlir4LLVM11AddressOfOp11getFunctionERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####: 1569:LLVMFuncOp AddressOfOp::getFunction(SymbolTableCollection &symbolTable) {
    #####: 1570:  return dyn_cast_or_null<LLVMFuncOp>(
    #####: 1571:      symbolTable.lookupSymbolIn(parentLLVMModule(*this), getGlobalNameAttr()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1572:}
        -: 1573:
        -: 1574:LogicalResult
function _ZN4mlir4LLVM11AddressOfOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 2713400 returned 100% blocks executed 49%
  2713400: 1575:AddressOfOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
  2713400: 1576:  Operation *symbol =
  2713400: 1577:      symbolTable.lookupSymbolIn(parentLLVMModule(*this), getGlobalNameAttr());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1578:
  2713400: 1579:  auto global = dyn_cast_or_null<GlobalOp>(symbol);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2713400: 1580:  auto function = dyn_cast_or_null<LLVMFuncOp>(symbol);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1581:
 2713400*: 1582:  if (!global && !function)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1583:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1584:        "must reference a global defined by 'llvm.mlir.global' or 'llvm.func'");
call    0 never executed
        -: 1585:
  2713400: 1586:  LLVMPointerType type = getType();
call    0 returned 100%
  2713400: 1587:  if (global && global.getAddrSpace() != type.getAddressSpace())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 1588:    return emitOpError("pointer address space must match address space of the "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1589:                       "referenced global");
call    0 never executed
        -: 1590:
  2713400: 1591:  if (type.isOpaque())
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 1592:    return success();
        -: 1593:
 5426800*: 1594:  if (global && type.getElementType() != global.getType())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 1595:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1596:        "the type must be a pointer to the type of the referenced global");
call    0 never executed
        -: 1597:
 2713400*: 1598:  if (function && type.getElementType() != function.getFunctionType())
branch  0 taken 0%
branch  1 taken 100%
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1599:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1600:        "the type must be a pointer to the type of the referenced function");
call    0 never executed
        -: 1601:
  2713400: 1602:  return success();
        -: 1603:}
        -: 1604:
        -: 1605://===----------------------------------------------------------------------===//
        -: 1606:// Builder, printer and verifier for LLVM::GlobalOp.
        -: 1607://===----------------------------------------------------------------------===//
        -: 1608:
function _ZN4mlir4LLVM8GlobalOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeEbNS0_7linkage7LinkageEN4llvm9StringRefENS_9AttributeEmjbbNS9_8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1609:void GlobalOp::build(OpBuilder &builder, OperationState &result, Type type,
        -: 1610:                     bool isConstant, Linkage linkage, StringRef name,
        -: 1611:                     Attribute value, uint64_t alignment, unsigned addrSpace,
        -: 1612:                     bool dsoLocal, bool threadLocal,
        -: 1613:                     ArrayRef<NamedAttribute> attrs) {
    #####: 1614:  result.addAttribute(getSymNameAttrName(result.name),
call    0 never executed
    #####: 1615:                      builder.getStringAttr(name));
call    0 never executed
call    1 never executed
    #####: 1616:  result.addAttribute(getGlobalTypeAttrName(result.name), TypeAttr::get(type));
call    0 never executed
call    1 never executed
    #####: 1617:  if (isConstant)
branch  0 never executed
branch  1 never executed
    #####: 1618:    result.addAttribute(getConstantAttrName(result.name),
call    0 never executed
    #####: 1619:                        builder.getUnitAttr());
call    0 never executed
    #####: 1620:  if (value)
branch  0 never executed
branch  1 never executed
    #####: 1621:    result.addAttribute(getValueAttrName(result.name), value);
call    0 never executed
call    1 never executed
    #####: 1622:  if (dsoLocal)
branch  0 never executed
branch  1 never executed
    #####: 1623:    result.addAttribute(getDsoLocalAttrName(result.name),
call    0 never executed
    #####: 1624:                        builder.getUnitAttr());
call    0 never executed
    #####: 1625:  if (threadLocal)
branch  0 never executed
branch  1 never executed
    #####: 1626:    result.addAttribute(getThreadLocal_AttrName(result.name),
call    0 never executed
    #####: 1627:                        builder.getUnitAttr());
call    0 never executed
        -: 1628:
        -: 1629:  // Only add an alignment attribute if the "alignment" input
        -: 1630:  // is different from 0. The value must also be a power of two, but
        -: 1631:  // this is tested in GlobalOp::verify, not here.
    #####: 1632:  if (alignment != 0)
branch  0 never executed
branch  1 never executed
    #####: 1633:    result.addAttribute(getAlignmentAttrName(result.name),
call    0 never executed
    #####: 1634:                        builder.getI64IntegerAttr(alignment));
call    0 never executed
        -: 1635:
    #####: 1636:  result.addAttribute(getLinkageAttrName(result.name),
call    0 never executed
    #####: 1637:                      LinkageAttr::get(builder.getContext(), linkage));
call    0 never executed
    #####: 1638:  if (addrSpace != 0)
branch  0 never executed
branch  1 never executed
    #####: 1639:    result.addAttribute(getAddrSpaceAttrName(result.name),
call    0 never executed
    #####: 1640:                        builder.getI32IntegerAttr(addrSpace));
call    0 never executed
    #####: 1641:  result.attributes.append(attrs.begin(), attrs.end());
call    0 never executed
    #####: 1642:  result.addRegion();
call    0 never executed
    #####: 1643:}
        -: 1644:
function _ZN4mlir4LLVM8GlobalOp5printERNS_12OpAsmPrinterE called 1149598 returned 100% blocks executed 89%
  1149598: 1645:void GlobalOp::print(OpAsmPrinter &p) {
  3448794: 1646:  p << ' ' << stringifyLinkage(getLinkage()) << ' ';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
  1149598: 1647:  if (auto unnamedAddr = getUnnamedAddr()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1149598: 1648:    StringRef str = stringifyUnnamedAddr(*unnamedAddr);
call    0 returned 100%
  1149598: 1649:    if (!str.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1650:      p << str << ' ';
call    0 never executed
call    1 never executed
        -: 1651:  }
 1149598*: 1652:  if (getThreadLocal_())
call    0 returned 100%
    #####: 1653:    p << "thread_local ";
call    0 never executed
  1149598: 1654:  if (getConstant())
call    0 returned 100%
  1149598: 1655:    p << "constant ";
call    0 returned 100%
  2299196: 1656:  p.printSymbolName(getSymName());
call    0 returned 100%
call    1 returned 100%
  1149598: 1657:  p << '(';
call    0 returned 100%
  2299196: 1658:  if (auto value = getValueOrNull())
call    0 returned 100%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
   959522: 1659:    p.printAttribute(value);
call    0 returned 100%
  1149598: 1660:  p << ')';
call    0 returned 100%
        -: 1661:  // Note that the alignment attribute is printed using the
        -: 1662:  // default syntax here, even though it is an inherent attribute
        -: 1663:  // (as defined in https://mlir.llvm.org/docs/LangRef/#attributes)
  1149598: 1664:  p.printOptionalAttrDict(
call    0 returned 100%
        -: 1665:      (*this)->getAttrs(),
  1149598: 1666:      {SymbolTable::getSymbolAttrName(), getGlobalTypeAttrName(),
call    0 returned 100%
call    1 returned 100%
  3448794: 1667:       getConstantAttrName(), getValueAttrName(), getLinkageAttrName(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  5747990: 1668:       getUnnamedAddrAttrName(), getThreadLocal_AttrName()});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
        -: 1669:
        -: 1670:  // Print the trailing type unless it's a string global.
  3258718: 1671:  if (getValueOrNull().dyn_cast_or_null<StringAttr>())
call    0 returned 100%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
        -: 1672:    return;
  1156544: 1673:  p << " : " << getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1674:
   578272: 1675:  Region &initializer = getInitializerRegion();
call    0 returned 100%
   578272: 1676:  if (!initializer.empty()) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
   190076: 1677:    p << ' ';
call    0 returned 100%
   190076: 1678:    p.printRegion(initializer, /*printEntryBlockArgs=*/false);
call    0 returned 100%
        -: 1679:  }
        -: 1680:}
        -: 1681:
        -: 1682:// Parses one of the keywords provided in the list `keywords` and returns the
        -: 1683:// position of the parsed keyword in the list. If none of the keywords from the
        -: 1684:// list is parsed, returns -1.
function _ZL31parseOptionalKeywordAlternativeRN4mlir11OpAsmParserEN4llvm8ArrayRefINS2_9StringRefEEE called 5340380 returned 100% blocks executed 100%
  5340380: 1685:static int parseOptionalKeywordAlternative(OpAsmParser &parser,
        -: 1686:                                           ArrayRef<StringRef> keywords) {
242411845: 1687:  for (const auto &en : llvm::enumerate(keywords)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
call    2 returned 100%
237690359: 1688:    if (succeeded(parser.parseOptionalKeyword(en.value())))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
   618894: 1689:      return en.index();
        -: 1690:  }
  4721486: 1691:  return -1;
        -: 1692:}
        -: 1693:
        -: 1694:namespace {
        -: 1695:template <typename Ty>
        -: 1696:struct EnumTraits {};
        -: 1697:
        -: 1698:#define REGISTER_ENUM_TYPE(Ty)                                                 \
        -: 1699:  template <>                                                                  \
        -: 1700:  struct EnumTraits<Ty> {                                                      \
        -: 1701:    static StringRef stringify(Ty value) { return stringify##Ty(value); }      \
        -: 1702:    static unsigned getMaxEnumVal() { return getMaxEnumValFor##Ty(); }         \
        -: 1703:  }
        -: 1704:
        -: 1705:REGISTER_ENUM_TYPE(Linkage);
        -: 1706:REGISTER_ENUM_TYPE(UnnamedAddr);
        -: 1707:REGISTER_ENUM_TYPE(CConv);
        -: 1708:} // namespace
        -: 1709:
        -: 1710:/// Parse an enum from the keyword, or default to the provided default value.
        -: 1711:/// The return type is the enum type by default, unless overriden with the
        -: 1712:/// second template argument.
        -: 1713:template <typename EnumTy, typename RetTy = EnumTy>
        -: 1714:static RetTy parseOptionalLLVMKeyword(OpAsmParser &parser,
        -: 1715:                                      OperationState &result,
        -: 1716:                                      EnumTy defaultValue) {
        -: 1717:  SmallVector<StringRef, 10> names;
        -: 1718:  for (unsigned i = 0, e = EnumTraits<EnumTy>::getMaxEnumVal(); i <= e; ++i)
        -: 1719:    names.push_back(EnumTraits<EnumTy>::stringify(static_cast<EnumTy>(i)));
        -: 1720:
        -: 1721:  int index = parseOptionalKeywordAlternative(parser, names);
        -: 1722:  if (index == -1)
        -: 1723:    return static_cast<RetTy>(defaultValue);
        -: 1724:  return static_cast<RetTy>(index);
        -: 1725:}
        -: 1726:
        -: 1727:// operation ::= `llvm.mlir.global` linkage? `constant`? `@` identifier
        -: 1728://               `(` attribute? `)` align? attribute-list? (`:` type)? region?
        -: 1729:// align     ::= `align` `=` UINT64
        -: 1730://
        -: 1731:// The type can be omitted for string attributes, in which case it will be
        -: 1732:// inferred from the value of the string as [strlen(value) x i8].
function _ZN4mlir4LLVM8GlobalOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 618894 returned 100% blocks executed 73%
   618894: 1733:ParseResult GlobalOp::parse(OpAsmParser &parser, OperationState &result) {
   618894: 1734:  MLIRContext *ctx = parser.getContext();
call    0 returned 100%
        -: 1735:  // Parse optional linkage, default to External.
   618894: 1736:  result.addAttribute(getLinkageAttrName(result.name),
call    0 returned 100%
   618894: 1737:                      LLVM::LinkageAttr::get(
        -: 1738:                          ctx, parseOptionalLLVMKeyword<Linkage>(
   618894: 1739:                                   parser, result, LLVM::Linkage::External)));
call    0 returned 100%
call    1 returned 100%
        -: 1740:
   618894: 1741:  if (succeeded(parser.parseOptionalKeyword("thread_local")))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1742:    result.addAttribute(getThreadLocal_AttrName(result.name),
call    0 never executed
    #####: 1743:                        parser.getBuilder().getUnitAttr());
call    0 never executed
call    1 never executed
        -: 1744:
        -: 1745:  // Parse optional UnnamedAddr, default to None.
   618894: 1746:  result.addAttribute(getUnnamedAddrAttrName(result.name),
call    0 returned 100%
   618894: 1747:                      parser.getBuilder().getI64IntegerAttr(
call    0 returned 100%
        -: 1748:                          parseOptionalLLVMKeyword<UnnamedAddr, int64_t>(
   618894: 1749:                              parser, result, LLVM::UnnamedAddr::None)));
call    0 returned 100%
call    1 returned 100%
        -: 1750:
   618894: 1751:  if (succeeded(parser.parseOptionalKeyword("constant")))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   618894: 1752:    result.addAttribute(getConstantAttrName(result.name),
call    0 returned 100%
  1237788: 1753:                        parser.getBuilder().getUnitAttr());
call    0 returned 100%
call    1 returned 100%
        -: 1754:
   618894: 1755:  StringAttr name;
  618894*: 1756:  if (parser.parseSymbolName(name, getSymNameAttrName(result.name),
call    0 returned 100%
call    1 returned 100%
  1237788: 1757:                             result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  618894*: 1758:      parser.parseLParen())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1759:    return failure();
        -: 1760:
   618894: 1761:  Attribute value;
   618894: 1762:  if (parser.parseOptionalRParen()) {
call    0 returned 100%
branch  1 taken 84% (fallthrough)
branch  2 taken 16%
  520036*: 1763:    if (parser.parseAttribute(value, getValueAttrName(result.name),
call    0 returned 100%
call    1 returned 100%
  1040072: 1764:                              result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  520036*: 1765:        parser.parseRParen())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 1766:      return failure();
        -: 1767:  }
        -: 1768:
   618894: 1769:  SmallVector<Type, 1> types;
call    0 returned 100%
 1237788*: 1770:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  618894*: 1771:      parser.parseOptionalColonTypeList(types))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 1772:    return failure();
        -: 1773:
   618894: 1774:  if (types.size() > 1)
branch  0 taken 0%
branch  1 taken 100%
    #####: 1775:    return parser.emitError(parser.getNameLoc(), "expected zero or one type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1776:
   618894: 1777:  Region &initRegion = *result.addRegion();
call    0 returned 100%
   618894: 1778:  if (types.empty()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   624882: 1779:    if (auto strAttr = value.dyn_cast_or_null<StringAttr>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   312441: 1780:      MLIRContext *context = parser.getContext();
call    0 returned 100%
   312441: 1781:      auto arrayType = LLVM::LLVMArrayType::get(IntegerType::get(context, 8),
call    0 returned 100%
   312441: 1782:                                                strAttr.getValue().size());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   312441: 1783:      types.push_back(arrayType);
call    0 returned 100%
        -: 1784:    } else {
    #####: 1785:      return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1786:                              "type can only be omitted for string globals");
call    0 never executed
call    1 never executed
        -: 1787:    }
        -: 1788:  } else {
   306453: 1789:    OptionalParseResult parseResult =
        -: 1790:        parser.parseOptionalRegion(initRegion, /*arguments=*/{},
   306453: 1791:                                   /*argTypes=*/{});
call    0 returned 100%
   306453: 1792:    if (parseResult.has_value() && failed(*parseResult))
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 1793:      return failure();
        -: 1794:  }
        -: 1795:
  1237788: 1796:  result.addAttribute(getGlobalTypeAttrName(result.name),
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
   618894: 1797:                      TypeAttr::get(types[0]));
call    0 returned 100%
   618894: 1798:  return success();
        -: 1799:}
        -: 1800:
function _ZL15isZeroAttributeN4mlir9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1801:static bool isZeroAttribute(Attribute value) {
    #####: 1802:  if (auto intValue = value.dyn_cast<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1803:    return intValue.getValue().isNullValue();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1804:  if (auto fpValue = value.dyn_cast<FloatAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1805:    return fpValue.getValue().isZero();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1806:  if (auto splatValue = value.dyn_cast<SplatElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1807:    return isZeroAttribute(splatValue.getSplatValue<Attribute>());
call    0 never executed
call    1 never executed
    #####: 1808:  if (auto elementsValue = value.dyn_cast<ElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1809:    return llvm::all_of(elementsValue.getValues<Attribute>(), isZeroAttribute);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1810:  if (auto arrayValue = value.dyn_cast<ArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1811:    return llvm::all_of(arrayValue.getValue(), isZeroAttribute);
call    0 never executed
call    1 never executed
    #####: 1812:  return false;
        -: 1813:}
        -: 1814:
function _ZN4mlir4LLVM8GlobalOp6verifyEv called 1705609 returned 100% blocks executed 48%
  1705609: 1815:LogicalResult GlobalOp::verify() {
  1705609: 1816:  if (!LLVMPointerType::isValidElementType(getType()))
call    0 returned 99%
call    1 returned 104%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1817:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1818:        "expects type to be a valid element type for an LLVM pointer");
call    0 never executed
  5267735: 1819:  if ((*this)->getParentOp() && !satisfiesLLVMModule((*this)->getParentOp()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
    #####: 1820:    return emitOpError("must appear at the module level");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1821:
  4855968: 1822:  if (auto strAttr = getValueOrNull().dyn_cast_or_null<StringAttr>()) {
call    0 returned 97%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
branch  3 taken 51% (fallthrough)
branch  4 taken 49%
   860111: 1823:    auto type = getType().dyn_cast<LLVMArrayType>();
call    0 returned 100%
call    1 returned 100%
   858768: 1824:    IntegerType elementType =
   858768: 1825:        type ? type.getElementType().dyn_cast<IntegerType>() : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
  1721625: 1826:    if (!elementType || elementType.getWidth() != 8 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken -0%
branch  5 taken 100% (fallthrough)
branch  6 taken -0%
   860942: 1827:        type.getNumElements() != strAttr.getValue().size())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
    #####: 1828:      return emitOpError(
call    0 returned -0%
call    1 never executed
call    2 never executed
        -: 1829:          "requires an i8 array type of the length equal to that of the string "
    #####: 1830:          "attribute");
call    0 never executed
        -: 1831:  }
        -: 1832:
  3391442: 1833:  if (getLinkage() == Linkage::Common) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1834:    if (Attribute value = getValueOrNull()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1835:      if (!isZeroAttribute(value)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1836:        return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1837:               << "expected zero value for '"
    #####: 1838:               << stringifyLinkage(Linkage::Common) << "' linkage";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1839:      }
        -: 1840:    }
        -: 1841:  }
        -: 1842:
  3386175: 1843:  if (getLinkage() == Linkage::Appending) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1844:    if (!getType().isa<LLVMArrayType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1845:      return emitOpError() << "expected array type for '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1846:                           << stringifyLinkage(Linkage::Appending)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1847:                           << "' linkage";
call    0 never executed
        -: 1848:    }
        -: 1849:  }
        -: 1850:
  1692541: 1851:  Optional<uint64_t> alignAttr = getAlignment();
call    0 returned 101%
  1705206: 1852:  if (alignAttr.has_value()) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
   563962: 1853:    uint64_t value = alignAttr.value();
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
   563962: 1854:    if (!llvm::isPowerOf2_64(value))
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
    #####: 1855:      return emitError() << "alignment attribute is not a power of 2";
call    0 returned -0%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1856:  }
        -: 1857:
  1705222: 1858:  return success();
        -: 1859:}
        -: 1860:
function _ZN4mlir4LLVM8GlobalOp13verifyRegionsEv called 1771852 returned 100% blocks executed 47%
  1771852: 1861:LogicalResult GlobalOp::verifyRegions() {
  1771852: 1862:  if (Block *b = getInitializerBlock()) {
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
   304565: 1863:    ReturnOp ret = cast<ReturnOp>(b->getTerminator());
call    0 returned 100%
call    1 returned 100%
  304565*: 1864:    if (ret.operand_type_begin() == ret.operand_type_end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 1865:      return emitOpError("initializer region cannot return void");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   304565: 1866:    if (*ret.operand_type_begin() != getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1867:      return emitOpError("initializer region type ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1868:             << *ret.operand_type_begin() << " does not match global type "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1869:             << getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1870:
  2706760: 1871:    for (Operation &op : *b) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
call    2 returned 100%
  2402195: 1872:      auto iface = dyn_cast<MemoryEffectOpInterface>(op);
call    0 returned 100%
  2402195: 1873:      if (!iface || !iface.hasNoEffect())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 1874:        return op.emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1875:               << "ops with side effects not allowed in global initializers";
call    0 never executed
        -: 1876:    }
        -: 1877:
   609130: 1878:    if (getValueOrNull())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1879:      return emitOpError("cannot have both initializer value and region");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1880:  }
        -: 1881:
  1770587: 1882:  return success();
        -: 1883:}
        -: 1884:
        -: 1885://===----------------------------------------------------------------------===//
        -: 1886:// LLVM::GlobalCtorsOp
        -: 1887://===----------------------------------------------------------------------===//
        -: 1888:
        -: 1889:LogicalResult
function _ZN4mlir4LLVM13GlobalCtorsOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####: 1890:GlobalCtorsOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
    #####: 1891:  for (Attribute ctor : getCtors()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1892:    if (failed(verifySymbolAttrUse(ctor.cast<FlatSymbolRefAttr>(), *this,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1893:                                   symbolTable)))
    #####: 1894:      return failure();
        -: 1895:  }
    #####: 1896:  return success();
        -: 1897:}
        -: 1898:
function _ZN4mlir4LLVM13GlobalCtorsOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1899:LogicalResult GlobalCtorsOp::verify() {
    #####: 1900:  if (getCtors().size() != getPriorities().size())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1901:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1902:        "mismatch between the number of ctors and the number of priorities");
call    0 never executed
    #####: 1903:  return success();
        -: 1904:}
        -: 1905:
        -: 1906://===----------------------------------------------------------------------===//
        -: 1907:// LLVM::GlobalDtorsOp
        -: 1908://===----------------------------------------------------------------------===//
        -: 1909:
        -: 1910:LogicalResult
function _ZN4mlir4LLVM13GlobalDtorsOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####: 1911:GlobalDtorsOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
    #####: 1912:  for (Attribute dtor : getDtors()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1913:    if (failed(verifySymbolAttrUse(dtor.cast<FlatSymbolRefAttr>(), *this,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1914:                                   symbolTable)))
    #####: 1915:      return failure();
        -: 1916:  }
    #####: 1917:  return success();
        -: 1918:}
        -: 1919:
function _ZN4mlir4LLVM13GlobalDtorsOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1920:LogicalResult GlobalDtorsOp::verify() {
    #####: 1921:  if (getDtors().size() != getPriorities().size())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1922:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1923:        "mismatch between the number of dtors and the number of priorities");
call    0 never executed
    #####: 1924:  return success();
        -: 1925:}
        -: 1926:
        -: 1927://===----------------------------------------------------------------------===//
        -: 1928:// ShuffleVectorOp
        -: 1929://===----------------------------------------------------------------------===//
        -: 1930:
function _ZN4mlir4LLVM15ShuffleVectorOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_6detail18DenseArrayAttrImplIiEEN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1931:void ShuffleVectorOp::build(OpBuilder &builder, OperationState &state, Value v1,
        -: 1932:                            Value v2, DenseI32ArrayAttr mask,
        -: 1933:                            ArrayRef<NamedAttribute> attrs) {
    #####: 1934:  auto containerType = v1.getType();
call    0 never executed
    #####: 1935:  auto vType = LLVM::getVectorType(LLVM::getVectorElementType(containerType),
    #####: 1936:                                   mask.size(),
    #####: 1937:                                   LLVM::isScalableVectorType(containerType));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1938:  build(builder, state, vType, v1, v2, mask);
call    0 never executed
    #####: 1939:  state.addAttributes(attrs);
call    0 never executed
    #####: 1940:}
        -: 1941:
function _ZN4mlir4LLVM15ShuffleVectorOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIiEE called 0 returned 0% blocks executed 0%
    #####: 1942:void ShuffleVectorOp::build(OpBuilder &builder, OperationState &state, Value v1,
        -: 1943:                            Value v2, ArrayRef<int32_t> mask) {
    #####: 1944:  build(builder, state, v1, v2, builder.getDenseI32ArrayAttr(mask));
call    0 never executed
call    1 never executed
    #####: 1945:}
        -: 1946:
        -: 1947:/// Build the result type of a shuffle vector operation.
function _ZL16parseShuffleTypeRN4mlir9AsmParserENS_4TypeERS2_NS_6detail18DenseArrayAttrImplIiEE called 0 returned 0% blocks executed 0%
    #####: 1948:static ParseResult parseShuffleType(AsmParser &parser, Type v1Type,
        -: 1949:                                    Type &resType, DenseI32ArrayAttr mask) {
    #####: 1950:  if (!LLVM::isCompatibleVectorType(v1Type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1951:    return parser.emitError(parser.getCurrentLocation(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1952:                            "expected an LLVM compatible vector type");
call    0 never executed
call    1 never executed
    #####: 1953:  resType = LLVM::getVectorType(LLVM::getVectorElementType(v1Type), mask.size(),
    #####: 1954:                                LLVM::isScalableVectorType(v1Type));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1955:  return success();
        -: 1956:}
        -: 1957:
        -: 1958:/// Nothing to do when the result type is inferred.
    #####: 1959:static void printShuffleType(AsmPrinter &printer, Operation *op, Type v1Type,
branch  0 never executed
branch  1 never executed
        -: 1960:                             Type resType, DenseI32ArrayAttr mask) {}
        -: 1961:
function _ZN4mlir4LLVM15ShuffleVectorOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1962:LogicalResult ShuffleVectorOp::verify() {
    #####: 1963:  if (LLVM::isScalableVectorType(getV1().getType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1964:      llvm::any_of(getMask(), [](int32_t v) { return v != 0; }))
branch  0 never executed
branch  1 never executed
    #####: 1965:    return emitOpError("expected a splat operation for scalable vectors");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1966:  return success();
        -: 1967:}
        -: 1968:
        -: 1969://===----------------------------------------------------------------------===//
        -: 1970:// Implementations for LLVM::LLVMFuncOp.
        -: 1971://===----------------------------------------------------------------------===//
        -: 1972:
        -: 1973:// Add the entry block to the function.
function _ZN4mlir4LLVM10LLVMFuncOp13addEntryBlockEv called 0 returned 0% blocks executed 0%
    #####: 1974:Block *LLVMFuncOp::addEntryBlock() {
    #####: 1975:  assert(empty() && "function already has an entry block");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1976:
    #####: 1977:  auto *entry = new Block;
call    0 never executed
call    1 never executed
    #####: 1978:  push_back(entry);
call    0 never executed
        -: 1979:
        -: 1980:  // FIXME: Allow passing in proper locations for the entry arguments.
    #####: 1981:  LLVMFunctionType type = getFunctionType();
call    0 never executed
    #####: 1982:  for (unsigned i = 0, e = type.getNumParams(); i < e; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1983:    entry->addArgument(type.getParamType(i), getLoc());
call    0 never executed
call    1 never executed
    #####: 1984:  return entry;
        -: 1985:}
        -: 1986:
function _ZN4mlir4LLVM10LLVMFuncOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm9StringRefENS_4TypeENS0_7linkage7LinkageEbNS0_5cconv5CConvENS6_8ArrayRefINS_14NamedAttributeEEENSD_INS_14DictionaryAttrEEE called 0 returned 0% blocks executed 0%
    #####: 1987:void LLVMFuncOp::build(OpBuilder &builder, OperationState &result,
        -: 1988:                       StringRef name, Type type, LLVM::Linkage linkage,
        -: 1989:                       bool dsoLocal, CConv cconv,
        -: 1990:                       ArrayRef<NamedAttribute> attrs,
        -: 1991:                       ArrayRef<DictionaryAttr> argAttrs) {
    #####: 1992:  result.addRegion();
call    0 never executed
    #####: 1993:  result.addAttribute(SymbolTable::getSymbolAttrName(),
call    0 never executed
    #####: 1994:                      builder.getStringAttr(name));
call    0 never executed
call    1 never executed
    #####: 1995:  result.addAttribute(getFunctionTypeAttrName(result.name),
call    0 never executed
    #####: 1996:                      TypeAttr::get(type));
call    0 never executed
    #####: 1997:  result.addAttribute(getLinkageAttrName(result.name),
call    0 never executed
    #####: 1998:                      LinkageAttr::get(builder.getContext(), linkage));
call    0 never executed
    #####: 1999:  result.addAttribute(getCConvAttrName(result.name),
call    0 never executed
    #####: 2000:                      CConvAttr::get(builder.getContext(), cconv));
call    0 never executed
    #####: 2001:  result.attributes.append(attrs.begin(), attrs.end());
call    0 never executed
    #####: 2002:  if (dsoLocal)
branch  0 never executed
branch  1 never executed
    #####: 2003:    result.addAttribute("dso_local", builder.getUnitAttr());
call    0 never executed
call    1 never executed
    #####: 2004:  if (argAttrs.empty())
branch  0 never executed
branch  1 never executed
        -: 2005:    return;
        -: 2006:
    #####: 2007:  assert(type.cast<LLVMFunctionType>().getNumParams() == argAttrs.size() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2008:         "expected as many argument attribute lists as arguments");
    #####: 2009:  function_interface_impl::addArgAndResultAttrs(builder, result, argAttrs,
call    0 never executed
        -: 2010:                                                /*resultAttrs=*/llvm::None);
        -: 2011:}
        -: 2012:
        -: 2013:// Builds an LLVM function type from the given lists of input and output types.
        -: 2014:// Returns a null type if any of the types provided are non-LLVM types, or if
        -: 2015:// there is more than one output type.
        -: 2016:static Type
function _ZL21buildLLVMFunctionTypeRN4mlir11OpAsmParserEN4llvm5SMLocENS2_8ArrayRefINS_4TypeEEES6_NS_23function_interface_impl12VariadicFlagE called 2051296 returned 100% blocks executed 61%
  2051296: 2017:buildLLVMFunctionType(OpAsmParser &parser, SMLoc loc, ArrayRef<Type> inputs,
        -: 2018:                      ArrayRef<Type> outputs,
        -: 2019:                      function_interface_impl::VariadicFlag variadicFlag) {
  2051296: 2020:  Builder &b = parser.getBuilder();
call    0 returned 100%
  2051296: 2021:  if (outputs.size() > 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2022:    parser.emitError(loc, "failed to construct function type: expected zero or "
call    0 never executed
call    1 never executed
    #####: 2023:                          "one function result");
call    0 never executed
    #####: 2024:    return {};
        -: 2025:  }
        -: 2026:
        -: 2027:  // Convert inputs to LLVM types, exit early on error.
  2051296: 2028:  SmallVector<Type, 4> llvmInputs;
  7017819: 2029:  for (auto t : inputs) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
  4966523: 2030:    if (!isCompatibleType(t)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2031:      parser.emitError(loc, "failed to construct function type: expected LLVM "
call    0 never executed
call    1 never executed
    #####: 2032:                            "type for function arguments");
call    0 never executed
    #####: 2033:      return {};
        -: 2034:    }
  4966523: 2035:    llvmInputs.push_back(t);
call    0 returned 100%
        -: 2036:  }
        -: 2037:
        -: 2038:  // No output is denoted as "void" in LLVM type system.
  2051296: 2039:  Type llvmOutput =
  2051296: 2040:      outputs.empty() ? LLVMVoidType::get(b.getContext()) : outputs.front();
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
  2051296: 2041:  if (!isCompatibleType(llvmOutput)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2042:    parser.emitError(loc, "failed to construct function type: expected LLVM "
call    0 never executed
call    1 never executed
    #####: 2043:                          "type for function results")
call    0 never executed
    #####: 2044:        << llvmOutput;
call    0 never executed
    #####: 2045:    return {};
        -: 2046:  }
  4102592: 2047:  return LLVMFunctionType::get(llvmOutput, llvmInputs,
  2051296: 2048:                               variadicFlag.isVariadic());
call    0 returned 100%
        -: 2049:}
        -: 2050:
        -: 2051:// Parses an LLVM function.
        -: 2052://
        -: 2053:// operation ::= `llvm.func` linkage? cconv? function-signature
        -: 2054:// function-attributes?
        -: 2055://               function-body
        -: 2056://
function _ZN4mlir4LLVM10LLVMFuncOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 2051296 returned 100% blocks executed 89%
  2051296: 2057:ParseResult LLVMFuncOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 2058:  // Default to external linkage if no keyword is provided.
  2051296: 2059:  result.addAttribute(
call    0 returned 100%
        -: 2060:      getLinkageAttrName(result.name),
  2051296: 2061:      LinkageAttr::get(parser.getContext(),
        -: 2062:                       parseOptionalLLVMKeyword<Linkage>(
  2051296: 2063:                           parser, result, LLVM::Linkage::External)));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2064:
        -: 2065:  // Default to C Calling Convention if no keyword is provided.
  2051296: 2066:  result.addAttribute(
call    0 returned 100%
        -: 2067:      getCConvAttrName(result.name),
  2051296: 2068:      CConvAttr::get(parser.getContext(), parseOptionalLLVMKeyword<CConv>(
  2051296: 2069:                                              parser, result, LLVM::CConv::C)));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2070:
  2051296: 2071:  StringAttr nameAttr;
  2051296: 2072:  SmallVector<OpAsmParser::Argument> entryArgs;
call    0 returned 100%
  2051296: 2073:  SmallVector<DictionaryAttr> resultAttrs;
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
  2051296: 2074:  SmallVector<Type> resultTypes;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  2051296: 2075:  bool isVariadic;
        -: 2076:
  2051296: 2077:  auto signatureLocation = parser.getCurrentLocation();
call    0 returned 100%
 2051296*: 2078:  if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
call    0 returned 100%
  4102592: 2079:                             result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 2051296*: 2080:      function_interface_impl::parseFunctionSignature(
        -: 2081:          parser, /*allowVariadic=*/true, entryArgs, isVariadic, resultTypes,
  2051296: 2082:          resultAttrs))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2083:    return failure();
        -: 2084:
  4102592: 2085:  SmallVector<Type> argTypes;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  7017819: 2086:  for (auto &arg : entryArgs)
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
  4966523: 2087:    argTypes.push_back(arg.type);
call    0 returned 100%
  2051296: 2088:  auto type =
        -: 2089:      buildLLVMFunctionType(parser, signatureLocation, argTypes, resultTypes,
  2051296: 2090:                            function_interface_impl::VariadicFlag(isVariadic));
call    0 returned 100%
  2051296: 2091:  if (!type)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2092:    return failure();
  2051296: 2093:  result.addAttribute(FunctionOpInterface::getTypeAttrName(),
call    0 returned 100%
  2051296: 2094:                      TypeAttr::get(type));
call    0 returned 100%
        -: 2095:
  2051296: 2096:  if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2097:    return failure();
  2051296: 2098:  function_interface_impl::addArgAndResultAttrs(parser.getBuilder(), result,
call    0 returned 100%
call    1 returned 100%
        -: 2099:                                                entryArgs, resultAttrs);
        -: 2100:
  2051296: 2101:  auto *body = result.addRegion();
call    0 returned 100%
  2051296: 2102:  OptionalParseResult parseResult =
  2051296: 2103:      parser.parseOptionalRegion(*body, entryArgs);
call    0 returned 100%
  2644444: 2104:  return failure(parseResult.has_value() && failed(*parseResult));
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
        -: 2105:}
        -: 2106:
        -: 2107:// Print the LLVMFuncOp. Collects argument and result types and passes them to
        -: 2108:// helper functions. Drops "void" result since it cannot be parsed back. Skips
        -: 2109:// the external linkage since it is the default value.
function _ZN4mlir4LLVM10LLVMFuncOp5printERNS_12OpAsmPrinterE called 3796899 returned 100% blocks executed 73%
  3796899: 2110:void LLVMFuncOp::print(OpAsmPrinter &p) {
  3796899: 2111:  p << ' ';
call    0 returned 100%
  7593798: 2112:  if (getLinkage() != LLVM::Linkage::External)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2113:    p << stringifyLinkage(getLinkage()) << ' ';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  7593798: 2114:  if (getCConv() != LLVM::CConv::C)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2115:    p << stringifyCConv(getCConv()) << ' ';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2116:
  3796899: 2117:  p.printSymbolName(getName());
call    0 returned 100%
call    1 returned 100%
        -: 2118:
  3796899: 2119:  LLVMFunctionType fnType = getFunctionType();
call    0 returned 100%
  3796899: 2120:  SmallVector<Type, 8> argTypes;
call    0 returned 100%
  3796899: 2121:  SmallVector<Type, 1> resTypes;
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
  3796899: 2122:  argTypes.reserve(fnType.getNumParams());
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
 12990380: 2123:  for (unsigned i = 0, e = fnType.getNumParams(); i < e; ++i)
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
  9193481: 2124:    argTypes.push_back(fnType.getParamType(i));
call    0 returned 100%
call    1 returned 100%
        -: 2125:
  3796899: 2126:  Type returnType = fnType.getReturnType();
call    0 returned 100%
  3796899: 2127:  if (!returnType.isa<LLVMVoidType>())
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
  3036195: 2128:    resTypes.push_back(returnType);
call    0 returned 100%
        -: 2129:
  3796899: 2130:  function_interface_impl::printFunctionSignature(p, *this, argTypes,
call    0 returned 100%
  3796899: 2131:                                                  isVarArg(), resTypes);
call    0 returned 100%
  3796899: 2132:  function_interface_impl::printFunctionAttributes(
call    0 returned 100%
  3796899: 2133:      p, *this, argTypes.size(), resTypes.size(),
call    0 returned 100%
  3796899: 2134:      {getLinkageAttrName(), getCConvAttrName()});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2135:
        -: 2136:  // Print the body if this is not an external function.
  3796899: 2137:  Region &body = getBody();
call    0 returned 100%
  3796899: 2138:  if (!body.empty()) {
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
  1140534: 2139:    p << ' ';
call    0 returned 100%
  1140534: 2140:    p.printRegion(body, /*printEntryBlockArgs=*/false,
  1140534: 2141:                  /*printBlockTerminators=*/true);
call    0 returned 100%
        -: 2142:  }
  3796899: 2143:}
        -: 2144:
        -: 2145:// Verifies LLVM- and implementation-specific properties of the LLVM func Op:
        -: 2146:// - functions don't have 'common' linkage
        -: 2147:// - external functions have 'external' or 'extern_weak' linkage;
        -: 2148:// - vararg is (currently) only supported for external functions;
function _ZN4mlir4LLVM10LLVMFuncOp6verifyEv called 6425055 returned 100% blocks executed 36%
  6425055: 2149:LogicalResult LLVMFuncOp::verify() {
 12843549: 2150:  if (getLinkage() == LLVM::Linkage::Common)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2151:    return emitOpError() << "functions cannot have '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2152:                         << stringifyLinkage(LLVM::Linkage::Common)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2153:                         << "' linkage";
call    0 never executed
        -: 2154:
        -: 2155:  // Check to see if this function has a void return with a result attribute to
        -: 2156:  // it. It isn't clear what semantics we would assign to that.
 7615086*: 2157:  if (getFunctionType().getReturnType().isa<LLVMVoidType>() &&
call    0 returned 99%
call    1 returned 100%
call    2 returned 101%
branch  3 taken 19% (fallthrough)
branch  4 taken 81%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
  1196592: 2158:      !getResultAttrs(0).empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2159:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2160:           << "cannot attach result attributes to functions with a void return";
call    0 never executed
        -: 2161:  }
        -: 2162:
  6424711: 2163:  if (isExternal()) {
call    0 returned 101%
branch  1 taken 58% (fallthrough)
branch  2 taken 42%
 7524458*: 2164:    if (getLinkage() != LLVM::Linkage::External &&
call    0 returned 99%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2165:        getLinkage() != LLVM::Linkage::ExternWeak)
branch  0 never executed
branch  1 never executed
    #####: 2166:      return emitOpError() << "external functions must have '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2167:                           << stringifyLinkage(LLVM::Linkage::External)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2168:                           << "' or '"
    #####: 2169:                           << stringifyLinkage(LLVM::Linkage::ExternWeak)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2170:                           << "' linkage";
call    0 never executed
  3747359: 2171:    return success();
        -: 2172:  }
        -: 2173:
  2693677: 2174:  return success();
        -: 2175:}
        -: 2176:
        -: 2177:/// Verifies LLVM- and implementation-specific properties of the LLVM func Op:
        -: 2178:/// - entry block arguments are of LLVM types.
function _ZN4mlir4LLVM10LLVMFuncOp13verifyRegionsEv called 6856936 returned 100% blocks executed 65%
  6856936: 2179:LogicalResult LLVMFuncOp::verifyRegions() {
  6856936: 2180:  if (isExternal())
call    0 returned 100%
branch  1 taken 58% (fallthrough)
branch  2 taken 42%
  4002573: 2181:    return success();
        -: 2182:
  2840214: 2183:  unsigned numArguments = getFunctionType().getNumParams();
call    0 returned 100%
call    1 returned 100%
  2838134: 2184:  Block &entryBlock = front();
call    0 returned 100%
 25565689: 2185:  for (unsigned i = 0; i < numArguments; ++i) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
 22722347: 2186:    Type argType = entryBlock.getArgument(i).getType();
call    0 returned 100%
 22722347: 2187:    if (!isCompatibleType(argType))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2188:      return emitOpError("entry block argument #")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2189:             << i << " is not of LLVM type";
call    0 never executed
call    1 never executed
        -: 2190:  }
        -: 2191:
  2843342: 2192:  return success();
        -: 2193:}
        -: 2194:
        -: 2195://===----------------------------------------------------------------------===//
        -: 2196:// Verification for LLVM::ConstantOp.
        -: 2197://===----------------------------------------------------------------------===//
        -: 2198:
function _ZN4mlir4LLVM10ConstantOp6verifyEv called 167357673 returned 100% blocks executed 11%
167357673: 2199:LogicalResult LLVM::ConstantOp::verify() {
167357673: 2200:  if (StringAttr sAttr = getValue().dyn_cast<StringAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2201:    auto arrayType = getType().dyn_cast<LLVMArrayType>();
call    0 never executed
    #####: 2202:    if (!arrayType || arrayType.getNumElements() != sAttr.getValue().size() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2203:        !arrayType.getElementType().isInteger(8)) {
call    0 never executed
call    1 never executed
    #####: 2204:      return emitOpError() << "expected array type of "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2205:                           << sAttr.getValue().size()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2206:                           << " i8 elements for the string constant";
call    0 never executed
        -: 2207:    }
    #####: 2208:    return success();
        -: 2209:  }
167393762: 2210:  if (auto structType = getType().dyn_cast<LLVMStructType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2211:    if (structType.getBody().size() != 2 ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2212:        structType.getBody()[0] != structType.getBody()[1]) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2213:      return emitError() << "expected struct type with two elements of the "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2214:                            "same type, the type of a complex constant";
call    0 never executed
        -: 2215:    }
        -: 2216:
    #####: 2217:    auto arrayAttr = getValue().dyn_cast<ArrayAttr>();
call    0 never executed
call    1 never executed
    #####: 2218:    if (!arrayAttr || arrayAttr.size() != 2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2219:      return emitOpError() << "expected array attribute with two elements, "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2220:                              "representing a complex constant";
call    0 never executed
        -: 2221:    }
    #####: 2222:    auto re = arrayAttr[0].dyn_cast<TypedAttr>();
call    0 never executed
call    1 never executed
    #####: 2223:    auto im = arrayAttr[1].dyn_cast<TypedAttr>();
call    0 never executed
call    1 never executed
    #####: 2224:    if (!re || !im || re.getType() != im.getType()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2225:      return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2226:             << "expected array attribute with two elements of the same type";
call    0 never executed
        -: 2227:    }
        -: 2228:
    #####: 2229:    Type elementType = structType.getBody()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2230:    if (!elementType
call    0 never executed
    #####: 2231:             .isa<IntegerType, Float16Type, Float32Type, Float64Type>()) {
branch  0 never executed
branch  1 never executed
    #####: 2232:      return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2233:             << "expected struct element types to be floating point type or "
    #####: 2234:                "integer type";
call    0 never executed
        -: 2235:    }
    #####: 2236:    return success();
        -: 2237:  }
167383588: 2238:  if (!getValue().isa<IntegerAttr, ArrayAttr, FloatAttr, ElementsAttr>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2239:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2240:           << "only supports integer, float, string or elements attributes";
call    0 never executed
167333906: 2241:  return success();
        -: 2242:}
        -: 2243:
        -: 2244:// Constant op constant-folds to its value.
function _ZN4mlir4LLVM10ConstantOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 16572232 returned 100% blocks executed 100%
 16572232: 2245:OpFoldResult LLVM::ConstantOp::fold(ArrayRef<Attribute>) { return getValue(); }
call    0 returned 100%
call    1 returned 100%
        -: 2246:
        -: 2247://===----------------------------------------------------------------------===//
        -: 2248:// Utility functions for parsing atomic ops
        -: 2249://===----------------------------------------------------------------------===//
        -: 2250:
        -: 2251:// Helper function to parse a keyword into the specified attribute named by
        -: 2252:// `attrName`. The keyword must match one of the string values defined by the
        -: 2253:// AtomicBinOp enum. The resulting I64 attribute is added to the `result`
        -: 2254:// state.
function _ZL16parseAtomicBinOpRN4mlir11OpAsmParserERNS_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 2255:static ParseResult parseAtomicBinOp(OpAsmParser &parser, OperationState &result,
        -: 2256:                                    StringRef attrName) {
    #####: 2257:  SMLoc loc;
    #####: 2258:  StringRef keyword;
    #####: 2259:  if (parser.getCurrentLocation(&loc) || parser.parseKeyword(&keyword))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2260:    return failure();
        -: 2261:
        -: 2262:  // Replace the keyword `keyword` with an integer attribute.
    #####: 2263:  auto kind = symbolizeAtomicBinOp(keyword);
call    0 never executed
    #####: 2264:  if (!kind) {
branch  0 never executed
branch  1 never executed
    #####: 2265:    return parser.emitError(loc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2266:           << "'" << keyword << "' is an incorrect value of the '" << attrName
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2267:           << "' attribute";
call    0 never executed
call    1 never executed
        -: 2268:  }
        -: 2269:
    #####: 2270:  auto value = static_cast<int64_t>(*kind);
call    0 never executed
    #####: 2271:  auto attr = parser.getBuilder().getI64IntegerAttr(value);
call    0 never executed
call    1 never executed
    #####: 2272:  result.addAttribute(attrName, attr);
call    0 never executed
        -: 2273:
    #####: 2274:  return success();
        -: 2275:}
        -: 2276:
        -: 2277:// Helper function to parse a keyword into the specified attribute named by
        -: 2278:// `attrName`. The keyword must match one of the string values defined by the
        -: 2279:// AtomicOrdering enum. The resulting I64 attribute is added to the `result`
        -: 2280:// state.
function _ZL19parseAtomicOrderingRN4mlir11OpAsmParserERNS_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 2281:static ParseResult parseAtomicOrdering(OpAsmParser &parser,
        -: 2282:                                       OperationState &result,
        -: 2283:                                       StringRef attrName) {
    #####: 2284:  SMLoc loc;
    #####: 2285:  StringRef ordering;
    #####: 2286:  if (parser.getCurrentLocation(&loc) || parser.parseKeyword(&ordering))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2287:    return failure();
        -: 2288:
        -: 2289:  // Replace the keyword `ordering` with an integer attribute.
    #####: 2290:  auto kind = symbolizeAtomicOrdering(ordering);
call    0 never executed
    #####: 2291:  if (!kind) {
branch  0 never executed
branch  1 never executed
    #####: 2292:    return parser.emitError(loc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2293:           << "'" << ordering << "' is an incorrect value of the '" << attrName
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2294:           << "' attribute";
call    0 never executed
call    1 never executed
        -: 2295:  }
        -: 2296:
    #####: 2297:  auto value = static_cast<int64_t>(*kind);
call    0 never executed
    #####: 2298:  auto attr = parser.getBuilder().getI64IntegerAttr(value);
call    0 never executed
call    1 never executed
    #####: 2299:  result.addAttribute(attrName, attr);
call    0 never executed
        -: 2300:
    #####: 2301:  return success();
        -: 2302:}
        -: 2303:
        -: 2304://===----------------------------------------------------------------------===//
        -: 2305:// Printer, parser and verifier for LLVM::AtomicRMWOp.
        -: 2306://===----------------------------------------------------------------------===//
        -: 2307:
function _ZN4mlir4LLVM11AtomicRMWOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2308:void AtomicRMWOp::print(OpAsmPrinter &p) {
    #####: 2309:  p << ' ' << stringifyAtomicBinOp(getBinOp()) << ' ' << getPtr() << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 2310:    << getVal() << ' ' << stringifyAtomicOrdering(getOrdering()) << ' ';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2311:  p.printOptionalAttrDict((*this)->getAttrs(), {"bin_op", "ordering"});
call    0 never executed
call    1 never executed
    #####: 2312:  p << " : " << getRes().getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2313:}
        -: 2314:
        -: 2315:// <operation> ::= `llvm.atomicrmw` keyword ssa-use `,` ssa-use keyword
        -: 2316://                 attribute-dict? `:` type
function _ZN4mlir4LLVM11AtomicRMWOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2317:ParseResult AtomicRMWOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2318:  Type type;
    #####: 2319:  OpAsmParser::UnresolvedOperand ptr, val;
call    0 never executed
    #####: 2320:  if (parseAtomicBinOp(parser, result, "bin_op") || parser.parseOperand(ptr) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2321:      parser.parseComma() || parser.parseOperand(val) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2322:      parseAtomicOrdering(parser, result, "ordering") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2323:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2324:      parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2325:      parser.resolveOperand(ptr, LLVM::LLVMPointerType::get(type),
    #####: 2326:                            result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2327:      parser.resolveOperand(val, type, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2328:    return failure();
        -: 2329:
    #####: 2330:  result.addTypes(type);
call    0 never executed
    #####: 2331:  return success();
        -: 2332:}
        -: 2333:
function _ZN4mlir4LLVM11AtomicRMWOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2334:LogicalResult AtomicRMWOp::verify() {
    #####: 2335:  auto ptrType = getPtr().getType().cast<LLVM::LLVMPointerType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2336:  auto valType = getVal().getType();
call    0 never executed
call    1 never executed
    #####: 2337:  if (valType != ptrType.getElementType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2338:    return emitOpError("expected LLVM IR element type for operand #0 to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2339:                       "match type for operand #1");
call    0 never executed
    #####: 2340:  auto resType = getRes().getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2341:  if (resType != valType)
branch  0 never executed
branch  1 never executed
    #####: 2342:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2343:        "expected LLVM IR result type to match type for operand #1");
call    0 never executed
    #####: 2344:  if (getBinOp() == AtomicBinOp::fadd || getBinOp() == AtomicBinOp::fsub) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2345:    if (!mlir::LLVM::isCompatibleFloatingPointType(valType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2346:      return emitOpError("expected LLVM IR floating point type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2347:  } else if (getBinOp() == AtomicBinOp::xchg) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2348:    auto intType = valType.dyn_cast<IntegerType>();
call    0 never executed
    #####: 2349:    unsigned intBitWidth = intType ? intType.getWidth() : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2350:    if (intBitWidth != 8 && intBitWidth != 16 && intBitWidth != 32 &&
    #####: 2351:        intBitWidth != 64 && !valType.isa<BFloat16Type>() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2352:        !valType.isa<Float16Type>() && !valType.isa<Float32Type>() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2353:        !valType.isa<Float64Type>())
branch  0 never executed
branch  1 never executed
    #####: 2354:      return emitOpError("unexpected LLVM IR type for 'xchg' bin_op");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2355:  } else {
    #####: 2356:    auto intType = valType.dyn_cast<IntegerType>();
call    0 never executed
    #####: 2357:    unsigned intBitWidth = intType ? intType.getWidth() : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2358:    if (intBitWidth != 8 && intBitWidth != 16 && intBitWidth != 32 &&
branch  0 never executed
branch  1 never executed
    #####: 2359:        intBitWidth != 64)
branch  0 never executed
branch  1 never executed
    #####: 2360:      return emitOpError("expected LLVM IR integer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2361:  }
        -: 2362:
    #####: 2363:  if (static_cast<unsigned>(getOrdering()) <
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2364:      static_cast<unsigned>(AtomicOrdering::monotonic))
    #####: 2365:    return emitOpError() << "expected at least '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2366:                         << stringifyAtomicOrdering(AtomicOrdering::monotonic)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2367:                         << "' ordering";
call    0 never executed
        -: 2368:
    #####: 2369:  return success();
        -: 2370:}
        -: 2371:
        -: 2372://===----------------------------------------------------------------------===//
        -: 2373:// Printer, parser and verifier for LLVM::AtomicCmpXchgOp.
        -: 2374://===----------------------------------------------------------------------===//
        -: 2375:
function _ZN4mlir4LLVM15AtomicCmpXchgOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2376:void AtomicCmpXchgOp::print(OpAsmPrinter &p) {
    #####: 2377:  p << ' ' << getPtr() << ", " << getCmp() << ", " << getVal() << ' '
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####: 2378:    << stringifyAtomicOrdering(getSuccessOrdering()) << ' '
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2379:    << stringifyAtomicOrdering(getFailureOrdering());
call    0 never executed
call    1 never executed
    #####: 2380:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 never executed
    #####: 2381:                          {"success_ordering", "failure_ordering"});
call    0 never executed
    #####: 2382:  p << " : " << getVal().getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2383:}
        -: 2384:
        -: 2385:// <operation> ::= `llvm.cmpxchg` ssa-use `,` ssa-use `,` ssa-use
        -: 2386://                 keyword keyword attribute-dict? `:` type
function _ZN4mlir4LLVM15AtomicCmpXchgOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2387:ParseResult AtomicCmpXchgOp::parse(OpAsmParser &parser,
        -: 2388:                                   OperationState &result) {
    #####: 2389:  auto &builder = parser.getBuilder();
call    0 never executed
    #####: 2390:  Type type;
    #####: 2391:  OpAsmParser::UnresolvedOperand ptr, cmp, val;
call    0 never executed
    #####: 2392:  if (parser.parseOperand(ptr) || parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2393:      parser.parseOperand(cmp) || parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2394:      parser.parseOperand(val) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2395:      parseAtomicOrdering(parser, result, "success_ordering") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2396:      parseAtomicOrdering(parser, result, "failure_ordering") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2397:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2398:      parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2399:      parser.resolveOperand(ptr, LLVM::LLVMPointerType::get(type),
    #####: 2400:                            result.operands) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2401:      parser.resolveOperand(cmp, type, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2402:      parser.resolveOperand(val, type, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2403:    return failure();
        -: 2404:
    #####: 2405:  auto boolType = IntegerType::get(builder.getContext(), 1);
call    0 never executed
    #####: 2406:  auto resultType =
    #####: 2407:      LLVMStructType::getLiteral(builder.getContext(), {type, boolType});
call    0 never executed
    #####: 2408:  result.addTypes(resultType);
call    0 never executed
        -: 2409:
    #####: 2410:  return success();
        -: 2411:}
        -: 2412:
function _ZN4mlir4LLVM15AtomicCmpXchgOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2413:LogicalResult AtomicCmpXchgOp::verify() {
    #####: 2414:  auto ptrType = getPtr().getType().cast<LLVM::LLVMPointerType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2415:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 2416:    return emitOpError("expected LLVM IR pointer type for operand #0");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2417:  auto cmpType = getCmp().getType();
call    0 never executed
call    1 never executed
    #####: 2418:  auto valType = getVal().getType();
call    0 never executed
call    1 never executed
    #####: 2419:  if (cmpType != ptrType.getElementType() || cmpType != valType)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2420:    return emitOpError("expected LLVM IR element type for operand #0 to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2421:                       "match type for all other operands");
call    0 never executed
    #####: 2422:  auto intType = valType.dyn_cast<IntegerType>();
call    0 never executed
    #####: 2423:  unsigned intBitWidth = intType ? intType.getWidth() : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2424:  if (!valType.isa<LLVMPointerType>() && intBitWidth != 8 &&
call    0 never executed
    #####: 2425:      intBitWidth != 16 && intBitWidth != 32 && intBitWidth != 64 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2426:      !valType.isa<BFloat16Type>() && !valType.isa<Float16Type>() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2427:      !valType.isa<Float32Type>() && !valType.isa<Float64Type>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2428:    return emitOpError("unexpected LLVM IR type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2429:  if (getSuccessOrdering() < AtomicOrdering::monotonic ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2430:      getFailureOrdering() < AtomicOrdering::monotonic)
branch  0 never executed
branch  1 never executed
    #####: 2431:    return emitOpError("ordering must be at least 'monotonic'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2432:  if (getFailureOrdering() == AtomicOrdering::release ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2433:      getFailureOrdering() == AtomicOrdering::acq_rel)
branch  0 never executed
branch  1 never executed
    #####: 2434:    return emitOpError("failure ordering cannot be 'release' or 'acq_rel'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2435:  return success();
        -: 2436:}
        -: 2437:
        -: 2438://===----------------------------------------------------------------------===//
        -: 2439:// Printer, parser and verifier for LLVM::FenceOp.
        -: 2440://===----------------------------------------------------------------------===//
        -: 2441:
        -: 2442:// <operation> ::= `llvm.fence` (`syncscope(`strAttr`)`)? keyword
        -: 2443:// attribute-dict?
function _ZN4mlir4LLVM7FenceOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2444:ParseResult FenceOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2445:  StringAttr sScope;
    #####: 2446:  StringRef syncscopeKeyword = "syncscope";
call    0 never executed
    #####: 2447:  if (!failed(parser.parseOptionalKeyword(syncscopeKeyword))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2448:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2449:        parser.parseAttribute(sScope, syncscopeKeyword, result.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2450:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2451:      return failure();
        -: 2452:  } else {
    #####: 2453:    result.addAttribute(syncscopeKeyword,
call    0 never executed
    #####: 2454:                        parser.getBuilder().getStringAttr(""));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2455:  }
    #####: 2456:  if (parseAtomicOrdering(parser, result, "ordering") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2457:      parser.parseOptionalAttrDict(result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2458:    return failure();
    #####: 2459:  return success();
        -: 2460:}
        -: 2461:
function _ZN4mlir4LLVM7FenceOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2462:void FenceOp::print(OpAsmPrinter &p) {
    #####: 2463:  StringRef syncscopeKeyword = "syncscope";
call    0 never executed
    #####: 2464:  p << ' ';
call    0 never executed
    #####: 2465:  if (!(*this)->getAttr(syncscopeKeyword).cast<StringAttr>().getValue().empty())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2466:    p << "syncscope(" << (*this)->getAttr(syncscopeKeyword) << ") ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2467:  p << stringifyAtomicOrdering(getOrdering());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2468:}
        -: 2469:
function _ZN4mlir4LLVM7FenceOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2470:LogicalResult FenceOp::verify() {
    #####: 2471:  if (getOrdering() == AtomicOrdering::not_atomic ||
call    0 never executed
    #####: 2472:      getOrdering() == AtomicOrdering::unordered ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2473:      getOrdering() == AtomicOrdering::monotonic)
branch  0 never executed
branch  1 never executed
    #####: 2474:    return emitOpError("can be given only acquire, release, acq_rel, "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2475:                       "and seq_cst orderings");
call    0 never executed
    #####: 2476:  return success();
        -: 2477:}
        -: 2478:
        -: 2479://===----------------------------------------------------------------------===//
        -: 2480:// Folder for LLVM::BitcastOp
        -: 2481://===----------------------------------------------------------------------===//
        -: 2482:
function _ZN4mlir4LLVM9BitcastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 987053 returned 100% blocks executed 100%
   987053: 2483:OpFoldResult LLVM::BitcastOp::fold(ArrayRef<Attribute> operands) {
        -: 2484:  // bitcast(x : T0, T0) -> x
   987053: 2485:  if (getArg().getType() == getType())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      360: 2486:    return getArg();
call    0 returned 100%
call    1 returned 100%
        -: 2487:  // bitcast(bitcast(x : T0, T1), T0) -> x
   986693: 2488:  if (auto prev = getArg().getDefiningOp<BitcastOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
      380: 2489:    if (prev.getArg().getType() == getType())
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
      108: 2490:      return prev.getArg();
call    0 returned 100%
call    1 returned 100%
   986585: 2491:  return {};
        -: 2492:}
        -: 2493:
        -: 2494://===----------------------------------------------------------------------===//
        -: 2495:// Folder for LLVM::AddrSpaceCastOp
        -: 2496://===----------------------------------------------------------------------===//
        -: 2497:
function _ZN4mlir4LLVM15AddrSpaceCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2498:OpFoldResult LLVM::AddrSpaceCastOp::fold(ArrayRef<Attribute> operands) {
        -: 2499:  // addrcast(x : T0, T0) -> x
    #####: 2500:  if (getArg().getType() == getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2501:    return getArg();
call    0 never executed
call    1 never executed
        -: 2502:  // addrcast(addrcast(x : T0, T1), T0) -> x
    #####: 2503:  if (auto prev = getArg().getDefiningOp<AddrSpaceCastOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2504:    if (prev.getArg().getType() == getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2505:      return prev.getArg();
call    0 never executed
call    1 never executed
    #####: 2506:  return {};
        -: 2507:}
        -: 2508:
        -: 2509://===----------------------------------------------------------------------===//
        -: 2510:// Folder for LLVM::GEPOp
        -: 2511://===----------------------------------------------------------------------===//
        -: 2512:
function _ZN4mlir4LLVM5GEPOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 3188148 returned 100% blocks executed 89%
  3188148: 2513:OpFoldResult LLVM::GEPOp::fold(ArrayRef<Attribute> operands) {
  3188148: 2514:  GEPIndicesAdaptor<ArrayRef<Attribute>> indices(getRawConstantIndicesAttr(),
  3188148: 2515:                                                 operands.drop_front());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2516:
        -: 2517:  // gep %x:T, 0 -> %x
  6211076: 2518:  if (getBase().getType() == getType() && indices.size() == 1)
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  4928193: 2519:    if (auto integer = indices[0].dyn_cast_or_null<IntegerAttr>())
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
branch  3 taken 63% (fallthrough)
branch  4 taken 37%
  3810530: 2520:      if (integer.getValue().isZero())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 15% (fallthrough)
branch  6 taken 85%
   294659: 2521:        return getBase();
call    0 returned 100%
call    1 returned 100%
        -: 2522:
        -: 2523:  // Canonicalize any dynamic indices of constant value to constant indices.
  2893489: 2524:  bool changed = false;
  2893489: 2525:  SmallVector<GEPArg> gepArgs;
call    0 returned 100%
 11904396: 2526:  for (auto &iter : llvm::enumerate(indices)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
call    5 returned 100%
  3058709: 2527:    auto integer = iter.value().dyn_cast_or_null<IntegerAttr>();
call    0 returned 100%
branch  1 taken 63%
branch  2 taken 37%
        -: 2528:    // Constant indices can only be int32_t, so if integer does not fit we
        -: 2529:    // are forced to keep it dynamic, despite being a constant.
  4002819: 2530:    if (!indices.isDynamicIndex(iter.index()) || !integer ||
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
branch  3 taken 46% (fallthrough)
branch  4 taken 54%
call    5 returned 100%
  4946929: 2531:        !integer.getValue().isSignedIntN(kGEPConstantBitWidth)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 69% (fallthrough)
branch  6 taken 31%
        -: 2532:
  2114599: 2533:      PointerUnion<IntegerAttr, Value> existing = getIndices()[iter.index()];
call    0 returned 100%
call    1 returned 100%
  4229198: 2534:      if (Value val = existing.dyn_cast<Value>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 53% (fallthrough)
branch  3 taken 47%
  1117663: 2535:        gepArgs.emplace_back(val);
call    0 returned 100%
        -: 2536:      else
   996936: 2537:        gepArgs.emplace_back(existing.get<IntegerAttr>().getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2538:
  2114599: 2539:      continue;
        -: 2540:    }
        -: 2541:
   944110: 2542:    changed = true;
   944110: 2543:    gepArgs.emplace_back(integer.getInt());
call    0 returned 100%
call    1 returned 100%
        -: 2544:  }
  2893489: 2545:  if (changed) {
branch  0 taken 30%
branch  1 taken 70%
  1726092: 2546:    SmallVector<int32_t> rawConstantIndices;
call    0 returned 100%
   863046: 2547:    SmallVector<Value> dynamicIndices;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   863046: 2548:    destructureIndices(getSourceElementType(), gepArgs, rawConstantIndices,
call    0 returned 100%
call    1 returned 100%
        -: 2549:                       dynamicIndices);
        -: 2550:
   863046: 2551:    getDynamicIndicesMutable().assign(dynamicIndices);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   863046: 2552:    setRawConstantIndices(rawConstantIndices);
call    0 returned 100%
   863046: 2553:    return Value{*this};
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2554:  }
        -: 2555:
  2030443: 2556:  return {};
        -: 2557:}
        -: 2558:
        -: 2559://===----------------------------------------------------------------------===//
        -: 2560:// OpAsmDialectInterface
        -: 2561://===----------------------------------------------------------------------===//
        -: 2562:
        -: 2563:namespace {
        -: 2564:struct LLVMOpAsmDialectInterface : public OpAsmDialectInterface {
        -: 2565:  using OpAsmDialectInterface::OpAsmDialectInterface;
        -: 2566:
function _ZNK12_GLOBAL__N_125LLVMOpAsmDialectInterface8getAliasEN4mlir9AttributeERN4llvm11raw_ostreamE called 5462075 returned 100% blocks executed 92%
  5462075: 2567:  AliasResult getAlias(Attribute attr, raw_ostream &os) const override {
  5462075: 2568:    return TypeSwitch<Attribute, AliasResult>(attr)
call    0 returned 100%
        -: 2569:        .Case<DIBasicTypeAttr, DICompileUnitAttr, DICompositeTypeAttr,
        -: 2570:              DIDerivedTypeAttr, DIFileAttr, DILexicalBlockAttr,
        -: 2571:              DILexicalBlockFileAttr, DILocalVariableAttr, DISubprogramAttr,
    #####: 2572:              DISubroutineTypeAttr>([&](auto attr) {
    #####: 2573:          os << decltype(attr)::getMnemonic();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
call   21 never executed
branch 22 never executed
branch 23 never executed
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
        -: 2574:          return AliasResult::OverridableAlias;
  5462075: 2575:        })
call    0 returned 100%
  5462075: 2576:        .Default([](Attribute) { return AliasResult::NoAlias; });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2577:  }
        -: 2578:};
        -: 2579:} // namespace
        -: 2580:
        -: 2581://===----------------------------------------------------------------------===//
        -: 2582:// LLVMDialect initialization, type parsing, and registration.
        -: 2583://===----------------------------------------------------------------------===//
        -: 2584:
function _ZN4mlir4LLVM11LLVMDialect10initializeEv called 103683 returned 100% blocks executed 100%
   103683: 2585:void LLVMDialect::initialize() {
   103683: 2586:  registerAttributes();
call    0 returned 100%
        -: 2587:
        -: 2588:  // clang-format off
   103683: 2589:  addTypes<LLVMVoidType,
        -: 2590:           LLVMPPCFP128Type,
        -: 2591:           LLVMX86MMXType,
        -: 2592:           LLVMTokenType,
        -: 2593:           LLVMLabelType,
        -: 2594:           LLVMMetadataType,
   103683: 2595:           LLVMStructType>();
call    0 returned 100%
        -: 2596:  // clang-format on
   103683: 2597:  registerTypes();
call    0 returned 100%
        -: 2598:
   103683: 2599:  addOperations<
        -: 2600:#define GET_OP_LIST
        -: 2601:#include "mlir/Dialect/LLVMIR/LLVMOps.cpp.inc"
        -: 2602:      ,
        -: 2603:#define GET_OP_LIST
        -: 2604:#include "mlir/Dialect/LLVMIR/LLVMIntrinsicOps.cpp.inc"
   103683: 2605:      >();
call    0 returned 100%
        -: 2606:
        -: 2607:  // Support unknown operations because not all LLVM operations are registered.
   103683: 2608:  allowUnknownOperations();
call    0 returned 100%
   103683: 2609:  addInterfaces<LLVMOpAsmDialectInterface>();
call    0 returned 100%
   103683: 2610:}
        -: 2611:
        -: 2612:#define GET_OP_CLASSES
        -: 2613:#include "mlir/Dialect/LLVMIR/LLVMOps.cpp.inc"
        -: 2614:
function _ZN4mlir4LLVM11LLVMDialect22verifyDataLayoutStringEN4llvm9StringRefENS2_12function_refIFvRKNS2_5TwineEEEE called 334825 returned 100% blocks executed 24%
   334825: 2615:LogicalResult LLVMDialect::verifyDataLayoutString(
        -: 2616:    StringRef descr, llvm::function_ref<void(const Twine &)> reportError) {
   334825: 2617:  llvm::Expected<llvm::DataLayout> maybeDataLayout =
   334825: 2618:      llvm::DataLayout::parse(descr);
call    0 returned 100%
   334825: 2619:  if (maybeDataLayout)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   334825: 2620:    return success();
        -: 2621:
  334825*: 2622:  std::string message;
call    0 never executed
call    1 returned 100%
    #####: 2623:  llvm::raw_string_ostream messageStream(message);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2624:  llvm::logAllUnhandledErrors(maybeDataLayout.takeError(), messageStream);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2625:  reportError("invalid data layout descriptor: " + messageStream.str());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2626:  return failure();
call    0 never executed
        -: 2627:}
        -: 2628:
        -: 2629:/// Verify LLVM dialect attributes.
function _ZN4mlir4LLVM11LLVMDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeE called 2001365 returned 100% blocks executed 14%
  2001365: 2630:LogicalResult LLVMDialect::verifyOperationAttribute(Operation *op,
        -: 2631:                                                    NamedAttribute attr) {
        -: 2632:  // If the `llvm.loop` attribute is present, enforce the following structure,
        -: 2633:  // which the module translation can assume.
  2001365: 2634:  if (attr.getName() == LLVMDialect::getLoopAttrName()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2635:    auto loopAttr = attr.getValue().dyn_cast<DictionaryAttr>();
call    0 never executed
    #####: 2636:    if (!loopAttr)
branch  0 never executed
branch  1 never executed
    #####: 2637:      return op->emitOpError() << "expected '" << LLVMDialect::getLoopAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2638:                               << "' to be a dictionary attribute";
call    0 never executed
    #####: 2639:    Optional<NamedAttribute> parallelAccessGroup =
call    0 never executed
    #####: 2640:        loopAttr.getNamed(LLVMDialect::getParallelAccessAttrName());
call    0 never executed
    #####: 2641:    if (parallelAccessGroup) {
branch  0 never executed
branch  1 never executed
    #####: 2642:      auto accessGroups = parallelAccessGroup->getValue().dyn_cast<ArrayAttr>();
call    0 never executed
    #####: 2643:      if (!accessGroups)
branch  0 never executed
branch  1 never executed
    #####: 2644:        return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2645:               << "expected '" << LLVMDialect::getParallelAccessAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2646:               << "' to be an array attribute";
call    0 never executed
    #####: 2647:      for (Attribute attr : accessGroups) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2648:        auto accessGroupRef = attr.dyn_cast<SymbolRefAttr>();
call    0 never executed
    #####: 2649:        if (!accessGroupRef)
branch  0 never executed
branch  1 never executed
    #####: 2650:          return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2651:                 << "expected '" << attr << "' to be a symbol reference";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2652:        StringAttr metadataName = accessGroupRef.getRootReference();
call    0 never executed
    #####: 2653:        auto metadataOp =
        -: 2654:            SymbolTable::lookupNearestSymbolFrom<LLVM::MetadataOp>(
    #####: 2655:                op->getParentOp(), metadataName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2656:        if (!metadataOp)
branch  0 never executed
branch  1 never executed
    #####: 2657:          return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2658:                 << "expected '" << attr << "' to reference a metadata op";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2659:        StringAttr accessGroupName = accessGroupRef.getLeafReference();
call    0 never executed
    #####: 2660:        Operation *accessGroupOp =
    #####: 2661:            SymbolTable::lookupNearestSymbolFrom(metadataOp, accessGroupName);
call    0 never executed
    #####: 2662:        if (!accessGroupOp)
branch  0 never executed
branch  1 never executed
    #####: 2663:          return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2664:                 << "expected '" << attr << "' to reference an access_group op";
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2665:      }
        -: 2666:    }
        -: 2667:
    #####: 2668:    Optional<NamedAttribute> loopOptions =
call    0 never executed
    #####: 2669:        loopAttr.getNamed(LLVMDialect::getLoopOptionsAttrName());
call    0 never executed
    #####: 2670:    if (loopOptions && !loopOptions->getValue().isa<LoopOptionsAttr>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2671:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2672:             << "expected '" << LLVMDialect::getLoopOptionsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2673:             << "' to be a `loopopts` attribute";
call    0 never executed
        -: 2674:  }
        -: 2675:
  2003572: 2676:  if (attr.getName() == LLVMDialect::getReadnoneAttrName()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2677:    const auto attrName = LLVMDialect::getReadnoneAttrName();
call    0 never executed
    #####: 2678:    if (!isa<FunctionOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2679:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2680:             << "'" << attrName
call    0 never executed
call    1 never executed
    #####: 2681:             << "' is permitted only on FunctionOpInterface operations";
call    0 never executed
    #####: 2682:    if (!attr.getValue().isa<UnitAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2683:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2684:             << "expected '" << attrName << "' to be a unit attribute";
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2685:  }
        -: 2686:
  1999697: 2687:  if (attr.getName() == LLVMDialect::getStructAttrsAttrName()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2688:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2689:           << "'" << LLVM::LLVMDialect::getStructAttrsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2690:           << "' is permitted only in argument or result attributes";
call    0 never executed
        -: 2691:  }
        -: 2692:
        -: 2693:  // If the data layout attribute is present, it must use the LLVM data layout
        -: 2694:  // syntax. Try parsing it and report errors in case of failure. Users of this
        -: 2695:  // attribute may assume it is well-formed and can pass it to the (asserting)
        -: 2696:  // llvm::DataLayout constructor.
  3995891: 2697:  if (attr.getName() != LLVM::LLVMDialect::getDataLayoutAttrName())
call    0 returned 100%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
  1663020: 2698:    return success();
   333801: 2699:  if (auto stringAttr = attr.getValue().dyn_cast<StringAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   333801: 2700:    return verifyDataLayoutString(
        -: 2701:        stringAttr.getValue(),
function _ZZN4mlir4LLVM11LLVMDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeEENKUlRKN4llvm5TwineEE_clES8_.isra.0 called 0 returned 0% blocks executed 0%
  333801*: 2702:        [op](const Twine &message) { op->emitOpError() << message.str(); });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 returned 100%
call    8 returned 100%
        -: 2703:
    #####: 2704:  return op->emitOpError() << "expected '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2705:                           << LLVM::LLVMDialect::getDataLayoutAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2706:                           << "' to be a string attributes";
call    0 never executed
        -: 2707:}
        -: 2708:
function _ZN4mlir4LLVM11LLVMDialect16verifyStructAttrEPNS_9OperationENS_9AttributeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2709:LogicalResult LLVMDialect::verifyStructAttr(Operation *op, Attribute attr,
        -: 2710:                                            Type annotatedType) {
    #####: 2711:  auto structType = annotatedType.dyn_cast<LLVMStructType>();
call    0 never executed
    #####: 2712:  if (!structType) {
branch  0 never executed
branch  1 never executed
function _ZZN4mlir4LLVM11LLVMDialect16verifyStructAttrEPNS_9OperationENS_9AttributeENS_4TypeEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2713:    const auto emitIncorrectAnnotatedType = [&op]() {
    #####: 2714:      return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2715:             << "expected '" << LLVMDialect::getStructAttrsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2716:             << "' to annotate '!llvm.struct' or '!llvm.ptr<struct<...>>'";
call    0 never executed
    #####: 2717:    };
    #####: 2718:    const auto ptrType = annotatedType.dyn_cast<LLVMPointerType>();
call    0 never executed
    #####: 2719:    if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 2720:      return emitIncorrectAnnotatedType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2721:    structType = ptrType.getElementType().dyn_cast<LLVMStructType>();
call    0 never executed
call    1 never executed
    #####: 2722:    if (!structType)
branch  0 never executed
branch  1 never executed
    #####: 2723:      return emitIncorrectAnnotatedType();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2724:  }
        -: 2725:
    #####: 2726:  const auto arrAttrs = attr.dyn_cast<ArrayAttr>();
call    0 never executed
    #####: 2727:  if (!arrAttrs)
branch  0 never executed
branch  1 never executed
    #####: 2728:    return op->emitError() << "expected '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2729:                           << LLVMDialect::getStructAttrsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2730:                           << "' to be an array attribute";
call    0 never executed
        -: 2731:
    #####: 2732:  if (structType.getBody().size() != arrAttrs.size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2733:    return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2734:           << "size of '" << LLVMDialect::getStructAttrsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2735:           << "' must match the size of the annotated '!llvm.struct'";
call    0 never executed
    #####: 2736:  return success();
        -: 2737:}
        -: 2738:
function _ZL31verifyFuncOpInterfaceStructAttrPN4mlir9OperationENS_9AttributeERKSt8functionIFNS_4TypeENS_19FunctionOpInterfaceEEE called 0 returned 0% blocks executed 0%
    #####: 2739:static LogicalResult verifyFuncOpInterfaceStructAttr(
        -: 2740:    Operation *op, Attribute attr,
        -: 2741:    const std::function<Type(FunctionOpInterface)> &getAnnotatedType) {
    #####: 2742:  if (auto funcOp = dyn_cast<FunctionOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2743:    return LLVMDialect::verifyStructAttr(op, attr, getAnnotatedType(funcOp));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2744:  return op->emitError() << "expected '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2745:                         << LLVMDialect::getStructAttrsAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2746:                         << "' to be used on function-like operations";
call    0 never executed
        -: 2747:}
        -: 2748:
        -: 2749:/// Verify LLVMIR function argument attributes.
function _ZN4mlir4LLVM11LLVMDialect24verifyRegionArgAttributeEPNS_9OperationEjjNS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####: 2750:LogicalResult LLVMDialect::verifyRegionArgAttribute(Operation *op,
        -: 2751:                                                    unsigned regionIdx,
        -: 2752:                                                    unsigned argIdx,
        -: 2753:                                                    NamedAttribute argAttr) {
        -: 2754:  // Check that llvm.noalias is a unit attribute.
    #####: 2755:  if (argAttr.getName() == LLVMDialect::getNoAliasAttrName() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2756:      !argAttr.getValue().isa<UnitAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2757:    return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2758:           << "expected llvm.noalias argument attribute to be a unit attribute";
call    0 never executed
        -: 2759:  // Check that llvm.align is an integer attribute.
    #####: 2760:  if (argAttr.getName() == LLVMDialect::getAlignAttrName() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2761:      !argAttr.getValue().isa<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2762:    return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2763:           << "llvm.align argument attribute of non integer type";
call    0 never executed
    #####: 2764:  if (argAttr.getName() == LLVMDialect::getStructAttrsAttrName()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2765:    return verifyFuncOpInterfaceStructAttr(
function _ZZN4mlir4LLVM11LLVMDialect24verifyRegionArgAttributeEPNS_9OperationEjjNS_14NamedAttributeEENKUlNS_19FunctionOpInterfaceEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2766:        op, argAttr.getValue(), [argIdx](FunctionOpInterface funcOp) {
    #####: 2767:          return funcOp.getArgumentTypes()[argIdx];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2768:        });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2769:  }
    #####: 2770:  return success();
        -: 2771:}
        -: 2772:
function _ZN4mlir4LLVM11LLVMDialect27verifyRegionResultAttributeEPNS_9OperationEjjNS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####: 2773:LogicalResult LLVMDialect::verifyRegionResultAttribute(Operation *op,
        -: 2774:                                                       unsigned regionIdx,
        -: 2775:                                                       unsigned resIdx,
        -: 2776:                                                       NamedAttribute resAttr) {
    #####: 2777:  if (resAttr.getName() == LLVMDialect::getStructAttrsAttrName()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2778:    return verifyFuncOpInterfaceStructAttr(
function _ZZN4mlir4LLVM11LLVMDialect27verifyRegionResultAttributeEPNS_9OperationEjjNS_14NamedAttributeEENKUlNS_19FunctionOpInterfaceEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2779:        op, resAttr.getValue(), [resIdx](FunctionOpInterface funcOp) {
    #####: 2780:          return funcOp.getResultTypes()[resIdx];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2781:        });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2782:  }
    #####: 2783:  return success();
        -: 2784:}
        -: 2785:
        -: 2786://===----------------------------------------------------------------------===//
        -: 2787:// Utility functions.
        -: 2788://===----------------------------------------------------------------------===//
        -: 2789:
function _ZN4mlir4LLVM18createGlobalStringENS_8LocationERNS_9OpBuilderEN4llvm9StringRefES5_NS0_7linkage7LinkageE called 0 returned 0% blocks executed 0%
    #####: 2790:Value mlir::LLVM::createGlobalString(Location loc, OpBuilder &builder,
        -: 2791:                                     StringRef name, StringRef value,
        -: 2792:                                     LLVM::Linkage linkage) {
    #####: 2793:  assert(builder.getInsertionBlock() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 2794:         builder.getInsertionBlock()->getParentOp() &&
        -: 2795:         "expected builder to point to a block constrained in an op");
    #####: 2796:  auto module =
    #####: 2797:      builder.getInsertionBlock()->getParentOp()->getParentOfType<ModuleOp>();
call    0 never executed
call    1 never executed
    #####: 2798:  assert(module && "builder points to an op outside of a module");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2799:
        -: 2800:  // Create the global at the entry of the module.
    #####: 2801:  OpBuilder moduleBuilder(module.getBodyRegion(), builder.getListener());
call    0 never executed
call    1 never executed
    #####: 2802:  MLIRContext *ctx = builder.getContext();
call    0 never executed
    #####: 2803:  auto type = LLVM::LLVMArrayType::get(IntegerType::get(ctx, 8), value.size());
call    0 never executed
call    1 never executed
    #####: 2804:  auto global = moduleBuilder.create<LLVM::GlobalOp>(
    #####: 2805:      loc, type, /*isConstant=*/true, linkage, name,
    #####: 2806:      builder.getStringAttr(value), /*alignment=*/0);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2807:
        -: 2808:  // Get the pointer to the first character in the global string.
    #####: 2809:  Value globalPtr = builder.create<LLVM::AddressOfOp>(loc, global);
call    0 never executed
call    1 never executed
    #####: 2810:  return builder.create<LLVM::GEPOp>(
    #####: 2811:      loc, LLVM::LLVMPointerType::get(IntegerType::get(ctx, 8)), globalPtr,
call    0 never executed
call    1 never executed
    #####: 2812:      ArrayRef<GEPArg>{0, 0});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2813:}
        -: 2814:
function _ZN4mlir4LLVM19satisfiesLLVMModuleEPNS_9OperationE called 7183448 returned 100% blocks executed 83%
  7183448: 2815:bool mlir::LLVM::satisfiesLLVMModule(Operation *op) {
  7183448: 2816:  return op->hasTrait<OpTrait::SymbolTable>() &&
call    0 returned 100%
branch  1 taken 62% (fallthrough)
branch  2 taken 38%
  4467896: 2817:         op->hasTrait<OpTrait::IsIsolatedFromAbove>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2818:}
