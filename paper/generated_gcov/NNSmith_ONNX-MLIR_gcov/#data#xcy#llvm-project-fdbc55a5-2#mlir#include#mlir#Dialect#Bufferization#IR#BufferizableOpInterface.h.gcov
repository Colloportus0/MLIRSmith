        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Linalg/Transforms/CMakeFiles/obj.MLIRLinalgTransforms.dir/Bufferize.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Linalg/Transforms/CMakeFiles/obj.MLIRLinalgTransforms.dir/Bufferize.cpp.gcda
        -:    0:Runs:128628
        -:    1://===- BufferizableOpInterface.h - Bufferizable Ops -------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef MLIR_DIALECT_BUFFERIZATION_IR_BUFFERIZABLEOPINTERFACE_H_
        -:   10:#define MLIR_DIALECT_BUFFERIZATION_IR_BUFFERIZABLEOPINTERFACE_H_
        -:   11:
        -:   12:#include "mlir/IR/Operation.h"
        -:   13:#include "mlir/IR/PatternMatch.h"
        -:   14:#include "mlir/Support/LLVM.h"
        -:   15:#include "llvm/ADT/SetVector.h"
        -:   16:
        -:   17:namespace mlir {
        -:   18:class OpBuilder;
        -:   19:
        -:   20:namespace bufferization {
        -:   21:
        -:   22:class AnalysisState;
        -:   23:class BufferizableOpInterface;
        -:   24:struct DialectAnalysisState;
        -:   25:
        -:   26:class OpFilter {
        -:   27:public:
        -:   28:  /// An op filter entry. Filters can be used to specify which ops should be
        -:   29:  /// processed by the bufferization.
    #####:   30:  struct Entry {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   31:    /// If the filter function evaluates to `true`, the filter matches.
        -:   32:    using FilterFn = std::function<bool(Operation *)>;
        -:   33:
        -:   34:    /// Filter type: A filter can either be a DENY filter or an ALLOW filter.
        -:   35:    enum FilterType : int8_t { DENY = 0, ALLOW = 1 };
        -:   36:
        -:   37:    FilterFn fn;
        -:   38:    FilterType type;
        -:   39:  };
        -:   40:
        -:   41:  /// Return whether the op is allowed or not.
        -:   42:  ///
        -:   43:  /// If the filter does not have an ALLOW rule, ops are allowed by default,
        -:   44:  /// unless they are explicitly marked as DENY. If the filter has at least one
        -:   45:  /// ALLOW rule, ops are denied by default and only allowed if they match
        -:   46:  /// an ALLOW rule and no DENY rule.
        -:   47:  bool isOpAllowed(Operation *op) const;
        -:   48:
        -:   49:  /// Allow the given dialects.
        -:   50:  ///
        -:   51:  /// This function adds one or multiple ALLOW entries.
        -:   52:  template <typename... DialectTs>
    #####:   53:  void allowDialect() {
        -:   54:    // The following expands a call to allowDialectImpl for each dialect
        -:   55:    // in 'DialectTs'.
    #####:   56:    (allowDialectImpl<DialectTs>(), ...);
        -:   57:  }
        -:   58:
        -:   59:  /// Deny the given dialects.
        -:   60:  ///
        -:   61:  /// This function adds one or multiple DENY entries.
        -:   62:  template <typename... DialectTs>
        -:   63:  void denyDialect() {
        -:   64:    (denyDialectImpl<DialectTs>(), ...);
        -:   65:  }
        -:   66:
        -:   67:  /// Allow the given dialect.
        -:   68:  ///
        -:   69:  /// This function adds an ALLOW entry.
function _ZN4mlir13bufferization8OpFilter12allowDialectEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   70:  void allowDialect(StringRef dialectNamespace) {
function _ZZN4mlir13bufferization8OpFilter12allowDialectEN4llvm9StringRefEENKUlPNS_9OperationEE_clES5_ called 0 returned 0% blocks executed 0%
    #####:   71:    Entry::FilterFn filterFn = [=](Operation *op) {
    #####:   72:      return op->getDialect()->getNamespace() == dialectNamespace;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   73:    };
call    0 never executed
    #####:   74:    entries.push_back(Entry{filterFn, Entry::FilterType::ALLOW});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   75:  }
        -:   76:
        -:   77:  /// Allow the given ops.
        -:   78:  ///
        -:   79:  /// This function adds one or multiple ALLOW entries.
        -:   80:  template <typename... OpTys>
        -:   81:  void allowOperation() {
        -:   82:    (allowOperationImpl<OpTys>(), ...);
        -:   83:  }
        -:   84:
        -:   85:  /// Deny the given ops.
        -:   86:  ///
        -:   87:  /// This function adds one or multiple DENY entries.
        -:   88:  template <typename... OpTys>
        -:   89:  void denyOperation() {
        -:   90:    (denyOperationImpl<OpTys>(), ...);
        -:   91:  }
        -:   92:
        -:   93:  /// Allow the given op.
        -:   94:  ///
        -:   95:  /// This function adds an ALLOW entry.
        -:   96:  void allowOperation(StringRef opName) {
        -:   97:    Entry::FilterFn filterFn = [=](Operation *op) {
        -:   98:      return op->getName().getStringRef() == opName;
        -:   99:    };
        -:  100:    allowOperation(filterFn);
        -:  101:  }
        -:  102:
        -:  103:  /// Deny the given op.
        -:  104:  ///
        -:  105:  /// This function adds a DENY entry.
        -:  106:  void denyOperation(StringRef opName) {
        -:  107:    Entry::FilterFn filterFn = [=](Operation *op) {
        -:  108:      return op->getName().getStringRef() == opName;
        -:  109:    };
        -:  110:    denyOperation(filterFn);
        -:  111:  }
        -:  112:
        -:  113:  /// Allow ops that are matched by `fn`.
        -:  114:  ///
        -:  115:  /// This function adds an ALLOW entry.
        -:  116:  void allowOperation(Entry::FilterFn fn) {
        -:  117:    entries.push_back(Entry{fn, Entry::FilterType::ALLOW});
        -:  118:  }
        -:  119:
        -:  120:  /// Deny ops that are matched by `fn`.
        -:  121:  ///
        -:  122:  /// This function adds a DENY entry.
        -:  123:  void denyOperation(Entry::FilterFn fn) {
        -:  124:    entries.push_back(Entry{fn, Entry::FilterType::DENY});
        -:  125:  }
        -:  126:
        -:  127:private:
        -:  128:  /// Return `true` if the filter has at least one ALLOW rule.
        -:  129:  bool hasAllowRule() const {
        -:  130:    for (const Entry &e : entries)
        -:  131:      if (e.type == Entry::FilterType::ALLOW)
        -:  132:        return true;
        -:  133:    return false;
        -:  134:  }
        -:  135:
        -:  136:  /// Allow a dialect.
        -:  137:  template <typename DialectT>
    #####:  138:  void allowDialectImpl() {
    #####:  139:    allowDialect(DialectT::getDialectNamespace());
call    0 never executed
call    1 never executed
        -:  140:  }
        -:  141:
        -:  142:  /// Deny a dialect.
        -:  143:  template <typename DialectT>
        -:  144:  void denyDialectImpl() {
        -:  145:    denyDialect(DialectT::getDialectNamespace());
        -:  146:  }
        -:  147:
        -:  148:  /// Allow an op.
        -:  149:  template <typename OpTy>
        -:  150:  void allowOperationImpl() {
        -:  151:    allowOperation(OpTy::getOperationName());
        -:  152:  }
        -:  153:
        -:  154:  /// Deny an op.
        -:  155:  template <typename OpTy>
        -:  156:  void denyOperationImpl() {
        -:  157:    denyOperation(OpTy::getOperationName());
        -:  158:  }
        -:  159:
        -:  160:  /// A list of filter entries that determine whether an op should be allowed or
        -:  161:  /// denied. If the filter has an ALLOW rule, only ops that are allowed and not
        -:  162:  /// denied are allowed. If the filter does not have an ALLOW rule, only ops
        -:  163:  /// that are not denied are allowed.
        -:  164:  SmallVector<Entry> entries;
        -:  165:};
        -:  166:
        -:  167:/// Options for BufferizableOpInterface-based bufferization.
        -:  168:struct BufferizationOptions {
        -:  169:  /// Allocator function: Generate a memref allocation with the given type,
        -:  170:  /// dynamic extents and alignment.
        -:  171:  using AllocationFn = std::function<FailureOr<Value>(
        -:  172:      OpBuilder &, Location, MemRefType, ValueRange, unsigned int)>;
        -:  173:  /// Deallocator function: Deallocate a buffer that was allocated with
        -:  174:  /// AllocatorFn.
        -:  175:  using DeallocationFn =
        -:  176:      std::function<LogicalResult(OpBuilder &, Location, Value)>;
        -:  177:  /// Memcpy function: Generate a memcpy between two buffers.
        -:  178:  using MemCpyFn =
        -:  179:      std::function<LogicalResult(OpBuilder &, Location, Value, Value)>;
        -:  180:  /// Initializer function for analysis state.
        -:  181:  using AnalysisStateInitFn = std::function<void(AnalysisState &)>;
        -:  182:  /// Initializer function for dialect-specific analysis state.
        -:  183:  using DialectStateInitFn =
        -:  184:      std::function<std::unique_ptr<DialectAnalysisState>()>;
        -:  185:  /// Tensor -> MemRef type converter.
        -:  186:  /// Parameters: Value, memory space, bufferization options
        -:  187:  using UnknownTypeConverterFn = std::function<BaseMemRefType(
        -:  188:      Value, unsigned, const BufferizationOptions &)>;
        -:  189:
        -:  190:  enum class LayoutMapOption : int8_t {
        -:  191:    InferLayoutMap = 0,
        -:  192:    IdentityLayoutMap = 1,
        -:  193:    FullyDynamicLayoutMap = 2
        -:  194:  };
        -:  195:
        -:  196:  BufferizationOptions();
        -:  197:
        -:  198:  /// Try to cast the given op to BufferizableOpInterface if the op is allow
        -:  199:  /// listed.
        -:  200:  BufferizableOpInterface dynCastBufferizableOp(Operation *op) const;
        -:  201:
        -:  202:  /// Try to cast the given value to BufferizableOpInterface if the op is allow
        -:  203:  /// listed.
        -:  204:  BufferizableOpInterface dynCastBufferizableOp(Value value) const;
        -:  205:
        -:  206:  /// A filter that specifies which ops should be bufferized and which ops
        -:  207:  /// should be ignored.
        -:  208:  OpFilter opFilter;
        -:  209:
        -:  210:  /// Return `true` if the given op should be bufferized.
        -:  211:  bool isOpAllowed(Operation *op) const;
        -:  212:
        -:  213:  /// Helper functions for allocation, deallocation, memory copying.
        -:  214:  Optional<AllocationFn> allocationFn;
        -:  215:  Optional<DeallocationFn> deallocationFn;
        -:  216:  Optional<MemCpyFn> memCpyFn;
        -:  217:
        -:  218:  /// Create a memref allocation with the given type and dynamic extents.
        -:  219:  FailureOr<Value> createAlloc(OpBuilder &b, Location loc, MemRefType type,
        -:  220:                               ValueRange dynShape) const;
        -:  221:
        -:  222:  /// Creates a memref deallocation. The given memref buffer must have been
        -:  223:  /// allocated using `createAlloc`.
        -:  224:  LogicalResult createDealloc(OpBuilder &b, Location loc,
        -:  225:                              Value allocatedBuffer) const;
        -:  226:
        -:  227:  /// Creates a memcpy between two given buffers.
        -:  228:  LogicalResult createMemCpy(OpBuilder &b, Location loc, Value from,
        -:  229:                             Value to) const;
        -:  230:
        -:  231:  /// Specifies whether not bufferizable ops are allowed in the input. If so,
        -:  232:  /// bufferization.to_memref and bufferization.to_tensor ops are inserted at
        -:  233:  /// the boundaries.
        -:  234:  bool allowUnknownOps = false;
        -:  235:
        -:  236:  /// Specifies whether function boundaries (ops in the func dialect) should be
        -:  237:  /// bufferized or not.
        -:  238:  bool bufferizeFunctionBoundaries = false;
        -:  239:
        -:  240:  /// The default memory space that should be used when it cannot be inferred
        -:  241:  /// from the context. If no default memory space is specified, bufferization
        -:  242:  /// fails when the memory space cannot be inferred at any point.
        -:  243:  Optional<unsigned> defaultMemorySpace = 0;
        -:  244:
        -:  245:  /// Certain ops have aliasing OpOperand/OpResult invariants (e.g., scf.for).
        -:  246:  /// If this flag is set to `false`, those invariants are no longer enforced
        -:  247:  /// with buffer copies.
        -:  248:  ///
        -:  249:  /// Note: Deactivating this flag can lead to incorrect bufferization results
        -:  250:  /// when used incorrectly. This flag is useful with
        -:  251:  /// `AlwaysCopyAnalysisState` which bufferizes all writing tensor
        -:  252:  /// OpOperands out-of-place.
        -:  253:  bool enforceAliasingInvariants = true;
        -:  254:
        -:  255:  /// This flag controls buffer types on function signatures.
        -:  256:  ///
        -:  257:  /// * InferLayoutMap: All function parameter types have a fully dynamic layout
        -:  258:  ///   map, but function result types are inferred from the body of the
        -:  259:  ///   function.
        -:  260:  /// * FullyDynamicLayoutMap: All function parameter types and result types
        -:  261:  ///   have a fully dynamic layout map. This option is most efficient because
        -:  262:  ///   any layout map can be casted to a fully dynamic one.
        -:  263:  /// * IdentityLayoutMap: All function parameter types and result types have a
        -:  264:  ///   static identity layout (i.e., no layout map). This option may introduce
        -:  265:  ///   additional buffer allocs and copies because layout maps cannot be casted
        -:  266:  ///   away.
        -:  267:  ///
        -:  268:  /// If `bufferizeFunctionBoundaries` is not set, this flag has no effect.
        -:  269:  ///
        -:  270:  /// Note: Inferred layout maps may not be desireable when interacting with
        -:  271:  /// external functions, because the generated function signatures will be less
        -:  272:  /// predictable.
        -:  273:  LayoutMapOption functionBoundaryTypeConversion =
        -:  274:      LayoutMapOption::InferLayoutMap;
        -:  275:
        -:  276:  /// Type converter from tensors to memrefs. This type converter is used if no
        -:  277:  /// memref type could be inferred during bufferization. By default, a type
        -:  278:  /// converter that returns a memref type with a fully dynamic layout map is
        -:  279:  /// used.
        -:  280:  UnknownTypeConverterFn unknownTypeConverterFn = nullptr;
        -:  281:
        -:  282:  /// Specifies whether dealloc ops should be generated along with alloc ops. If
        -:  283:  /// not, new memory allocations will leak.
        -:  284:  bool createDeallocs = true;
        -:  285:
        -:  286:  /// Seed for the analysis fuzzer. If set to `0`, the fuzzer is deactivated.
        -:  287:  /// Should be used only with `testAnalysisOnly = true`.
        -:  288:  unsigned analysisFuzzerSeed = 0;
        -:  289:
        -:  290:  /// If set to `true`, the analysis is skipped. A buffer is copied before every
        -:  291:  /// write. This flag cannot be used together with `testAnalysisOnly = true`.
        -:  292:  bool copyBeforeWrite = false;
        -:  293:
        -:  294:  /// If set to `true`, does not modify the IR apart from adding attributes (for
        -:  295:  /// checking the results of the analysis) and post analysis steps.
        -:  296:  bool testAnalysisOnly = false;
        -:  297:
        -:  298:  /// If set to `true`, the IR is annotated with details about RaW conflicts.
        -:  299:  /// For debugging only. Should be used together with `testAnalysisOnly`.
        -:  300:  bool printConflicts = false;
        -:  301:
        -:  302:  /// Buffer alignment for new memory allocations.
        -:  303:  unsigned int bufferAlignment = 128;
        -:  304:
        -:  305:  /// Initializer functions for analysis state. These can be used to
        -:  306:  /// initialize dialect-specific analysis state.
        -:  307:  SmallVector<AnalysisStateInitFn> stateInitializers;
        -:  308:
        -:  309:  /// Add a analysis state initializer that initializes the specified
        -:  310:  /// dialect-specific analysis state.
        -:  311:  void addDialectStateInitializer(StringRef name, const DialectStateInitFn &fn);
        -:  312:};
        -:  313:
        -:  314:/// Specify fine-grain relationship between buffers to enable more analysis.
        -:  315:enum class BufferRelation {
        -:  316:  None,
        -:  317:  // TODO: ResultContainsOperand,
        -:  318:  // TODO: OperandContainsResult,
        -:  319:  Equivalent
        -:  320:};
        -:  321:
        -:  322:/// Return `true` if the given value is a BlockArgument of a func::FuncOp.
        -:  323:bool isFunctionArgument(Value value);
        -:  324:
        -:  325:/// Dialect-specific analysis state. Analysis/bufferization information
        -:  326:/// that is specific to ops from a certain dialect can be stored in derived
        -:  327:/// variants of this struct.
        -:  328:struct DialectAnalysisState {
        -:  329:  DialectAnalysisState() = default;
        -:  330:
        -:  331:  virtual ~DialectAnalysisState() = default;
        -:  332:
        -:  333:  // Copying state is forbidden. Always pass as reference.
        -:  334:  DialectAnalysisState(const DialectAnalysisState &) = delete;
        -:  335:};
        -:  336:
        -:  337:/// AnalysisState provides a variety of helper functions for dealing with
        -:  338:/// tensor values.
        -:  339:class AnalysisState {
        -:  340:public:
        -:  341:  /// Determine which OpOperand* will alias with `result` if the op is
        -:  342:  /// bufferized in place. Return an empty vector if the op is not bufferizable.
        -:  343:  SmallVector<OpOperand *> getAliasingOpOperand(OpResult result) const;
        -:  344:
        -:  345:  /// Determine which OpResult will alias with `opOperand` if the op is
        -:  346:  /// bufferized in place. Return an empty vector if the op is not bufferizable.
        -:  347:  SmallVector<OpResult> getAliasingOpResult(OpOperand &opOperand) const;
        -:  348:
        -:  349:  /// Return true if `opOperand` bufferizes to a memory read. Return `true` if
        -:  350:  /// the op is not bufferizable.
        -:  351:  bool bufferizesToMemoryRead(OpOperand &opOperand) const;
        -:  352:
        -:  353:  /// Return true if `opOperand` bufferizes to a memory write. Return true` if
        -:  354:  /// the op is not bufferizable.
        -:  355:  bool bufferizesToMemoryWrite(OpOperand &opOperand) const;
        -:  356:
        -:  357:  /// Return true if `opOperand` does neither read nor write but bufferizes to
        -:  358:  /// an alias. Return false if the op is not bufferizable.
        -:  359:  bool bufferizesToAliasOnly(OpOperand &opOperand) const;
        -:  360:
        -:  361:  /// Return true if a copy can always be avoided when allocating a new tensor
        -:  362:  /// for the given OpOperand.
        -:  363:  bool canOmitTensorCopy(OpOperand &opOperand) const;
        -:  364:
        -:  365:  /// Return true if the given value is read by an op that bufferizes to a
        -:  366:  /// memory read. Also takes into account ops that create an alias but do not
        -:  367:  /// read by themselves (e.g., ExtractSliceOp).
        -:  368:  bool isValueRead(Value value) const;
        -:  369:
        -:  370:  /// Starting from `value`, follow the use-def chain in reverse, always
        -:  371:  /// selecting the aliasing OpOperands. Find and return Values for which
        -:  372:  /// `condition` evaluates to true. OpOperands of such matching Values are not
        -:  373:  /// traversed any further.
        -:  374:  ///
        -:  375:  /// When reaching the end of a chain (BlockArgument or Value without aliasing
        -:  376:  /// OpOperands), also return the last Value of that chain.
        -:  377:  ///
        -:  378:  /// Example:
        -:  379:  ///
        -:  380:  ///                               8
        -:  381:  ///                               |
        -:  382:  ///   6*         7*         +-----+----+
        -:  383:  ///   |          |          |          |
        -:  384:  ///   2*         3          4*         5
        -:  385:  ///   |          |          |          |
        -:  386:  ///   +----------+----------+----------+
        -:  387:  ///              |
        -:  388:  ///              1
        -:  389:  ///
        -:  390:  /// In the above example, Values with a star satisfy the condition. When
        -:  391:  /// starting the traversal from Value 1, the resulting SetVector is:
        -:  392:  /// { 2, 7, 8, 5 }
        -:  393:  ///
        -:  394:  /// If `followEquivalentOnly` is set, only equivalent OpOperands are selected.
        -:  395:  SetVector<Value>
        -:  396:  findValueInReverseUseDefChain(Value value,
        -:  397:                                llvm::function_ref<bool(Value)> condition,
        -:  398:                                bool followEquivalentOnly = false) const;
        -:  399:
        -:  400:  /// Find the Values of the last preceding write of a given Value.
        -:  401:  ///
        -:  402:  /// Note: Unknown ops are handled conservatively and assumed to be writes.
        -:  403:  /// Furthermore, BlockArguments are also assumed to be writes. There is no
        -:  404:  /// analysis across block boundaries.
        -:  405:  ///
        -:  406:  /// Note: When reaching an end of the reverse SSA use-def chain, that value
        -:  407:  /// is returned regardless of whether it is a memory write or not.
        -:  408:  SetVector<Value> findLastPrecedingWrite(Value value) const;
        -:  409:
        -:  410:  /// Return `true` if the given OpResult has been decided to bufferize inplace.
        -:  411:  virtual bool isInPlace(OpOperand &opOperand) const;
        -:  412:
        -:  413:  /// Return true if `v1` and `v2` bufferize to equivalent buffers.
        -:  414:  virtual bool areEquivalentBufferizedValues(Value v1, Value v2) const;
        -:  415:
        -:  416:  /// Return true if `v1` and `v2` may bufferize to aliasing buffers.
        -:  417:  virtual bool areAliasingBufferizedValues(Value v1, Value v2) const;
        -:  418:
        -:  419:  /// Return `true` if the given tensor has undefined contents.
        -:  420:  virtual bool hasUndefinedContents(OpOperand *opOperand) const;
        -:  421:
        -:  422:  /// Return true if the given tensor (or an aliasing tensor) is yielded from
        -:  423:  /// the containing block. Also include all aliasing tensors in the same block.
        -:  424:  ///
        -:  425:  /// Note: In the absence of an analysis, an implementation may return true for
        -:  426:  /// any given tensor.
        -:  427:  virtual bool isTensorYielded(Value tensor) const;
        -:  428:
        -:  429:  /// Return `true` if the given dialect state exists.
        -:  430:  bool hasDialectState(StringRef name) const {
        -:  431:    auto it = dialectState.find(name);
        -:  432:    return it != dialectState.end();
        -:  433:  }
        -:  434:
        -:  435:  /// Return dialect-specific bufferization state.
        -:  436:  template <typename StateT>
        -:  437:  Optional<const StateT *> getDialectState(StringRef name) const {
        -:  438:    auto it = dialectState.find(name);
        -:  439:    if (it == dialectState.end())
        -:  440:      return None;
        -:  441:    return static_cast<const StateT *>(it->getSecond().get());
        -:  442:  }
        -:  443:
        -:  444:  /// Return dialect-specific analysis state or create one if none exists.
        -:  445:  template <typename StateT>
        -:  446:  StateT &getOrCreateDialectState(StringRef name) {
        -:  447:    // Create state if it does not exist yet.
        -:  448:    if (!hasDialectState(name))
        -:  449:      dialectState[name] = std::make_unique<StateT>();
        -:  450:    return static_cast<StateT &>(*dialectState[name]);
        -:  451:  }
        -:  452:
        -:  453:  void insertDialectState(StringRef name,
        -:  454:                          std::unique_ptr<DialectAnalysisState> state) {
        -:  455:    assert(!dialectState.count(name) && "dialect state already initialized");
        -:  456:    dialectState[name] = std::move(state);
        -:  457:  }
        -:  458:
        -:  459:  /// Return a reference to the BufferizationOptions.
        -:  460:  const BufferizationOptions &getOptions() const { return options; }
        -:  461:
        -:  462:  explicit AnalysisState(const BufferizationOptions &options);
        -:  463:
        -:  464:  // AnalysisState should be passed as a reference.
        -:  465:  AnalysisState(const AnalysisState &) = delete;
        -:  466:
        -:  467:  virtual ~AnalysisState() = default;
        -:  468:
        -:  469:private:
        -:  470:  /// Dialect-specific analysis state.
        -:  471:  DenseMap<StringRef, std::unique_ptr<DialectAnalysisState>> dialectState;
        -:  472:
        -:  473:  /// A reference to current bufferization options.
        -:  474:  const BufferizationOptions &options;
        -:  475:};
        -:  476:
        -:  477:/// Create an AllocTensorOp for the given shaped value (memref or tensor).
        -:  478:/// If `copy` is set, the shaped value is copied. Otherwise, a tensor with
        -:  479:/// undefined contents is allocated.
        -:  480:FailureOr<Value>
        -:  481:allocateTensorForShapedValue(OpBuilder &b, Location loc, Value shapedValue,
        -:  482:                             bool escape, const BufferizationOptions &options,
        -:  483:                             bool copy = true);
        -:  484:
        -:  485:/// Return `true` if the allocation of the given op is guaranteed to not escape
        -:  486:/// the containing block.
        -:  487:bool allocationDoesNotEscape(OpResult opResult);
        -:  488:
        -:  489:/// Lookup the buffer for the given value. If the value was not bufferized
        -:  490:/// yet, wrap it in a ToMemrefOp. Otherwise, it is the result of a ToTensorOp,
        -:  491:/// from which the memref operand is returned.
        -:  492:FailureOr<Value> getBuffer(RewriterBase &rewriter, Value value,
        -:  493:                           const BufferizationOptions &options);
        -:  494:
        -:  495:/// Return the buffer type for a given Value (tensor) after bufferization
        -:  496:/// without bufferizing any IR.
        -:  497:///
        -:  498:/// Note: It should be sufficient to call `getBuffer()->getType()` in most
        -:  499:/// cases. However, when a buffer type should be predicted without modifying any
        -:  500:/// IR, this function can be used.
        -:  501:///
        -:  502:/// This function is a wrapper around BufferizableOpInterface::getBufferType.
        -:  503:FailureOr<BaseMemRefType> getBufferType(Value value,
        -:  504:                                        const BufferizationOptions &options);
        -:  505:
        -:  506:/// Return the buffer type for a given Value (tensor) after bufferization
        -:  507:/// without bufferizing any IR. If at any point during the type computation, the
        -:  508:/// type of a value in `fixedTypes` in required, the mapped type is used.
        -:  509:///
        -:  510:/// Note: It should be sufficient to call `getBuffer()->getType()` in most
        -:  511:/// cases. However, when a buffer type should be predicted without modifying any
        -:  512:/// IR, this function can be used.
        -:  513:///
        -:  514:/// This function is a wrapper around BufferizableOpInterface::getBufferType.
        -:  515:FailureOr<BaseMemRefType>
        -:  516:getBufferType(Value value, const BufferizationOptions &options,
        -:  517:              const DenseMap<Value, BaseMemRefType> &fixedTypes);
        -:  518:
        -:  519:/// Replace an op with replacement values. The op is deleted. Tensor OpResults
        -:  520:/// must be replaced with memref values.
        -:  521:void replaceOpWithBufferizedValues(RewriterBase &rewriter, Operation *op,
        -:  522:                                   ValueRange values);
        -:  523:
        -:  524:/// Replace an op with a new op. The new op must have the same number of
        -:  525:/// results as the replaced op. The new op may not return any tensor values.
        -:  526:template <typename OpTy, typename... Args>
        -:  527:OpTy replaceOpWithNewBufferizedOp(RewriterBase &rewriter, Operation *op,
        -:  528:                                  Args &&...args) {
        -:  529:  auto newOp = rewriter.create<OpTy>(op->getLoc(), std::forward<Args>(args)...);
        -:  530:  replaceOpWithBufferizedValues(rewriter, op, newOp->getResults());
        -:  531:  return newOp;
        -:  532:}
        -:  533:
        -:  534:/// Return `true` if the buffer of given OpResult should be deallocated. This
        -:  535:/// function should be called during `BufferizableOpInterface::bufferize`
        -:  536:/// implementations that allocate a new buffer for the given OpResult.
        -:  537:bool shouldDeallocateOpResult(OpResult opResult,
        -:  538:                              const BufferizationOptions &options);
        -:  539:
        -:  540:/// Return a MemRefType to which the type of the given value can be bufferized.
        -:  541:///
        -:  542:/// If possible, op bufferization implementations should not use this function
        -:  543:/// and instead infer precise memref types for tensor results by themselves.
        -:  544:///
        -:  545:/// Unless a layout map was specified, `options.unknownTypeConverterFn`
        -:  546:/// determines what kind of layout map will be used. For best composability
        -:  547:/// (without copies), the fully dynamic layout map is used by default.
        -:  548:///
        -:  549:/// Note: Canonicalization patterns could clean up layout maps and infer more
        -:  550:/// precise layout maps after bufferization. However, many possible
        -:  551:/// canonicalizations are currently not implemented.
        -:  552:BaseMemRefType getMemRefType(Value value, const BufferizationOptions &options,
        -:  553:                             MemRefLayoutAttrInterface layout = {},
        -:  554:                             unsigned memorySpace = 0);
        -:  555:
        -:  556:/// Return a MemRef type with fully dynamic layout. If the given tensor type
        -:  557:/// is unranked, return an unranked MemRef type.
        -:  558:BaseMemRefType getMemRefTypeWithFullyDynamicLayout(TensorType tensorType,
        -:  559:                                                   unsigned memorySpace = 0);
        -:  560:
        -:  561:/// Return a MemRef type with a static identity layout (i.e., no layout map). If
        -:  562:/// the given tensor type is unranked, return an unranked MemRef type.
        -:  563:BaseMemRefType getMemRefTypeWithStaticIdentityLayout(TensorType tensorType,
        -:  564:                                                     unsigned memorySpace = 0);
        -:  565:
        -:  566:/// Return the owner of the given value. In case of a BlockArgument that is the
        -:  567:/// owner of the block. In case of an OpResult that is the defining op.
        -:  568:Operation *getOwnerOfValue(Value value);
        -:  569:
        -:  570:namespace detail {
        -:  571:/// This is the default implementation of
        -:  572:/// BufferizableOpInterface::getBufferType. Should not be called from other
        -:  573:/// places.
        -:  574:FailureOr<BaseMemRefType>
        -:  575:defaultGetBufferType(Value value, const BufferizationOptions &options,
        -:  576:                     const DenseMap<Value, BaseMemRefType> &fixedTypes);
        -:  577:
        -:  578:/// This is the default implementation of
        -:  579:/// BufferizableOpInterface::isRepetitiveRegion. Should not be called from other
        -:  580:/// places.
        -:  581:bool defaultIsRepetitiveRegion(BufferizableOpInterface bufferizableOp,
        -:  582:                               unsigned index);
        -:  583:} // namespace detail
        -:  584:
        -:  585:} // namespace bufferization
        -:  586:} // namespace mlir
        -:  587:
        -:  588:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h.inc"
        -:  589:
        -:  590:#endif // MLIR_DIALECT_BUFFERIZATION_IR_BUFFERIZABLEOPINTERFACE_H_
