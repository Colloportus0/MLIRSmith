        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/SCFToOpenMP/SCFToOpenMP.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/SCFToOpenMP/CMakeFiles/obj.MLIRSCFToOpenMP.dir/SCFToOpenMP.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/SCFToOpenMP/CMakeFiles/obj.MLIRSCFToOpenMP.dir/SCFToOpenMP.cpp.gcda
        -:    0:Runs:128636
        -:    1://===- SCFToOpenMP.cpp - Structured Control Flow to OpenMP conversion -----===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements a pass to convert scf.parallel operations into OpenMP
        -:   10:// parallel loops.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Conversion/SCFToOpenMP/SCFToOpenMP.h"
        -:   15:
        -:   16:#include "mlir/Analysis/SliceAnalysis.h"
        -:   17:#include "mlir/Dialect/Affine/Analysis/LoopAnalysis.h"
        -:   18:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   19:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   20:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   21:#include "mlir/Dialect/OpenMP/OpenMPDialect.h"
        -:   22:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   23:#include "mlir/IR/ImplicitLocOpBuilder.h"
        -:   24:#include "mlir/IR/SymbolTable.h"
        -:   25:#include "mlir/Pass/Pass.h"
        -:   26:#include "mlir/Transforms/DialectConversion.h"
        -:   27:
        -:   28:namespace mlir {
        -:   29:#define GEN_PASS_DEF_CONVERTSCFTOOPENMP
        -:   30:#include "mlir/Conversion/Passes.h.inc"
        -:   31:} // namespace mlir
        -:   32:
        -:   33:using namespace mlir;
        -:   34:
        -:   35:/// Matches a block containing a "simple" reduction. The expected shape of the
        -:   36:/// block is as follows.
        -:   37:///
        -:   38:///   ^bb(%arg0, %arg1):
        -:   39:///     %0 = OpTy(%arg0, %arg1)
        -:   40:///     scf.reduce.return %0
        -:   41:template <typename... OpTy>
    #####:   42:static bool matchSimpleReduction(Block &block) {
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
    #####:   44:      std::next(block.begin(), 2) != block.end())
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
    #####:   55:      combinerOps.size() != 1)
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
    #####:   60:         block.front().getOperands() == block.getArguments();
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith6MulFOpENS0_4LLVM6FMulOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith6MulFOpENS0_4LLVM6FMulOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith6AndIOpENS0_4LLVM5AndOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith6AndIOpENS0_4LLVM5AndOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith6XOrIOpENS0_4LLVM5XOrOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith6XOrIOpENS0_4LLVM5XOrOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith5OrIOpENS0_4LLVM4OrOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith5OrIOpENS0_4LLVM4OrOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith6AddIOpENS0_4LLVM5AddOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith6AddIOpENS0_4LLVM5AddOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
_Z20matchSimpleReductionIJN4mlir5arith6AddFOpENS0_4LLVM6FAddOpEEEbRNS0_5BlockE:
function _Z20matchSimpleReductionIJN4mlir5arith6AddFOpENS0_4LLVM6FAddOpEEEbRNS0_5BlockE called 0 returned 0% blocks executed 0%
    #####:   42:static bool matchSimpleReduction(Block &block) {
branch  0 never executed
branch  1 never executed
    #####:   43:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   44:      std::next(block.begin(), 2) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   45:    return false;
        -:   46:
    #####:   47:  if (block.getNumArguments() != 2)
branch  0 never executed
branch  1 never executed
        -:   48:    return false;
        -:   49:
    #####:   50:  SmallVector<Operation *, 4> combinerOps;
branch  0 never executed
branch  1 never executed
    #####:   51:  Value reducedVal = matchReduction({block.getArguments()[1]},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   52:                                    /*redPos=*/0, combinerOps);
        -:   53:
    #####:   54:  if (!reducedVal || !reducedVal.isa<BlockArgument>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      combinerOps.size() != 1)
branch  0 never executed
branch  1 never executed
        -:   56:    return false;
        -:   57:
    #####:   58:  return isa<OpTy...>(combinerOps[0]) &&
call    0 never executed
    #####:   59:         isa<scf::ReduceReturnOp>(block.back()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   60:         block.front().getOperands() == block.getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
        -:   61:}
------------------
        -:   62:
        -:   63:/// Matches a block containing a select-based min/max reduction. The types of
        -:   64:/// select and compare operations are provided as template arguments. The
        -:   65:/// comparison predicates suitable for min and max are provided as function
        -:   66:/// arguments. If a reduction is matched, `ifMin` will be set if the reduction
        -:   67:/// compute the minimum and unset if it computes the maximum, otherwise it
        -:   68:/// remains unmodified. The expected shape of the block is as follows.
        -:   69:///
        -:   70:///   ^bb(%arg0, %arg1):
        -:   71:///     %0 = CompareOpTy(<one-of-predicates>, %arg0, %arg1)
        -:   72:///     %1 = SelectOpTy(%0, %arg0, %arg1)  // %arg0, %arg1 may be swapped here.
        -:   73:///     scf.reduce.return %1
        -:   74:template <
        -:   75:    typename CompareOpTy, typename SelectOpTy,
        -:   76:    typename Predicate = decltype(std::declval<CompareOpTy>().getPredicate())>
        -:   77:static bool
    #####:   78:matchSelectReduction(Block &block, ArrayRef<Predicate> lessThanPredicates,
        -:   79:                     ArrayRef<Predicate> greaterThanPredicates, bool &isMin) {
        -:   80:  static_assert(
        -:   81:      llvm::is_one_of<SelectOpTy, arith::SelectOp, LLVM::SelectOp>::value,
        -:   82:      "only arithmetic and llvm select ops are supported");
        -:   83:
        -:   84:  // Expect exactly three operations in the block.
    #####:   85:  if (block.empty() || llvm::hasSingleElement(block) ||
    #####:   86:      std::next(block.begin(), 2) == block.end() ||
    #####:   87:      std::next(block.begin(), 3) != block.end())
        -:   88:    return false;
        -:   89:
        -:   90:  // Check op kinds.
    #####:   91:  auto compare = dyn_cast<CompareOpTy>(block.front());
    #####:   92:  auto select = dyn_cast<SelectOpTy>(block.front().getNextNode());
    #####:   93:  auto terminator = dyn_cast<scf::ReduceReturnOp>(block.back());
    #####:   94:  if (!compare || !select || !terminator)
        -:   95:    return false;
        -:   96:
        -:   97:  // Block arguments must be compared.
    #####:   98:  if (compare->getOperands() != block.getArguments())
        -:   99:    return false;
        -:  100:
        -:  101:  // Detect whether the comparison is less-than or greater-than, otherwise bail.
        -:  102:  bool isLess;
    #####:  103:  if (llvm::is_contained(lessThanPredicates, compare.getPredicate())) {
        -:  104:    isLess = true;
    #####:  105:  } else if (llvm::is_contained(greaterThanPredicates,
        -:  106:                                compare.getPredicate())) {
        -:  107:    isLess = false;
        -:  108:  } else {
        -:  109:    return false;
        -:  110:  }
        -:  111:
    #####:  112:  if (select.getCondition() != compare.getResult())
        -:  113:    return false;
        -:  114:
        -:  115:  // Detect if the operands are swapped between cmpf and select. Match the
        -:  116:  // comparison type with the requested type or with the opposite of the
        -:  117:  // requested type if the operands are swapped. Use generic accessors because
        -:  118:  // std and LLVM versions of select have different operand names but identical
        -:  119:  // positions.
    #####:  120:  constexpr unsigned kTrueValue = 1;
    #####:  121:  constexpr unsigned kFalseValue = 2;
    #####:  122:  bool sameOperands = select.getOperand(kTrueValue) == compare.getLhs() &&
    #####:  123:                      select.getOperand(kFalseValue) == compare.getRhs();
    #####:  124:  bool swappedOperands = select.getOperand(kTrueValue) == compare.getRhs() &&
    #####:  125:                         select.getOperand(kFalseValue) == compare.getLhs();
    #####:  126:  if (!sameOperands && !swappedOperands)
        -:  127:    return false;
        -:  128:
    #####:  129:  if (select.getResult() != terminator.getResult())
        -:  130:    return false;
        -:  131:
        -:  132:  // The reduction is a min if it uses less-than predicates with same operands
        -:  133:  // or greather-than predicates with swapped operands. Similarly for max.
    #####:  134:  isMin = (isLess && sameOperands) || (!isLess && swappedOperands);
    #####:  135:  return isMin || (isLess & swappedOperands) || (!isLess && sameOperands);
        -:  136:}
------------------
_Z20matchSelectReductionIN4mlir4LLVM6ICmpOpENS1_8SelectOpENS1_13ICmpPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb:
function _Z20matchSelectReductionIN4mlir4LLVM6ICmpOpENS1_8SelectOpENS1_13ICmpPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb called 0 returned 0% blocks executed 0%
    #####:   78:matchSelectReduction(Block &block, ArrayRef<Predicate> lessThanPredicates,
branch  0 never executed
branch  1 never executed
        -:   79:                     ArrayRef<Predicate> greaterThanPredicates, bool &isMin) {
        -:   80:  static_assert(
        -:   81:      llvm::is_one_of<SelectOpTy, arith::SelectOp, LLVM::SelectOp>::value,
        -:   82:      "only arithmetic and llvm select ops are supported");
        -:   83:
        -:   84:  // Expect exactly three operations in the block.
    #####:   85:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      std::next(block.begin(), 2) == block.end() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   87:      std::next(block.begin(), 3) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   88:    return false;
        -:   89:
        -:   90:  // Check op kinds.
    #####:   91:  auto compare = dyn_cast<CompareOpTy>(block.front());
call    0 never executed
call    1 never executed
    #####:   92:  auto select = dyn_cast<SelectOpTy>(block.front().getNextNode());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:   93:  auto terminator = dyn_cast<scf::ReduceReturnOp>(block.back());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:  if (!compare || !select || !terminator)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   95:    return false;
        -:   96:
        -:   97:  // Block arguments must be compared.
    #####:   98:  if (compare->getOperands() != block.getArguments())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   99:    return false;
        -:  100:
        -:  101:  // Detect whether the comparison is less-than or greater-than, otherwise bail.
        -:  102:  bool isLess;
    #####:  103:  if (llvm::is_contained(lessThanPredicates, compare.getPredicate())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  104:    isLess = true;
    #####:  105:  } else if (llvm::is_contained(greaterThanPredicates,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  106:                                compare.getPredicate())) {
        -:  107:    isLess = false;
        -:  108:  } else {
        -:  109:    return false;
        -:  110:  }
        -:  111:
    #####:  112:  if (select.getCondition() != compare.getResult())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  113:    return false;
        -:  114:
        -:  115:  // Detect if the operands are swapped between cmpf and select. Match the
        -:  116:  // comparison type with the requested type or with the opposite of the
        -:  117:  // requested type if the operands are swapped. Use generic accessors because
        -:  118:  // std and LLVM versions of select have different operand names but identical
        -:  119:  // positions.
    #####:  120:  constexpr unsigned kTrueValue = 1;
    #####:  121:  constexpr unsigned kFalseValue = 2;
    #####:  122:  bool sameOperands = select.getOperand(kTrueValue) == compare.getLhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  123:                      select.getOperand(kFalseValue) == compare.getRhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:  bool swappedOperands = select.getOperand(kTrueValue) == compare.getRhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  125:                         select.getOperand(kFalseValue) == compare.getLhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:  if (!sameOperands && !swappedOperands)
branch  0 never executed
branch  1 never executed
        -:  127:    return false;
        -:  128:
    #####:  129:  if (select.getResult() != terminator.getResult())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  130:    return false;
        -:  131:
        -:  132:  // The reduction is a min if it uses less-than predicates with same operands
        -:  133:  // or greather-than predicates with swapped operands. Similarly for max.
    #####:  134:  isMin = (isLess && sameOperands) || (!isLess && swappedOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  135:  return isMin || (isLess & swappedOperands) || (!isLess && sameOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  136:}
------------------
_Z20matchSelectReductionIN4mlir5arith6CmpIOpENS1_8SelectOpENS1_13CmpIPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb:
function _Z20matchSelectReductionIN4mlir5arith6CmpIOpENS1_8SelectOpENS1_13CmpIPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb called 0 returned 0% blocks executed 0%
    #####:   78:matchSelectReduction(Block &block, ArrayRef<Predicate> lessThanPredicates,
branch  0 never executed
branch  1 never executed
        -:   79:                     ArrayRef<Predicate> greaterThanPredicates, bool &isMin) {
        -:   80:  static_assert(
        -:   81:      llvm::is_one_of<SelectOpTy, arith::SelectOp, LLVM::SelectOp>::value,
        -:   82:      "only arithmetic and llvm select ops are supported");
        -:   83:
        -:   84:  // Expect exactly three operations in the block.
    #####:   85:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      std::next(block.begin(), 2) == block.end() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   87:      std::next(block.begin(), 3) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   88:    return false;
        -:   89:
        -:   90:  // Check op kinds.
    #####:   91:  auto compare = dyn_cast<CompareOpTy>(block.front());
call    0 never executed
call    1 never executed
    #####:   92:  auto select = dyn_cast<SelectOpTy>(block.front().getNextNode());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:   93:  auto terminator = dyn_cast<scf::ReduceReturnOp>(block.back());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:  if (!compare || !select || !terminator)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   95:    return false;
        -:   96:
        -:   97:  // Block arguments must be compared.
    #####:   98:  if (compare->getOperands() != block.getArguments())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   99:    return false;
        -:  100:
        -:  101:  // Detect whether the comparison is less-than or greater-than, otherwise bail.
        -:  102:  bool isLess;
    #####:  103:  if (llvm::is_contained(lessThanPredicates, compare.getPredicate())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  104:    isLess = true;
    #####:  105:  } else if (llvm::is_contained(greaterThanPredicates,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  106:                                compare.getPredicate())) {
        -:  107:    isLess = false;
        -:  108:  } else {
        -:  109:    return false;
        -:  110:  }
        -:  111:
    #####:  112:  if (select.getCondition() != compare.getResult())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  113:    return false;
        -:  114:
        -:  115:  // Detect if the operands are swapped between cmpf and select. Match the
        -:  116:  // comparison type with the requested type or with the opposite of the
        -:  117:  // requested type if the operands are swapped. Use generic accessors because
        -:  118:  // std and LLVM versions of select have different operand names but identical
        -:  119:  // positions.
    #####:  120:  constexpr unsigned kTrueValue = 1;
    #####:  121:  constexpr unsigned kFalseValue = 2;
    #####:  122:  bool sameOperands = select.getOperand(kTrueValue) == compare.getLhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  123:                      select.getOperand(kFalseValue) == compare.getRhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:  bool swappedOperands = select.getOperand(kTrueValue) == compare.getRhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  125:                         select.getOperand(kFalseValue) == compare.getLhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:  if (!sameOperands && !swappedOperands)
branch  0 never executed
branch  1 never executed
        -:  127:    return false;
        -:  128:
    #####:  129:  if (select.getResult() != terminator.getResult())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  130:    return false;
        -:  131:
        -:  132:  // The reduction is a min if it uses less-than predicates with same operands
        -:  133:  // or greather-than predicates with swapped operands. Similarly for max.
    #####:  134:  isMin = (isLess && sameOperands) || (!isLess && swappedOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  135:  return isMin || (isLess & swappedOperands) || (!isLess && sameOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  136:}
------------------
_Z20matchSelectReductionIN4mlir4LLVM6FCmpOpENS1_8SelectOpENS1_13FCmpPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb:
function _Z20matchSelectReductionIN4mlir4LLVM6FCmpOpENS1_8SelectOpENS1_13FCmpPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb called 0 returned 0% blocks executed 0%
    #####:   78:matchSelectReduction(Block &block, ArrayRef<Predicate> lessThanPredicates,
branch  0 never executed
branch  1 never executed
        -:   79:                     ArrayRef<Predicate> greaterThanPredicates, bool &isMin) {
        -:   80:  static_assert(
        -:   81:      llvm::is_one_of<SelectOpTy, arith::SelectOp, LLVM::SelectOp>::value,
        -:   82:      "only arithmetic and llvm select ops are supported");
        -:   83:
        -:   84:  // Expect exactly three operations in the block.
    #####:   85:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      std::next(block.begin(), 2) == block.end() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   87:      std::next(block.begin(), 3) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   88:    return false;
        -:   89:
        -:   90:  // Check op kinds.
    #####:   91:  auto compare = dyn_cast<CompareOpTy>(block.front());
call    0 never executed
call    1 never executed
    #####:   92:  auto select = dyn_cast<SelectOpTy>(block.front().getNextNode());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:   93:  auto terminator = dyn_cast<scf::ReduceReturnOp>(block.back());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:  if (!compare || !select || !terminator)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   95:    return false;
        -:   96:
        -:   97:  // Block arguments must be compared.
    #####:   98:  if (compare->getOperands() != block.getArguments())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   99:    return false;
        -:  100:
        -:  101:  // Detect whether the comparison is less-than or greater-than, otherwise bail.
        -:  102:  bool isLess;
    #####:  103:  if (llvm::is_contained(lessThanPredicates, compare.getPredicate())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  104:    isLess = true;
    #####:  105:  } else if (llvm::is_contained(greaterThanPredicates,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  106:                                compare.getPredicate())) {
        -:  107:    isLess = false;
        -:  108:  } else {
        -:  109:    return false;
        -:  110:  }
        -:  111:
    #####:  112:  if (select.getCondition() != compare.getResult())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  113:    return false;
        -:  114:
        -:  115:  // Detect if the operands are swapped between cmpf and select. Match the
        -:  116:  // comparison type with the requested type or with the opposite of the
        -:  117:  // requested type if the operands are swapped. Use generic accessors because
        -:  118:  // std and LLVM versions of select have different operand names but identical
        -:  119:  // positions.
    #####:  120:  constexpr unsigned kTrueValue = 1;
    #####:  121:  constexpr unsigned kFalseValue = 2;
    #####:  122:  bool sameOperands = select.getOperand(kTrueValue) == compare.getLhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  123:                      select.getOperand(kFalseValue) == compare.getRhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:  bool swappedOperands = select.getOperand(kTrueValue) == compare.getRhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  125:                         select.getOperand(kFalseValue) == compare.getLhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:  if (!sameOperands && !swappedOperands)
branch  0 never executed
branch  1 never executed
        -:  127:    return false;
        -:  128:
    #####:  129:  if (select.getResult() != terminator.getResult())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  130:    return false;
        -:  131:
        -:  132:  // The reduction is a min if it uses less-than predicates with same operands
        -:  133:  // or greather-than predicates with swapped operands. Similarly for max.
    #####:  134:  isMin = (isLess && sameOperands) || (!isLess && swappedOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  135:  return isMin || (isLess & swappedOperands) || (!isLess && sameOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  136:}
------------------
_Z20matchSelectReductionIN4mlir5arith6CmpFOpENS1_8SelectOpENS1_13CmpFPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb:
function _Z20matchSelectReductionIN4mlir5arith6CmpFOpENS1_8SelectOpENS1_13CmpFPredicateEEbRNS0_5BlockEN4llvm8ArrayRefIT1_EESA_Rb called 0 returned 0% blocks executed 0%
    #####:   78:matchSelectReduction(Block &block, ArrayRef<Predicate> lessThanPredicates,
branch  0 never executed
branch  1 never executed
        -:   79:                     ArrayRef<Predicate> greaterThanPredicates, bool &isMin) {
        -:   80:  static_assert(
        -:   81:      llvm::is_one_of<SelectOpTy, arith::SelectOp, LLVM::SelectOp>::value,
        -:   82:      "only arithmetic and llvm select ops are supported");
        -:   83:
        -:   84:  // Expect exactly three operations in the block.
    #####:   85:  if (block.empty() || llvm::hasSingleElement(block) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      std::next(block.begin(), 2) == block.end() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   87:      std::next(block.begin(), 3) != block.end())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   88:    return false;
        -:   89:
        -:   90:  // Check op kinds.
    #####:   91:  auto compare = dyn_cast<CompareOpTy>(block.front());
call    0 never executed
call    1 never executed
    #####:   92:  auto select = dyn_cast<SelectOpTy>(block.front().getNextNode());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:   93:  auto terminator = dyn_cast<scf::ReduceReturnOp>(block.back());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:  if (!compare || !select || !terminator)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   95:    return false;
        -:   96:
        -:   97:  // Block arguments must be compared.
    #####:   98:  if (compare->getOperands() != block.getArguments())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   99:    return false;
        -:  100:
        -:  101:  // Detect whether the comparison is less-than or greater-than, otherwise bail.
        -:  102:  bool isLess;
    #####:  103:  if (llvm::is_contained(lessThanPredicates, compare.getPredicate())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  104:    isLess = true;
    #####:  105:  } else if (llvm::is_contained(greaterThanPredicates,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  106:                                compare.getPredicate())) {
        -:  107:    isLess = false;
        -:  108:  } else {
        -:  109:    return false;
        -:  110:  }
        -:  111:
    #####:  112:  if (select.getCondition() != compare.getResult())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  113:    return false;
        -:  114:
        -:  115:  // Detect if the operands are swapped between cmpf and select. Match the
        -:  116:  // comparison type with the requested type or with the opposite of the
        -:  117:  // requested type if the operands are swapped. Use generic accessors because
        -:  118:  // std and LLVM versions of select have different operand names but identical
        -:  119:  // positions.
    #####:  120:  constexpr unsigned kTrueValue = 1;
    #####:  121:  constexpr unsigned kFalseValue = 2;
    #####:  122:  bool sameOperands = select.getOperand(kTrueValue) == compare.getLhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  123:                      select.getOperand(kFalseValue) == compare.getRhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:  bool swappedOperands = select.getOperand(kTrueValue) == compare.getRhs() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  125:                         select.getOperand(kFalseValue) == compare.getLhs();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:  if (!sameOperands && !swappedOperands)
branch  0 never executed
branch  1 never executed
        -:  127:    return false;
        -:  128:
    #####:  129:  if (select.getResult() != terminator.getResult())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  130:    return false;
        -:  131:
        -:  132:  // The reduction is a min if it uses less-than predicates with same operands
        -:  133:  // or greather-than predicates with swapped operands. Similarly for max.
    #####:  134:  isMin = (isLess && sameOperands) || (!isLess && swappedOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  135:  return isMin || (isLess & swappedOperands) || (!isLess && sameOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  136:}
------------------
        -:  137:
        -:  138:/// Returns the float semantics for the given float type.
function _ZL19fltSemanticsForTypeN4mlir9FloatTypeE called 0 returned 0% blocks executed 0%
    #####:  139:static const llvm::fltSemantics &fltSemanticsForType(FloatType type) {
    #####:  140:  if (type.isF16())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  141:    return llvm::APFloat::IEEEhalf();
    #####:  142:  if (type.isF32())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  143:    return llvm::APFloat::IEEEsingle();
    #####:  144:  if (type.isF64())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  145:    return llvm::APFloat::IEEEdouble();
    #####:  146:  if (type.isF128())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  147:    return llvm::APFloat::IEEEquad();
    #####:  148:  if (type.isBF16())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  149:    return llvm::APFloat::BFloat();
    #####:  150:  if (type.isF80())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  151:    return llvm::APFloat::x87DoubleExtended();
    #####:  152:  llvm_unreachable("unknown float type");
call    0 never executed
        -:  153:}
        -:  154:
        -:  155:/// Returns an attribute with the minimum (if `min` is set) or the maximum value
        -:  156:/// (otherwise) for the given float type.
function _ZL19minMaxValueForFloatN4mlir4TypeEb called 0 returned 0% blocks executed 0%
    #####:  157:static Attribute minMaxValueForFloat(Type type, bool min) {
    #####:  158:  auto fltType = type.cast<FloatType>();
call    0 never executed
    #####:  159:  return FloatAttr::get(
    #####:  160:      type, llvm::APFloat::getLargest(fltSemanticsForType(fltType), min));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  161:}
        -:  162:
        -:  163:/// Returns an attribute with the signed integer minimum (if `min` is set) or
        -:  164:/// the maximum value (otherwise) for the given integer type, regardless of its
        -:  165:/// signedness semantics (only the width is considered).
function _ZL23minMaxValueForSignedIntN4mlir4TypeEb called 0 returned 0% blocks executed 0%
    #####:  166:static Attribute minMaxValueForSignedInt(Type type, bool min) {
    #####:  167:  auto intType = type.cast<IntegerType>();
call    0 never executed
    #####:  168:  unsigned bitwidth = intType.getWidth();
call    0 never executed
    #####:  169:  return IntegerAttr::get(type, min ? llvm::APInt::getSignedMinValue(bitwidth)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  170:                                    : llvm::APInt::getSignedMaxValue(bitwidth));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  171:}
        -:  172:
        -:  173:/// Returns an attribute with the unsigned integer minimum (if `min` is set) or
        -:  174:/// the maximum value (otherwise) for the given integer type, regardless of its
        -:  175:/// signedness semantics (only the width is considered).
function _ZL25minMaxValueForUnsignedIntN4mlir4TypeEb called 0 returned 0% blocks executed 0%
    #####:  176:static Attribute minMaxValueForUnsignedInt(Type type, bool min) {
    #####:  177:  auto intType = type.cast<IntegerType>();
call    0 never executed
    #####:  178:  unsigned bitwidth = intType.getWidth();
call    0 never executed
    #####:  179:  return IntegerAttr::get(type, min ? llvm::APInt::getNullValue(bitwidth)
branch  0 never executed
branch  1 never executed
    #####:  180:                                    : llvm::APInt::getAllOnesValue(bitwidth));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  181:}
        -:  182:
        -:  183:/// Creates an OpenMP reduction declaration and inserts it into the provided
        -:  184:/// symbol table. The declaration has a constant initializer with the neutral
        -:  185:/// value `initValue`, and the reduction combiner carried over from `reduce`.
function _ZL10createDeclRN4mlir15PatternRewriterERNS_11SymbolTableENS_3scf8ReduceOpENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  186:static omp::ReductionDeclareOp createDecl(PatternRewriter &builder,
        -:  187:                                          SymbolTable &symbolTable,
        -:  188:                                          scf::ReduceOp reduce,
        -:  189:                                          Attribute initValue) {
    #####:  190:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####:  191:  auto decl = builder.create<omp::ReductionDeclareOp>(
    #####:  192:      reduce.getLoc(), "__scf_reduction", reduce.getOperand().getType());
call    0 never executed
call    1 never executed
    #####:  193:  symbolTable.insert(decl);
call    0 never executed
        -:  194:
    #####:  195:  Type type = reduce.getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  196:  builder.createBlock(&decl.getInitializerRegion(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  197:                      decl.getInitializerRegion().end(), {type},
call    0 never executed
call    1 never executed
    #####:  198:                      {reduce.getOperand().getLoc()});
call    0 never executed
call    1 never executed
    #####:  199:  builder.setInsertionPointToEnd(&decl.getInitializerRegion().back());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  200:  Value init =
    #####:  201:      builder.create<LLVM::ConstantOp>(reduce.getLoc(), type, initValue);
call    0 never executed
call    1 never executed
    #####:  202:  builder.create<omp::YieldOp>(reduce.getLoc(), init);
call    0 never executed
        -:  203:
    #####:  204:  Operation *terminator = &reduce.getRegion().front().back();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  205:  assert(isa<scf::ReduceReturnOp>(terminator) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  206:         "expected reduce op to be terminated by redure return");
    #####:  207:  builder.setInsertionPoint(terminator);
call    0 never executed
    #####:  208:  builder.replaceOpWithNewOp<omp::YieldOp>(terminator,
    #####:  209:                                           terminator->getOperands());
call    0 never executed
call    1 never executed
    #####:  210:  builder.inlineRegionBefore(reduce.getRegion(), decl.getReductionRegion(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  211:                             decl.getReductionRegion().end());
call    0 never executed
call    1 never executed
    #####:  212:  return decl;
branch  0 never executed
branch  1 never executed
        -:  213:}
        -:  214:
        -:  215:/// Adds an atomic reduction combiner to the given OpenMP reduction declaration
        -:  216:/// using llvm.atomicrmw of the given kind.
function _ZL12addAtomicRMWRN4mlir9OpBuilderENS_4LLVM11AtomicBinOpENS_3omp18ReductionDeclareOpENS_3scf8ReduceOpE called 0 returned 0% blocks executed 0%
    #####:  217:static omp::ReductionDeclareOp addAtomicRMW(OpBuilder &builder,
        -:  218:                                            LLVM::AtomicBinOp atomicKind,
        -:  219:                                            omp::ReductionDeclareOp decl,
        -:  220:                                            scf::ReduceOp reduce) {
    #####:  221:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####:  222:  Type type = reduce.getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  223:  Type ptrType = LLVM::LLVMPointerType::get(type);
call    0 never executed
    #####:  224:  Location reduceOperandLoc = reduce.getOperand().getLoc();
call    0 never executed
call    1 never executed
    #####:  225:  builder.createBlock(&decl.getAtomicReductionRegion(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  226:                      decl.getAtomicReductionRegion().end(), {ptrType, ptrType},
call    0 never executed
call    1 never executed
        -:  227:                      {reduceOperandLoc, reduceOperandLoc});
    #####:  228:  Block *atomicBlock = &decl.getAtomicReductionRegion().back();
call    0 never executed
call    1 never executed
    #####:  229:  builder.setInsertionPointToEnd(atomicBlock);
call    0 never executed
    #####:  230:  Value loaded = builder.create<LLVM::LoadOp>(reduce.getLoc(),
call    0 never executed
    #####:  231:                                              atomicBlock->getArgument(1));
call    0 never executed
call    1 never executed
    #####:  232:  builder.create<LLVM::AtomicRMWOp>(reduce.getLoc(), type, atomicKind,
    #####:  233:                                    atomicBlock->getArgument(0), loaded,
call    0 never executed
    #####:  234:                                    LLVM::AtomicOrdering::monotonic);
call    0 never executed
    #####:  235:  builder.create<omp::YieldOp>(reduce.getLoc(), ArrayRef<Value>());
call    0 never executed
    #####:  236:  return decl;
branch  0 never executed
branch  1 never executed
        -:  237:}
        -:  238:
        -:  239:/// Creates an OpenMP reduction declaration that corresponds to the given SCF
        -:  240:/// reduction and returns it. Recognizes common reductions in order to identify
        -:  241:/// the neutral value, necessary for the OpenMP declaration. If the reduction
        -:  242:/// cannot be recognized, returns null.
function _ZL16declareReductionRN4mlir15PatternRewriterENS_3scf8ReduceOpE called 0 returned 0% blocks executed 0%
    #####:  243:static omp::ReductionDeclareOp declareReduction(PatternRewriter &builder,
        -:  244:                                                scf::ReduceOp reduce) {
    #####:  245:  Operation *container = SymbolTable::getNearestSymbolTable(reduce);
call    0 never executed
    #####:  246:  SymbolTable symbolTable(container);
call    0 never executed
        -:  247:
        -:  248:  // Insert reduction declarations in the symbol-table ancestor before the
        -:  249:  // ancestor of the current insertion point.
    #####:  250:  Operation *insertionPoint = reduce;
    #####:  251:  while (insertionPoint->getParentOp() != container)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  252:    insertionPoint = insertionPoint->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  253:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
call    1 never executed
    #####:  254:  builder.setInsertionPoint(insertionPoint);
call    0 never executed
        -:  255:
    #####:  256:  assert(llvm::hasSingleElement(reduce.getRegion()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  257:         "expected reduction region to have a single element");
        -:  258:
        -:  259:  // Match simple binary reductions that can be expressed with atomicrmw.
    #####:  260:  Type type = reduce.getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  261:  Block &reduction = reduce.getRegion().front();
call    0 never executed
call    1 never executed
    #####:  262:  if (matchSimpleReduction<arith::AddFOp, LLVM::FAddOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  263:    omp::ReductionDeclareOp decl = createDecl(builder, symbolTable, reduce,
    #####:  264:                                              builder.getFloatAttr(type, 0.0));
call    0 never executed
call    1 never executed
    #####:  265:    return addAtomicRMW(builder, LLVM::AtomicBinOp::fadd, decl, reduce);
call    0 never executed
        -:  266:  }
    #####:  267:  if (matchSimpleReduction<arith::AddIOp, LLVM::AddOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  268:    omp::ReductionDeclareOp decl = createDecl(builder, symbolTable, reduce,
    #####:  269:                                              builder.getIntegerAttr(type, 0));
call    0 never executed
call    1 never executed
    #####:  270:    return addAtomicRMW(builder, LLVM::AtomicBinOp::add, decl, reduce);
call    0 never executed
        -:  271:  }
    #####:  272:  if (matchSimpleReduction<arith::OrIOp, LLVM::OrOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  273:    omp::ReductionDeclareOp decl = createDecl(builder, symbolTable, reduce,
    #####:  274:                                              builder.getIntegerAttr(type, 0));
call    0 never executed
call    1 never executed
    #####:  275:    return addAtomicRMW(builder, LLVM::AtomicBinOp::_or, decl, reduce);
call    0 never executed
        -:  276:  }
    #####:  277:  if (matchSimpleReduction<arith::XOrIOp, LLVM::XOrOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  278:    omp::ReductionDeclareOp decl = createDecl(builder, symbolTable, reduce,
    #####:  279:                                              builder.getIntegerAttr(type, 0));
call    0 never executed
call    1 never executed
    #####:  280:    return addAtomicRMW(builder, LLVM::AtomicBinOp::_xor, decl, reduce);
call    0 never executed
        -:  281:  }
    #####:  282:  if (matchSimpleReduction<arith::AndIOp, LLVM::AndOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  283:    omp::ReductionDeclareOp decl = createDecl(
        -:  284:        builder, symbolTable, reduce,
    #####:  285:        builder.getIntegerAttr(
branch  0 never executed
branch  1 never executed
    #####:  286:            type, llvm::APInt::getAllOnesValue(type.getIntOrFloatBitWidth())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  287:    return addAtomicRMW(builder, LLVM::AtomicBinOp::_and, decl, reduce);
call    0 never executed
        -:  288:  }
        -:  289:
        -:  290:  // Match simple binary reductions that cannot be expressed with atomicrmw.
        -:  291:  // TODO: add atomic region using cmpxchg (which needs atomic load to be
        -:  292:  // available as an op).
    #####:  293:  if (matchSimpleReduction<arith::MulFOp, LLVM::FMulOp>(reduction)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:    return createDecl(builder, symbolTable, reduce,
    #####:  295:                      builder.getFloatAttr(type, 1.0));
call    0 never executed
call    1 never executed
        -:  296:  }
        -:  297:
        -:  298:  // Match select-based min/max reductions.
    #####:  299:  bool isMin;
    #####:  300:  if (matchSelectReduction<arith::CmpFOp, arith::SelectOp>(
call    0 never executed
        -:  301:          reduction, {arith::CmpFPredicate::OLT, arith::CmpFPredicate::OLE},
    #####:  302:          {arith::CmpFPredicate::OGT, arith::CmpFPredicate::OGE}, isMin) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  303:      matchSelectReduction<LLVM::FCmpOp, LLVM::SelectOp>(
call    0 never executed
        -:  304:          reduction, {LLVM::FCmpPredicate::olt, LLVM::FCmpPredicate::ole},
        -:  305:          {LLVM::FCmpPredicate::ogt, LLVM::FCmpPredicate::oge}, isMin)) {
    #####:  306:    return createDecl(builder, symbolTable, reduce,
    #####:  307:                      minMaxValueForFloat(type, !isMin));
call    0 never executed
call    1 never executed
        -:  308:  }
    #####:  309:  if (matchSelectReduction<arith::CmpIOp, arith::SelectOp>(
call    0 never executed
        -:  310:          reduction, {arith::CmpIPredicate::slt, arith::CmpIPredicate::sle},
    #####:  311:          {arith::CmpIPredicate::sgt, arith::CmpIPredicate::sge}, isMin) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  312:      matchSelectReduction<LLVM::ICmpOp, LLVM::SelectOp>(
call    0 never executed
        -:  313:          reduction, {LLVM::ICmpPredicate::slt, LLVM::ICmpPredicate::sle},
        -:  314:          {LLVM::ICmpPredicate::sgt, LLVM::ICmpPredicate::sge}, isMin)) {
    #####:  315:    omp::ReductionDeclareOp decl = createDecl(
    #####:  316:        builder, symbolTable, reduce, minMaxValueForSignedInt(type, !isMin));
call    0 never executed
call    1 never executed
    #####:  317:    return addAtomicRMW(builder,
        -:  318:                        isMin ? LLVM::AtomicBinOp::min : LLVM::AtomicBinOp::max,
    #####:  319:                        decl, reduce);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  320:  }
    #####:  321:  if (matchSelectReduction<arith::CmpIOp, arith::SelectOp>(
call    0 never executed
        -:  322:          reduction, {arith::CmpIPredicate::ult, arith::CmpIPredicate::ule},
    #####:  323:          {arith::CmpIPredicate::ugt, arith::CmpIPredicate::uge}, isMin) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  324:      matchSelectReduction<LLVM::ICmpOp, LLVM::SelectOp>(
call    0 never executed
        -:  325:          reduction, {LLVM::ICmpPredicate::ugt, LLVM::ICmpPredicate::ule},
        -:  326:          {LLVM::ICmpPredicate::ugt, LLVM::ICmpPredicate::uge}, isMin)) {
    #####:  327:    omp::ReductionDeclareOp decl = createDecl(
    #####:  328:        builder, symbolTable, reduce, minMaxValueForUnsignedInt(type, !isMin));
call    0 never executed
call    1 never executed
    #####:  329:    return addAtomicRMW(
        -:  330:        builder, isMin ? LLVM::AtomicBinOp::umin : LLVM::AtomicBinOp::umax,
    #####:  331:        decl, reduce);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  332:  }
        -:  333:
    #####:  334:  return nullptr;
        -:  335:}
        -:  336:
        -:  337:namespace {
        -:  338:
        -:  339:struct ParallelOpLowering : public OpRewritePattern<scf::ParallelOp> {
        -:  340:  using OpRewritePattern<scf::ParallelOp>::OpRewritePattern;
        -:  341:
function _ZNK12_GLOBAL__N_118ParallelOpLowering15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  342:  LogicalResult matchAndRewrite(scf::ParallelOp parallelOp,
        -:  343:                                PatternRewriter &rewriter) const override {
        -:  344:    // Declare reductions.
        -:  345:    // TODO: consider checking it here is already a compatible reduction
        -:  346:    // declaration and use it instead of redeclaring.
    #####:  347:    SmallVector<Attribute> reductionDeclSymbols;
call    0 never executed
    #####:  348:    for (auto reduce : parallelOp.getOps<scf::ReduceOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  349:      omp::ReductionDeclareOp decl = declareReduction(rewriter, reduce);
call    0 never executed
    #####:  350:      if (!decl)
branch  0 never executed
branch  1 never executed
    #####:  351:        return failure();
    #####:  352:      reductionDeclSymbols.push_back(
call    0 never executed
    #####:  353:          SymbolRefAttr::get(rewriter.getContext(), decl.getSymName()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  354:    }
        -:  355:
        -:  356:    // Allocate reduction variables. Make sure the we don't overflow the stack
        -:  357:    // with local `alloca`s by saving and restoring the stack pointer.
    #####:  358:    Location loc = parallelOp.getLoc();
call    0 never executed
    #####:  359:    Value one = rewriter.create<LLVM::ConstantOp>(
    #####:  360:        loc, rewriter.getIntegerType(64), rewriter.getI64IntegerAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  361:    SmallVector<Value> reductionVariables;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  362:    reductionVariables.reserve(parallelOp.getNumReductions());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  363:    for (Value init : parallelOp.getInitVals()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  364:      assert((LLVM::isCompatibleType(init.getType()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  365:              init.getType().isa<LLVM::PointerElementTypeInterface>()) &&
        -:  366:             "cannot create a reduction variable if the type is not an LLVM "
        -:  367:             "pointer element");
    #####:  368:      Value storage = rewriter.create<LLVM::AllocaOp>(
    #####:  369:          loc, LLVM::LLVMPointerType::get(init.getType()), one, 0);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  370:      rewriter.create<LLVM::StoreOp>(loc, init, storage);
call    0 never executed
    #####:  371:      reductionVariables.push_back(storage);
call    0 never executed
        -:  372:    }
        -:  373:
        -:  374:    // Replace the reduction operations contained in this loop. Must be done
        -:  375:    // here rather than in a separate pattern to have access to the list of
        -:  376:    // reduction variables.
    #####:  377:    for (auto pair :
    #####:  378:         llvm::zip(parallelOp.getOps<scf::ReduceOp>(), reductionVariables)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  379:      OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
call    1 never executed
    #####:  380:      scf::ReduceOp reduceOp = std::get<0>(pair);
call    0 never executed
    #####:  381:      rewriter.setInsertionPoint(reduceOp);
call    0 never executed
    #####:  382:      rewriter.replaceOpWithNewOp<omp::ReductionOp>(
    #####:  383:          reduceOp, reduceOp.getOperand(), std::get<1>(pair));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  384:    }
        -:  385:
        -:  386:    // Create the parallel wrapper.
    #####:  387:    auto ompParallel = rewriter.create<omp::ParallelOp>(loc);
call    0 never executed
    #####:  388:    {
        -:  389:
    #####:  390:      OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  391:      rewriter.createBlock(&ompParallel.getRegion());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  392:
        -:  393:      // Replace the loop.
    #####:  394:      {
    #####:  395:        OpBuilder::InsertionGuard allocaGuard(rewriter);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  396:        auto loop = rewriter.create<omp::WsLoopOp>(
    #####:  397:            parallelOp.getLoc(), parallelOp.getLowerBound(),
call    0 never executed
    #####:  398:            parallelOp.getUpperBound(), parallelOp.getStep());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  399:        rewriter.create<omp::TerminatorOp>(loc);
call    0 never executed
        -:  400:
    #####:  401:        rewriter.inlineRegionBefore(parallelOp.getRegion(), loop.getRegion(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  402:                                    loop.getRegion().begin());
call    0 never executed
call    1 never executed
        -:  403:
    #####:  404:        Block *ops = rewriter.splitBlock(&*loop.getRegion().begin(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  405:                                         loop.getRegion().begin()->begin());
call    0 never executed
call    1 never executed
        -:  406:
    #####:  407:        rewriter.setInsertionPointToStart(&*loop.getRegion().begin());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  408:
    #####:  409:        auto scope = rewriter.create<memref::AllocaScopeOp>(parallelOp.getLoc(),
    #####:  410:                                                            TypeRange());
call    0 never executed
call    1 never executed
    #####:  411:        rewriter.create<omp::YieldOp>(loc, ValueRange());
call    0 never executed
call    1 never executed
    #####:  412:        Block *scopeBlock = rewriter.createBlock(&scope.getBodyRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  413:        rewriter.mergeBlocks(ops, scopeBlock);
call    0 never executed
call    1 never executed
    #####:  414:        auto oldYield = cast<scf::YieldOp>(scopeBlock->getTerminator());
call    0 never executed
call    1 never executed
    #####:  415:        rewriter.setInsertionPointToEnd(&*scope.getBodyRegion().begin());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  416:        rewriter.replaceOpWithNewOp<memref::AllocaScopeReturnOp>(
    #####:  417:            oldYield, oldYield->getOperands());
call    0 never executed
call    1 never executed
    #####:  418:        if (!reductionVariables.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  419:          loop.setReductionsAttr(
call    0 never executed
call    1 never executed
        -:  420:              ArrayAttr::get(rewriter.getContext(), reductionDeclSymbols));
    #####:  421:          loop.getReductionVarsMutable().append(reductionVariables);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  422:        }
        -:  423:      }
        -:  424:    }
        -:  425:
        -:  426:    // Load loop results.
    #####:  427:    SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  428:    results.reserve(reductionVariables.size());
branch  0 never executed
branch  1 never executed
    #####:  429:    for (Value variable : reductionVariables) {
branch  0 never executed
branch  1 never executed
    #####:  430:      Value res = rewriter.create<LLVM::LoadOp>(loc, variable);
call    0 never executed
call    1 never executed
    #####:  431:      results.push_back(res);
call    0 never executed
        -:  432:    }
    #####:  433:    rewriter.replaceOp(parallelOp, results);
call    0 never executed
call    1 never executed
        -:  434:
    #####:  435:    return success();
branch  0 never executed
branch  1 never executed
        -:  436:  }
        -:  437:};
        -:  438:
        -:  439:/// Applies the conversion patterns in the given function.
function _ZN12_GLOBAL__N_1L13applyPatternsEN4mlir8ModuleOpE called 513 returned 100% blocks executed 100%
      513:  440:static LogicalResult applyPatterns(ModuleOp module) {
      513:  441:  ConversionTarget target(*module.getContext());
call    0 returned 100%
call    1 returned 100%
      513:  442:  target.addIllegalOp<scf::ReduceOp, scf::ReduceReturnOp, scf::ParallelOp>();
call    0 returned 100%
      513:  443:  target.addLegalDialect<omp::OpenMPDialect, LLVM::LLVMDialect,
      513:  444:                         memref::MemRefDialect>();
call    0 returned 100%
        -:  445:
     1026:  446:  RewritePatternSet patterns(module.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      513:  447:  patterns.add<ParallelOpLowering>(module.getContext());
call    0 returned 100%
call    1 returned 100%
     1026:  448:  FrozenRewritePatternSet frozen(std::move(patterns));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      513:  449:  return applyPartialConversion(module, target, frozen);
call    0 returned 100%
        -:  450:}
        -:  451:
        -:  452:/// A pass converting SCF operations to OpenMP operations.
  129230*:  453:struct SCFToOpenMPPass : public impl::ConvertSCFToOpenMPBase<SCFToOpenMPPass> {
call    0 never executed
call    1 returned 100%
        -:  454:  /// Pass entry point.
function _ZN12_GLOBAL__N_115SCFToOpenMPPass14runOnOperationEv called 513 returned 100% blocks executed 80%
      513:  455:  void runOnOperation() override {
      513:  456:    if (failed(applyPatterns(getOperation())))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  457:      signalPassFailure();
call    0 never executed
      513:  458:  }
        -:  459:};
        -:  460:
        -:  461:} // namespace
        -:  462:
function _ZN4mlir28createConvertSCFToOpenMPPassEv called 129230 returned 100% blocks executed 100%
   129230:  463:std::unique_ptr<OperationPass<ModuleOp>> mlir::createConvertSCFToOpenMPPass() {
   129230:  464:  return std::make_unique<SCFToOpenMPPass>();
call    0 returned 100%
        -:  465:}
