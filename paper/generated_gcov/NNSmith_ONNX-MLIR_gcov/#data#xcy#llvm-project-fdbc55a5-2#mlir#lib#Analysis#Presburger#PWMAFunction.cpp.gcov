        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Analysis/Presburger/PWMAFunction.cpp
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/PWMAFunction.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/PWMAFunction.cpp.gcda
        -:    0:Runs:128654
        -:    1://===- PWMAFunction.cpp - MLIR PWMAFunction Class -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Analysis/Presburger/PWMAFunction.h"
        -:   10:#include "mlir/Analysis/Presburger/Simplex.h"
        -:   11:
        -:   12:using namespace mlir;
        -:   13:using namespace presburger;
        -:   14:
function _ZNK4mlir10presburger19MultiAffineFunction18assertIsConsistentEv called 0 returned 0% blocks executed 0%
    #####:   15:void MultiAffineFunction::assertIsConsistent() const {
    #####:   16:  assert(space.getNumVars() - space.getNumRangeVars() + 1 ==
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   17:             output.getNumColumns() &&
        -:   18:         "Inconsistent number of output columns");
    #####:   19:  assert(space.getNumDomainVars() + space.getNumSymbolVars() ==
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   20:             divs.getNumNonDivs() &&
        -:   21:         "Inconsistent number of non-division variables in divs");
    #####:   22:  assert(space.getNumRangeVars() == output.getNumRows() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   23:         "Inconsistent number of output rows");
    #####:   24:  assert(space.getNumLocalVars() == divs.getNumDivs() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   25:         "Inconsistent number of divisions.");
    #####:   26:  assert(divs.hasAllReprs() && "All divisions should have a representation");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   27:}
        -:   28:
        -:   29:// Return the result of subtracting the two given vectors pointwise.
        -:   30:// The vectors must be of the same size.
        -:   31:// e.g., [3, 4, 6] - [2, 5, 1] = [1, -1, 5].
function _ZL13subtractExprsN4llvm8ArrayRefIN4mlir10presburger5MPIntEEES4_ called 0 returned 0% blocks executed 0%
    #####:   32:static SmallVector<MPInt, 8> subtractExprs(ArrayRef<MPInt> vecA,
        -:   33:                                           ArrayRef<MPInt> vecB) {
    #####:   34:  assert(vecA.size() == vecB.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   35:         "Cannot subtract vectors of differing lengths!");
    #####:   36:  SmallVector<MPInt, 8> result;
branch  0 never executed
branch  1 never executed
    #####:   37:  result.reserve(vecA.size());
branch  0 never executed
branch  1 never executed
    #####:   38:  for (unsigned i = 0, e = vecA.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:   39:    result.push_back(vecA[i] - vecB[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   40:  return result;
        -:   41:}
        -:   42:
function _ZNK4mlir10presburger12PWMAFunction9getDomainEv called 0 returned 0% blocks executed 0%
    #####:   43:PresburgerSet PWMAFunction::getDomain() const {
    #####:   44:  PresburgerSet domain = PresburgerSet::getEmpty(getDomainSpace());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   45:  for (const Piece &piece : pieces)
branch  0 never executed
branch  1 never executed
    #####:   46:    domain.unionInPlace(piece.domain);
call    0 never executed
    #####:   47:  return domain;
        -:   48:}
        -:   49:
function _ZNK4mlir10presburger19MultiAffineFunction5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:   50:void MultiAffineFunction::print(raw_ostream &os) const {
    #####:   51:  space.print(os);
call    0 never executed
    #####:   52:  os << "Division Representation:\n";
call    0 never executed
    #####:   53:  divs.print(os);
call    0 never executed
    #####:   54:  os << "Output:\n";
call    0 never executed
    #####:   55:  output.print(os);
call    0 never executed
    #####:   56:}
        -:   57:
        -:   58:SmallVector<MPInt, 8>
function _ZNK4mlir10presburger19MultiAffineFunction7valueAtEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:   59:MultiAffineFunction::valueAt(ArrayRef<MPInt> point) const {
    #####:   60:  assert(point.size() == getNumDomainVars() + getNumSymbolVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   61:         "Point has incorrect dimensionality!");
        -:   62:
    #####:   63:  SmallVector<MPInt, 8> pointHomogenous{llvm::to_vector(point)};
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:   64:  // Get the division values at this point.
    #####:   65:  SmallVector<Optional<MPInt>, 8> divValues = divs.divValuesAt(point);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   66:  // The given point didn't include the values of the divs which the output is a
        -:   67:  // function of; we have computed one possible set of values and use them here.
    #####:   68:  pointHomogenous.reserve(pointHomogenous.size() + divValues.size());
branch  0 never executed
branch  1 never executed
    #####:   69:  for (const Optional<MPInt> &divVal : divValues)
branch  0 never executed
branch  1 never executed
    #####:   70:    pointHomogenous.push_back(*divVal);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   71:  // The matrix `output` has an affine expression in the ith row, corresponding
        -:   72:  // to the expression for the ith value in the output vector. The last column
        -:   73:  // of the matrix contains the constant term. Let v be the input point with
        -:   74:  // a 1 appended at the end. We can see that output * v gives the desired
        -:   75:  // output vector.
    #####:   76:  pointHomogenous.emplace_back(1);
call    0 never executed
    #####:   77:  SmallVector<MPInt, 8> result = output.postMultiplyWithColumn(pointHomogenous);
call    0 never executed
    #####:   78:  assert(result.size() == getNumOutputs());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   79:  return result;
call    0 never executed
        -:   80:}
        -:   81:
function _ZNK4mlir10presburger19MultiAffineFunction7isEqualERKS1_ called 0 returned 0% blocks executed 0%
    #####:   82:bool MultiAffineFunction::isEqual(const MultiAffineFunction &other) const {
    #####:   83:  assert(space.isCompatible(other.space) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   84:         "Spaces should be compatible for equality check.");
    #####:   85:  return getAsRelation().isEqual(other.getAsRelation());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   86:}
        -:   87:
function _ZNK4mlir10presburger19MultiAffineFunction7isEqualERKS1_RKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####:   88:bool MultiAffineFunction::isEqual(const MultiAffineFunction &other,
        -:   89:                                  const IntegerPolyhedron &domain) const {
    #####:   90:  assert(space.isCompatible(other.space) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   91:         "Spaces should be compatible for equality check.");
    #####:   92:  IntegerRelation restrictedThis = getAsRelation();
call    0 never executed
call    1 never executed
    #####:   93:  restrictedThis.intersectDomain(domain);
call    0 never executed
        -:   94:
    #####:   95:  IntegerRelation restrictedOther = other.getAsRelation();
call    0 never executed
call    1 never executed
    #####:   96:  restrictedOther.intersectDomain(domain);
call    0 never executed
        -:   97:
    #####:   98:  return restrictedThis.isEqual(restrictedOther);
call    0 never executed
        -:   99:}
        -:  100:
function _ZNK4mlir10presburger19MultiAffineFunction7isEqualERKS1_RKNS0_13PresburgerSetE called 0 returned 0% blocks executed 0%
    #####:  101:bool MultiAffineFunction::isEqual(const MultiAffineFunction &other,
        -:  102:                                  const PresburgerSet &domain) const {
    #####:  103:  assert(space.isCompatible(other.space) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  104:         "Spaces should be compatible for equality check.");
    #####:  105:  return llvm::all_of(domain.getAllDisjuncts(),
call    0 never executed
call    1 never executed
function _ZZNK4mlir10presburger19MultiAffineFunction7isEqualERKS1_RKNS0_13PresburgerSetEENKUlRKNS0_15IntegerRelationEE_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  106:                      [&](const IntegerRelation &disjunct) {
    #####:  107:                        return isEqual(other, IntegerPolyhedron(disjunct));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  108:                      });
        -:  109:}
        -:  110:
function _ZN4mlir10presburger19MultiAffineFunction13removeOutputsEjj called 0 returned 0% blocks executed 0%
    #####:  111:void MultiAffineFunction::removeOutputs(unsigned start, unsigned end) {
    #####:  112:  assert(end <= getNumOutputs() && "Invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  113:
    #####:  114:  if (start >= end)
branch  0 never executed
branch  1 never executed
        -:  115:    return;
        -:  116:
    #####:  117:  space.removeVarRange(VarKind::Range, start, end);
call    0 never executed
    #####:  118:  output.removeRows(start, end - start);
call    0 never executed
        -:  119:}
        -:  120:
function _ZN4mlir10presburger19MultiAffineFunction9mergeDivsERS1_ called 0 returned 0% blocks executed 0%
    #####:  121:void MultiAffineFunction::mergeDivs(MultiAffineFunction &other) {
    #####:  122:  assert(space.isCompatible(other.space) && "Functions should be compatible");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  123:
    #####:  124:  unsigned nDivs = getNumDivs();
call    0 never executed
    #####:  125:  unsigned divOffset = divs.getDivOffset();
call    0 never executed
        -:  126:
    #####:  127:  other.divs.insertDiv(0, nDivs);
call    0 never executed
        -:  128:
    #####:  129:  SmallVector<MPInt, 8> div(other.divs.getNumVars() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  130:  for (unsigned i = 0; i < nDivs; ++i) {
branch  0 never executed
branch  1 never executed
        -:  131:    // Zero fill.
    #####:  132:    std::fill(div.begin(), div.end(), 0);
call    0 never executed
        -:  133:    // Fill div with dividend from `divs`. Do not fill the constant.
    #####:  134:    std::copy(divs.getDividend(i).begin(), divs.getDividend(i).end() - 1,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  135:              div.begin());
        -:  136:    // Fill constant.
    #####:  137:    div.back() = divs.getDividend(i).back();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  138:    other.divs.setDiv(i, div, divs.getDenom(i));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  139:  }
        -:  140:
    #####:  141:  other.space.insertVar(VarKind::Local, 0, nDivs);
call    0 never executed
    #####:  142:  other.output.insertColumns(divOffset, nDivs);
call    0 never executed
        -:  143:
function _ZZN4mlir10presburger19MultiAffineFunction9mergeDivsERS1_ENKUljjE_clEjj called 0 returned 0% blocks executed 0%
    #####:  144:  auto merge = [&](unsigned i, unsigned j) {
        -:  145:    // We only merge from local at pos j to local at pos i, where j > i.
    #####:  146:    if (i >= j)
branch  0 never executed
branch  1 never executed
        -:  147:      return false;
        -:  148:
        -:  149:    // If i < nDivs, we are trying to merge duplicate divs in `this`. Since we
        -:  150:    // do not want to merge duplicates in `this`, we ignore this call.
    #####:  151:    if (j < nDivs)
branch  0 never executed
branch  1 never executed
        -:  152:      return false;
        -:  153:
        -:  154:    // Merge things in space and output.
    #####:  155:    other.space.removeVarRange(VarKind::Local, j, j + 1);
call    0 never executed
    #####:  156:    other.output.addToColumn(divOffset + i, divOffset + j, 1);
call    0 never executed
    #####:  157:    other.output.removeColumn(divOffset + j);
    #####:  158:    return true;
call    0 never executed
    #####:  159:  };
        -:  160:
    #####:  161:  other.divs.removeDuplicateDivs(merge);
call    0 never executed
        -:  162:
    #####:  163:  unsigned newDivs = other.divs.getNumDivs() - nDivs;
call    0 never executed
        -:  164:
    #####:  165:  space.insertVar(VarKind::Local, nDivs, newDivs);
call    0 never executed
    #####:  166:  output.insertColumns(divOffset + nDivs, newDivs);
call    0 never executed
    #####:  167:  divs = other.divs;
call    0 never executed
        -:  168:
        -:  169:  // Check consistency.
    #####:  170:  assertIsConsistent();
call    0 never executed
    #####:  171:  other.assertIsConsistent();
call    0 never executed
    #####:  172:}
        -:  173:
        -:  174:/// Two PWMAFunctions are equal if they have the same dimensionalities,
        -:  175:/// the same domain, and take the same value at every point in the domain.
function _ZNK4mlir10presburger12PWMAFunction7isEqualERKS1_ called 0 returned 0% blocks executed 0%
    #####:  176:bool PWMAFunction::isEqual(const PWMAFunction &other) const {
    #####:  177:  if (!space.isCompatible(other.space))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  178:    return false;
        -:  179:
    #####:  180:  if (!this->getDomain().isEqual(other.getDomain()))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  181:    return false;
        -:  182:
        -:  183:  // Check if, whenever the domains of a piece of `this` and a piece of `other`
        -:  184:  // overlap, they take the same output value. If `this` and `other` have the
        -:  185:  // same domain (checked above), then this check passes iff the two functions
        -:  186:  // have the same output at every point in the domain.
    #####:  187:  return llvm::all_of(this->pieces, [&other](const Piece &pieceA) {
call    0 never executed
function _ZZZNK4mlir10presburger12PWMAFunction7isEqualERKS1_ENKUlRKNS1_5PieceEE_clES6_ENKUlS6_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  188:    return llvm::all_of(other.pieces, [&pieceA](const Piece &pieceB) {
call    0 never executed
    #####:  189:      PresburgerSet commonDomain = pieceA.domain.intersect(pieceB.domain);
call    0 never executed
    #####:  190:      return pieceA.output.isEqual(pieceB.output, commonDomain);
call    0 never executed
call    1 never executed
        -:  191:    });
    #####:  192:  });
        -:  193:}
        -:  194:
function _ZN4mlir10presburger12PWMAFunction8addPieceERKNS1_5PieceE called 0 returned 0% blocks executed 0%
    #####:  195:void PWMAFunction::addPiece(const Piece &piece) {
    #####:  196:  assert(piece.isConsistent() && "Piece should be consistent");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  197:  pieces.push_back(piece);
call    0 never executed
    #####:  198:}
        -:  199:
function _ZNK4mlir10presburger12PWMAFunction5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  200:void PWMAFunction::print(raw_ostream &os) const {
    #####:  201:  space.print(os);
call    0 never executed
    #####:  202:  os << getNumPieces() << " pieces:\n";
call    0 never executed
call    1 never executed
    #####:  203:  for (const Piece &piece : pieces) {
branch  0 never executed
branch  1 never executed
    #####:  204:    os << "Domain of piece:\n";
call    0 never executed
    #####:  205:    piece.domain.print(os);
call    0 never executed
    #####:  206:    os << "Output of piece\n";
call    0 never executed
    #####:  207:    piece.output.print(os);
call    0 never executed
        -:  208:  }
    #####:  209:}
        -:  210:
function _ZNK4mlir10presburger12PWMAFunction4dumpEv called 0 returned 0% blocks executed 0%
    #####:  211:void PWMAFunction::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -:  212:
function _ZNK4mlir10presburger12PWMAFunction13unionFunctionERKS1_N4llvm12function_refIFNS0_13PresburgerSetENS1_5PieceES7_EEE called 0 returned 0% blocks executed 0%
    #####:  213:PWMAFunction PWMAFunction::unionFunction(
        -:  214:    const PWMAFunction &func,
        -:  215:    llvm::function_ref<PresburgerSet(Piece maf1, Piece maf2)> tiebreak) const {
    #####:  216:  assert(getNumOutputs() == func.getNumOutputs() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  217:         "Ranges of functions should be same.");
    #####:  218:  assert(getSpace().isCompatible(func.getSpace()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  219:         "Space is not compatible.");
        -:  220:
        -:  221:  // The algorithm used here is as follows:
        -:  222:  // - Add the output of pieceB for the part of the domain where both pieceA and
        -:  223:  //   pieceB are defined, and `tiebreak` chooses the output of pieceB.
        -:  224:  // - Add the output of pieceA, where pieceB is not defined or `tiebreak`
        -:  225:  // chooses
        -:  226:  //   pieceA over pieceB.
        -:  227:  // - Add the output of pieceB, where pieceA is not defined.
        -:  228:
        -:  229:  // Add parts of the common domain where pieceB's output is used. Also
        -:  230:  // add all the parts where pieceA's output is used, both common and
        -:  231:  // non-common.
    #####:  232:  PWMAFunction result(getSpace());
call    0 never executed
    #####:  233:  for (const Piece &pieceA : pieces) {
branch  0 never executed
branch  1 never executed
    #####:  234:    PresburgerSet dom(pieceA.domain);
call    0 never executed
    #####:  235:    for (const Piece &pieceB : func.pieces) {
branch  0 never executed
branch  1 never executed
    #####:  236:      PresburgerSet better = tiebreak(pieceB, pieceA);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  237:      // Add the output of pieceB, where it is better than output of pieceA.
        -:  238:      // The disjuncts in "better" will be disjoint as tiebreak should gurantee
        -:  239:      // that.
    #####:  240:      result.addPiece({better, pieceB.output});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  241:      dom = dom.subtract(better);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  242:    }
        -:  243:    // Add output of pieceA, where it is better than pieceB, or pieceB is not
        -:  244:    // defined.
        -:  245:    //
        -:  246:    // `dom` here is guranteed to be disjoint from already added pieces
        -:  247:    // because because the pieces added before are either:
        -:  248:    // - Subsets of the domain of other MAFs in `this`, which are guranteed
        -:  249:    //   to be disjoint from `dom`, or
        -:  250:    // - They are one of the pieces added for `pieceB`, and we have been
        -:  251:    //   subtracting all such pieces from `dom`, so `dom` is disjoint from those
        -:  252:    //   pieces as well.
    #####:  253:    result.addPiece({dom, pieceA.output});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  254:  }
        -:  255:
        -:  256:  // Add parts of pieceB which are not shared with pieceA.
    #####:  257:  PresburgerSet dom = getDomain();
call    0 never executed
    #####:  258:  for (const Piece &pieceB : func.pieces)
branch  0 never executed
branch  1 never executed
    #####:  259:    result.addPiece({pieceB.domain.subtract(dom), pieceB.output});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  260:
    #####:  261:  return result;
call    0 never executed
        -:  262:}
        -:  263:
        -:  264:/// A tiebreak function which breaks ties by comparing the outputs
        -:  265:/// lexicographically. If `lexMin` is true, then the ties are broken by
        -:  266:/// taking the lexicographically smaller output and otherwise, by taking the
        -:  267:/// lexicographically larger output.
        -:  268:template <bool lexMin>
    #####:  269:static PresburgerSet tiebreakLex(const PWMAFunction::Piece &pieceA,
        -:  270:                                 const PWMAFunction::Piece &pieceB) {
        -:  271:  // TODO: Support local variables here.
    #####:  272:  assert(pieceA.output.getSpace().isCompatible(pieceB.output.getSpace()) &&
        -:  273:         "Pieces should be compatible");
    #####:  274:  assert(pieceA.domain.getSpace().getNumLocalVars() == 0 &&
        -:  275:         "Local variables are not supported yet.");
        -:  276:
    #####:  277:  PresburgerSpace compatibleSpace = pieceA.domain.getSpace();
    #####:  278:  const PresburgerSpace &space = pieceA.domain.getSpace();
        -:  279:
        -:  280:  // We first create the set `result`, corresponding to the set where output
        -:  281:  // of pieceA is lexicographically larger/smaller than pieceB. This is done by
        -:  282:  // creating a PresburgerSet with the following constraints:
        -:  283:  //
        -:  284:  //    (outA[0] > outB[0]) U
        -:  285:  //    (outA[0] = outB[0], outA[1] > outA[1]) U
        -:  286:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] > outA[2]) U
        -:  287:  //    ...
        -:  288:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] > outB[n-1])
        -:  289:  //
        -:  290:  // where `n` is the number of outputs.
        -:  291:  // If `lexMin` is set, the complement inequality is used:
        -:  292:  //
        -:  293:  //    (outA[0] < outB[0]) U
        -:  294:  //    (outA[0] = outB[0], outA[1] < outA[1]) U
        -:  295:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] < outA[2]) U
        -:  296:  //    ...
        -:  297:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] < outB[n-1])
    #####:  298:  PresburgerSet result = PresburgerSet::getEmpty(compatibleSpace);
    #####:  299:  IntegerPolyhedron levelSet(
        -:  300:      /*numReservedInequalities=*/1,
        -:  301:      /*numReservedEqualities=*/pieceA.output.getNumOutputs(),
    #####:  302:      /*numReservedCols=*/space.getNumVars() + 1, space);
    #####:  303:  for (unsigned level = 0; level < pieceA.output.getNumOutputs(); ++level) {
        -:  304:
        -:  305:    // Create the expression `outA - outB` for this level.
    #####:  306:    SmallVector<MPInt, 8> subExpr = subtractExprs(
        -:  307:        pieceA.output.getOutputExpr(level), pieceB.output.getOutputExpr(level));
        -:  308:
        -:  309:    if (lexMin) {
        -:  310:      // For lexMin, we add an upper bound of -1:
        -:  311:      //        outA - outB <= -1
        -:  312:      //        outA <= outB - 1
        -:  313:      //        outA < outB
    #####:  314:      levelSet.addBound(IntegerPolyhedron::BoundType::UB, subExpr, MPInt(-1));
        -:  315:    } else {
        -:  316:      // For lexMax, we add a lower bound of 1:
        -:  317:      //        outA - outB >= 1
        -:  318:      //        outA > outB + 1
        -:  319:      //        outA > outB
    #####:  320:      levelSet.addBound(IntegerPolyhedron::BoundType::LB, subExpr, MPInt(1));
        -:  321:    }
        -:  322:
        -:  323:    // Union the set with the result.
    #####:  324:    result.unionInPlace(levelSet);
        -:  325:    // There is only 1 inequality in `levelSet`, so the index is always 0.
    #####:  326:    levelSet.removeInequality(0);
        -:  327:    // Add equality `outA - outB == 0` for this level for next iteration.
    #####:  328:    levelSet.addEquality(subExpr);
        -:  329:  }
        -:  330:
        -:  331:  // We then intersect `result` with the domain of pieceA and pieceB, to only
        -:  332:  // tiebreak on the domain where both are defined.
    #####:  333:  result = result.intersect(pieceA.domain).intersect(pieceB.domain);
        -:  334:
    #####:  335:  return result;
        -:  336:}
------------------
_Z11tiebreakLexILb0EEN4mlir10presburger13PresburgerSetERKNS1_12PWMAFunction5PieceES6_:
function _Z11tiebreakLexILb0EEN4mlir10presburger13PresburgerSetERKNS1_12PWMAFunction5PieceES6_ called 0 returned 0% blocks executed 0%
    #####:  269:static PresburgerSet tiebreakLex(const PWMAFunction::Piece &pieceA,
        -:  270:                                 const PWMAFunction::Piece &pieceB) {
        -:  271:  // TODO: Support local variables here.
    #####:  272:  assert(pieceA.output.getSpace().isCompatible(pieceB.output.getSpace()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  273:         "Pieces should be compatible");
    #####:  274:  assert(pieceA.domain.getSpace().getNumLocalVars() == 0 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  275:         "Local variables are not supported yet.");
        -:  276:
    #####:  277:  PresburgerSpace compatibleSpace = pieceA.domain.getSpace();
call    0 never executed
    #####:  278:  const PresburgerSpace &space = pieceA.domain.getSpace();
call    0 never executed
        -:  279:
        -:  280:  // We first create the set `result`, corresponding to the set where output
        -:  281:  // of pieceA is lexicographically larger/smaller than pieceB. This is done by
        -:  282:  // creating a PresburgerSet with the following constraints:
        -:  283:  //
        -:  284:  //    (outA[0] > outB[0]) U
        -:  285:  //    (outA[0] = outB[0], outA[1] > outA[1]) U
        -:  286:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] > outA[2]) U
        -:  287:  //    ...
        -:  288:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] > outB[n-1])
        -:  289:  //
        -:  290:  // where `n` is the number of outputs.
        -:  291:  // If `lexMin` is set, the complement inequality is used:
        -:  292:  //
        -:  293:  //    (outA[0] < outB[0]) U
        -:  294:  //    (outA[0] = outB[0], outA[1] < outA[1]) U
        -:  295:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] < outA[2]) U
        -:  296:  //    ...
        -:  297:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] < outB[n-1])
    #####:  298:  PresburgerSet result = PresburgerSet::getEmpty(compatibleSpace);
call    0 never executed
call    1 never executed
    #####:  299:  IntegerPolyhedron levelSet(
branch  0 never executed
branch  1 never executed
        -:  300:      /*numReservedInequalities=*/1,
        -:  301:      /*numReservedEqualities=*/pieceA.output.getNumOutputs(),
    #####:  302:      /*numReservedCols=*/space.getNumVars() + 1, space);
call    0 never executed
    #####:  303:  for (unsigned level = 0; level < pieceA.output.getNumOutputs(); ++level) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  304:
        -:  305:    // Create the expression `outA - outB` for this level.
    #####:  306:    SmallVector<MPInt, 8> subExpr = subtractExprs(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  307:        pieceA.output.getOutputExpr(level), pieceB.output.getOutputExpr(level));
        -:  308:
        -:  309:    if (lexMin) {
        -:  310:      // For lexMin, we add an upper bound of -1:
        -:  311:      //        outA - outB <= -1
        -:  312:      //        outA <= outB - 1
        -:  313:      //        outA < outB
        -:  314:      levelSet.addBound(IntegerPolyhedron::BoundType::UB, subExpr, MPInt(-1));
        -:  315:    } else {
        -:  316:      // For lexMax, we add a lower bound of 1:
        -:  317:      //        outA - outB >= 1
        -:  318:      //        outA > outB + 1
        -:  319:      //        outA > outB
    #####:  320:      levelSet.addBound(IntegerPolyhedron::BoundType::LB, subExpr, MPInt(1));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  321:    }
        -:  322:
        -:  323:    // Union the set with the result.
    #####:  324:    result.unionInPlace(levelSet);
call    0 never executed
        -:  325:    // There is only 1 inequality in `levelSet`, so the index is always 0.
    #####:  326:    levelSet.removeInequality(0);
call    0 never executed
call    1 never executed
        -:  327:    // Add equality `outA - outB == 0` for this level for next iteration.
    #####:  328:    levelSet.addEquality(subExpr);
call    0 never executed
call    1 never executed
        -:  329:  }
        -:  330:
        -:  331:  // We then intersect `result` with the domain of pieceA and pieceB, to only
        -:  332:  // tiebreak on the domain where both are defined.
    #####:  333:  result = result.intersect(pieceA.domain).intersect(pieceB.domain);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  334:
    #####:  335:  return result;
        -:  336:}
------------------
_Z11tiebreakLexILb1EEN4mlir10presburger13PresburgerSetERKNS1_12PWMAFunction5PieceES6_:
function _Z11tiebreakLexILb1EEN4mlir10presburger13PresburgerSetERKNS1_12PWMAFunction5PieceES6_ called 0 returned 0% blocks executed 0%
    #####:  269:static PresburgerSet tiebreakLex(const PWMAFunction::Piece &pieceA,
        -:  270:                                 const PWMAFunction::Piece &pieceB) {
        -:  271:  // TODO: Support local variables here.
    #####:  272:  assert(pieceA.output.getSpace().isCompatible(pieceB.output.getSpace()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  273:         "Pieces should be compatible");
    #####:  274:  assert(pieceA.domain.getSpace().getNumLocalVars() == 0 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  275:         "Local variables are not supported yet.");
        -:  276:
    #####:  277:  PresburgerSpace compatibleSpace = pieceA.domain.getSpace();
call    0 never executed
    #####:  278:  const PresburgerSpace &space = pieceA.domain.getSpace();
call    0 never executed
        -:  279:
        -:  280:  // We first create the set `result`, corresponding to the set where output
        -:  281:  // of pieceA is lexicographically larger/smaller than pieceB. This is done by
        -:  282:  // creating a PresburgerSet with the following constraints:
        -:  283:  //
        -:  284:  //    (outA[0] > outB[0]) U
        -:  285:  //    (outA[0] = outB[0], outA[1] > outA[1]) U
        -:  286:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] > outA[2]) U
        -:  287:  //    ...
        -:  288:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] > outB[n-1])
        -:  289:  //
        -:  290:  // where `n` is the number of outputs.
        -:  291:  // If `lexMin` is set, the complement inequality is used:
        -:  292:  //
        -:  293:  //    (outA[0] < outB[0]) U
        -:  294:  //    (outA[0] = outB[0], outA[1] < outA[1]) U
        -:  295:  //    (outA[0] = outB[0], outA[1] = outA[1], outA[2] < outA[2]) U
        -:  296:  //    ...
        -:  297:  //    (outA[0] = outB[0], ..., outA[n-2] = outB[n-2], outA[n-1] < outB[n-1])
    #####:  298:  PresburgerSet result = PresburgerSet::getEmpty(compatibleSpace);
call    0 never executed
call    1 never executed
    #####:  299:  IntegerPolyhedron levelSet(
branch  0 never executed
branch  1 never executed
        -:  300:      /*numReservedInequalities=*/1,
        -:  301:      /*numReservedEqualities=*/pieceA.output.getNumOutputs(),
    #####:  302:      /*numReservedCols=*/space.getNumVars() + 1, space);
call    0 never executed
    #####:  303:  for (unsigned level = 0; level < pieceA.output.getNumOutputs(); ++level) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  304:
        -:  305:    // Create the expression `outA - outB` for this level.
    #####:  306:    SmallVector<MPInt, 8> subExpr = subtractExprs(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  307:        pieceA.output.getOutputExpr(level), pieceB.output.getOutputExpr(level));
        -:  308:
        -:  309:    if (lexMin) {
        -:  310:      // For lexMin, we add an upper bound of -1:
        -:  311:      //        outA - outB <= -1
        -:  312:      //        outA <= outB - 1
        -:  313:      //        outA < outB
    #####:  314:      levelSet.addBound(IntegerPolyhedron::BoundType::UB, subExpr, MPInt(-1));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  315:    } else {
        -:  316:      // For lexMax, we add a lower bound of 1:
        -:  317:      //        outA - outB >= 1
        -:  318:      //        outA > outB + 1
        -:  319:      //        outA > outB
        -:  320:      levelSet.addBound(IntegerPolyhedron::BoundType::LB, subExpr, MPInt(1));
        -:  321:    }
        -:  322:
        -:  323:    // Union the set with the result.
    #####:  324:    result.unionInPlace(levelSet);
call    0 never executed
        -:  325:    // There is only 1 inequality in `levelSet`, so the index is always 0.
    #####:  326:    levelSet.removeInequality(0);
call    0 never executed
call    1 never executed
        -:  327:    // Add equality `outA - outB == 0` for this level for next iteration.
    #####:  328:    levelSet.addEquality(subExpr);
call    0 never executed
call    1 never executed
        -:  329:  }
        -:  330:
        -:  331:  // We then intersect `result` with the domain of pieceA and pieceB, to only
        -:  332:  // tiebreak on the domain where both are defined.
    #####:  333:  result = result.intersect(pieceA.domain).intersect(pieceB.domain);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  334:
    #####:  335:  return result;
        -:  336:}
------------------
        -:  337:
function _ZN4mlir10presburger12PWMAFunction11unionLexMinERKS1_ called 0 returned 0% blocks executed 0%
    #####:  338:PWMAFunction PWMAFunction::unionLexMin(const PWMAFunction &func) {
    #####:  339:  return unionFunction(func, tiebreakLex</*lexMin=*/true>);
call    0 never executed
        -:  340:}
        -:  341:
function _ZN4mlir10presburger12PWMAFunction11unionLexMaxERKS1_ called 0 returned 0% blocks executed 0%
    #####:  342:PWMAFunction PWMAFunction::unionLexMax(const PWMAFunction &func) {
    #####:  343:  return unionFunction(func, tiebreakLex</*lexMin=*/false>);
call    0 never executed
        -:  344:}
        -:  345:
function _ZN4mlir10presburger19MultiAffineFunction8subtractERKS1_ called 0 returned 0% blocks executed 0%
    #####:  346:void MultiAffineFunction::subtract(const MultiAffineFunction &other) {
    #####:  347:  assert(space.isCompatible(other.space) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  348:         "Spaces should be compatible for subtraction.");
        -:  349:
    #####:  350:  MultiAffineFunction copyOther = other;
call    0 never executed
call    1 never executed
    #####:  351:  mergeDivs(copyOther);
call    0 never executed
    #####:  352:  for (unsigned i = 0, e = getNumOutputs(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  353:    output.addToRow(i, copyOther.getOutputExpr(i), MPInt(-1));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  354:
        -:  355:  // Check consistency.
    #####:  356:  assertIsConsistent();
call    0 never executed
    #####:  357:}
        -:  358:
        -:  359:/// Adds division constraints corresponding to local variables, given a
        -:  360:/// relation and division representations of the local variables in the
        -:  361:/// relation.
function _ZL22addDivisionConstraintsRN4mlir10presburger15IntegerRelationERKNS0_12DivisionReprE called 0 returned 0% blocks executed 0%
    #####:  362:static void addDivisionConstraints(IntegerRelation &rel,
        -:  363:                                   const DivisionRepr &divs) {
    #####:  364:  assert(divs.hasAllReprs() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  365:         "All divisions in divs should have a representation");
    #####:  366:  assert(rel.getNumVars() == divs.getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  367:         "Relation and divs should have the same number of vars");
    #####:  368:  assert(rel.getNumLocalVars() == divs.getNumDivs() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  369:         "Relation and divs should have the same number of local vars");
        -:  370:
    #####:  371:  for (unsigned i = 0, e = divs.getNumDivs(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  372:    rel.addInequality(getDivUpperBound(divs.getDividend(i), divs.getDenom(i),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  373:                                       divs.getDivOffset() + i));
call    0 never executed
    #####:  374:    rel.addInequality(getDivLowerBound(divs.getDividend(i), divs.getDenom(i),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  375:                                       divs.getDivOffset() + i));
call    0 never executed
        -:  376:  }
    #####:  377:}
        -:  378:
function _ZNK4mlir10presburger19MultiAffineFunction13getAsRelationEv called 0 returned 0% blocks executed 0%
    #####:  379:IntegerRelation MultiAffineFunction::getAsRelation() const {
        -:  380:  // Create a relation corressponding to the input space plus the divisions
        -:  381:  // used in outputs.
    #####:  382:  IntegerRelation result(PresburgerSpace::getRelationSpace(
call    0 never executed
        -:  383:      space.getNumDomainVars(), 0, space.getNumSymbolVars(),
    #####:  384:      space.getNumLocalVars()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  385:  // Add division constraints corresponding to divisions used in outputs.
    #####:  386:  addDivisionConstraints(result, divs);
call    0 never executed
        -:  387:  // The outputs are represented as range variables in the relation. We add
        -:  388:  // range variables for the outputs.
    #####:  389:  result.insertVar(VarKind::Range, 0, getNumOutputs());
call    0 never executed
        -:  390:
        -:  391:  // Add equalities such that the i^th range variable is equal to the i^th
        -:  392:  // output expression.
    #####:  393:  SmallVector<MPInt, 8> eq(result.getNumCols());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  394:  for (unsigned i = 0, e = getNumOutputs(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -:  395:    // TODO: Add functions to get VarKind offsets in output in MAF and use them
        -:  396:    // here.
        -:  397:    // The output expression does not contain range variables, while the
        -:  398:    // equality does. So, we need to copy all variables and mark all range
        -:  399:    // variables as 0 in the equality.
    #####:  400:    ArrayRef<MPInt> expr = getOutputExpr(i);
call    0 never executed
        -:  401:    // Copy domain variables in `expr` to domain variables in `eq`.
    #####:  402:    std::copy(expr.begin(), expr.begin() + getNumDomainVars(), eq.begin());
call    0 never executed
        -:  403:    // Fill the range variables in `eq` as zero.
    #####:  404:    std::fill(eq.begin() + result.getVarKindOffset(VarKind::Range),
call    0 never executed
    #####:  405:              eq.begin() + result.getVarKindEnd(VarKind::Range), 0);
call    0 never executed
call    1 never executed
        -:  406:    // Copy remaining variables in `expr` to the remaining variables in `eq`.
    #####:  407:    std::copy(expr.begin() + getNumDomainVars(), expr.end(),
    #####:  408:              eq.begin() + result.getVarKindEnd(VarKind::Range));
call    0 never executed
call    1 never executed
        -:  409:
        -:  410:    // Set the i^th range var to -1 in `eq` to equate the output expression to
        -:  411:    // this range var.
    #####:  412:    eq[result.getVarKindOffset(VarKind::Range) + i] = -1;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  413:    // Add the equality `rangeVar_i = output[i]`.
    #####:  414:    result.addEquality(eq);
call    0 never executed
        -:  415:  }
        -:  416:
    #####:  417:  return result;
call    0 never executed
        -:  418:}
        -:  419:
function _ZN4mlir10presburger12PWMAFunction13removeOutputsEjj called 0 returned 0% blocks executed 0%
    #####:  420:void PWMAFunction::removeOutputs(unsigned start, unsigned end) {
    #####:  421:  space.removeVarRange(VarKind::Range, start, end);
call    0 never executed
    #####:  422:  for (Piece &piece : pieces)
branch  0 never executed
branch  1 never executed
    #####:  423:    piece.output.removeOutputs(start, end);
call    0 never executed
    #####:  424:}
        -:  425:
        -:  426:Optional<SmallVector<MPInt, 8>>
function _ZNK4mlir10presburger12PWMAFunction7valueAtEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  427:PWMAFunction::valueAt(ArrayRef<MPInt> point) const {
    #####:  428:  assert(point.size() == getNumDomainVars() + getNumSymbolVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  429:
    #####:  430:  for (const Piece &piece : pieces)
branch  0 never executed
branch  1 never executed
    #####:  431:    if (piece.domain.containsPoint(point))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  432:      return piece.output.valueAt(point);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  433:  return None;
        -:  434:}
