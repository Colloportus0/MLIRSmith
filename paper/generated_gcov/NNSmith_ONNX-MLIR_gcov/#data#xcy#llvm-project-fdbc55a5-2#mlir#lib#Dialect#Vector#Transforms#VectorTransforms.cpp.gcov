        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Vector/Transforms/VectorTransforms.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorTransforms.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorTransforms.cpp.gcda
        -:    0:Runs:128633
        -:    1://===- VectorTransforms.cpp - Conversion within the Vector dialect --------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements target-independent rewrites as 1->N patterns.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Vector/Transforms/VectorTransforms.h"
        -:   14:
        -:   15:#include <type_traits>
        -:   16:
        -:   17:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   18:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   19:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   20:#include "mlir/Dialect/Linalg/IR/Linalg.h"
        -:   21:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   22:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   23:#include "mlir/Dialect/Utils/IndexingUtils.h"
        -:   24:#include "mlir/Dialect/Utils/StructuredOpsUtils.h"
        -:   25:#include "mlir/Dialect/Vector/IR/VectorOps.h"
        -:   26:#include "mlir/Dialect/Vector/Utils/VectorUtils.h"
        -:   27:#include "mlir/IR/BuiltinAttributeInterfaces.h"
        -:   28:#include "mlir/IR/BuiltinTypes.h"
        -:   29:#include "mlir/IR/ImplicitLocOpBuilder.h"
        -:   30:#include "mlir/IR/Matchers.h"
        -:   31:#include "mlir/IR/PatternMatch.h"
        -:   32:#include "mlir/Interfaces/VectorInterfaces.h"
        -:   33:
        -:   34:#include "llvm/ADT/DenseSet.h"
        -:   35:#include "llvm/ADT/MapVector.h"
        -:   36:#include "llvm/ADT/STLExtras.h"
        -:   37:#include "llvm/Support/CommandLine.h"
        -:   38:#include "llvm/Support/Debug.h"
        -:   39:#include "llvm/Support/raw_ostream.h"
        -:   40:
        -:   41:#define DEBUG_TYPE "vector-to-vector"
        -:   42:
        -:   43:using namespace mlir;
        -:   44:using namespace mlir::vector;
        -:   45:
        -:   46:// Helper to find an index in an affine map.
function _ZL14getResultIndexN4mlir9AffineMapEl called 0 returned 0% blocks executed 0%
    #####:   47:static Optional<int64_t> getResultIndex(AffineMap map, int64_t index) {
    #####:   48:  for (int64_t i = 0, e = map.getNumResults(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   49:    int64_t idx = map.getDimPosition(i);
call    0 never executed
    #####:   50:    if (idx == index)
branch  0 never executed
branch  1 never executed
    #####:   51:      return i;
        -:   52:  }
    #####:   53:  return None;
        -:   54:}
        -:   55:
        -:   56:// Helper to construct iterator types with one index removed.
function _ZL10adjustIterN4mlir9ArrayAttrEl called 0 returned 0% blocks executed 0%
    #####:   57:static SmallVector<Attribute, 4> adjustIter(ArrayAttr iteratorTypes,
        -:   58:                                            int64_t index) {
    #####:   59:  SmallVector<Attribute, 4> results;
call    0 never executed
    #####:   60:  for (const auto &it : llvm::enumerate(iteratorTypes)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   61:    int64_t idx = it.index();
branch  0 never executed
branch  1 never executed
    #####:   62:    if (idx == index)
branch  0 never executed
branch  1 never executed
    #####:   63:      continue;
    #####:   64:    results.push_back(it.value());
call    0 never executed
        -:   65:  }
    #####:   66:  return results;
        -:   67:}
        -:   68:
        -:   69:// Helper to construct an affine map with one index removed.
function _ZL9adjustMapN4mlir9AffineMapElRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   70:static AffineMap adjustMap(AffineMap map, int64_t index,
        -:   71:                           PatternRewriter &rewriter) {
    #####:   72:  auto *ctx = rewriter.getContext();
call    0 never executed
    #####:   73:  SmallVector<AffineExpr, 4> results;
call    0 never executed
    #####:   74:  for (int64_t i = 0, e = map.getNumResults(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   75:    int64_t idx = map.getDimPosition(i);
call    0 never executed
    #####:   76:    if (idx == index)
branch  0 never executed
branch  1 never executed
    #####:   77:      continue;
        -:   78:    // Re-insert remaining indices, but renamed when occurring
        -:   79:    // after the removed index.
    #####:   80:    auto targetExpr = getAffineDimExpr(idx < index ? idx : idx - 1, ctx);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   81:    results.push_back(targetExpr);
call    0 never executed
        -:   82:  }
    #####:   83:  return AffineMap::get(map.getNumDims() - 1, 0, results, ctx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   84:}
        -:   85:
        -:   86:// Helper method to possibly drop a dimension in a load.
        -:   87:// TODO
function _ZL11reshapeLoadN4mlir8LocationENS_5ValueENS_10VectorTypeEllRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:static Value reshapeLoad(Location loc, Value val, VectorType type,
        -:   89:                         int64_t index, int64_t pos,
        -:   90:                         PatternRewriter &rewriter) {
    #####:   91:  if (index == -1)
branch  0 never executed
branch  1 never executed
    #####:   92:    return val;
    #####:   93:  Type lowType = VectorType::Builder(type).dropDim(0);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   94:  // At extraction dimension?
    #####:   95:  if (index == 0) {
branch  0 never executed
branch  1 never executed
    #####:   96:    auto posAttr = rewriter.getI64ArrayAttr(pos);
call    0 never executed
    #####:   97:    return rewriter.create<vector::ExtractOp>(loc, lowType, val, posAttr);
call    0 never executed
        -:   98:  }
        -:   99:  // Unroll leading dimensions.
    #####:  100:  VectorType vType = lowType.cast<VectorType>();
call    0 never executed
    #####:  101:  Type resType = VectorType::Builder(type).dropDim(index);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  102:  auto resVectorType = resType.cast<VectorType>();
call    0 never executed
    #####:  103:  Value result = rewriter.create<arith::ConstantOp>(
    #####:  104:      loc, resVectorType, rewriter.getZeroAttr(resVectorType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  105:  for (int64_t d = 0, e = resVectorType.getDimSize(0); d < e; d++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  106:    auto posAttr = rewriter.getI64ArrayAttr(d);
call    0 never executed
    #####:  107:    Value ext = rewriter.create<vector::ExtractOp>(loc, vType, val, posAttr);
call    0 never executed
call    1 never executed
    #####:  108:    Value load = reshapeLoad(loc, ext, vType, index - 1, pos, rewriter);
call    0 never executed
    #####:  109:    result = rewriter.create<vector::InsertOp>(loc, resVectorType, load, result,
    #####:  110:                                               posAttr);
call    0 never executed
        -:  111:  }
    #####:  112:  return result;
        -:  113:}
        -:  114:
        -:  115:// Helper method to possibly drop a dimension in a store.
        -:  116:// TODO
function _ZL12reshapeStoreN4mlir8LocationENS_5ValueES1_NS_10VectorTypeEllRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  117:static Value reshapeStore(Location loc, Value val, Value result,
        -:  118:                          VectorType type, int64_t index, int64_t pos,
        -:  119:                          PatternRewriter &rewriter) {
        -:  120:  // Unmodified?
    #####:  121:  if (index == -1)
branch  0 never executed
branch  1 never executed
    #####:  122:    return val;
        -:  123:  // At insertion dimension?
    #####:  124:  if (index == 0) {
branch  0 never executed
branch  1 never executed
    #####:  125:    auto posAttr = rewriter.getI64ArrayAttr(pos);
call    0 never executed
    #####:  126:    return rewriter.create<vector::InsertOp>(loc, type, val, result, posAttr);
call    0 never executed
        -:  127:  }
        -:  128:  // Unroll leading dimensions.
    #####:  129:  Type lowType = VectorType::Builder(type).dropDim(0);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  130:  VectorType vType = lowType.cast<VectorType>();
call    0 never executed
    #####:  131:  Type insType = VectorType::Builder(vType).dropDim(0);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  132:  for (int64_t d = 0, e = type.getDimSize(0); d < e; d++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  133:    auto posAttr = rewriter.getI64ArrayAttr(d);
call    0 never executed
    #####:  134:    Value ext = rewriter.create<vector::ExtractOp>(loc, vType, result, posAttr);
call    0 never executed
call    1 never executed
    #####:  135:    Value ins = rewriter.create<vector::ExtractOp>(loc, insType, val, posAttr);
call    0 never executed
call    1 never executed
    #####:  136:    Value sto = reshapeStore(loc, ins, ext, vType, index - 1, pos, rewriter);
call    0 never executed
    #####:  137:    result = rewriter.create<vector::InsertOp>(loc, type, sto, result, posAttr);
call    0 never executed
        -:  138:  }
    #####:  139:  return result;
        -:  140:}
        -:  141:
        -:  142:template <typename IntType>
function _Z13extractVectorIjEN4llvm11SmallVectorIT_Lj4EEEN4mlir9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####:  143:static SmallVector<IntType, 4> extractVector(ArrayAttr arrayAttr) {
    #####:  144:  return llvm::to_vector<4>(llvm::map_range(
call    0 never executed
    #####:  145:      arrayAttr.getAsRange<IntegerAttr>(),
call    0 never executed
    #####:  146:      [](IntegerAttr attr) { return static_cast<IntType>(attr.getInt()); }));
call    0 never executed
call    1 never executed
        -:  147:}
        -:  148:
        -:  149:/// Helper to create arithmetic operation associated with a kind of contraction.
function _ZL21createContractArithOpN4mlir8LocationENS_5ValueES1_S1_NS_6vector13CombiningKindERNS_15PatternRewriterEb called 0 returned 0% blocks executed 0%
    #####:  150:static Optional<Value> createContractArithOp(Location loc, Value x, Value y,
        -:  151:                                             Value acc,
        -:  152:                                             vector::CombiningKind kind,
        -:  153:                                             PatternRewriter &rewriter,
        -:  154:                                             bool isInt) {
    #####:  155:  using vector::CombiningKind;
    #####:  156:  Value mul;
    #####:  157:  if (isInt) {
branch  0 never executed
branch  1 never executed
    #####:  158:    if (kind == CombiningKind::MINF || kind == CombiningKind::MAXF)
branch  0 never executed
branch  1 never executed
        -:  159:      // Only valid for floating point types.
    #####:  160:      return Optional<Value>();
    #####:  161:    mul = rewriter.create<arith::MulIOp>(loc, x, y);
call    0 never executed
        -:  162:  } else {
        -:  163:    // Float case.
    #####:  164:    if (kind == CombiningKind::AND || kind == CombiningKind::MINUI ||
branch  0 never executed
branch  1 never executed
    #####:  165:        kind == CombiningKind::MINSI || kind == CombiningKind::MAXUI ||
branch  0 never executed
branch  1 never executed
    #####:  166:        kind == CombiningKind::MAXSI || kind == CombiningKind::OR ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  167:        kind == CombiningKind::XOR)
        -:  168:      // Only valid for integer types.
    #####:  169:      return Optional<Value>();
        -:  170:    // Special case for fused multiply-add.
    #####:  171:    if (acc && acc.getType().isa<VectorType>() && kind == CombiningKind::ADD) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  172:      return Optional<Value>(rewriter.create<vector::FMAOp>(loc, x, y, acc));
call    0 never executed
        -:  173:    }
    #####:  174:    mul = rewriter.create<arith::MulFOp>(loc, x, y);
call    0 never executed
        -:  175:  }
    #####:  176:  if (!acc)
branch  0 never executed
branch  1 never executed
    #####:  177:    return Optional<Value>(mul);
    #####:  178:  return makeArithReduction(rewriter, loc, kind, mul, acc);
call    0 never executed
        -:  179:}
        -:  180:
        -:  181:/// Return the positions of the reductions in the given map.
function _ZL17getReductionIndexN4mlir9AffineMapENS_9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####:  182:static SmallVector<int64_t> getReductionIndex(AffineMap map,
        -:  183:                                              ArrayAttr iteratorTypes) {
    #####:  184:  SmallVector<int64_t> dimsIdx;
call    0 never executed
    #####:  185:  for (unsigned i = 0, e = map.getNumResults(); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:    if (isReductionIterator(iteratorTypes[map.getDimPosition(i)]))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  187:      dimsIdx.push_back(i);
call    0 never executed
        -:  188:  }
    #####:  189:  return dimsIdx;
        -:  190:}
        -:  191:
        -:  192:/// Look for a given dimension in an affine map and return its position. Return
        -:  193:/// llvm::None if the dimension is not in the map results.
function _ZL14getDimPositionN4mlir9AffineMapEj called 0 returned 0% blocks executed 0%
    #####:  194:static llvm::Optional<unsigned> getDimPosition(AffineMap map, unsigned dim) {
    #####:  195:  for (unsigned i = 0, e = map.getNumResults(); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  196:    if (map.getDimPosition(i) == dim)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  197:      return i;
        -:  198:  }
    #####:  199:  return llvm::None;
        -:  200:}
        -:  201:
        -:  202:namespace {
        -:  203:
        -:  204:/// ShapeCastOpFolder folds cancelling ShapeCastOps away.
        -:  205://
        -:  206:// Example:
        -:  207://
        -:  208://  The following MLIR with cancelling ShapeCastOps:
        -:  209://
        -:  210://   %0 = source : vector<5x4x2xf32>
        -:  211://   %1 = shape_cast %0 : vector<5x4x2xf32> to vector<20x2xf32>
        -:  212://   %2 = shape_cast %1 : vector<20x2xf32> to vector<5x4x2xf32>
        -:  213://   %3 = user %2 : vector<5x4x2xf32>
        -:  214://
        -:  215://  Should canonicalize to the following:
        -:  216://
        -:  217://   %0 = source : vector<5x4x2xf32>
        -:  218://   %1 = user %0 : vector<5x4x2xf32>
        -:  219://
        -:  220:struct ShapeCastOpFolder : public OpRewritePattern<vector::ShapeCastOp> {
        -:  221:  using OpRewritePattern::OpRewritePattern;
        -:  222:
function _ZNK12_GLOBAL__N_117ShapeCastOpFolder15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  223:  LogicalResult matchAndRewrite(vector::ShapeCastOp shapeCastOp,
        -:  224:                                PatternRewriter &rewriter) const override {
        -:  225:    // Check if 'shapeCastOp' has vector source/result type.
    #####:  226:    auto sourceVectorType =
    #####:  227:        shapeCastOp.getSource().getType().dyn_cast_or_null<VectorType>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  228:    auto resultVectorType =
    #####:  229:        shapeCastOp.getResult().getType().dyn_cast_or_null<VectorType>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  230:    if (!sourceVectorType || !resultVectorType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  231:      return failure();
        -:  232:
        -:  233:    // Check if shape cast op source operand is also a shape cast op.
    #####:  234:    auto sourceShapeCastOp = dyn_cast_or_null<vector::ShapeCastOp>(
    #####:  235:        shapeCastOp.getSource().getDefiningOp());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  236:    if (!sourceShapeCastOp)
branch  0 never executed
branch  1 never executed
    #####:  237:      return failure();
    #####:  238:    auto operandSourceVectorType =
    #####:  239:        sourceShapeCastOp.getSource().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  240:    auto operandResultVectorType = sourceShapeCastOp.getType();
call    0 never executed
        -:  241:
        -:  242:    // Check if shape cast operations invert each other.
    #####:  243:    if (operandSourceVectorType != resultVectorType ||
branch  0 never executed
branch  1 never executed
    #####:  244:        operandResultVectorType != sourceVectorType)
branch  0 never executed
branch  1 never executed
    #####:  245:      return failure();
        -:  246:
    #####:  247:    rewriter.replaceOp(shapeCastOp, sourceShapeCastOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  248:    return success();
        -:  249:  }
        -:  250:};
        -:  251:
        -:  252:/// Progressive lowering of BroadcastOp.
        -:  253:class BroadcastOpLowering : public OpRewritePattern<vector::BroadcastOp> {
        -:  254:public:
        -:  255:  using OpRewritePattern::OpRewritePattern;
        -:  256:
function _ZNK12_GLOBAL__N_119BroadcastOpLowering15matchAndRewriteEN4mlir6vector11BroadcastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  257:  LogicalResult matchAndRewrite(vector::BroadcastOp op,
        -:  258:                                PatternRewriter &rewriter) const override {
    #####:  259:    auto loc = op.getLoc();
call    0 never executed
    #####:  260:    VectorType dstType = op.getVectorType();
call    0 never executed
    #####:  261:    VectorType srcType = op.getSourceType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####:  262:    Type eltType = dstType.getElementType();
call    0 never executed
        -:  263:
        -:  264:    // Scalar to any vector can use splat.
    #####:  265:    if (!srcType) {
branch  0 never executed
branch  1 never executed
    #####:  266:      rewriter.replaceOpWithNewOp<vector::SplatOp>(op, dstType, op.getSource());
call    0 never executed
call    1 never executed
    #####:  267:      return success();
        -:  268:    }
        -:  269:
        -:  270:    // Determine rank of source and destination.
    #####:  271:    int64_t srcRank = srcType.getRank();
call    0 never executed
    #####:  272:    int64_t dstRank = dstType.getRank();
call    0 never executed
        -:  273:
        -:  274:    // Stretching scalar inside vector (e.g. vector<1xf32>) can use splat.
    #####:  275:    if (srcRank <= 1 && dstRank == 1) {
branch  0 never executed
branch  1 never executed
    #####:  276:      Value ext;
    #####:  277:      if (srcRank == 0)
branch  0 never executed
branch  1 never executed
    #####:  278:        ext = rewriter.create<vector::ExtractElementOp>(loc, op.getSource());
call    0 never executed
call    1 never executed
        -:  279:      else
    #####:  280:        ext = rewriter.create<vector::ExtractOp>(loc, op.getSource(), 0);
call    0 never executed
call    1 never executed
    #####:  281:      rewriter.replaceOpWithNewOp<vector::SplatOp>(op, dstType, ext);
call    0 never executed
    #####:  282:      return success();
        -:  283:    }
        -:  284:
        -:  285:    // Duplicate this rank.
        -:  286:    // For example:
        -:  287:    //   %x = broadcast %y  : k-D to n-D, k < n
        -:  288:    // becomes:
        -:  289:    //   %b = broadcast %y  : k-D to (n-1)-D
        -:  290:    //   %x = [%b,%b,%b,%b] : n-D
        -:  291:    // becomes:
        -:  292:    //   %b = [%y,%y]       : (n-1)-D
        -:  293:    //   %x = [%b,%b,%b,%b] : n-D
    #####:  294:    if (srcRank < dstRank) {
branch  0 never executed
branch  1 never executed
        -:  295:      // Duplication.
    #####:  296:      VectorType resType =
    #####:  297:          VectorType::get(dstType.getShape().drop_front(), eltType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  298:      Value bcst =
    #####:  299:          rewriter.create<vector::BroadcastOp>(loc, resType, op.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  300:      Value result = rewriter.create<arith::ConstantOp>(
    #####:  301:          loc, dstType, rewriter.getZeroAttr(dstType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  302:      for (int64_t d = 0, dim = dstType.getDimSize(0); d < dim; ++d)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  303:        result = rewriter.create<vector::InsertOp>(loc, bcst, result, d);
call    0 never executed
    #####:  304:      rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  305:      return success();
        -:  306:    }
        -:  307:
        -:  308:    // Find non-matching dimension, if any.
    #####:  309:    assert(srcRank == dstRank);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  310:    int64_t m = -1;
    #####:  311:    for (int64_t r = 0; r < dstRank; r++)
branch  0 never executed
branch  1 never executed
    #####:  312:      if (srcType.getDimSize(r) != dstType.getDimSize(r)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  313:        m = r;
        -:  314:        break;
        -:  315:      }
        -:  316:
        -:  317:    // All trailing dimensions are the same. Simply pass through.
    #####:  318:    if (m == -1) {
branch  0 never executed
branch  1 never executed
    #####:  319:      rewriter.replaceOp(op, op.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  320:      return success();
        -:  321:    }
        -:  322:
        -:  323:    // Any non-matching dimension forces a stretch along this rank.
        -:  324:    // For example:
        -:  325:    //   %x = broadcast %y : vector<4x1x2xf32> to vector<4x2x2xf32>
        -:  326:    // becomes:
        -:  327:    //   %a = broadcast %y[0] : vector<1x2xf32> to vector<2x2xf32>
        -:  328:    //   %b = broadcast %y[1] : vector<1x2xf32> to vector<2x2xf32>
        -:  329:    //   %c = broadcast %y[2] : vector<1x2xf32> to vector<2x2xf32>
        -:  330:    //   %d = broadcast %y[3] : vector<1x2xf32> to vector<2x2xf32>
        -:  331:    //   %x = [%a,%b,%c,%d]
        -:  332:    // becomes:
        -:  333:    //   %u = broadcast %y[0][0] : vector<2xf32> to vector <2x2xf32>
        -:  334:    //   %v = broadcast %y[1][0] : vector<2xf32> to vector <2x2xf32>
        -:  335:    //   %a = [%u, %v]
        -:  336:    //   ..
        -:  337:    //   %x = [%a,%b,%c,%d]
    #####:  338:    VectorType resType =
    #####:  339:        VectorType::get(dstType.getShape().drop_front(), eltType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  340:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  341:        loc, dstType, rewriter.getZeroAttr(dstType));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  342:    if (m == 0) {
branch  0 never executed
branch  1 never executed
        -:  343:      // Stetch at start.
    #####:  344:      Value ext = rewriter.create<vector::ExtractOp>(loc, op.getSource(), 0);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  345:      Value bcst = rewriter.create<vector::BroadcastOp>(loc, resType, ext);
call    0 never executed
call    1 never executed
    #####:  346:      for (int64_t d = 0, dim = dstType.getDimSize(0); d < dim; ++d)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:        result = rewriter.create<vector::InsertOp>(loc, bcst, result, d);
call    0 never executed
        -:  348:    } else {
        -:  349:      // Stetch not at start.
    #####:  350:      for (int64_t d = 0, dim = dstType.getDimSize(0); d < dim; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  351:        Value ext = rewriter.create<vector::ExtractOp>(loc, op.getSource(), d);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  352:        Value bcst = rewriter.create<vector::BroadcastOp>(loc, resType, ext);
call    0 never executed
call    1 never executed
    #####:  353:        result = rewriter.create<vector::InsertOp>(loc, bcst, result, d);
call    0 never executed
        -:  354:      }
        -:  355:    }
    #####:  356:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  357:    return success();
        -:  358:  }
        -:  359:};
        -:  360:
        -:  361:/// Given a 'transpose' pattern, prune the rightmost dimensions that are not
        -:  362:/// transposed.
function _ZN12_GLOBAL__N_122pruneNonTransposedDimsEN4llvm8ArrayRefIlEERNS0_15SmallVectorImplIlEE called 0 returned 0% blocks executed 0%
    #####:  363:void pruneNonTransposedDims(ArrayRef<int64_t> transpose,
        -:  364:                            SmallVectorImpl<int64_t> &result) {
    #####:  365:  size_t numTransposedDims = transpose.size();
    #####:  366:  for (size_t transpDim : llvm::reverse(transpose)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  367:    if (transpDim != numTransposedDims - 1)
branch  0 never executed
branch  1 never executed
        -:  368:      break;
    #####:  369:    numTransposedDims--;
        -:  370:  }
        -:  371:
    #####:  372:  result.append(transpose.begin(), transpose.begin() + numTransposedDims);
call    0 never executed
    #####:  373:}
        -:  374:
        -:  375:/// Progressive lowering of TransposeOp.
        -:  376:/// One:
        -:  377:///   %x = vector.transpose %y, [1, 0]
        -:  378:/// is replaced by:
        -:  379:///   %z = arith.constant dense<0.000000e+00>
        -:  380:///   %0 = vector.extract %y[0, 0]
        -:  381:///   %1 = vector.insert %0, %z [0, 0]
        -:  382:///   ..
        -:  383:///   %x = vector.insert .., .. [.., ..]
        -:  384:class TransposeOpLowering : public OpRewritePattern<vector::TransposeOp> {
        -:  385:public:
        -:  386:  using OpRewritePattern::OpRewritePattern;
        -:  387:
function _ZN12_GLOBAL__N_119TransposeOpLoweringC2EN4mlir6vector23VectorTransformsOptionsEPNS1_11MLIRContextENS1_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034:  388:  TransposeOpLowering(vector::VectorTransformsOptions vectorTransformOptions,
        -:  389:                      MLIRContext *context, PatternBenefit benefit = 1)
     1034:  390:      : OpRewritePattern<vector::TransposeOp>(context, benefit),
     1034:  391:        vectorTransformOptions(vectorTransformOptions) {}
call    0 returned 100%
        -:  392:
function _ZNK12_GLOBAL__N_119TransposeOpLowering15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  393:  LogicalResult matchAndRewrite(vector::TransposeOp op,
        -:  394:                                PatternRewriter &rewriter) const override {
    #####:  395:    auto loc = op.getLoc();
call    0 never executed
        -:  396:
    #####:  397:    Value input = op.getVector();
call    0 never executed
    #####:  398:    VectorType inputType = op.getVectorType();
call    0 never executed
    #####:  399:    VectorType resType = op.getResultType();
call    0 never executed
        -:  400:
        -:  401:    // Set up convenience transposition table.
    #####:  402:    SmallVector<int64_t, 4> transp;
call    0 never executed
    #####:  403:    for (auto attr : op.getTransp())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  404:      transp.push_back(attr.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  405:
    #####:  406:    if (vectorTransformOptions.vectorTransposeLowering ==
    #####:  407:            vector::VectorTransposeLowering::Shuffle &&
    #####:  408:        resType.getRank() == 2 && transp[0] == 1 && transp[1] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  409:      return rewriter.notifyMatchFailure(
    #####:  410:          op, "Options specifies lowering to shuffle");
call    0 never executed
        -:  411:
        -:  412:    // Handle a true 2-D matrix transpose differently when requested.
    #####:  413:    if (vectorTransformOptions.vectorTransposeLowering ==
    #####:  414:            vector::VectorTransposeLowering::Flat &&
    #####:  415:        resType.getRank() == 2 && transp[0] == 1 && transp[1] == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  416:      Type flattenedType =
    #####:  417:          VectorType::get(resType.getNumElements(), resType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  418:      auto matrix =
    #####:  419:          rewriter.create<vector::ShapeCastOp>(loc, flattenedType, input);
call    0 never executed
    #####:  420:      auto rows = rewriter.getI32IntegerAttr(resType.getShape()[0]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  421:      auto columns = rewriter.getI32IntegerAttr(resType.getShape()[1]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  422:      Value trans = rewriter.create<vector::FlatTransposeOp>(
    #####:  423:          loc, flattenedType, matrix, rows, columns);
call    0 never executed
call    1 never executed
    #####:  424:      rewriter.replaceOpWithNewOp<vector::ShapeCastOp>(op, resType, trans);
call    0 never executed
    #####:  425:      return success();
        -:  426:    }
        -:  427:
        -:  428:    // Generate unrolled extract/insert ops. We do not unroll the rightmost
        -:  429:    // (i.e., highest-order) dimensions that are not transposed and leave them
        -:  430:    // in vector form to improve performance. Therefore, we prune those
        -:  431:    // dimensions from the shape/transpose data structures used to generate the
        -:  432:    // extract/insert ops.
    #####:  433:    SmallVector<int64_t, 4> prunedTransp;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  434:    pruneNonTransposedDims(transp, prunedTransp);
call    0 never executed
    #####:  435:    size_t numPrunedDims = transp.size() - prunedTransp.size();
call    0 never executed
    #####:  436:    auto prunedInShape = inputType.getShape().drop_back(numPrunedDims);
call    0 never executed
call    1 never executed
    #####:  437:    SmallVector<int64_t, 4> ones(prunedInShape.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  438:    auto prunedInStrides = computeStrides(prunedInShape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  439:
        -:  440:    // Generates the extract/insert operations for every scalar/vector element
        -:  441:    // of the leftmost transposed dimensions. We traverse every transpose
        -:  442:    // element using a linearized index that we delinearize to generate the
        -:  443:    // appropriate indices for the extract/insert operations.
    #####:  444:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  445:        loc, resType, rewriter.getZeroAttr(resType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  446:    int64_t numTransposedElements = ShapedType::getNumElements(prunedInShape);
        -:  447:
    #####:  448:    for (int64_t linearIdx = 0; linearIdx < numTransposedElements;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  449:         ++linearIdx) {
    #####:  450:      auto extractIdxs = delinearize(prunedInStrides, linearIdx);
call    0 never executed
    #####:  451:      SmallVector<int64_t, 4> insertIdxs(extractIdxs);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  452:      applyPermutationToVector(insertIdxs, prunedTransp);
call    0 never executed
    #####:  453:      Value extractOp =
    #####:  454:          rewriter.create<vector::ExtractOp>(loc, input, extractIdxs);
call    0 never executed
call    1 never executed
    #####:  455:      result =
    #####:  456:          rewriter.create<vector::InsertOp>(loc, extractOp, result, insertIdxs);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  457:    }
        -:  458:
    #####:  459:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  460:    return success();
branch  0 never executed
branch  1 never executed
        -:  461:  }
        -:  462:
        -:  463:private:
        -:  464:  /// Options to control the vector patterns.
        -:  465:  vector::VectorTransformsOptions vectorTransformOptions;
        -:  466:};
        -:  467:
        -:  468:/// Rewrite a 2-D vector.transpose as a sequence of:
        -:  469:///   vector.shape_cast 2D -> 1D
        -:  470:///   vector.shuffle
        -:  471:///   vector.shape_cast 1D -> 2D
        -:  472:class TransposeOp2DToShuffleLowering
        -:  473:    : public OpRewritePattern<vector::TransposeOp> {
        -:  474:public:
        -:  475:  using OpRewritePattern::OpRewritePattern;
        -:  476:
function _ZN12_GLOBAL__N_130TransposeOp2DToShuffleLoweringC2EN4mlir6vector23VectorTransformsOptionsEPNS1_11MLIRContextENS1_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034:  477:  TransposeOp2DToShuffleLowering(
        -:  478:      vector::VectorTransformsOptions vectorTransformOptions,
        -:  479:      MLIRContext *context, PatternBenefit benefit = 1)
     1034:  480:      : OpRewritePattern<vector::TransposeOp>(context, benefit),
     1034:  481:        vectorTransformOptions(vectorTransformOptions) {}
call    0 returned 100%
        -:  482:
function _ZNK12_GLOBAL__N_130TransposeOp2DToShuffleLowering15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  483:  LogicalResult matchAndRewrite(vector::TransposeOp op,
        -:  484:                                PatternRewriter &rewriter) const override {
    #####:  485:    auto loc = op.getLoc();
call    0 never executed
        -:  486:
    #####:  487:    VectorType srcType = op.getVectorType();
call    0 never executed
    #####:  488:    if (srcType.getRank() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  489:      return rewriter.notifyMatchFailure(op, "Not a 2D transpose");
call    0 never executed
        -:  490:
    #####:  491:    SmallVector<int64_t, 4> transp;
call    0 never executed
    #####:  492:    for (auto attr : op.getTransp())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  493:      transp.push_back(attr.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  494:    if (transp[0] != 1 && transp[1] != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  495:      return rewriter.notifyMatchFailure(op, "Not a 2D transpose permutation");
call    0 never executed
        -:  496:
    #####:  497:    if (vectorTransformOptions.vectorTransposeLowering !=
branch  0 never executed
branch  1 never executed
        -:  498:        VectorTransposeLowering::Shuffle)
    #####:  499:      return rewriter.notifyMatchFailure(op, "Options do not ask for Shuffle");
call    0 never executed
        -:  500:
    #####:  501:    int64_t m = srcType.getShape().front(), n = srcType.getShape().back();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  502:    Value casted = rewriter.create<vector::ShapeCastOp>(
    #####:  503:        loc, VectorType::get({m * n}, srcType.getElementType()),
call    0 never executed
call    1 never executed
    #####:  504:        op.getVector());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  505:    SmallVector<int64_t> mask;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  506:    mask.reserve(m * n);
branch  0 never executed
branch  1 never executed
    #####:  507:    for (int64_t j = 0; j < n; ++j)
branch  0 never executed
branch  1 never executed
    #####:  508:      for (int64_t i = 0; i < m; ++i)
branch  0 never executed
branch  1 never executed
    #####:  509:        mask.push_back(i * n + j);
call    0 never executed
        -:  510:
    #####:  511:    Value shuffled =
    #####:  512:        rewriter.create<vector::ShuffleOp>(loc, casted, casted, mask);
call    0 never executed
call    1 never executed
    #####:  513:    rewriter.replaceOpWithNewOp<vector::ShapeCastOp>(op, op.getResultType(),
    #####:  514:                                                     shuffled);
call    0 never executed
call    1 never executed
        -:  515:
    #####:  516:    return success();
branch  0 never executed
branch  1 never executed
        -:  517:  }
        -:  518:
        -:  519:private:
        -:  520:  /// Options to control the vector patterns.
        -:  521:  vector::VectorTransformsOptions vectorTransformOptions;
        -:  522:};
        -:  523:
        -:  524:/// Progressive lowering of OuterProductOp.
        -:  525:/// One:
        -:  526:///   %x = vector.outerproduct %lhs, %rhs, %acc
        -:  527:/// is replaced by:
        -:  528:///   %z = zero-result
        -:  529:///   %0 = vector.extract %lhs[0]
        -:  530:///   %1 = vector.broadcast %0
        -:  531:///   %2 = vector.extract %acc[0]
        -:  532:///   %3 = vector.fma %1, %rhs, %2
        -:  533:///   %4 = vector.insert %3, %z[0]
        -:  534:///   ..
        -:  535:///   %x = vector.insert %.., %..[N-1]
        -:  536:///
        -:  537:class OuterProductOpLowering : public OpRewritePattern<vector::OuterProductOp> {
        -:  538:public:
        -:  539:  using OpRewritePattern::OpRewritePattern;
        -:  540:
function _ZNK12_GLOBAL__N_122OuterProductOpLowering15matchAndRewriteEN4mlir6vector14OuterProductOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  541:  LogicalResult matchAndRewrite(vector::OuterProductOp op,
        -:  542:                                PatternRewriter &rewriter) const override {
    #####:  543:    auto loc = op.getLoc();
call    0 never executed
        -:  544:
    #####:  545:    VectorType lhsType = op.getOperandVectorTypeLHS();
call    0 never executed
    #####:  546:    VectorType rhsType = op.getOperandTypeRHS().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####:  547:    VectorType resType = op.getVectorType();
call    0 never executed
    #####:  548:    Type eltType = resType.getElementType();
call    0 never executed
    #####:  549:    bool isInt = eltType.isa<IntegerType, IndexType>();
call    0 never executed
    #####:  550:    Value acc = (op.getAcc().empty()) ? nullptr : op.getAcc()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  551:    vector::CombiningKind kind = op.getKind();
call    0 never executed
        -:  552:
    #####:  553:    if (!rhsType) {
branch  0 never executed
branch  1 never executed
        -:  554:      // Special case: AXPY operation.
    #####:  555:      Value b = rewriter.create<vector::BroadcastOp>(loc, lhsType, op.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  556:      Optional<Value> mult = createContractArithOp(loc, op.getLhs(), b, acc,
    #####:  557:                                                   kind, rewriter, isInt);
call    0 never executed
call    1 never executed
    #####:  558:      if (!mult.has_value())
branch  0 never executed
branch  1 never executed
    #####:  559:        return failure();
    #####:  560:      rewriter.replaceOp(op, mult.value());
call    0 never executed
call    1 never executed
    #####:  561:      return success();
        -:  562:    }
        -:  563:
    #####:  564:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  565:        loc, resType, rewriter.getZeroAttr(resType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  566:    for (int64_t d = 0, e = resType.getDimSize(0); d < e; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  567:      auto pos = rewriter.getI64ArrayAttr(d);
call    0 never executed
    #####:  568:      Value x =
    #####:  569:          rewriter.create<vector::ExtractOp>(loc, eltType, op.getLhs(), pos);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  570:      Value a = rewriter.create<vector::BroadcastOp>(loc, rhsType, x);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  571:      Value r = nullptr;
    #####:  572:      if (acc)
branch  0 never executed
branch  1 never executed
    #####:  573:        r = rewriter.create<vector::ExtractOp>(loc, rhsType, acc, pos);
call    0 never executed
    #####:  574:      Optional<Value> m =
    #####:  575:          createContractArithOp(loc, a, op.getRhs(), r, kind, rewriter, isInt);
call    0 never executed
call    1 never executed
    #####:  576:      if (!m.has_value())
branch  0 never executed
branch  1 never executed
    #####:  577:        return failure();
    #####:  578:      result = rewriter.create<vector::InsertOp>(loc, resType, m.value(),
    #####:  579:                                                 result, pos);
call    0 never executed
        -:  580:    }
    #####:  581:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  582:    return success();
        -:  583:  }
        -:  584:};
        -:  585:
        -:  586:/// Lower vector.contract with all size one reduction dimensions to
        -:  587:/// elementwise ops when possible.
        -:  588:struct ContractOpToElementwise
        -:  589:    : public OpRewritePattern<vector::ContractionOp> {
        -:  590:  using OpRewritePattern::OpRewritePattern;
        -:  591:  using FilterConstraintType =
        -:  592:      std::function<LogicalResult(vector::ContractionOp op)>;
function _ZN12_GLOBAL__N_123ContractOpToElementwise13defaultFilterEN4mlir6vector13ContractionOpE called 0 returned 0% blocks executed 0%
    #####:  593:  static LogicalResult defaultFilter(vector::ContractionOp op) {
    #####:  594:    return success();
        -:  595:  }
        -:  596:  ContractOpToElementwise(
        -:  597:      vector::VectorTransformsOptions vectorTransformOptions,
        -:  598:      MLIRContext *context, PatternBenefit benefit = 1,
        -:  599:      const FilterConstraintType &constraint = defaultFilter)
        -:  600:      : OpRewritePattern<vector::ContractionOp>(context, benefit),
        -:  601:        vectorTransformOptions(vectorTransformOptions), filter(defaultFilter) {}
        -:  602:
function _ZNK12_GLOBAL__N_123ContractOpToElementwise15matchAndRewriteEN4mlir6vector13ContractionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  603:  LogicalResult matchAndRewrite(vector::ContractionOp contractOp,
        -:  604:                                PatternRewriter &rewriter) const override {
        -:  605:    // TODO: implement masks
    #####:  606:    if (!contractOp.getMasks().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  607:      return failure();
        -:  608:
    #####:  609:    if (failed(filter(contractOp)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  610:      return failure();
        -:  611:
    #####:  612:    if (vectorTransformOptions.vectorContractLowering !=
branch  0 never executed
branch  1 never executed
        -:  613:        vector::VectorContractLowering::ParallelArith)
    #####:  614:      return failure();
    #####:  615:    ArrayRef<int64_t> lhsShape = contractOp.getLhsType().getShape();
call    0 never executed
call    1 never executed
    #####:  616:    ArrayRef<int64_t> rhsShape = contractOp.getRhsType().getShape();
call    0 never executed
call    1 never executed
    #####:  617:    AffineMap lhsMap = contractOp.getIndexingMapsArray()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  618:    AffineMap rhsMap = contractOp.getIndexingMapsArray()[1];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  619:    SmallVector<int64_t> lhsReductionDims =
    #####:  620:        getReductionIndex(lhsMap, contractOp.getIteratorTypes());
call    0 never executed
call    1 never executed
    #####:  621:    SmallVector<int64_t> rhsReductionDims =
    #####:  622:        getReductionIndex(rhsMap, contractOp.getIteratorTypes());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  623:    // All the reduction dimensions must be a size 1.
    #####:  624:    for (int64_t dim : lhsReductionDims) {
branch  0 never executed
branch  1 never executed
    #####:  625:      if (lhsShape[dim] != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  626:        return failure();
        -:  627:    }
    #####:  628:    for (int64_t dim : rhsReductionDims) {
branch  0 never executed
branch  1 never executed
    #####:  629:      if (rhsShape[dim] != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  630:        return failure();
        -:  631:    }
    #####:  632:    AffineMap accMap = contractOp.getIndexingMapsArray()[2];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  633:    unsigned numParallelDims = accMap.getNumResults();
call    0 never executed
    #####:  634:    unsigned numLhsDimToBroadcast =
    #####:  635:        numParallelDims - (lhsMap.getNumResults() - lhsReductionDims.size());
call    0 never executed
    #####:  636:    unsigned numRhsDimToBroadcast =
    #####:  637:        numParallelDims - (rhsMap.getNumResults() - rhsReductionDims.size());
call    0 never executed
    #####:  638:    SmallVector<int64_t> lhsDims;
branch  0 never executed
branch  1 never executed
    #####:  639:    SmallVector<int64_t> lhsTranspose;
branch  0 never executed
branch  1 never executed
    #####:  640:    SmallVector<int64_t> rhsDims;
branch  0 never executed
branch  1 never executed
    #####:  641:    SmallVector<int64_t> rhsTranspose;
branch  0 never executed
branch  1 never executed
    #####:  642:    for (int64_t dim : lhsReductionDims)
branch  0 never executed
branch  1 never executed
    #####:  643:      lhsTranspose.push_back(numLhsDimToBroadcast + dim);
call    0 never executed
    #####:  644:    for (int64_t dim : rhsReductionDims)
branch  0 never executed
branch  1 never executed
    #####:  645:      rhsTranspose.push_back(numRhsDimToBroadcast + dim);
call    0 never executed
        -:  646:    // Loop through the parallel dimensions to calculate the dimensions to
        -:  647:    // broadcast and to permute in order to extract only parallel dimensions.
    #####:  648:    for (unsigned i = 0; i < numParallelDims; i++) {
branch  0 never executed
branch  1 never executed
    #####:  649:      llvm::Optional<unsigned> lhsDim =
    #####:  650:          getDimPosition(lhsMap, accMap.getDimPosition(i));
call    0 never executed
call    1 never executed
    #####:  651:      if (lhsDim) {
branch  0 never executed
branch  1 never executed
    #####:  652:        lhsTranspose.push_back(numLhsDimToBroadcast + *lhsDim);
call    0 never executed
        -:  653:      } else {
        -:  654:        // If the parallel dimension doesn't exist we will have to broadcast it.
    #####:  655:        lhsDims.push_back(
call    0 never executed
call    1 never executed
    #####:  656:            contractOp.getResultType().cast<VectorType>().getDimSize(i));
call    0 never executed
call    1 never executed
    #####:  657:        lhsTranspose.push_back(lhsDims.size() - 1);
call    0 never executed
        -:  658:      }
    #####:  659:      llvm::Optional<unsigned> rhsDim =
    #####:  660:          getDimPosition(rhsMap, accMap.getDimPosition(i));
call    0 never executed
call    1 never executed
    #####:  661:      if (rhsDim) {
branch  0 never executed
branch  1 never executed
    #####:  662:        rhsTranspose.push_back(numRhsDimToBroadcast + *rhsDim);
call    0 never executed
        -:  663:      } else {
        -:  664:        // If the parallel dimension doesn't exist we will have to broadcast it.
    #####:  665:        rhsDims.push_back(
call    0 never executed
call    1 never executed
    #####:  666:            contractOp.getResultType().cast<VectorType>().getDimSize(i));
call    0 never executed
call    1 never executed
    #####:  667:        rhsTranspose.push_back(rhsDims.size() - 1);
call    0 never executed
        -:  668:      }
        -:  669:    }
    #####:  670:    Value newLhs = contractOp.getLhs();
call    0 never executed
    #####:  671:    Value newRhs = contractOp.getRhs();
call    0 never executed
    #####:  672:    Location loc = contractOp.getLoc();
branch  0 never executed
branch  1 never executed
    #####:  673:    if (!lhsDims.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  674:      lhsDims.append(lhsShape.begin(), lhsShape.end());
call    0 never executed
    #####:  675:      auto expandedType =
    #####:  676:          VectorType::get(lhsDims, contractOp.getLhsType().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  677:      newLhs = rewriter.create<vector::BroadcastOp>(loc, expandedType, newLhs);
call    0 never executed
        -:  678:    }
    #####:  679:    if (!rhsDims.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  680:      rhsDims.append(rhsShape.begin(), rhsShape.end());
call    0 never executed
    #####:  681:      auto expandedType =
    #####:  682:          VectorType::get(rhsDims, contractOp.getRhsType().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  683:      newRhs = rewriter.create<vector::BroadcastOp>(loc, expandedType, newRhs);
call    0 never executed
        -:  684:    }
    #####:  685:    bool isInt = contractOp.getLhsType().getElementType().isIntOrIndex();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  686:    newLhs = rewriter.create<vector::TransposeOp>(loc, newLhs, lhsTranspose);
call    0 never executed
call    1 never executed
    #####:  687:    newRhs = rewriter.create<vector::TransposeOp>(loc, newRhs, rhsTranspose);
call    0 never executed
call    1 never executed
    #####:  688:    SmallVector<int64_t, 4> lhsOffsets(lhsReductionDims.size(), 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  689:    SmallVector<int64_t, 4> rhsOffsets(rhsReductionDims.size(), 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  690:    newLhs = rewriter.create<vector::ExtractOp>(
    #####:  691:        loc, newLhs, rewriter.getI64ArrayAttr(lhsOffsets));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  692:    newRhs = rewriter.create<vector::ExtractOp>(
    #####:  693:        loc, newRhs, rewriter.getI64ArrayAttr(rhsOffsets));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  694:    Optional<Value> result =
        -:  695:        createContractArithOp(loc, newLhs, newRhs, contractOp.getAcc(),
    #####:  696:                              contractOp.getKind(), rewriter, isInt);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  697:    rewriter.replaceOp(contractOp, {*result});
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  698:    return success();
branch  0 never executed
branch  1 never executed
        -:  699:  }
        -:  700:
        -:  701:private:
        -:  702:  /// Options to control the vector patterns.
        -:  703:  vector::VectorTransformsOptions vectorTransformOptions;
        -:  704:  FilterConstraintType filter;
        -:  705:};
        -:  706:
        -:  707:/// Progressive lowering of ConstantMaskOp.
        -:  708:/// One:
        -:  709:///   %x = vector.constant_mask [a,b]
        -:  710:/// is replaced by:
        -:  711:///   %z = zero-result
        -:  712:///   %l = vector.constant_mask [b]
        -:  713:///   %4 = vector.insert %l, %z[0]
        -:  714:///   ..
        -:  715:///   %x = vector.insert %l, %..[a-1]
        -:  716:/// until a one-dimensional vector is reached. All these operations
        -:  717:/// will be folded at LLVM IR level.
        -:  718:class ConstantMaskOpLowering : public OpRewritePattern<vector::ConstantMaskOp> {
        -:  719:public:
        -:  720:  using OpRewritePattern::OpRewritePattern;
        -:  721:
function _ZNK12_GLOBAL__N_122ConstantMaskOpLowering15matchAndRewriteEN4mlir6vector14ConstantMaskOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  722:  LogicalResult matchAndRewrite(vector::ConstantMaskOp op,
        -:  723:                                PatternRewriter &rewriter) const override {
    #####:  724:    auto loc = op.getLoc();
call    0 never executed
    #####:  725:    auto dstType = op.getType();
call    0 never executed
    #####:  726:    auto eltType = dstType.getElementType();
call    0 never executed
    #####:  727:    auto dimSizes = op.getMaskDimSizes();
call    0 never executed
    #####:  728:    int64_t rank = dstType.getRank();
call    0 never executed
        -:  729:
    #####:  730:    if (rank == 0) {
branch  0 never executed
branch  1 never executed
    #####:  731:      assert(dimSizes.size() == 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  732:             "Expected exactly one dim size for a 0-D vector");
    #####:  733:      bool value = dimSizes[0].cast<IntegerAttr>().getInt() == 1;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  734:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(
        -:  735:          op, dstType,
    #####:  736:          DenseIntElementsAttr::get(
    #####:  737:              VectorType::get(ArrayRef<int64_t>{}, rewriter.getI1Type()),
call    0 never executed
    #####:  738:              ArrayRef<bool>{value}));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  739:      return success();
        -:  740:    }
        -:  741:
        -:  742:    // Scalable constant masks can only be lowered for the "none set" case.
    #####:  743:    if (dstType.cast<VectorType>().isScalable()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  744:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(
    #####:  745:          op, DenseElementsAttr::get(dstType, false));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  746:      return success();
        -:  747:    }
        -:  748:
    #####:  749:    int64_t trueDim = std::min(dstType.getDimSize(0),
branch  0 never executed
branch  1 never executed
    #####:  750:                               dimSizes[0].cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  751:
    #####:  752:    if (rank == 1) {
branch  0 never executed
branch  1 never executed
        -:  753:      // Express constant 1-D case in explicit vector form:
        -:  754:      //   [T,..,T,F,..,F].
    #####:  755:      SmallVector<bool, 4> values(dstType.getDimSize(0));
call    0 never executed
call    1 never executed
    #####:  756:      for (int64_t d = 0; d < trueDim; d++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  757:        values[d] = true;
branch  0 never executed
branch  1 never executed
    #####:  758:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(
    #####:  759:          op, dstType, rewriter.getBoolVectorAttr(values));
call    0 never executed
call    1 never executed
    #####:  760:      return success();
branch  0 never executed
branch  1 never executed
        -:  761:    }
        -:  762:
    #####:  763:    VectorType lowType =
    #####:  764:        VectorType::get(dstType.getShape().drop_front(), eltType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  765:    SmallVector<int64_t, 4> newDimSizes;
    #####:  766:    for (int64_t r = 1; r < rank; r++)
branch  0 never executed
branch  1 never executed
    #####:  767:      newDimSizes.push_back(dimSizes[r].cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  768:    Value trueVal = rewriter.create<vector::ConstantMaskOp>(
    #####:  769:        loc, lowType, rewriter.getI64ArrayAttr(newDimSizes));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  770:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  771:        loc, dstType, rewriter.getZeroAttr(dstType));
call    0 never executed
call    1 never executed
    #####:  772:    for (int64_t d = 0; d < trueDim; d++) {
branch  0 never executed
branch  1 never executed
    #####:  773:      auto pos = rewriter.getI64ArrayAttr(d);
call    0 never executed
    #####:  774:      result =
    #####:  775:          rewriter.create<vector::InsertOp>(loc, dstType, trueVal, result, pos);
call    0 never executed
        -:  776:    }
    #####:  777:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  778:    return success();
branch  0 never executed
branch  1 never executed
        -:  779:  }
        -:  780:};
        -:  781:
        -:  782:/// Progressive lowering of CreateMaskOp.
        -:  783:/// One:
        -:  784:///   %x = vector.create_mask %a, ... : vector<dx...>
        -:  785:/// is replaced by:
        -:  786:///   %l = vector.create_mask ... : vector<...>  ; one lower rank
        -:  787:///   %0 = arith.cmpi "slt", %ci, %a       |
        -:  788:///   %1 = select %0, %l, %zeroes    |
        -:  789:///   %r = vector.insert %1, %pr [i] | d-times
        -:  790:///   %x = ....
        -:  791:/// until a one-dimensional vector is reached.
        -:  792:class CreateMaskOpLowering : public OpRewritePattern<vector::CreateMaskOp> {
        -:  793:public:
        -:  794:  using OpRewritePattern::OpRewritePattern;
        -:  795:
function _ZNK12_GLOBAL__N_120CreateMaskOpLowering15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  796:  LogicalResult matchAndRewrite(vector::CreateMaskOp op,
        -:  797:                                PatternRewriter &rewriter) const override {
    #####:  798:    auto dstType = op.getResult().getType().cast<VectorType>();
call    0 never executed
    #####:  799:    int64_t rank = dstType.getRank();
call    0 never executed
    #####:  800:    if (rank <= 1)
branch  0 never executed
branch  1 never executed
    #####:  801:      return rewriter.notifyMatchFailure(
    #####:  802:          op, "0-D and 1-D vectors are handled separately");
call    0 never executed
        -:  803:
    #####:  804:    auto loc = op.getLoc();
call    0 never executed
    #####:  805:    auto eltType = dstType.getElementType();
call    0 never executed
    #####:  806:    int64_t dim = dstType.getDimSize(0);
call    0 never executed
    #####:  807:    Value idx = op.getOperand(0);
call    0 never executed
        -:  808:
    #####:  809:    VectorType lowType =
    #####:  810:        VectorType::get(dstType.getShape().drop_front(), eltType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  811:    Value trueVal = rewriter.create<vector::CreateMaskOp>(
    #####:  812:        loc, lowType, op.getOperands().drop_front());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  813:    Value falseVal = rewriter.create<arith::ConstantOp>(
    #####:  814:        loc, lowType, rewriter.getZeroAttr(lowType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  815:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  816:        loc, dstType, rewriter.getZeroAttr(dstType));
call    0 never executed
call    1 never executed
    #####:  817:    for (int64_t d = 0; d < dim; d++) {
branch  0 never executed
branch  1 never executed
    #####:  818:      Value bnd =
    #####:  819:          rewriter.create<arith::ConstantOp>(loc, rewriter.getIndexAttr(d));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  820:      Value val = rewriter.create<arith::CmpIOp>(loc, arith::CmpIPredicate::slt,
    #####:  821:                                                 bnd, idx);
call    0 never executed
call    1 never executed
    #####:  822:      Value sel = rewriter.create<arith::SelectOp>(loc, val, trueVal, falseVal);
call    0 never executed
call    1 never executed
    #####:  823:      auto pos = rewriter.getI64ArrayAttr(d);
call    0 never executed
    #####:  824:      result =
    #####:  825:          rewriter.create<vector::InsertOp>(loc, dstType, sel, result, pos);
call    0 never executed
        -:  826:    }
    #####:  827:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  828:    return success();
        -:  829:  }
        -:  830:};
        -:  831:
        -:  832:/// ShapeOp 2D -> 1D downcast serves the purpose of flattening 2-D to 1-D
        -:  833:/// vectors progressively on the way to target llvm.matrix intrinsics.
        -:  834:/// This iterates over the most major dimension of the 2-D vector and performs
        -:  835:/// rewrites into:
        -:  836:///   vector.extract from 2-D + vector.insert_strided_slice offset into 1-D
        -:  837:class ShapeCastOp2DDownCastRewritePattern
        -:  838:    : public OpRewritePattern<vector::ShapeCastOp> {
        -:  839:public:
        -:  840:  using OpRewritePattern::OpRewritePattern;
        -:  841:
function _ZNK12_GLOBAL__N_135ShapeCastOp2DDownCastRewritePattern15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  842:  LogicalResult matchAndRewrite(vector::ShapeCastOp op,
        -:  843:                                PatternRewriter &rewriter) const override {
    #####:  844:    auto sourceVectorType = op.getSourceVectorType();
call    0 never executed
    #####:  845:    auto resultVectorType = op.getResultVectorType();
call    0 never executed
    #####:  846:    if (sourceVectorType.getRank() != 2 || resultVectorType.getRank() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  847:      return failure();
        -:  848:
    #####:  849:    auto loc = op.getLoc();
call    0 never executed
    #####:  850:    Value desc = rewriter.create<arith::ConstantOp>(
    #####:  851:        loc, resultVectorType, rewriter.getZeroAttr(resultVectorType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  852:    unsigned mostMinorVectorSize = sourceVectorType.getShape()[1];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  853:    for (int64_t i = 0, e = sourceVectorType.getShape().front(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  854:      Value vec = rewriter.create<vector::ExtractOp>(loc, op.getSource(), i);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  855:      desc = rewriter.create<vector::InsertStridedSliceOp>(
        -:  856:          loc, vec, desc,
    #####:  857:          /*offsets=*/i * mostMinorVectorSize, /*strides=*/1);
call    0 never executed
        -:  858:    }
    #####:  859:    rewriter.replaceOp(op, desc);
call    0 never executed
call    1 never executed
    #####:  860:    return success();
        -:  861:  }
        -:  862:};
        -:  863:
        -:  864:/// ShapeOp 1D -> 2D upcast serves the purpose of unflattening 2-D from 1-D
        -:  865:/// vectors progressively.
        -:  866:/// This iterates over the most major dimension of the 2-D vector and performs
        -:  867:/// rewrites into:
        -:  868:///   vector.extract_strided_slice from 1-D + vector.insert into 2-D
        -:  869:/// Note that 1-D extract_strided_slice are lowered to efficient vector.shuffle.
        -:  870:class ShapeCastOp2DUpCastRewritePattern
        -:  871:    : public OpRewritePattern<vector::ShapeCastOp> {
        -:  872:public:
        -:  873:  using OpRewritePattern::OpRewritePattern;
        -:  874:
function _ZNK12_GLOBAL__N_133ShapeCastOp2DUpCastRewritePattern15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  875:  LogicalResult matchAndRewrite(vector::ShapeCastOp op,
        -:  876:                                PatternRewriter &rewriter) const override {
    #####:  877:    auto sourceVectorType = op.getSourceVectorType();
call    0 never executed
    #####:  878:    auto resultVectorType = op.getResultVectorType();
call    0 never executed
    #####:  879:    if (sourceVectorType.getRank() != 1 || resultVectorType.getRank() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  880:      return failure();
        -:  881:
    #####:  882:    auto loc = op.getLoc();
call    0 never executed
    #####:  883:    Value desc = rewriter.create<arith::ConstantOp>(
    #####:  884:        loc, resultVectorType, rewriter.getZeroAttr(resultVectorType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  885:    unsigned mostMinorVectorSize = resultVectorType.getShape()[1];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  886:    for (int64_t i = 0, e = resultVectorType.getShape().front(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  887:      Value vec = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  888:          loc, op.getSource(), /*offsets=*/i * mostMinorVectorSize,
        -:  889:          /*sizes=*/mostMinorVectorSize,
    #####:  890:          /*strides=*/1);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  891:      desc = rewriter.create<vector::InsertOp>(loc, vec, desc, i);
call    0 never executed
        -:  892:    }
    #####:  893:    rewriter.replaceOp(op, desc);
call    0 never executed
call    1 never executed
    #####:  894:    return success();
        -:  895:  }
        -:  896:};
        -:  897:
        -:  898:// We typically should not lower general shape cast operations into data
        -:  899:// movement instructions, since the assumption is that these casts are
        -:  900:// optimized away during progressive lowering. For completeness, however,
        -:  901:// we fall back to a reference implementation that moves all elements
        -:  902:// into the right place if we get here.
        -:  903:class ShapeCastOpRewritePattern : public OpRewritePattern<vector::ShapeCastOp> {
        -:  904:public:
        -:  905:  using OpRewritePattern::OpRewritePattern;
        -:  906:
function _ZNK12_GLOBAL__N_125ShapeCastOpRewritePattern15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  907:  LogicalResult matchAndRewrite(vector::ShapeCastOp op,
        -:  908:                                PatternRewriter &rewriter) const override {
    #####:  909:    Location loc = op.getLoc();
call    0 never executed
    #####:  910:    auto sourceVectorType = op.getSourceVectorType();
call    0 never executed
    #####:  911:    auto resultVectorType = op.getResultVectorType();
call    0 never executed
        -:  912:
        -:  913:    // Special case 2D/1D lowerings with better implementations.
        -:  914:    // TODO: make is ND/1D to allow generic ND->1D->MD.
    #####:  915:    int64_t srcRank = sourceVectorType.getRank();
call    0 never executed
    #####:  916:    int64_t resRank = resultVectorType.getRank();
call    0 never executed
    #####:  917:    if ((srcRank == 2 && resRank == 1) || (srcRank == 1 && resRank == 2))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  918:      return failure();
        -:  919:
        -:  920:    // Generic ShapeCast lowering path goes all the way down to unrolled scalar
        -:  921:    // extract/insert chains.
        -:  922:    // TODO: consider evolving the semantics to only allow 1D source or dest and
        -:  923:    // drop this potentially very expensive lowering.
        -:  924:    // Compute number of elements involved in the reshape.
        -:  925:    int64_t numElts = 1;
    #####:  926:    for (int64_t r = 0; r < srcRank; r++)
branch  0 never executed
branch  1 never executed
    #####:  927:      numElts *= sourceVectorType.getDimSize(r);
call    0 never executed
        -:  928:    // Replace with data movement operations:
        -:  929:    //    x[0,0,0] = y[0,0]
        -:  930:    //    x[0,0,1] = y[0,1]
        -:  931:    //    x[0,1,0] = y[0,2]
        -:  932:    // etc., incrementing the two index vectors "row-major"
        -:  933:    // within the source and result shape.
    #####:  934:    SmallVector<int64_t, 4> srcIdx(srcRank);
call    0 never executed
    #####:  935:    SmallVector<int64_t, 4> resIdx(resRank);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  936:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  937:        loc, resultVectorType, rewriter.getZeroAttr(resultVectorType));
call    0 never executed
call    1 never executed
    #####:  938:    for (int64_t i = 0; i < numElts; i++) {
branch  0 never executed
branch  1 never executed
    #####:  939:      if (i != 0) {
branch  0 never executed
branch  1 never executed
    #####:  940:        incIdx(srcIdx, sourceVectorType, srcRank - 1);
call    0 never executed
    #####:  941:        incIdx(resIdx, resultVectorType, resRank - 1);
call    0 never executed
        -:  942:      }
    #####:  943:      Value e = rewriter.create<vector::ExtractOp>(loc, op.getSource(), srcIdx);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  944:      result = rewriter.create<vector::InsertOp>(loc, e, result, resIdx);
call    0 never executed
        -:  945:    }
    #####:  946:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  947:    return success();
branch  0 never executed
branch  1 never executed
        -:  948:  }
        -:  949:
        -:  950:private:
function _ZN12_GLOBAL__N_125ShapeCastOpRewritePattern6incIdxERN4llvm11SmallVectorIlLj4EEEN4mlir10VectorTypeEl called 0 returned 0% blocks executed 0%
    #####:  951:  static void incIdx(SmallVector<int64_t, 4> &idx, VectorType tp, int64_t r) {
    #####:  952:    assert(0 <= r && r < tp.getRank());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  953:    if (++idx[r] == tp.getDimSize(r)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  954:      idx[r] = 0;
branch  0 never executed
branch  1 never executed
    #####:  955:      incIdx(idx, tp, r - 1);
        -:  956:    }
    #####:  957:  }
        -:  958:};
        -:  959:
        -:  960:/// Convert MulIOp/MulFOp + MultiDimReductionOp<add> into ContractionOp.
        -:  961:/// Ex:
        -:  962:/// ```
        -:  963:///   %0 = arith.mulf %arg0, %arg1 : vector<8x32x16xf32>
        -:  964:///   %1 = vector.multi_reduction add, %0 [1]
        -:  965:///     : vector<8x32x16xf32> to vector<8x16xf32>
        -:  966:/// ```
        -:  967:/// Gets converted to:
        -:  968:/// ```
        -:  969:///   %1 = vector.contract {indexing_maps = [
        -:  970:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -:  971:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -:  972:///         affine_map<(d0, d1, d2) -> (d0, d1)>],
        -:  973:///    iterator_types = ["parallel", "parallel", "reduction"],
        -:  974:///    kind = add} %0, %arg1, %cst_f0
        -:  975:///    : vector<8x32x16xf32>, vector<8x32x16xf32> into vector<8x32xf32>
        -:  976:///  ```
        -:  977:struct MultiReduceToContract
        -:  978:    : public OpRewritePattern<vector::MultiDimReductionOp> {
        -:  979:  using OpRewritePattern::OpRewritePattern;
        -:  980:
function _ZNK12_GLOBAL__N_121MultiReduceToContract15matchAndRewriteEN4mlir6vector19MultiDimReductionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  981:  LogicalResult matchAndRewrite(vector::MultiDimReductionOp reduceOp,
        -:  982:                                PatternRewriter &rewriter) const override {
    #####:  983:    if (reduceOp.getKind() != vector::CombiningKind::ADD)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  984:      return failure();
    #####:  985:    Operation *mulOp = reduceOp.getSource().getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  986:    if (!mulOp || !isa<arith::MulIOp, arith::MulFOp>(mulOp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  987:      return failure();
    #####:  988:    SmallVector<bool> reductionMask = reduceOp.getReductionMask();
call    0 never executed
    #####:  989:    auto srcMap = rewriter.getMultiDimIdentityMap(reductionMask.size());
call    0 never executed
    #####:  990:    SmallVector<AffineExpr> exprs;
branch  0 never executed
branch  1 never executed
    #####:  991:    SmallVector<vector::IteratorType> iteratorTypes;
branch  0 never executed
branch  1 never executed
    #####:  992:    for (const auto &isReduceDim : llvm::enumerate(reductionMask)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  993:      if (!isReduceDim.value()) {
branch  0 never executed
branch  1 never executed
    #####:  994:        iteratorTypes.push_back(vector::IteratorType::parallel);
call    0 never executed
    #####:  995:        exprs.push_back(rewriter.getAffineDimExpr(isReduceDim.index()));
call    0 never executed
call    1 never executed
        -:  996:      } else {
    #####:  997:        iteratorTypes.push_back(vector::IteratorType::reduction);
call    0 never executed
        -:  998:      }
        -:  999:    }
    #####: 1000:    auto dstMap = AffineMap::get(/*dimCount=*/reductionMask.size(),
call    0 never executed
call    1 never executed
    #####: 1001:                                 /*symCount=*/0, exprs, reduceOp.getContext());
call    0 never executed
    #####: 1002:    rewriter.replaceOpWithNewOp<mlir::vector::ContractionOp>(
    #####: 1003:        reduceOp, mulOp->getOperand(0), mulOp->getOperand(1), reduceOp.getAcc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1004:        rewriter.getAffineMapArrayAttr({srcMap, srcMap, dstMap}),
call    0 never executed
    #####: 1005:        rewriter.getArrayAttr(llvm::to_vector(llvm::map_range(
call    0 never executed
        -: 1006:            iteratorTypes, [&](IteratorType t) -> mlir::Attribute {
        -: 1007:              return IteratorTypeAttr::get(rewriter.getContext(), t);
    #####: 1008:            }))));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1009:    return success();
branch  0 never executed
branch  1 never executed
        -: 1010:  }
        -: 1011:};
        -: 1012:
        -: 1013:/// Merge LHS/RHS (A/B) TransposeOp into ContractionOp user.
        -: 1014:/// Ex:
        -: 1015:/// ```
        -: 1016:///   %0 = vector.transpose %arg0, [2, 0, 1]
        -: 1017:///     : vector<32x16x8xf32> to vector<8x32x16xf32>
        -: 1018:///   %1 = vector.contract {indexing_maps = [
        -: 1019:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1020:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1021:///         affine_map<(d0, d1, d2) -> (d0, d1)>],
        -: 1022:///    iterator_types = ["parallel", "parallel", "reduction"],
        -: 1023:///    kind = add} %0, %arg1, %cst_f0
        -: 1024:///    : vector<8x32x16xf32>, vector<8x32x16xf32> into vector<8x32xf32>
        -: 1025:/// ```
        -: 1026:/// Gets converted to:
        -: 1027:/// ```
        -: 1028:///   %1 = vector.contract {indexing_maps = [
        -: 1029:///         affine_map<(d0, d1, d2) -> (d1, d2, d0)>,
        -: 1030:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1031:///         affine_map<(d0, d1, d2) -> (d0, d1)>],
        -: 1032:///    iterator_types = ["parallel", "parallel", "reduction"],
        -: 1033:///    kind = add} %arg0, %arg1, %cst_f0
        -: 1034:///    : vector<8x32x16xf32>, vector<8x32x16xf32> into vector<8x32xf32>
        -: 1035:///  ```
        -: 1036:struct CombineContractABTranspose final
        -: 1037:    : public OpRewritePattern<vector::ContractionOp> {
        -: 1038:  using OpRewritePattern::OpRewritePattern;
        -: 1039:
function _ZNK12_GLOBAL__N_126CombineContractABTranspose15matchAndRewriteEN4mlir6vector13ContractionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1040:  LogicalResult matchAndRewrite(vector::ContractionOp contractOp,
        -: 1041:                                PatternRewriter &rewriter) const override {
    #####: 1042:    SmallVector<AffineMap, 4> maps =
    #####: 1043:        llvm::to_vector<4>(contractOp.getIndexingMapsArray());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1044:    Value lhs = contractOp.getLhs();
call    0 never executed
    #####: 1045:    Value rhs = contractOp.getRhs();
call    0 never executed
    #####: 1046:    size_t index = 0;
    #####: 1047:    bool changed = false;
    #####: 1048:    for (Value *operand : {&lhs, &rhs}) {
branch  0 never executed
branch  1 never executed
    #####: 1049:      AffineMap &map = maps[index++];
branch  0 never executed
branch  1 never executed
    #####: 1050:      auto transposeOp = operand->getDefiningOp<vector::TransposeOp>();
call    0 never executed
    #####: 1051:      if (!transposeOp)
branch  0 never executed
branch  1 never executed
    #####: 1052:        continue;
    #####: 1053:      AffineMap permutationMap = AffineMap::getPermutationMap(
call    0 never executed
    #####: 1054:          extractVector<unsigned>(transposeOp.getTransp()),
call    0 never executed
call    1 never executed
    #####: 1055:          contractOp.getContext());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1056:      map = inversePermutation(permutationMap).compose(map);
call    0 never executed
call    1 never executed
    #####: 1057:      *operand = transposeOp.getVector();
call    0 never executed
    #####: 1058:      changed = true;
        -: 1059:    }
    #####: 1060:    if (!changed)
branch  0 never executed
branch  1 never executed
    #####: 1061:      return failure();
    #####: 1062:    rewriter.replaceOpWithNewOp<vector::ContractionOp>(
    #####: 1063:        contractOp, lhs, rhs, contractOp.getAcc(),
call    0 never executed
    #####: 1064:        rewriter.getAffineMapArrayAttr(maps), contractOp.getIteratorTypes());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1065:    return success();
branch  0 never executed
branch  1 never executed
        -: 1066:  }
        -: 1067:};
        -: 1068:
        -: 1069:/// Merges accumulator and result transposes into contract.
        -: 1070:///
        -: 1071:/// For example:
        -: 1072:/// ```mlir
        -: 1073:/// %accT = vector.transpose %acc, [0, 2, 1]
        -: 1074:///   : vector<2x8x4xf32> to vector<2x4x8xf32>
        -: 1075:/// %contract = vector.contract {
        -: 1076:///   indexing_maps = [
        -: 1077:///     affine_map<(d0, d1, d2, d3) -> (d0, d3, d1)>,
        -: 1078:///     affine_map<(d0, d1, d2, d3) -> (d3, d2)>,
        -: 1079:///     affine_map<(d0, d1, d2, d3) -> (d0, d1, d2)>
        -: 1080:///   ],
        -: 1081:///   iterator_types = ["parallel", "parallel", "parallel", "reduction"],
        -: 1082:///   kind = #vector.kind<add>
        -: 1083:/// } %lhs, %rhs, %accT
        -: 1084:///   : vector<2x4x4xf32>, vector<4x8xf32> into vector<2x4x8xf32>
        -: 1085:/// %0 = vector.transpose %contract, [0, 2, 1]
        -: 1086:///   : vector<2x4x8xf32> to vector<2x8x4>
        -: 1087:/// ```
        -: 1088:/// Becomes:
        -: 1089:/// ```mlir
        -: 1090:/// %0 = vector.contract {
        -: 1091:///   indexing_maps = [
        -: 1092:///     affine_map<(d0, d1, d2, d3) -> (d0, d3, d1)>,
        -: 1093:///     affine_map<(d0, d1, d2, d3) -> (d3, d2)>,
        -: 1094:///     affine_map<(d0, d1, d2, d3) -> (d0, d2, d1)>
        -: 1095:///   ],
        -: 1096:///   iterator_types = ["parallel", "parallel", "parallel", "reduction"],
        -: 1097:///   kind = #vector.kind<add>
        -: 1098:/// } %lhs, %rhs, %acc
        -: 1099:///   : vector<2x4x4xf32>, vector<4x8xf32> into vector<2x8x4xf32>
        -: 1100:/// ```
        -: 1101:struct CombineContractResultTranspose final
        -: 1102:    : public OpRewritePattern<vector::TransposeOp> {
        -: 1103:  using OpRewritePattern::OpRewritePattern;
        -: 1104:
function _ZNK12_GLOBAL__N_130CombineContractResultTranspose15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1105:  LogicalResult matchAndRewrite(vector::TransposeOp resTOp,
        -: 1106:                                PatternRewriter &rewriter) const override {
    #####: 1107:    auto contractOp = resTOp.getVector().getDefiningOp<vector::ContractionOp>();
call    0 never executed
call    1 never executed
    #####: 1108:    if (!contractOp || !contractOp->hasOneUse())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1109:      return failure();
        -: 1110:
    #####: 1111:    auto accTOp = contractOp.getAcc().getDefiningOp<vector::TransposeOp>();
call    0 never executed
call    1 never executed
    #####: 1112:    if (!accTOp)
branch  0 never executed
branch  1 never executed
    #####: 1113:      return failure();
        -: 1114:
    #####: 1115:    MLIRContext *context = contractOp.getContext();
call    0 never executed
    #####: 1116:    auto maps = llvm::to_vector<3>(contractOp.getIndexingMapsArray());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1117:    AffineMap contractMap = maps.back();
call    0 never executed
        -: 1118:
        -: 1119:    // Accumulator transpose performs f(A) -> B. Contract performs g(C) -> B.
        -: 1120:    // To index into A in contract, we need revert(f)(g(C)) -> A.
    #####: 1121:    auto accTMap = AffineMap::getPermutationMap(
    #####: 1122:        extractVector<unsigned>(accTOp.getTransp()), context);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1123:
        -: 1124:    // Contract performs g(C) -> D. Result transpose performs h(D) -> E.
        -: 1125:    // To index into E in contract, we need h(g(C)) -> E.
    #####: 1126:    auto resTMap = AffineMap::getPermutationMap(
    #####: 1127:        extractVector<unsigned>(resTOp.getTransp()), context);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1128:    auto combinedResMap = resTMap.compose(contractMap);
call    0 never executed
        -: 1129:
        -: 1130:    // The accumulator and result share the same indexing map. So they should be
        -: 1131:    // the same to be able to merge. This means combinedResMap is the same as
        -: 1132:    // inversePermutation(accTMap).compose(contractMap), which means
    #####: 1133:    if (inversePermutation(accTMap) != resTMap)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1134:      return failure();
    #####: 1135:    maps.back() = combinedResMap;
call    0 never executed
        -: 1136:
    #####: 1137:    rewriter.replaceOpWithNewOp<vector::ContractionOp>(
    #####: 1138:        resTOp, contractOp.getLhs(), contractOp.getRhs(), accTOp.getVector(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1139:        rewriter.getAffineMapArrayAttr(maps), contractOp.getIteratorTypes());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1140:    return success();
branch  0 never executed
branch  1 never executed
        -: 1141:  }
        -: 1142:};
        -: 1143:
        -: 1144:/// Merge BroadcastOp into ContractionOp user.
        -: 1145:/// Ex:
        -: 1146:/// ```
        -: 1147:///   %0 = vector.broadcast %arg0 : vector<32x16xf32> to vector<8x32x16xf32>
        -: 1148:///   %1 = vector.contract {indexing_maps = [
        -: 1149:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1150:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1151:///         affine_map<(d0, d1, d2) -> (d0, d1)>],
        -: 1152:///    iterator_types = ["parallel", "parallel", "reduction"],
        -: 1153:///    kind = add} %0, %arg1, %cst_f0
        -: 1154:///    : vector<8x32x16xf32>, vector<8x32x16xf32> into vector<8x32xf32>
        -: 1155:/// ```
        -: 1156:/// Gets converted to:
        -: 1157:/// ```
        -: 1158:///   %1 = vector.contract {indexing_maps = [
        -: 1159:///         affine_map<(d0, d1, d2) -> (d1, d2)>,
        -: 1160:///         affine_map<(d0, d1, d2) -> (d0, d1, d2)>,
        -: 1161:///         affine_map<(d0, d1, d2) -> (d0, d1)>],
        -: 1162:///    iterator_types = ["parallel", "parallel", "reduction"],
        -: 1163:///    kind = add} %arg0, %arg1, %cst_f0
        -: 1164:///    : vector<32x16xf32>, vector<8x32x16xf32> into vector<8x32xf32>
        -: 1165:///  ```
        -: 1166:struct CombineContractBroadcast
        -: 1167:    : public OpRewritePattern<vector::ContractionOp> {
        -: 1168:  using OpRewritePattern::OpRewritePattern;
        -: 1169:
function _ZNK12_GLOBAL__N_124CombineContractBroadcast15matchAndRewriteEN4mlir6vector13ContractionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1170:  LogicalResult matchAndRewrite(vector::ContractionOp contractOp,
        -: 1171:                                PatternRewriter &rewriter) const override {
    #####: 1172:    SmallVector<AffineMap, 4> maps =
    #####: 1173:        llvm::to_vector<4>(contractOp.getIndexingMapsArray());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1174:    Value lhs = contractOp.getLhs();
call    0 never executed
    #####: 1175:    Value rhs = contractOp.getRhs();
call    0 never executed
    #####: 1176:    size_t index = 0;
    #####: 1177:    bool changed = false;
    #####: 1178:    for (Value *operand : {&lhs, &rhs}) {
branch  0 never executed
branch  1 never executed
    #####: 1179:      AffineMap &map = maps[index++];
branch  0 never executed
branch  1 never executed
    #####: 1180:      auto broadcast = operand->getDefiningOp<vector::BroadcastOp>();
call    0 never executed
    #####: 1181:      if (!broadcast)
branch  0 never executed
branch  1 never executed
    #####: 1182:        continue;
        -: 1183:      // contractionOp can only take vector as operands.
    #####: 1184:      auto srcType = broadcast.getSourceType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####: 1185:      if (!srcType || srcType.getRank() == broadcast.getVectorType().getRank())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1186:        continue;
    #####: 1187:      int64_t rankDiff =
    #####: 1188:          broadcast.getVectorType().getRank() - srcType.getRank();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1189:      bool innerDimBroadcast = false;
    #####: 1190:      SmallVector<AffineExpr> originalDims;
call    0 never executed
    #####: 1191:      for (const auto &dim : llvm::enumerate(srcType.getShape())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1192:        if (dim.value() !=
call    0 never executed
    #####: 1193:            broadcast.getVectorType().getDimSize(rankDiff + dim.index())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1194:          innerDimBroadcast = true;
        -: 1195:          break;
        -: 1196:        }
    #####: 1197:        originalDims.push_back(
call    0 never executed
    #####: 1198:            rewriter.getAffineDimExpr(dim.index() + rankDiff));
call    0 never executed
        -: 1199:      }
        -: 1200:      // Contract doesn't support inner dimension broadcast. Once this is
        -: 1201:      // relaxed we can remove this case.
    #####: 1202:      if (innerDimBroadcast)
branch  0 never executed
branch  1 never executed
    #####: 1203:        continue;
        -: 1204:
        -: 1205:      // It would be incorrect to fold a broadcast onto a reduction dimension
        -: 1206:      // of non-unit size.
    #####: 1207:      bool nonUnitDimReductionBroadcast = false;
    #####: 1208:      for (int64_t i = 0; i < rankDiff; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1209:        if (broadcast.getVectorType().getDimSize(i) != 1 &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1210:            isReductionIterator(contractOp.getIteratorTypes()
call    0 never executed
    #####: 1211:                                    .getValue()[map.getDimPosition(i)])) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1212:          nonUnitDimReductionBroadcast = true;
        -: 1213:          break;
        -: 1214:        }
        -: 1215:      }
    #####: 1216:      if (nonUnitDimReductionBroadcast)
branch  0 never executed
branch  1 never executed
    #####: 1217:        continue;
        -: 1218:
    #####: 1219:      AffineMap broadcastMap =
call    0 never executed
    #####: 1220:          AffineMap::get(broadcast.getVectorType().getRank(), 0, originalDims,
call    0 never executed
call    1 never executed
    #####: 1221:                         contractOp.getContext());
call    0 never executed
call    1 never executed
    #####: 1222:      map = broadcastMap.compose(map);
call    0 never executed
    #####: 1223:      *operand = broadcast.getSource();
call    0 never executed
    #####: 1224:      changed = true;
branch  0 never executed
branch  1 never executed
        -: 1225:    }
        -: 1226:
    #####: 1227:    if (!changed)
branch  0 never executed
branch  1 never executed
    #####: 1228:      return failure();
branch  0 never executed
branch  1 never executed
        -: 1229:
        -: 1230:    // Determine which dims are usused, now that the maps have been composed
        -: 1231:    // with the broadcast maps.
    #####: 1232:    llvm::SmallBitVector unusedDimsBitVector = getUnusedDimsBitVector(maps);
call    0 never executed
        -: 1233:    // Compress unused dims.
    #####: 1234:    for (auto &m : maps)
branch  0 never executed
branch  1 never executed
    #####: 1235:      m = compressDims(m, unusedDimsBitVector);
call    0 never executed
        -: 1236:    // Compute the combined iterators.
    #####: 1237:    SmallVector<Attribute, 4> iterators;
call    0 never executed
    #####: 1238:    for (unsigned i = 0; i < unusedDimsBitVector.size(); ++i) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1239:      if (!unusedDimsBitVector.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1240:        iterators.push_back(contractOp.getIteratorTypes().getValue()[i]);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1241:    }
        -: 1242:    // Check that compressing unused dims isn't removing all reduction dimension
        -: 1243:    // pairs. For example, if the vector.contract had only one reduction
        -: 1244:    // iterator and that was a unit-dimension created by a broadcast,
        -: 1245:    // then we should bail here, otherwise we would create a contract without
        -: 1246:    // a reduction dimension pair.
    #####: 1247:    bool hasReductionIteratorApplyingOnBothSides = false;
    #####: 1248:    for (unsigned i = 0; i < iterators.size(); ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1249:      if (!isReductionIterator(iterators[i]))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1250:        continue;
    #####: 1251:      if (getResultIndex(maps[0], i) && getResultIndex(maps[1], i)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -: 1252:        hasReductionIteratorApplyingOnBothSides = true;
        -: 1253:        break;
        -: 1254:      }
        -: 1255:    }
    #####: 1256:    if (!hasReductionIteratorApplyingOnBothSides)
branch  0 never executed
branch  1 never executed
    #####: 1257:      return failure();
        -: 1258:
        -: 1259:    // If the compressed maps have a dimension that is not used by either LHS or
        -: 1260:    // RHS then the ContractionOp verifier would fail.
    #####: 1261:    if (getUnusedDimsBitVector({maps[0], maps[1]}).any())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1262:      return failure();
    #####: 1263:    rewriter.replaceOpWithNewOp<vector::ContractionOp>(
    #####: 1264:        contractOp, lhs, rhs, contractOp.getAcc(),
call    0 never executed
    #####: 1265:        rewriter.getAffineMapArrayAttr(maps), rewriter.getArrayAttr(iterators));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1266:    return success();
branch  0 never executed
branch  1 never executed
        -: 1267:  }
        -: 1268:};
        -: 1269:
        -: 1270:/// Reorders cast(broadcast) to broadcast(cast). This makes broadcast ops and
        -: 1271:/// contraction ops closer, which kicks in CombineContractBroadcast pattern when
        -: 1272:/// casting ops are around these operations.
        -: 1273:/// Ex:
        -: 1274:/// ```
        -: 1275:///   %0 = vector.broadcast %arg0 : vector<32x16xi8> to vector<8x32x16xi8>
        -: 1276:///   %1 = arith.extsi %0 : vector<8x32x16xi8> to vector<8x32x16xi32>
        -: 1277:/// ```
        -: 1278:/// Gets converted to:
        -: 1279:/// ```
        -: 1280:///   %0 = arith.extsi %0 : vector<32x16xi8> to vector<32x16xi32>
        -: 1281:///   %1 = vector.broadcast %arg0 : vector<32x16xi32> to vector<8x32x16xi32>
        -: 1282:/// ```
        -: 1283:struct ReorderCastOpsOnBroadcast
        -: 1284:    : public OpInterfaceRewritePattern<CastOpInterface> {
        -: 1285:  using OpInterfaceRewritePattern<CastOpInterface>::OpInterfaceRewritePattern;
        -: 1286:
function _ZNK12_GLOBAL__N_125ReorderCastOpsOnBroadcast15matchAndRewriteEN4mlir15CastOpInterfaceERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1287:  LogicalResult matchAndRewrite(CastOpInterface op,
        -: 1288:                                PatternRewriter &rewriter) const override {
    #####: 1289:    if (op->getNumOperands() != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1290:      return failure();
    #####: 1291:    auto bcastOp = op->getOperand(0).getDefiningOp<vector::BroadcastOp>();
call    0 never executed
call    1 never executed
    #####: 1292:    if (!bcastOp)
branch  0 never executed
branch  1 never executed
    #####: 1293:      return failure();
        -: 1294:
    #####: 1295:    Type castResTy = getElementTypeOrSelf(op->getResult(0));
call    0 never executed
    #####: 1296:    if (auto vecTy = bcastOp.getSourceType().dyn_cast<VectorType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1297:      castResTy = VectorType::get(vecTy.getShape(), castResTy);
call    0 never executed
call    1 never executed
    #####: 1298:    auto *castOp =
    #####: 1299:        rewriter.create(op->getLoc(), op->getName().getIdentifier(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1300:                        bcastOp.getSource(), castResTy, op->getAttrs());
call    0 never executed
call    1 never executed
    #####: 1301:    rewriter.replaceOpWithNewOp<vector::BroadcastOp>(
    #####: 1302:        op, op->getResult(0).getType(), castOp->getResult(0));
call    0 never executed
    #####: 1303:    return success();
        -: 1304:  }
        -: 1305:};
        -: 1306:
        -: 1307:/// Reorders elementwise(transpose) to transpose(elementwise). This makes
        -: 1308:/// transpose ops and contraction ops closer, which kicks in
        -: 1309:/// CombineContractABTranspose pattern when elementwise ops are between these
        -: 1310:/// operations. Ex:
        -: 1311:/// ```
        -: 1312:/// %at = vector.transpose %a, [1, 0]: vector<4x2xf32> to vector<2x4xf32>
        -: 1313:/// %bt = vector.transpose %b, [1, 0]: vector<4x2xf32> to vector<2x4xf32>
        -: 1314:/// %r = arith.addf %at, %bt : vector<2x4xf32>
        -: 1315:/// ```
        -: 1316:/// Gets converted to:
        -: 1317:/// ```
        -: 1318:/// %0 = arith.addf %a, %b : vector<4x2xf32>
        -: 1319:/// %r = vector.transpose %0, [1, 0] : vector<2x4xf32>
        -: 1320:/// ```
        -: 1321:struct ReorderElementwiseOpsOnTranspose final
        -: 1322:    : public OpTraitRewritePattern<OpTrait::Elementwise> {
        -: 1323:  using OpTraitRewritePattern::OpTraitRewritePattern;
function _ZNK12_GLOBAL__N_132ReorderElementwiseOpsOnTranspose15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1324:  LogicalResult matchAndRewrite(Operation *op,
        -: 1325:                                PatternRewriter &rewriter) const override {
    #####: 1326:    if (op->getNumResults() != 1 || op->getNumRegions() != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1327:      return failure();
        -: 1328:
        -: 1329:    // Make sure all operands are transpose/constant ops and collect their
        -: 1330:    // transposition maps.
    #####: 1331:    SmallVector<ArrayAttr, 4> transposeMaps;
branch  0 never executed
branch  1 never executed
    #####: 1332:    transposeMaps.reserve(op->getNumOperands());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1333:    // Record the initial type before transposition. We'll use its shape later.
        -: 1334:    // Any type will do here as we will check all transpose maps are the same.
    #####: 1335:    VectorType srcType;
    #####: 1336:    for (Value operand : op->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1337:      auto transposeOp = operand.getDefiningOp<vector::TransposeOp>();
call    0 never executed
    #####: 1338:      if (transposeOp) {
branch  0 never executed
branch  1 never executed
    #####: 1339:        transposeMaps.push_back(transposeOp.getTransp());
call    0 never executed
call    1 never executed
    #####: 1340:        srcType = transposeOp.getVectorType();
call    0 never executed
    #####: 1341:      } else if (!matchPattern(operand, m_Constant())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1342:        return failure();
        -: 1343:      }
        -: 1344:    }
    #####: 1345:    if (transposeMaps.empty())
branch  0 never executed
branch  1 never executed
    #####: 1346:      return failure();
        -: 1347:    // This is an elementwise op, so all transposed operands should have the
        -: 1348:    // same type. We need to additionally check that all transposes uses the
        -: 1349:    // same map.
    #####: 1350:    if (!llvm::all_equal(transposeMaps))
branch  0 never executed
branch  1 never executed
    #####: 1351:      return rewriter.notifyMatchFailure(op, "different transpose map");
call    0 never executed
        -: 1352:
    #####: 1353:    SmallVector<Value, 4> srcValues;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1354:    srcValues.reserve(op->getNumOperands());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1355:
        -: 1356:    // If there are constant operands, we need to insert inverse transposes for
        -: 1357:    // them. Calculate the inverse order first.
    #####: 1358:    auto order = extractVector<unsigned>(transposeMaps.front());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1359:    SmallVector<int64_t> invOrder(order.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1360:    for (int i = 0, e = order.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1361:      invOrder[order[i]] = i;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1362:
    #####: 1363:    for (Value operand : op->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1364:      auto transposeOp = operand.getDefiningOp<vector::TransposeOp>();
call    0 never executed
    #####: 1365:      if (transposeOp) {
branch  0 never executed
branch  1 never executed
    #####: 1366:        srcValues.push_back(transposeOp.getVector());
call    0 never executed
call    1 never executed
        -: 1367:      } else {
        -: 1368:        // This is a constant. Create a reverse transpose op for it.
    #####: 1369:        auto vectorType = VectorType::get(
        -: 1370:            srcType.getShape(),
    #####: 1371:            operand.getType().cast<VectorType>().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1372:        srcValues.push_back(rewriter.create<vector::TransposeOp>(
call    0 never executed
        -: 1373:            operand.getLoc(), vectorType, operand,
    #####: 1374:            rewriter.getI64ArrayAttr(invOrder)));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1375:      }
        -: 1376:    }
        -: 1377:
    #####: 1378:    auto vectorType = VectorType::get(
        -: 1379:        srcType.getShape(),
    #####: 1380:        op->getResultTypes()[0].cast<VectorType>().getElementType());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1381:    Operation *elementwiseOp =
    #####: 1382:        rewriter.create(op->getLoc(), op->getName().getIdentifier(), srcValues,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1383:                        vectorType, op->getAttrs());
    #####: 1384:    rewriter.replaceOpWithNewOp<vector::TransposeOp>(
    #####: 1385:        op, op->getResultTypes()[0], elementwiseOp->getResult(0),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1386:        transposeMaps.front());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1387:    return success();
branch  0 never executed
branch  1 never executed
        -: 1388:  }
        -: 1389:};
        -: 1390:
        -: 1391:} // namespace
        -: 1392:
        -: 1393:/// Creates an AddIOp if `isInt` is true otherwise create an arith::AddFOp using
        -: 1394:/// operands `x` and `y`.
function _ZL9createAddN4mlir8LocationENS_5ValueES1_bRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1395:static Value createAdd(Location loc, Value x, Value y, bool isInt,
        -: 1396:                       PatternRewriter &rewriter) {
    #####: 1397:  if (isInt)
branch  0 never executed
branch  1 never executed
    #####: 1398:    return rewriter.create<arith::AddIOp>(loc, x, y);
call    0 never executed
    #####: 1399:  return rewriter.create<arith::AddFOp>(loc, x, y);
call    0 never executed
        -: 1400:}
        -: 1401:
        -: 1402:/// Creates a MulIOp if `isInt` is true otherwise create an MulFOp using
        -: 1403:/// operands `x and `y`.
function _ZL9createMulN4mlir8LocationENS_5ValueES1_bRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1404:static Value createMul(Location loc, Value x, Value y, bool isInt,
        -: 1405:                       PatternRewriter &rewriter) {
    #####: 1406:  if (isInt)
branch  0 never executed
branch  1 never executed
    #####: 1407:    return rewriter.create<arith::MulIOp>(loc, x, y);
call    0 never executed
    #####: 1408:  return rewriter.create<arith::MulFOp>(loc, x, y);
call    0 never executed
        -: 1409:}
        -: 1410:
        -: 1411:namespace mlir {
        -: 1412:
        -: 1413:/// Progressively lower a `vector.contract %a, %b, %c` with row-major matmul
        -: 1414:/// semantics to:
        -: 1415:/// ```
        -: 1416:///    %mta = maybe_transpose
        -: 1417:///    %mtb = maybe_transpose
        -: 1418:///    %flattened_a = vector.shape_cast %mta
        -: 1419:///    %flattened_b = vector.shape_cast %mtb
        -: 1420:///    %flattened_d = vector.matmul %flattened_a, %flattened_b
        -: 1421:///    %mtd = vector.shape_cast %flattened_d
        -: 1422:///    %d = maybe_untranspose %mtd
        -: 1423:///    %e = add %c, %d
        -: 1424:/// ```
        -: 1425:/// `vector.matmul` later lowers to `llvm.matrix.multiply`.
        -: 1426://
        -: 1427:/// This only kicks in when VectorTransformsOptions is set to `Matmul`.
        -: 1428:/// vector.transpose operations are inserted if the vector.contract op is not a
        -: 1429:/// row-major matrix multiply.
        -: 1430:LogicalResult
function _ZNK4mlir6vector31ContractionOpToMatmulOpLowering15matchAndRewriteENS0_13ContractionOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1431:ContractionOpToMatmulOpLowering::matchAndRewrite(vector::ContractionOp op,
        -: 1432:                                                 PatternRewriter &rew) const {
        -: 1433:  // TODO: implement masks
    #####: 1434:  if (!op.getMasks().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1435:    return failure();
    #####: 1436:  if (vectorTransformOptions.vectorContractLowering !=
branch  0 never executed
branch  1 never executed
        -: 1437:      vector::VectorContractLowering::Matmul)
    #####: 1438:    return failure();
    #####: 1439:  if (failed(filter(op)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1440:    return failure();
        -: 1441:
    #####: 1442:  auto iteratorTypes = op.getIteratorTypes().getValue();
call    0 never executed
call    1 never executed
    #####: 1443:  if (!isParallelIterator(iteratorTypes[0]) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1444:      !isParallelIterator(iteratorTypes[1]) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1445:      !isReductionIterator(iteratorTypes[2]))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1446:    return failure();
        -: 1447:
    #####: 1448:  Type elementType = op.getLhsType().getElementType();
call    0 never executed
call    1 never executed
    #####: 1449:  if (!elementType.isIntOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1450:    return failure();
        -: 1451:
    #####: 1452:  Type dstElementType = op.getType();
call    0 never executed
    #####: 1453:  if (auto vecType = dstElementType.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1454:    dstElementType = vecType.getElementType();
call    0 never executed
    #####: 1455:  if (elementType != dstElementType)
branch  0 never executed
branch  1 never executed
    #####: 1456:    return failure();
        -: 1457:
        -: 1458:  // Perform lhs + rhs transpositions to conform to matmul row-major semantics.
        -: 1459:  // Bail out if the contraction cannot be put in this form.
    #####: 1460:  MLIRContext *ctx = op.getContext();
call    0 never executed
    #####: 1461:  Location loc = op.getLoc();
call    0 never executed
    #####: 1462:  AffineExpr m, n, k;
    #####: 1463:  bindDims(rew.getContext(), m, n, k);
call    0 never executed
        -: 1464:  // LHS must be A(m, k) or A(k, m).
    #####: 1465:  Value lhs = op.getLhs();
call    0 never executed
    #####: 1466:  auto lhsMap = op.getIndexingMapsArray()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1467:  if (lhsMap == AffineMap::get(3, 0, {k, m}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1468:    lhs = rew.create<vector::TransposeOp>(loc, lhs, ArrayRef<int64_t>{1, 0});
call    0 never executed
    #####: 1469:  else if (lhsMap != AffineMap::get(3, 0, {m, k}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1470:    return failure();
        -: 1471:
        -: 1472:  // RHS must be B(k, n) or B(n, k).
    #####: 1473:  Value rhs = op.getRhs();
call    0 never executed
    #####: 1474:  auto rhsMap = op.getIndexingMapsArray()[1];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1475:  if (rhsMap == AffineMap::get(3, 0, {n, k}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1476:    rhs = rew.create<vector::TransposeOp>(loc, rhs, ArrayRef<int64_t>{1, 0});
call    0 never executed
    #####: 1477:  else if (rhsMap != AffineMap::get(3, 0, {k, n}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1478:    return failure();
        -: 1479:
        -: 1480:  // At this point lhs and rhs are in row-major.
    #####: 1481:  VectorType lhsType = lhs.getType().cast<VectorType>();
call    0 never executed
    #####: 1482:  VectorType rhsType = rhs.getType().cast<VectorType>();
call    0 never executed
    #####: 1483:  int64_t lhsRows = lhsType.getDimSize(0);
call    0 never executed
    #####: 1484:  int64_t lhsColumns = lhsType.getDimSize(1);
call    0 never executed
    #####: 1485:  int64_t rhsColumns = rhsType.getDimSize(1);
call    0 never executed
        -: 1486:
    #####: 1487:  Type flattenedLHSType =
    #####: 1488:      VectorType::get(lhsType.getNumElements(), lhsType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1489:  lhs = rew.create<vector::ShapeCastOp>(loc, flattenedLHSType, lhs);
call    0 never executed
call    1 never executed
        -: 1490:
    #####: 1491:  Type flattenedRHSType =
    #####: 1492:      VectorType::get(rhsType.getNumElements(), rhsType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1493:  rhs = rew.create<vector::ShapeCastOp>(loc, flattenedRHSType, rhs);
call    0 never executed
call    1 never executed
        -: 1494:
    #####: 1495:  Value mul = rew.create<vector::MatmulOp>(loc, lhs, rhs, lhsRows, lhsColumns,
    #####: 1496:                                           rhsColumns);
call    0 never executed
call    1 never executed
    #####: 1497:  mul = rew.create<vector::ShapeCastOp>(
        -: 1498:      loc,
    #####: 1499:      VectorType::get({lhsRows, rhsColumns},
    #####: 1500:                      getElementTypeOrSelf(op.getAcc().getType())),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1501:      mul);
call    0 never executed
call    1 never executed
        -: 1502:
        -: 1503:  // ACC must be C(m, n) or C(n, m).
    #####: 1504:  auto accMap = op.getIndexingMapsArray()[2];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1505:  if (accMap == AffineMap::get(3, 0, {n, m}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1506:    mul = rew.create<vector::TransposeOp>(loc, mul, ArrayRef<int64_t>{1, 0});
call    0 never executed
    #####: 1507:  else if (accMap != AffineMap::get(3, 0, {m, n}, ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1508:    llvm_unreachable("invalid contraction semantics");
call    0 never executed
        -: 1509:
    #####: 1510:  Value res =
call    0 never executed
    #####: 1511:      elementType.isa<IntegerType>()
    #####: 1512:          ? static_cast<Value>(rew.create<arith::AddIOp>(loc, op.getAcc(), mul))
call    0 never executed
call    1 never executed
        -: 1513:          : static_cast<Value>(
    #####: 1514:                rew.create<arith::AddFOp>(loc, op.getAcc(), mul));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1515:
    #####: 1516:  rew.replaceOp(op, res);
call    0 never executed
call    1 never executed
    #####: 1517:  return success();
        -: 1518:}
        -: 1519:
        -: 1520:namespace {
        -: 1521:struct IteratorType {
        -: 1522:  IteratorType(StringRef strRef) : strRef(strRef) {}
        -: 1523:  bool isOfType(Attribute attr) const {
        -: 1524:    auto sAttr = attr.dyn_cast<StringAttr>();
        -: 1525:    return sAttr && sAttr.getValue() == strRef;
        -: 1526:  }
        -: 1527:  StringRef strRef;
        -: 1528:};
        -: 1529:struct Par : public IteratorType {
        -: 1530:  Par() : IteratorType(getParallelIteratorTypeName()) {}
        -: 1531:};
        -: 1532:struct Red : public IteratorType {
        -: 1533:  Red() : IteratorType(getReductionIteratorTypeName()) {}
        -: 1534:};
        -: 1535:
        -: 1536:/// Generate a vector implementation for matmat, matvec and tmatvec.
        -: 1537:/// This unrolls outer-products along the reduction dimension.
    #####: 1538:struct UnrolledOuterProductGenerator
        -: 1539:    : public StructuredGenerator<vector::ContractionOp> {
function _ZN4mlir12_GLOBAL__N_129UnrolledOuterProductGeneratorC2ERNS_9OpBuilderENS_6vector13ContractionOpE called 0 returned 0% blocks executed 0%
    #####: 1540:  UnrolledOuterProductGenerator(OpBuilder &builder, vector::ContractionOp op)
    #####: 1541:      : StructuredGenerator<vector::ContractionOp>(builder, op),
    #####: 1542:        kind(op.getKind()), lhs(op.getLhs()), rhs(op.getRhs()),
call    0 never executed
    #####: 1543:        res(op.getAcc()), lhsType(op.getLhsType()) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1544:
    #####: 1545:  Value t(Value v) {
    #####: 1546:    static constexpr std::array<int64_t, 2> perm = {1, 0};
    #####: 1547:    return builder.create<vector::TransposeOp>(loc, v, perm);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -: 1548:  }
        -: 1549:
        -: 1550:  Value promote(Value v, Type dstElementType) {
        -: 1551:    Type elementType = v.getType();
        -: 1552:    auto vecType = elementType.dyn_cast<VectorType>();
        -: 1553:    if (vecType)
        -: 1554:      elementType = vecType.getElementType();
        -: 1555:    if (elementType == dstElementType)
        -: 1556:      return v;
        -: 1557:    Type promotedType = dstElementType;
        -: 1558:    if (vecType)
        -: 1559:      promotedType = VectorType::get(vecType.getShape(), promotedType);
        -: 1560:    if (dstElementType.isa<FloatType>())
        -: 1561:      return builder.create<arith::ExtFOp>(loc, promotedType, v);
        -: 1562:    return builder.create<arith::ExtSIOp>(loc, promotedType, v);
        -: 1563:  }
        -: 1564:
function _ZN4mlir12_GLOBAL__N_129UnrolledOuterProductGenerator9outerProdENS_5ValueES2_S2_i called 0 returned 0% blocks executed 0%
    #####: 1565:  Value outerProd(Value lhs, Value rhs, Value res, int reductionSize) {
    #####: 1566:    assert(reductionSize > 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1567:    Type resElementType = res.getType().cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 1568:    for (int64_t k = 0; k < reductionSize; ++k) {
branch  0 never executed
branch  1 never executed
    #####: 1569:      Value a = builder.create<vector::ExtractOp>(loc, lhs, k);
call    0 never executed
call    1 never executed
    #####: 1570:      Value b = builder.create<vector::ExtractOp>(loc, rhs, k);
call    0 never executed
call    1 never executed
    #####: 1571:      a = promote(a, resElementType);
call    0 never executed
    #####: 1572:      b = promote(b, resElementType);
call    0 never executed
    #####: 1573:      res = builder.create<vector::OuterProductOp>(loc, res.getType(), a, b,
    #####: 1574:                                                   res, kind);
call    0 never executed
        -: 1575:    }
    #####: 1576:    return res;
        -: 1577:  }
        -: 1578:
        -: 1579:  /// Two outer parallel, one inner reduction (matmat flavor).
function _ZN4mlir12_GLOBAL__N_129UnrolledOuterProductGenerator6matmatEv called 0 returned 0% blocks executed 0%
    #####: 1580:  FailureOr<Value> matmat() {
    #####: 1581:    if (!iters({Par(), Par(), Red()}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1582:      return failure();
        -: 1583:    // Set up the parallel/reduction structure in the right form.
    #####: 1584:    AffineExpr m, n, k;
    #####: 1585:    bindDims(builder.getContext(), m, n, k);
call    0 never executed
        -: 1586:    // Classical row-major matmul:  Just permute the lhs.
    #####: 1587:    if (layout({{m, k}, {k, n}, {m, n}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1588:      return outerProd(t(lhs), rhs, res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1589:    // TODO: may be better to fail and use some vector<k> -> scalar reduction.
    #####: 1590:    if (layout({{m, k}, {n, k}, {m, n}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1591:      Value tlhs = t(lhs);
call    0 never executed
    #####: 1592:      return outerProd(tlhs, t(rhs), res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1593:    }
        -: 1594:    // No need to permute anything.
    #####: 1595:    if (layout({{k, m}, {k, n}, {m, n}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1596:      return outerProd(lhs, rhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
        -: 1597:    // Just permute the rhs.
    #####: 1598:    if (layout({{k, m}, {n, k}, {m, n}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1599:      return outerProd(lhs, t(rhs), res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1600:    // Transposed output: swap RHS and LHS.
        -: 1601:    // Classical row-major matmul: permute the lhs.
    #####: 1602:    if (layout({{m, k}, {k, n}, {n, m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1603:      return outerProd(rhs, t(lhs), res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1604:    // TODO: may be better to fail and use some vector<k> -> scalar reduction.
    #####: 1605:    if (layout({{m, k}, {n, k}, {n, m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1606:      Value trhs = t(rhs);
call    0 never executed
    #####: 1607:      return outerProd(trhs, t(lhs), res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1608:    }
    #####: 1609:    if (layout({{k, m}, {k, n}, {n, m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1610:      return outerProd(rhs, lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
    #####: 1611:    if (layout({{k, m}, {n, k}, {n, m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1612:      return outerProd(t(rhs), lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1613:    return failure();
        -: 1614:  }
        -: 1615:
        -: 1616:  /// One outer parallel, one inner reduction (matvec flavor)
function _ZN4mlir12_GLOBAL__N_129UnrolledOuterProductGenerator6matvecEv called 0 returned 0% blocks executed 0%
    #####: 1617:  FailureOr<Value> matvec() {
    #####: 1618:    if (!iters({Par(), Red()}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1619:      return failure();
    #####: 1620:    AffineExpr m, k;
    #####: 1621:    bindDims(builder.getContext(), m, k);
call    0 never executed
        -: 1622:
        -: 1623:    // Case mat-vec: transpose.
    #####: 1624:    if (layout({{m, k}, {k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1625:      return outerProd(t(lhs), rhs, res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1626:    // Case mat-trans-vec: ready to go.
    #####: 1627:    if (layout({{k, m}, {k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1628:      return outerProd(lhs, rhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
        -: 1629:    // Case vec-mat: swap and transpose.
    #####: 1630:    if (layout({{k}, {m, k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1631:      return outerProd(t(rhs), lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1632:    // Case vec-mat-trans: swap and ready to go.
    #####: 1633:    if (layout({{k}, {k, m}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1634:      return outerProd(rhs, lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
    #####: 1635:    return failure();
        -: 1636:  }
        -: 1637:
        -: 1638:  //
        -: 1639:  // One outer reduction, one inner parallel (tmatvec flavor)
        -: 1640:  //
function _ZN4mlir12_GLOBAL__N_129UnrolledOuterProductGenerator7tmatvecEv called 0 returned 0% blocks executed 0%
    #####: 1641:  FailureOr<Value> tmatvec() {
    #####: 1642:    if (!iters({Red(), Par()}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1643:      return failure();
    #####: 1644:    AffineExpr k, m;
    #####: 1645:    bindDims(builder.getContext(), k, m);
call    0 never executed
        -: 1646:
        -: 1647:    // Case mat-vec: transpose.
    #####: 1648:    if (layout({{m, k}, {k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1649:      return outerProd(t(lhs), rhs, res, lhsType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1650:    // Case mat-trans-vec: ready to go.
    #####: 1651:    if (layout({{k, m}, {k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1652:      return outerProd(lhs, rhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
        -: 1653:    // Case vec-mat: swap and transpose.
    #####: 1654:    if (layout({{k}, {m, k}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1655:      return outerProd(t(rhs), lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1656:    // Case vec-mat-trans: swap and ready to go.
    #####: 1657:    if (layout({{k}, {k, m}, {m}}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1658:      return outerProd(rhs, lhs, res, lhsType.getDimSize(0));
call    0 never executed
call    1 never executed
    #####: 1659:    return failure();
        -: 1660:  }
        -: 1661:
        -: 1662:private:
        -: 1663:  vector::CombiningKind kind;
        -: 1664:  Value lhs, rhs, res;
        -: 1665:  VectorType lhsType;
        -: 1666:};
        -: 1667:} // namespace
        -: 1668:
        -: 1669:/// Progressively lower a `vector.contract %a, %b, %c` with row-major matmul
        -: 1670:/// semantics to a reduction_size-unrolled sequence:
        -: 1671:/// ```
        -: 1672:///    %at = vector.transpose %a, [1, 0]
        -: 1673:///    %bRow0 = vector.extract %b[0]
        -: 1674:///    %atRow0 = vector.extract %at[0]
        -: 1675:///    %c0 = vector.outerproduct %atRow0, %bRow0, %c
        -: 1676:///    ...
        -: 1677:///    %bRowK = vector.extract %b[K]
        -: 1678:///    %atRowK = vector.extract %at[K]
        -: 1679:///    %cK = vector.outerproduct %atRowK, %bRowK, %cK-1
        -: 1680:/// ```
        -: 1681:///
        -: 1682:/// This only kicks in when VectorTransformsOptions is set to OuterProduct but
        -: 1683:/// otherwise supports any layout permutation of the matrix-multiply.
function _ZNK4mlir6vector37ContractionOpToOuterProductOpLowering15matchAndRewriteENS0_13ContractionOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1684:LogicalResult ContractionOpToOuterProductOpLowering::matchAndRewrite(
        -: 1685:    vector::ContractionOp op, PatternRewriter &rewriter) const {
        -: 1686:  // TODO: implement masks
    #####: 1687:  if (!op.getMasks().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1688:    return failure();
        -: 1689:
    #####: 1690:  if (vectorTransformOptions.vectorContractLowering !=
branch  0 never executed
branch  1 never executed
        -: 1691:      vector::VectorContractLowering::OuterProduct)
    #####: 1692:    return failure();
        -: 1693:
    #####: 1694:  if (failed(filter(op)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1695:    return failure();
        -: 1696:
    #####: 1697:  UnrolledOuterProductGenerator e(rewriter, op);
call    0 never executed
    #####: 1698:  FailureOr<Value> matmatRes = e.matmat();
call    0 never executed
    #####: 1699:  if (succeeded(matmatRes)) {
branch  0 never executed
branch  1 never executed
    #####: 1700:    rewriter.replaceOp(op, *matmatRes);
call    0 never executed
call    1 never executed
    #####: 1701:    return success();
        -: 1702:  }
    #####: 1703:  FailureOr<Value> matvecRes = e.matvec();
call    0 never executed
    #####: 1704:  if (succeeded(matvecRes)) {
branch  0 never executed
branch  1 never executed
    #####: 1705:    rewriter.replaceOp(op, *matvecRes);
call    0 never executed
call    1 never executed
    #####: 1706:    return success();
        -: 1707:  }
    #####: 1708:  FailureOr<Value> tmatvecRes = e.tmatvec();
call    0 never executed
    #####: 1709:  if (succeeded(tmatvecRes)) {
branch  0 never executed
branch  1 never executed
    #####: 1710:    rewriter.replaceOp(op, *tmatvecRes);
call    0 never executed
call    1 never executed
    #####: 1711:    return success();
        -: 1712:  }
        -: 1713:
    #####: 1714:  return failure();
call    0 never executed
        -: 1715:}
        -: 1716:
        -: 1717:LogicalResult
function _ZNK4mlir6vector26ContractionOpToDotLowering15matchAndRewriteENS0_13ContractionOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1718:ContractionOpToDotLowering::matchAndRewrite(vector::ContractionOp op,
        -: 1719:                                            PatternRewriter &rewriter) const {
        -: 1720:  // TODO: implement masks
    #####: 1721:  if (!op.getMasks().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1722:    return failure();
        -: 1723:
    #####: 1724:  if (failed(filter(op)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1725:    return failure();
        -: 1726:
    #####: 1727:  if (vectorTransformOptions.vectorContractLowering !=
branch  0 never executed
branch  1 never executed
        -: 1728:      vector::VectorContractLowering::Dot)
    #####: 1729:    return failure();
        -: 1730:
    #####: 1731:  auto iteratorTypes = op.getIteratorTypes().getValue();
call    0 never executed
call    1 never executed
    #####: 1732:  static constexpr std::array<int64_t, 2> perm = {1, 0};
    #####: 1733:  Location loc = op.getLoc();
call    0 never executed
    #####: 1734:  Value lhs = op.getLhs(), rhs = op.getRhs();
call    0 never executed
call    1 never executed
        -: 1735:
    #####: 1736:  using MapList = ArrayRef<ArrayRef<AffineExpr>>;
    #####: 1737:  auto infer = [](MapList m) { return AffineMap::inferFromExprList(m); };
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####: 1738:  AffineExpr m, n, k;
    #####: 1739:  bindDims(rewriter.getContext(), m, n, k);
call    0 never executed
    #####: 1740:  SmallVector<AffineMap, 4> maps = op.getIndexingMapsArray();
call    0 never executed
        -: 1741:  //
        -: 1742:  // In the following we wish to make the reduction dimension innermost so we
        -: 1743:  // can load vectors and just fmul + reduce into a scalar.
        -: 1744:  //
    #####: 1745:  if (isParallelIterator(iteratorTypes[0]) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1746:      isParallelIterator(iteratorTypes[1]) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1747:      isReductionIterator(iteratorTypes[2])) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1748:    //
        -: 1749:    // Two outer parallel, one inner reduction (matmat flavor).
        -: 1750:    //
    #####: 1751:    if (maps == infer({{m, k}, {k, n}, {m, n}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1752:      rhs = rewriter.create<vector::TransposeOp>(loc, rhs, perm);
call    0 never executed
    #####: 1753:    } else if (maps == infer({{m, k}, {n, k}, {m, n}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1754:      // No need to permute anything.
    #####: 1755:    } else if (maps == infer({{k, m}, {k, n}, {m, n}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1756:      lhs = rewriter.create<vector::TransposeOp>(loc, lhs, perm);
call    0 never executed
call    1 never executed
    #####: 1757:      rhs = rewriter.create<vector::TransposeOp>(loc, rhs, perm);
call    0 never executed
    #####: 1758:    } else if (maps == infer({{k, m}, {n, k}, {m, n}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1759:      lhs = rewriter.create<vector::TransposeOp>(loc, lhs, perm);
call    0 never executed
    #####: 1760:    } else if (maps == infer({{m, k}, {k, n}, {n, m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1761:      // This is the classical row-major matmul. Just permute the lhs.
    #####: 1762:      Value tmp = lhs;
    #####: 1763:      lhs = rewriter.create<vector::TransposeOp>(loc, rhs, perm);
call    0 never executed
    #####: 1764:      rhs = tmp;
    #####: 1765:    } else if (maps == infer({{m, k}, {n, k}, {n, m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1766:      std::swap(lhs, rhs);
    #####: 1767:    } else if (maps == infer({{k, m}, {k, n}, {n, m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1768:      Value tmp = lhs;
    #####: 1769:      lhs = rewriter.create<vector::TransposeOp>(loc, rhs, perm);
call    0 never executed
call    1 never executed
    #####: 1770:      rhs = rewriter.create<vector::TransposeOp>(loc, tmp, perm);
call    0 never executed
    #####: 1771:    } else if (maps == infer({{k, m}, {n, k}, {n, m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1772:      Value tmp = rhs;
    #####: 1773:      rhs = rewriter.create<vector::TransposeOp>(loc, lhs, perm);
call    0 never executed
    #####: 1774:      lhs = tmp;
        -: 1775:    } else {
    #####: 1776:      return failure();
        -: 1777:    }
    #####: 1778:  } else if (isParallelIterator(iteratorTypes[0]) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1779:             isReductionIterator(iteratorTypes[1])) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1780:    //
        -: 1781:    // One outer parallel, one inner reduction (matvec flavor)
        -: 1782:    //
    #####: 1783:    if (maps == infer({{m, n}, {n}, {m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1784:      // No need to permute anything.
    #####: 1785:    } else if (maps == infer({{n, m}, {n}, {m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1786:      lhs = rewriter.create<vector::TransposeOp>(loc, lhs, perm);
call    0 never executed
    #####: 1787:    } else if (maps == infer({{n}, {m, n}, {m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1788:      std::swap(lhs, rhs);
    #####: 1789:    } else if (maps == infer({{n}, {n, m}, {m}})) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1790:      std::swap(lhs, rhs);
call    0 never executed
    #####: 1791:      lhs = rewriter.create<vector::TransposeOp>(loc, lhs, perm);
call    0 never executed
        -: 1792:    } else {
    #####: 1793:      return failure();
        -: 1794:    }
        -: 1795:  } else {
    #####: 1796:    return failure();
        -: 1797:  }
        -: 1798:
    #####: 1799:  VectorType dstType = op.getResultType().cast<VectorType>();
call    0 never executed
    #####: 1800:  assert(dstType.getRank() >= 1 && dstType.getRank() <= 2 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1801:         "Expected dst type of rank 1 or 2");
        -: 1802:
    #####: 1803:  unsigned rank = dstType.getRank();
call    0 never executed
    #####: 1804:  unsigned dstRows = dstType.getShape()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1805:  unsigned dstColumns = rank == 1 ? 1 : dstType.getShape()[1];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1806:
        -: 1807:  // ExtractOp does not allow dynamic indexing, we must unroll explicitly.
    #####: 1808:  Value res = rewriter.create<arith::ConstantOp>(loc, dstType,
    #####: 1809:                                                 rewriter.getZeroAttr(dstType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1810:  bool isInt = dstType.getElementType().isa<IntegerType>();
call    0 never executed
call    1 never executed
    #####: 1811:  for (unsigned r = 0; r < dstRows; ++r) {
branch  0 never executed
branch  1 never executed
    #####: 1812:    Value a = rewriter.create<vector::ExtractOp>(op.getLoc(), lhs, r);
call    0 never executed
    #####: 1813:    for (unsigned c = 0; c < dstColumns; ++c) {
branch  0 never executed
branch  1 never executed
    #####: 1814:      Value b = rank == 1
        -: 1815:                    ? rhs
    #####: 1816:                    : rewriter.create<vector::ExtractOp>(op.getLoc(), rhs, c);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1817:      Value m = createMul(op.getLoc(), a, b, isInt, rewriter);
call    0 never executed
    #####: 1818:      Value reduced = rewriter.create<vector::ReductionOp>(
    #####: 1819:          op.getLoc(), vector::CombiningKind::ADD, m);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1820:
    #####: 1821:      SmallVector<int64_t, 2> pos = rank == 1 ? SmallVector<int64_t, 2>{r}
    #####: 1822:                                              : SmallVector<int64_t, 2>{r, c};
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1823:      res = rewriter.create<vector::InsertOp>(op.getLoc(), reduced, res, pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1824:    }
        -: 1825:  }
    #####: 1826:  if (auto acc = op.getAcc())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1827:    res = createAdd(op.getLoc(), res, acc, isInt, rewriter);
call    0 never executed
    #####: 1828:  rewriter.replaceOp(op, res);
call    0 never executed
call    1 never executed
    #####: 1829:  return success();
branch  0 never executed
branch  1 never executed
        -: 1830:}
        -: 1831:
        -: 1832:/// Progressive lowering of ContractionOp.
        -: 1833:/// One:
        -: 1834:///   %x = vector.contract with at least one free/batch dimension
        -: 1835:/// is replaced by:
        -: 1836:///   %a = vector.contract with one less free/batch dimension
        -: 1837:///   %b = vector.contract with one less free/batch dimension
        -: 1838:///   ..
        -: 1839:///   %x = combine %a %b ..
        -: 1840:/// until a pure contraction is reached (no free/batch dimensions),
        -: 1841:/// which is replaced by a dot-product.
        -: 1842:///
        -: 1843:/// This only kicks in when either VectorTransformsOptions is set
        -: 1844:/// to DOT or when other contraction patterns fail.
        -: 1845://
        -: 1846:// TODO: break down into transpose/reshape/cast ops
        -: 1847://               when they become available to avoid code dup
        -: 1848:// TODO: investigate lowering order impact on performance
        -: 1849:LogicalResult
function _ZNK4mlir6vector21ContractionOpLowering15matchAndRewriteENS0_13ContractionOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1850:ContractionOpLowering::matchAndRewrite(vector::ContractionOp op,
        -: 1851:                                       PatternRewriter &rewriter) const {
        -: 1852:  // TODO: implement masks.
    #####: 1853:  if (!op.getMasks().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1854:    return failure();
        -: 1855:
    #####: 1856:  if (failed(filter(op)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1857:    return failure();
        -: 1858:
        -: 1859:  // TODO: support mixed mode contract lowering.
    #####: 1860:  if (op.getLhsType().getElementType() !=
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1861:          getElementTypeOrSelf(op.getAccType()) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1862:      op.getRhsType().getElementType() != getElementTypeOrSelf(op.getAccType()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1863:    return failure();
        -: 1864:
        -: 1865:  // TODO: the code below assumes the default contraction, make sure it supports
        -: 1866:  // other kinds before enabling this lowering.
    #####: 1867:  if (op.getKind() != vector::CombiningKind::ADD) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1868:    return rewriter.notifyMatchFailure(
    #####: 1869:        op, "contractions other than 'add' not supported");
call    0 never executed
        -: 1870:  }
        -: 1871:
        -: 1872:  // TODO: implement benefits, cost models.
    #####: 1873:  MLIRContext *ctx = op.getContext();
call    0 never executed
    #####: 1874:  ContractionOpToMatmulOpLowering pat1(vectorTransformOptions, ctx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1875:  if (succeeded(pat1.matchAndRewrite(op, rewriter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1876:    return success();
call    0 never executed
    #####: 1877:  ContractionOpToOuterProductOpLowering pat2(vectorTransformOptions, ctx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1878:  if (succeeded(pat2.matchAndRewrite(op, rewriter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1879:    return success();
call    0 never executed
    #####: 1880:  ContractionOpToDotLowering pat3(vectorTransformOptions, ctx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1881:  if (succeeded(pat3.matchAndRewrite(op, rewriter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1882:    return success();
call    0 never executed
    #####: 1883:  ContractOpToElementwise pat4(vectorTransformOptions, ctx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1884:  if (succeeded(pat4.matchAndRewrite(op, rewriter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1885:    return success();
        -: 1886:
        -: 1887:  // Find first batch dimension in LHS/RHS, and lower when found.
    #####: 1888:  std::vector<std::pair<int64_t, int64_t>> batchDimMap = op.getBatchDimMap();
call    0 never executed
call    1 never executed
    #####: 1889:  if (!batchDimMap.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1890:    int64_t lhsIndex = batchDimMap[0].first;
call    0 never executed
    #####: 1891:    int64_t rhsIndex = batchDimMap[0].second;
    #####: 1892:    auto newOp = lowerParallel(op, lhsIndex, rhsIndex, rewriter);
call    0 never executed
    #####: 1893:    if (failed(newOp))
branch  0 never executed
branch  1 never executed
    #####: 1894:      return failure();
    #####: 1895:    rewriter.replaceOp(op, newOp.value());
call    0 never executed
call    1 never executed
    #####: 1896:    return success();
        -: 1897:  }
        -: 1898:
        -: 1899:  // Collect contracting dimensions.
    #####: 1900:  std::vector<std::pair<int64_t, int64_t>> contractingDimMap =
    #####: 1901:      op.getContractingDimMap();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1902:  DenseSet<int64_t> lhsContractingDimSet;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1903:  DenseSet<int64_t> rhsContractingDimSet;
call    0 never executed
call    1 never executed
    #####: 1904:  for (auto &dimPair : contractingDimMap) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1905:    lhsContractingDimSet.insert(dimPair.first);
call    0 never executed
    #####: 1906:    rhsContractingDimSet.insert(dimPair.second);
call    0 never executed
        -: 1907:  }
        -: 1908:
        -: 1909:  // Find first free dimension in LHS, and lower when found.
    #####: 1910:  VectorType lhsType = op.getLhsType();
call    0 never executed
    #####: 1911:  for (int64_t lhsIndex = 0, e = lhsType.getRank(); lhsIndex < e; ++lhsIndex) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1912:    if (lhsContractingDimSet.count(lhsIndex) == 0) {
call    0 never executed
    #####: 1913:      auto newOp = lowerParallel(op, lhsIndex, /*rhsIndex=*/-1, rewriter);
call    0 never executed
    #####: 1914:      if (failed(newOp))
branch  0 never executed
branch  1 never executed
    #####: 1915:        return failure();
    #####: 1916:      rewriter.replaceOp(op, newOp.value());
call    0 never executed
call    1 never executed
    #####: 1917:      return success();
        -: 1918:    }
        -: 1919:  }
        -: 1920:
        -: 1921:  // Find first free dimension in RHS, and lower when found.
    #####: 1922:  VectorType rhsType = op.getRhsType();
call    0 never executed
    #####: 1923:  for (int64_t rhsIndex = 0, e = rhsType.getRank(); rhsIndex < e; ++rhsIndex) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1924:    if (rhsContractingDimSet.count(rhsIndex) == 0) {
call    0 never executed
    #####: 1925:      auto newOp = lowerParallel(op, /*lhsIndex=*/-1, rhsIndex, rewriter);
call    0 never executed
    #####: 1926:      if (failed(newOp))
branch  0 never executed
branch  1 never executed
    #####: 1927:        return failure();
    #####: 1928:      rewriter.replaceOp(op, newOp.value());
call    0 never executed
call    1 never executed
    #####: 1929:      return success();
        -: 1930:    }
        -: 1931:  }
        -: 1932:
        -: 1933:  // Lower the first remaining reduction dimension.
    #####: 1934:  if (!contractingDimMap.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1935:    auto newOp = lowerReduction(op, rewriter);
call    0 never executed
    #####: 1936:    if (failed(newOp))
branch  0 never executed
branch  1 never executed
    #####: 1937:      return failure();
    #####: 1938:    rewriter.replaceOp(op, newOp.value());
call    0 never executed
call    1 never executed
    #####: 1939:    return success();
        -: 1940:  }
        -: 1941:
    #####: 1942:  return failure();
call    0 never executed
        -: 1943:}
        -: 1944:
        -: 1945:// Lower one parallel dimension.
        -: 1946:// Incidentally also tolerates unit-size (hence trivial) reduction dimensions.
        -: 1947:// TODO: consider reusing existing contract unrolling
        -: 1948:FailureOr<Value>
function _ZNK4mlir6vector21ContractionOpLowering13lowerParallelENS0_13ContractionOpEllRNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1949:ContractionOpLowering::lowerParallel(vector::ContractionOp op, int64_t lhsIndex,
        -: 1950:                                     int64_t rhsIndex,
        -: 1951:                                     PatternRewriter &rewriter) const {
    #####: 1952:  VectorType lhsType = op.getLhsType();
call    0 never executed
    #####: 1953:  VectorType rhsType = op.getRhsType();
call    0 never executed
    #####: 1954:  VectorType resType = op.getResultType().cast<VectorType>();
call    0 never executed
        -: 1955:  // Find the iterator type index and result index.
    #####: 1956:  SmallVector<AffineMap, 4> iMap = op.getIndexingMapsArray();
call    0 never executed
    #####: 1957:  int64_t iterIndex = -1;
    #####: 1958:  int64_t dimSize = -1;
    #####: 1959:  if (lhsIndex >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 1960:    iterIndex = iMap[0].getDimPosition(lhsIndex);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1961:    if (rhsIndex >= 0 && iterIndex != iMap[1].getDimPosition(rhsIndex))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
function _ZZNK4mlir6vector21ContractionOpLowering13lowerParallelENS0_13ContractionOpEllRNS_15PatternRewriterEENKUlRNS_10DiagnosticEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1962:      return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 1963:        diag << "expected lhsIndex=" << lhsIndex << " and rhsIndex=" << rhsIndex
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1964:             << " to map to the same dimension";
call    0 never executed
    #####: 1965:      });
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1966:    dimSize = lhsType.getDimSize(lhsIndex);
call    0 never executed
    #####: 1967:  } else if (rhsIndex >= 0) {
branch  0 never executed
branch  1 never executed
    #####: 1968:    iterIndex = iMap[1].getDimPosition(rhsIndex);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1969:    dimSize = rhsType.getDimSize(rhsIndex);
call    0 never executed
        -: 1970:  }
    #####: 1971:  if (iterIndex < 0)
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir6vector21ContractionOpLowering13lowerParallelENS0_13ContractionOpEllRNS_15PatternRewriterEENKUlRNS_10DiagnosticEE0_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1972:    return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 1973:      diag << "expected either lhsIndex=" << lhsIndex
call    0 never executed
call    1 never executed
    #####: 1974:           << " or rhsIndex=" << rhsIndex << " to be nonnegative";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1975:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1976:  // value_or(-1) means that we tolerate a dimension not appearing
        -: 1977:  // in the result map. That can't happen for actual parallel iterators, but
        -: 1978:  // the caller ContractionOpLowering::matchAndRewrite is currently calling
        -: 1979:  // lowerParallel also for the case of unit-size reduction dims appearing only
        -: 1980:  // on one of LHS or RHS, not both. At the moment, such cases are created by
        -: 1981:  // CastAwayContractionLeadingOneDim, so we need to either support that or
        -: 1982:  // modify that pattern.
    #####: 1983:  int64_t resIndex = getResultIndex(iMap[2], iterIndex).value_or(-1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1984:  if (resIndex == -1 && dimSize != 1)
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir6vector21ContractionOpLowering13lowerParallelENS0_13ContractionOpEllRNS_15PatternRewriterEENKUlRNS_10DiagnosticEE1_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1985:    return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 1986:      diag << "expected the dimension for iterIndex=" << iterIndex
call    0 never executed
call    1 never executed
    #####: 1987:           << " to either appear in the result map, or to be a unit dimension";
call    0 never executed
    #####: 1988:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1989:  // Construct new iterator types and affine map array attribute.
    #####: 1990:  std::array<AffineMap, 3> lowIndexingMaps = {
    #####: 1991:      adjustMap(iMap[0], iterIndex, rewriter),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1992:      adjustMap(iMap[1], iterIndex, rewriter),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1993:      adjustMap(iMap[2], iterIndex, rewriter)};
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1994:  auto lowAffine = rewriter.getAffineMapArrayAttr(lowIndexingMaps);
call    0 never executed
    #####: 1995:  auto lowIter =
    #####: 1996:      rewriter.getArrayAttr(adjustIter(op.getIteratorTypes(), iterIndex));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1997:  // Unroll into a series of lower dimensional vector.contract ops.
    #####: 1998:  Location loc = op.getLoc();
call    0 never executed
    #####: 1999:  Value result = rewriter.create<arith::ConstantOp>(
    #####: 2000:      loc, resType, rewriter.getZeroAttr(resType));
call    0 never executed
call    1 never executed
    #####: 2001:  for (int64_t d = 0; d < dimSize; ++d) {
branch  0 never executed
branch  1 never executed
    #####: 2002:    auto lhs = reshapeLoad(loc, op.getLhs(), lhsType, lhsIndex, d, rewriter);
call    0 never executed
call    1 never executed
    #####: 2003:    auto rhs = reshapeLoad(loc, op.getRhs(), rhsType, rhsIndex, d, rewriter);
call    0 never executed
call    1 never executed
    #####: 2004:    auto acc = reshapeLoad(loc, op.getAcc(), resType, resIndex, d, rewriter);
call    0 never executed
call    1 never executed
    #####: 2005:    Value lowContract = rewriter.create<vector::ContractionOp>(
    #####: 2006:        loc, lhs, rhs, acc, lowAffine, lowIter);
call    0 never executed
call    1 never executed
    #####: 2007:    result =
    #####: 2008:        reshapeStore(loc, lowContract, result, resType, resIndex, d, rewriter);
call    0 never executed
        -: 2009:  }
    #####: 2010:  return result;
        -: 2011:}
        -: 2012:
        -: 2013:// Lower one reduction dimension.
        -: 2014:FailureOr<Value>
function _ZNK4mlir6vector21ContractionOpLowering14lowerReductionENS0_13ContractionOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2015:ContractionOpLowering::lowerReduction(vector::ContractionOp op,
        -: 2016:                                      PatternRewriter &rewriter) const {
    #####: 2017:  auto loc = op.getLoc();
call    0 never executed
    #####: 2018:  VectorType lhsType = op.getLhsType();
call    0 never executed
    #####: 2019:  VectorType rhsType = op.getRhsType();
call    0 never executed
    #####: 2020:  Type resType = op.getResultType();
call    0 never executed
    #####: 2021:  if (resType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2022:    return rewriter.notifyMatchFailure(op,
    #####: 2023:                                       "did not expect a VectorType result");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2024:  bool isInt = resType.isa<IntegerType>();
call    0 never executed
        -: 2025:  // Use iterator index 0.
    #####: 2026:  int64_t iterIndex = 0;
    #####: 2027:  SmallVector<AffineMap, 4> iMap = op.getIndexingMapsArray();
call    0 never executed
    #####: 2028:  Optional<int64_t> lookupLhs = getResultIndex(iMap[0], iterIndex);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2029:  Optional<int64_t> lookupRhs = getResultIndex(iMap[1], iterIndex);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2030:  if (!lookupLhs.has_value())
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir6vector21ContractionOpLowering14lowerReductionENS0_13ContractionOpERNS_15PatternRewriterEENKUlRNS_10DiagnosticEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2031:    return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 2032:      diag << "expected iterIndex=" << iterIndex << "to map to a LHS dimension";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2033:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2034:  if (!lookupRhs.has_value())
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir6vector21ContractionOpLowering14lowerReductionENS0_13ContractionOpERNS_15PatternRewriterEENKUlRNS_10DiagnosticEE0_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2035:    return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 2036:      diag << "expected iterIndex=" << iterIndex << "to map to a RHS dimension";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2037:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2038:  int64_t lhsIndex = lookupLhs.value();
call    0 never executed
    #####: 2039:  int64_t rhsIndex = lookupRhs.value();
    #####: 2040:  int64_t dimSize = lhsType.getDimSize(lhsIndex);
call    0 never executed
    #####: 2041:  if (dimSize != rhsType.getDimSize(rhsIndex))
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZNK4mlir6vector21ContractionOpLowering14lowerReductionENS0_13ContractionOpERNS_15PatternRewriterEENKUlRNS_10DiagnosticEE1_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2042:    return rewriter.notifyMatchFailure(op, [&](Diagnostic &diag) {
    #####: 2043:      diag << "expect LHS dimension " << lhsIndex
call    0 never executed
call    1 never executed
    #####: 2044:           << " to have the same size as RHS dimension " << rhsIndex;
call    0 never executed
call    1 never executed
    #####: 2045:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2046:  // Base case.
    #####: 2047:  if (lhsType.getRank() == 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2048:    if (rhsType.getRank() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2049:      return rewriter.notifyMatchFailure(
    #####: 2050:          op, "When LHS has rank 1, expected also RHS to have rank 1");
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2051:    Value m = createMul(loc, op.getLhs(), op.getRhs(), isInt, rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2052:    auto kind = vector::CombiningKind::ADD;
    #####: 2053:    if (auto acc = op.getAcc())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2054:      return rewriter.create<vector::ReductionOp>(loc, kind, m, acc)
call    0 never executed
    #####: 2055:          .getResult();
    #####: 2056:    return rewriter.create<vector::ReductionOp>(loc, kind, m).getResult();
call    0 never executed
        -: 2057:  }
        -: 2058:  // Construct new iterator types and affine map array attribute.
    #####: 2059:  std::array<AffineMap, 3> lowIndexingMaps = {
    #####: 2060:      adjustMap(iMap[0], iterIndex, rewriter),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2061:      adjustMap(iMap[1], iterIndex, rewriter),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2062:      adjustMap(iMap[2], iterIndex, rewriter)};
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2063:  auto lowAffine = rewriter.getAffineMapArrayAttr(lowIndexingMaps);
call    0 never executed
    #####: 2064:  auto lowIter =
    #####: 2065:      rewriter.getArrayAttr(adjustIter(op.getIteratorTypes(), iterIndex));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2066:  // Unroll into a series of lower dimensional vector.contract ops.
        -: 2067:  // By feeding the initial accumulator into the first contraction,
        -: 2068:  // and the result of each contraction into the next, eventually
        -: 2069:  // the sum of all reductions is computed.
    #####: 2070:  Value result = op.getAcc();
    #####: 2071:  for (int64_t d = 0; d < dimSize; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2072:    auto lhs = reshapeLoad(loc, op.getLhs(), lhsType, lhsIndex, d, rewriter);
call    0 never executed
call    1 never executed
    #####: 2073:    auto rhs = reshapeLoad(loc, op.getRhs(), rhsType, rhsIndex, d, rewriter);
call    0 never executed
call    1 never executed
    #####: 2074:    result = rewriter.create<vector::ContractionOp>(loc, lhs, rhs, result,
    #####: 2075:                                                    lowAffine, lowIter);
call    0 never executed
        -: 2076:  }
    #####: 2077:  return result;
        -: 2078:}
        -: 2079:
        -: 2080:} // namespace mlir
        -: 2081:
        -: 2082:/// Progressive lowering of transfer_read. This pattern supports lowering of
        -: 2083:/// `vector.transfer_read` to a combination of `vector.load` and
        -: 2084:/// `vector.broadcast` if all of the following hold:
        -: 2085:/// - Stride of most minor memref dimension must be 1.
        -: 2086:/// - Out-of-bounds masking is not required.
        -: 2087:/// - If the memref's element type is a vector type then it coincides with the
        -: 2088:///   result type.
        -: 2089:/// - The permutation map doesn't perform permutation (broadcasting is allowed).
        -: 2090:struct TransferReadToVectorLoadLowering
        -: 2091:    : public OpRewritePattern<vector::TransferReadOp> {
function _ZN32TransferReadToVectorLoadLoweringC2EPN4mlir11MLIRContextEN4llvm8OptionalIjEENS0_14PatternBenefitE called 3635 returned 100% blocks executed 100%
     3635: 2092:  TransferReadToVectorLoadLowering(MLIRContext *context,
        -: 2093:                                   llvm::Optional<unsigned> maxRank,
        -: 2094:                                   PatternBenefit benefit = 1)
     3635: 2095:      : OpRewritePattern<vector::TransferReadOp>(context, benefit),
     3635: 2096:        maxTransferRank(maxRank) {}
call    0 returned 100%
        -: 2097:
function _ZNK32TransferReadToVectorLoadLowering15matchAndRewriteEN4mlir6vector14TransferReadOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2098:  LogicalResult matchAndRewrite(vector::TransferReadOp read,
        -: 2099:                                PatternRewriter &rewriter) const override {
    #####: 2100:    if (maxTransferRank && read.getVectorType().getRank() > *maxTransferRank)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2101:      return failure();
        -: 2102:
    #####: 2103:    SmallVector<unsigned, 4> broadcastedDims;
call    0 never executed
        -: 2104:    // Permutations are handled by VectorToSCF or
        -: 2105:    // populateVectorTransferPermutationMapLoweringPatterns.
        -: 2106:    // We let the 0-d corner case pass-through as it is supported.
    #####: 2107:    if (!read.getPermutationMap().isMinorIdentityWithBroadcasting(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2108:            &broadcastedDims))
    #####: 2109:      return failure();
        -: 2110:
    #####: 2111:    auto memRefType = read.getShapedType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 2112:    if (!memRefType)
branch  0 never executed
branch  1 never executed
    #####: 2113:      return failure();
        -: 2114:
        -: 2115:    // Non-unit strides are handled by VectorToSCF.
    #####: 2116:    if (!vector::isLastMemrefDimUnitStride(memRefType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2117:      return failure();
        -: 2118:
        -: 2119:    // If there is broadcasting involved then we first load the unbroadcasted
        -: 2120:    // vector, and then broadcast it with `vector.broadcast`.
    #####: 2121:    ArrayRef<int64_t> vectorShape = read.getVectorType().getShape();
call    0 never executed
call    1 never executed
    #####: 2122:    SmallVector<int64_t, 4> unbroadcastedVectorShape(vectorShape.begin(),
    #####: 2123:                                                     vectorShape.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2124:    for (unsigned i : broadcastedDims)
branch  0 never executed
branch  1 never executed
    #####: 2125:      unbroadcastedVectorShape[i] = 1;
branch  0 never executed
branch  1 never executed
    #####: 2126:    VectorType unbroadcastedVectorType = VectorType::get(
    #####: 2127:        unbroadcastedVectorShape, read.getVectorType().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2128:
        -: 2129:    // `vector.load` supports vector types as memref's elements only when the
        -: 2130:    // resulting vector type is the same as the element type.
    #####: 2131:    auto memrefElTy = memRefType.getElementType();
call    0 never executed
    #####: 2132:    if (memrefElTy.isa<VectorType>() && memrefElTy != unbroadcastedVectorType)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2133:      return failure();
        -: 2134:
        -: 2135:    // Otherwise, element types of the memref and the vector must match.
    #####: 2136:    if (!memrefElTy.isa<VectorType>() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2137:        memrefElTy != read.getVectorType().getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2138:      return failure();
        -: 2139:
        -: 2140:    // Out-of-bounds dims are handled by MaterializeTransferMask.
    #####: 2141:    if (read.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2142:      return failure();
        -: 2143:
        -: 2144:    // Create vector load op.
    #####: 2145:    Operation *loadOp;
    #####: 2146:    if (read.getMask()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2147:      Value fill = rewriter.create<vector::SplatOp>(
    #####: 2148:          read.getLoc(), unbroadcastedVectorType, read.getPadding());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2149:      loadOp = rewriter.create<vector::MaskedLoadOp>(
    #####: 2150:          read.getLoc(), unbroadcastedVectorType, read.getSource(),
call    0 never executed
    #####: 2151:          read.getIndices(), read.getMask(), fill);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2152:    } else {
    #####: 2153:      loadOp = rewriter.create<vector::LoadOp>(
    #####: 2154:          read.getLoc(), unbroadcastedVectorType, read.getSource(),
call    0 never executed
    #####: 2155:          read.getIndices());
call    0 never executed
call    1 never executed
        -: 2156:    }
        -: 2157:
        -: 2158:    // Insert a broadcasting op if required.
    #####: 2159:    if (!broadcastedDims.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2160:      rewriter.replaceOpWithNewOp<vector::BroadcastOp>(
    #####: 2161:          read, read.getVectorType(), loadOp->getResult(0));
call    0 never executed
call    1 never executed
        -: 2162:    } else {
    #####: 2163:      rewriter.replaceOp(read, loadOp->getResult(0));
call    0 never executed
call    1 never executed
        -: 2164:    }
        -: 2165:
    #####: 2166:    return success();
branch  0 never executed
branch  1 never executed
        -: 2167:  }
        -: 2168:
        -: 2169:  llvm::Optional<unsigned> maxTransferRank;
        -: 2170:};
        -: 2171:
        -: 2172:/// Replace a 0-d vector.load with a memref.load + vector.broadcast.
        -: 2173:// TODO: we shouldn't cross the vector/scalar domains just for this
        -: 2174:// but atm we lack the infra to avoid it. Possible solutions include:
        -: 2175:// - go directly to LLVM + bitcast
        -: 2176:// - introduce a bitcast op and likely a new pointer dialect
        -: 2177:// - let memref.load/store additionally support the 0-d vector case
        -: 2178:// There are still deeper data layout issues lingering even in this
        -: 2179:// trivial case (for architectures for which this matters).
        -: 2180:struct VectorLoadToMemrefLoadLowering
        -: 2181:    : public OpRewritePattern<vector::LoadOp> {
        -: 2182:  using OpRewritePattern::OpRewritePattern;
        -: 2183:
function _ZNK30VectorLoadToMemrefLoadLowering15matchAndRewriteEN4mlir6vector6LoadOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2184:  LogicalResult matchAndRewrite(vector::LoadOp loadOp,
        -: 2185:                                PatternRewriter &rewriter) const override {
    #####: 2186:    auto vecType = loadOp.getVectorType();
call    0 never executed
    #####: 2187:    if (vecType.getNumElements() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2188:      return failure();
    #####: 2189:    auto memrefLoad = rewriter.create<memref::LoadOp>(
    #####: 2190:        loadOp.getLoc(), loadOp.getBase(), loadOp.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2191:    rewriter.replaceOpWithNewOp<vector::BroadcastOp>(loadOp, vecType,
    #####: 2192:                                                     memrefLoad);
call    0 never executed
    #####: 2193:    return success();
        -: 2194:  }
        -: 2195:};
        -: 2196:
        -: 2197:/// Replace a 0-d vector.store with a vector.extractelement + memref.store.
        -: 2198:struct VectorStoreToMemrefStoreLowering
        -: 2199:    : public OpRewritePattern<vector::StoreOp> {
        -: 2200:  using OpRewritePattern::OpRewritePattern;
        -: 2201:
function _ZNK32VectorStoreToMemrefStoreLowering15matchAndRewriteEN4mlir6vector7StoreOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2202:  LogicalResult matchAndRewrite(vector::StoreOp storeOp,
        -: 2203:                                PatternRewriter &rewriter) const override {
    #####: 2204:    auto vecType = storeOp.getVectorType();
call    0 never executed
    #####: 2205:    if (vecType.getNumElements() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2206:      return failure();
    #####: 2207:    Value extracted;
    #####: 2208:    if (vecType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2209:      // TODO: Unifiy once ExtractOp supports 0-d vectors.
    #####: 2210:      extracted = rewriter.create<vector::ExtractElementOp>(
    #####: 2211:          storeOp.getLoc(), storeOp.getValueToStore());
call    0 never executed
call    1 never executed
        -: 2212:    } else {
    #####: 2213:      SmallVector<int64_t> indices(vecType.getRank(), 0);
call    0 never executed
call    1 never executed
    #####: 2214:      extracted = rewriter.create<vector::ExtractOp>(
branch  0 never executed
branch  1 never executed
    #####: 2215:          storeOp.getLoc(), storeOp.getValueToStore(), indices);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2216:    }
        -: 2217:
    #####: 2218:    rewriter.replaceOpWithNewOp<memref::StoreOp>(
    #####: 2219:        storeOp, extracted, storeOp.getBase(), storeOp.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2220:    return success();
        -: 2221:  }
        -: 2222:};
        -: 2223:
        -: 2224:/// Progressive lowering of transfer_write. This pattern supports lowering of
        -: 2225:/// `vector.transfer_write` to `vector.store` if all of the following hold:
        -: 2226:/// - Stride of most minor memref dimension must be 1.
        -: 2227:/// - Out-of-bounds masking is not required.
        -: 2228:/// - If the memref's element type is a vector type then it coincides with the
        -: 2229:///   type of the written value.
        -: 2230:/// - The permutation map is the minor identity map (neither permutation nor
        -: 2231:///   broadcasting is allowed).
        -: 2232:struct TransferWriteToVectorStoreLowering
        -: 2233:    : public OpRewritePattern<vector::TransferWriteOp> {
function _ZN34TransferWriteToVectorStoreLoweringC2EPN4mlir11MLIRContextEN4llvm8OptionalIjEENS0_14PatternBenefitE called 3635 returned 100% blocks executed 100%
     3635: 2234:  TransferWriteToVectorStoreLowering(MLIRContext *context,
        -: 2235:                                     llvm::Optional<unsigned> maxRank,
        -: 2236:                                     PatternBenefit benefit = 1)
     3635: 2237:      : OpRewritePattern<vector::TransferWriteOp>(context, benefit),
     3635: 2238:        maxTransferRank(maxRank) {}
call    0 returned 100%
        -: 2239:
function _ZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2240:  LogicalResult matchAndRewrite(vector::TransferWriteOp write,
        -: 2241:                                PatternRewriter &rewriter) const override {
    #####: 2242:    if (maxTransferRank && write.getVectorType().getRank() > *maxTransferRank)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2243:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2244:        diag << "rank exceeds maxTransferRank: " << write;
call    0 never executed
call    1 never executed
    #####: 2245:      });
call    0 never executed
        -: 2246:
        -: 2247:    // Permutations are handled by VectorToSCF or
        -: 2248:    // populateVectorTransferPermutationMapLoweringPatterns.
    #####: 2249:    if ( // pass-through for the 0-d corner case.
    #####: 2250:        !write.getPermutationMap().isMinorIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE0_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2251:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2252:        diag << "permutation map is not minor identity: " << write;
call    0 never executed
call    1 never executed
    #####: 2253:      });
call    0 never executed
        -: 2254:
    #####: 2255:    auto memRefType = write.getShapedType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 2256:    if (!memRefType)
branch  0 never executed
branch  1 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE1_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2257:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2258:        diag << "not a memref type: " << write;
call    0 never executed
call    1 never executed
    #####: 2259:      });
call    0 never executed
        -: 2260:
        -: 2261:    // Non-unit strides are handled by VectorToSCF.
    #####: 2262:    if (!vector::isLastMemrefDimUnitStride(memRefType))
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE2_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2263:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2264:        diag << "most minor stride is not 1: " << write;
call    0 never executed
call    1 never executed
    #####: 2265:      });
call    0 never executed
        -: 2266:
        -: 2267:    // `vector.store` supports vector types as memref's elements only when the
        -: 2268:    // type of the vector value being written is the same as the element type.
    #####: 2269:    auto memrefElTy = memRefType.getElementType();
call    0 never executed
    #####: 2270:    if (memrefElTy.isa<VectorType>() && memrefElTy != write.getVectorType())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE3_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2271:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2272:        diag << "elemental type mismatch: " << write;
call    0 never executed
call    1 never executed
    #####: 2273:      });
call    0 never executed
        -: 2274:
        -: 2275:    // Otherwise, element types of the memref and the vector must match.
    #####: 2276:    if (!memrefElTy.isa<VectorType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2277:        memrefElTy != write.getVectorType().getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE4_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2278:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2279:        diag << "elemental type mismatch: " << write;
call    0 never executed
call    1 never executed
    #####: 2280:      });
call    0 never executed
        -: 2281:
        -: 2282:    // Out-of-bounds dims are handled by MaterializeTransferMask.
    #####: 2283:    if (write.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZNK34TransferWriteToVectorStoreLowering15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS0_15PatternRewriterEENKUlRNS0_10DiagnosticEE5_clES6_ called 0 returned 0% blocks executed 0%
    #####: 2284:      return rewriter.notifyMatchFailure(write.getLoc(), [=](Diagnostic &diag) {
    #####: 2285:        diag << "out of bounds dim: " << write;
call    0 never executed
call    1 never executed
    #####: 2286:      });
call    0 never executed
    #####: 2287:    if (write.getMask()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2288:      rewriter.replaceOpWithNewOp<vector::MaskedStoreOp>(
    #####: 2289:          write, write.getSource(), write.getIndices(), write.getMask(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2290:          write.getVector());
call    0 never executed
call    1 never executed
        -: 2291:    } else {
    #####: 2292:      rewriter.replaceOpWithNewOp<vector::StoreOp>(
    #####: 2293:          write, write.getVector(), write.getSource(), write.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2294:    }
    #####: 2295:    return success();
        -: 2296:  }
        -: 2297:
        -: 2298:  llvm::Optional<unsigned> maxTransferRank;
        -: 2299:};
        -: 2300:
        -: 2301:// Returns the values in `arrayAttr` as an integer vector.
function _ZL17getIntValueVectorN4mlir9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####: 2302:static SmallVector<int64_t, 4> getIntValueVector(ArrayAttr arrayAttr) {
    #####: 2303:  return llvm::to_vector<4>(
    #####: 2304:      llvm::map_range(arrayAttr.getAsRange<IntegerAttr>(),
call    0 never executed
    #####: 2305:                      [](IntegerAttr attr) { return attr.getInt(); }));
call    0 never executed
call    1 never executed
        -: 2306:}
        -: 2307:
        -: 2308:// Shuffles vector.bitcast op after vector.extract op.
        -: 2309://
        -: 2310:// This transforms IR like:
        -: 2311://   %0 = vector.bitcast %src : vector<4xf32> to vector<8xf16>
        -: 2312://   %1 = vector.extract %0[3] : vector<8xf16>
        -: 2313:// Into:
        -: 2314://   %0 = vector.extract %src[1] : vector<4xf32>
        -: 2315://   %1 = vector.bitcast %0: vector<1xf32> to vector<2xf16>
        -: 2316://   %2 = vector.extract %1[1] : vector<2xf16>
        -: 2317:struct BubbleDownVectorBitCastForExtract
        -: 2318:    : public OpRewritePattern<vector::ExtractOp> {
        -: 2319:  using OpRewritePattern::OpRewritePattern;
        -: 2320:
function _ZNK33BubbleDownVectorBitCastForExtract15matchAndRewriteEN4mlir6vector9ExtractOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2321:  LogicalResult matchAndRewrite(vector::ExtractOp extractOp,
        -: 2322:                                PatternRewriter &rewriter) const override {
        -: 2323:    // Only support extracting scalars for now.
    #####: 2324:    if (extractOp.getVectorType().getRank() != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2325:      return failure();
        -: 2326:
    #####: 2327:    auto castOp = extractOp.getVector().getDefiningOp<vector::BitCastOp>();
call    0 never executed
call    1 never executed
    #####: 2328:    if (!castOp)
branch  0 never executed
branch  1 never executed
    #####: 2329:      return failure();
        -: 2330:
    #####: 2331:    VectorType castSrcType = castOp.getSourceVectorType();
call    0 never executed
    #####: 2332:    VectorType castDstType = castOp.getResultVectorType();
call    0 never executed
    #####: 2333:    assert(castSrcType.getRank() == castDstType.getRank());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2334:
        -: 2335:    // Fail to match if we only have one element in the cast op source.
        -: 2336:    // This is to avoid infinite loop given that this pattern can generate
        -: 2337:    // such cases.
    #####: 2338:    if (castSrcType.getNumElements() == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2339:      return failure();
        -: 2340:
        -: 2341:    // Only support casting to a larger number of elements or now.
        -: 2342:    // E.g., vector<4xf32> -> vector<8xf16>.
    #####: 2343:    if (castSrcType.getNumElements() > castDstType.getNumElements())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2344:      return failure();
        -: 2345:
    #####: 2346:    unsigned expandRatio =
    #####: 2347:        castDstType.getNumElements() / castSrcType.getNumElements();
call    0 never executed
call    1 never executed
        -: 2348:
function _ZZNK33BubbleDownVectorBitCastForExtract15matchAndRewriteEN4mlir6vector9ExtractOpERNS0_15PatternRewriterEENKUlNS0_9ArrayAttrEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2349:    auto getFirstIntValue = [](ArrayAttr attr) -> uint64_t {
    #####: 2350:      return (*attr.getAsValueRange<IntegerAttr>().begin()).getZExtValue();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2351:    };
        -: 2352:
    #####: 2353:    uint64_t index = getFirstIntValue(extractOp.getPosition());
call    0 never executed
call    1 never executed
        -: 2354:
        -: 2355:    // Get the single scalar (as a vector) in the source value that packs the
        -: 2356:    // desired scalar. E.g. extract vector<1xf32> from vector<4xf32>
    #####: 2357:    VectorType oneScalarType =
    #####: 2358:        VectorType::get({1}, castSrcType.getElementType());
call    0 never executed
call    1 never executed
    #####: 2359:    Value packedValue = rewriter.create<vector::ExtractOp>(
    #####: 2360:        extractOp.getLoc(), oneScalarType, castOp.getSource(),
call    0 never executed
    #####: 2361:        rewriter.getI64ArrayAttr(index / expandRatio));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2362:
        -: 2363:    // Cast it to a vector with the desired scalar's type.
        -: 2364:    // E.g. f32 -> vector<2xf16>
    #####: 2365:    VectorType packedType =
    #####: 2366:        VectorType::get({expandRatio}, castDstType.getElementType());
call    0 never executed
call    1 never executed
    #####: 2367:    Value castedValue = rewriter.create<vector::BitCastOp>(
    #####: 2368:        extractOp.getLoc(), packedType, packedValue);
call    0 never executed
call    1 never executed
        -: 2369:
        -: 2370:    // Finally extract the desired scalar.
    #####: 2371:    rewriter.replaceOpWithNewOp<vector::ExtractOp>(
    #####: 2372:        extractOp, extractOp.getType(), castedValue,
call    0 never executed
    #####: 2373:        rewriter.getI64ArrayAttr(index % expandRatio));
call    0 never executed
call    1 never executed
        -: 2374:
    #####: 2375:    return success();
        -: 2376:  }
        -: 2377:};
        -: 2378:
        -: 2379:// Shuffles vector.bitcast op after vector.extract_strided_slice op.
        -: 2380://
        -: 2381:// This transforms IR like:
        -: 2382://    %cast = vector.bitcast %arg0: vector<4xf32> to vector<8xf16>
        -: 2383://     %0 = vector.extract_strided_slice %cast {
        -: 2384://            offsets = [4], sizes = [4], strides = [1]
        -: 2385://          } : vector<8xf16> to vector<4xf16>
        -: 2386:// Into:
        -: 2387://   %0 = vector.extract_strided_slice %src {
        -: 2388://          offsets = [2], sizes = [2], strides = [1]
        -: 2389://        } : vector<4xf32> to vector<2xf32>
        -: 2390://   %1 = vector.bitcast %0 : vector<2xf32> to vector<4xf16>
        -: 2391:struct BubbleDownBitCastForStridedSliceExtract
        -: 2392:    : public OpRewritePattern<vector::ExtractStridedSliceOp> {
        -: 2393:  using OpRewritePattern::OpRewritePattern;
        -: 2394:
function _ZNK39BubbleDownBitCastForStridedSliceExtract15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2395:  LogicalResult matchAndRewrite(vector::ExtractStridedSliceOp extractOp,
        -: 2396:                                PatternRewriter &rewriter) const override {
    #####: 2397:    auto castOp = extractOp.getVector().getDefiningOp<vector::BitCastOp>();
call    0 never executed
call    1 never executed
    #####: 2398:    if (!castOp)
branch  0 never executed
branch  1 never executed
    #####: 2399:      return failure();
        -: 2400:
    #####: 2401:    VectorType castSrcType = castOp.getSourceVectorType();
call    0 never executed
    #####: 2402:    VectorType castDstType = castOp.getResultVectorType();
call    0 never executed
    #####: 2403:    assert(castSrcType.getRank() == castDstType.getRank());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2404:
    #####: 2405:    int64_t castSrcLastDim = castSrcType.getShape().back();
call    0 never executed
call    1 never executed
    #####: 2406:    int64_t castDstLastDim = castDstType.getShape().back();
call    0 never executed
call    1 never executed
        -: 2407:    // Require casting to more elements for now; other cases to be implemented.
    #####: 2408:    if (castSrcLastDim > castDstLastDim)
branch  0 never executed
branch  1 never executed
    #####: 2409:      return failure();
        -: 2410:
        -: 2411:    // Only accept all one strides for now.
    #####: 2412:    if (llvm::any_of(extractOp.getStrides().getAsValueRange<IntegerAttr>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2413:                     [](const APInt &val) { return !val.isOneValue(); }))
    #####: 2414:      return failure();
        -: 2415:
    #####: 2416:    unsigned rank = extractOp.getVectorType().getRank();
call    0 never executed
call    1 never executed
    #####: 2417:    assert(castDstLastDim % castSrcLastDim == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2418:    int64_t expandRatio = castDstLastDim / castSrcLastDim;
        -: 2419:
        -: 2420:    // If we have a less number of offsets than the rank, then implicitly we
        -: 2421:    // are selecting the full range for the last bitcasted dimension; other
        -: 2422:    // dimensions aren't affected. Otherwise, we need to scale down the last
        -: 2423:    // dimension's offset given we are extracting from less elements now.
    #####: 2424:    ArrayAttr newOffsets = extractOp.getOffsets();
call    0 never executed
    #####: 2425:    if (newOffsets.size() == rank) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2426:      SmallVector<int64_t, 4> offsets = getIntValueVector(newOffsets);
call    0 never executed
    #####: 2427:      if (offsets.back() % expandRatio != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2428:        return failure();
branch  0 never executed
branch  1 never executed
    #####: 2429:      offsets.back() = offsets.back() / expandRatio;
    #####: 2430:      newOffsets = rewriter.getI64ArrayAttr(offsets);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2431:    }
        -: 2432:
        -: 2433:    // Similarly for sizes.
    #####: 2434:    ArrayAttr newSizes = extractOp.getSizes();
call    0 never executed
    #####: 2435:    if (newSizes.size() == rank) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2436:      SmallVector<int64_t, 4> sizes = getIntValueVector(newSizes);
call    0 never executed
    #####: 2437:      if (sizes.back() % expandRatio != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2438:        return failure();
branch  0 never executed
branch  1 never executed
    #####: 2439:      sizes.back() = sizes.back() / expandRatio;
    #####: 2440:      newSizes = rewriter.getI64ArrayAttr(sizes);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2441:    }
        -: 2442:
    #####: 2443:    SmallVector<int64_t, 4> dims =
call    0 never executed
    #####: 2444:        llvm::to_vector<4>(extractOp.getType().cast<VectorType>().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2445:    dims.back() = dims.back() / expandRatio;
call    0 never executed
    #####: 2446:    VectorType newExtractType =
    #####: 2447:        VectorType::get(dims, castSrcType.getElementType());
call    0 never executed
call    1 never executed
        -: 2448:
    #####: 2449:    auto newExtractOp = rewriter.create<vector::ExtractStridedSliceOp>(
    #####: 2450:        extractOp.getLoc(), newExtractType, castOp.getSource(), newOffsets,
call    0 never executed
    #####: 2451:        newSizes, extractOp.getStrides());
call    0 never executed
call    1 never executed
        -: 2452:
    #####: 2453:    rewriter.replaceOpWithNewOp<vector::BitCastOp>(
    #####: 2454:        extractOp, extractOp.getType(), newExtractOp);
call    0 never executed
call    1 never executed
        -: 2455:
    #####: 2456:    return success();
branch  0 never executed
branch  1 never executed
        -: 2457:  }
        -: 2458:};
        -: 2459:
        -: 2460:// Shuffles vector.bitcast op before vector.insert_strided_slice op.
        -: 2461://
        -: 2462:// This transforms IR like:
        -: 2463://   %0 = vector.insert_strided_slice %src, %dst {
        -: 2464://          offsets = [0], strides = [1]} : vector<4xf16> into vector<8xf16>
        -: 2465://   %1 = vector.bitcast %0: vector<8xf16> to vector<4xf32>
        -: 2466:// Into:
        -: 2467://   %0 = vector.bitcast %src : vector<4xf16> to vector<2xf32>
        -: 2468://   %1 = vector.bitcast %dst : vector<8xf16> to vector<4xf32>
        -: 2469://   %2 = vector.insert_strided_slice %src, %dst {
        -: 2470://          offsets = [0], strides = [1]} : vector<2xf32> into vector<4xf32>
        -: 2471:struct BubbleUpBitCastForStridedSliceInsert
        -: 2472:    : public OpRewritePattern<vector::BitCastOp> {
        -: 2473:  using OpRewritePattern::OpRewritePattern;
        -: 2474:
function _ZNK36BubbleUpBitCastForStridedSliceInsert15matchAndRewriteEN4mlir6vector9BitCastOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2475:  LogicalResult matchAndRewrite(vector::BitCastOp bitcastOp,
        -: 2476:                                PatternRewriter &rewriter) const override {
    #####: 2477:    VectorType castSrcType = bitcastOp.getSourceVectorType();
call    0 never executed
    #####: 2478:    VectorType castDstType = bitcastOp.getResultVectorType();
call    0 never executed
    #####: 2479:    assert(castSrcType.getRank() == castDstType.getRank());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2480:
    #####: 2481:    int64_t castSrcLastDim = castSrcType.getShape().back();
call    0 never executed
call    1 never executed
    #####: 2482:    int64_t castDstLastDim = castDstType.getShape().back();
call    0 never executed
call    1 never executed
        -: 2483:    // Require casting to less elements for now; other cases to be implemented.
    #####: 2484:    if (castSrcLastDim < castDstLastDim)
branch  0 never executed
branch  1 never executed
    #####: 2485:      return failure();
        -: 2486:
    #####: 2487:    assert(castSrcLastDim % castDstLastDim == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2488:    int64_t shrinkRatio = castSrcLastDim / castDstLastDim;
        -: 2489:
    #####: 2490:    auto insertOp =
    #####: 2491:        bitcastOp.getSource().getDefiningOp<vector::InsertStridedSliceOp>();
call    0 never executed
call    1 never executed
    #####: 2492:    if (!insertOp)
branch  0 never executed
branch  1 never executed
    #####: 2493:      return failure();
        -: 2494:
        -: 2495:    // Only accept all one strides for now.
    #####: 2496:    if (llvm::any_of(insertOp.getStrides().getAsValueRange<IntegerAttr>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2497:                     [](const APInt &val) { return !val.isOneValue(); }))
    #####: 2498:      return failure();
        -: 2499:
    #####: 2500:    unsigned rank = insertOp.getSourceVectorType().getRank();
call    0 never executed
call    1 never executed
        -: 2501:    // Require insert op to have the same rank for the source and destination
        -: 2502:    // vector; other cases to be implemented.
    #####: 2503:    if (rank != insertOp.getDestVectorType().getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2504:      return failure();
        -: 2505:
    #####: 2506:    ArrayAttr newOffsets = insertOp.getOffsets();
call    0 never executed
    #####: 2507:    assert(newOffsets.size() == rank);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2508:    SmallVector<int64_t, 4> offsets = getIntValueVector(newOffsets);
call    0 never executed
    #####: 2509:    if (offsets.back() % shrinkRatio != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2510:      return failure();
    #####: 2511:    offsets.back() = offsets.back() / shrinkRatio;
    #####: 2512:    newOffsets = rewriter.getI64ArrayAttr(offsets);
call    0 never executed
        -: 2513:
    #####: 2514:    SmallVector<int64_t, 4> srcDims =
    #####: 2515:        llvm::to_vector<4>(insertOp.getSourceVectorType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2516:    srcDims.back() = srcDims.back() / shrinkRatio;
call    0 never executed
    #####: 2517:    VectorType newCastSrcType =
    #####: 2518:        VectorType::get(srcDims, castDstType.getElementType());
call    0 never executed
call    1 never executed
        -: 2519:
    #####: 2520:    auto newCastSrcOp = rewriter.create<vector::BitCastOp>(
    #####: 2521:        bitcastOp.getLoc(), newCastSrcType, insertOp.getSource());
call    0 never executed
call    1 never executed
        -: 2522:
    #####: 2523:    SmallVector<int64_t, 4> dstDims =
    #####: 2524:        llvm::to_vector<4>(insertOp.getDestVectorType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2525:    dstDims.back() = dstDims.back() / shrinkRatio;
call    0 never executed
    #####: 2526:    VectorType newCastDstType =
    #####: 2527:        VectorType::get(dstDims, castDstType.getElementType());
call    0 never executed
call    1 never executed
        -: 2528:
    #####: 2529:    auto newCastDstOp = rewriter.create<vector::BitCastOp>(
    #####: 2530:        bitcastOp.getLoc(), newCastDstType, insertOp.getDest());
call    0 never executed
call    1 never executed
        -: 2531:
    #####: 2532:    rewriter.replaceOpWithNewOp<vector::InsertStridedSliceOp>(
    #####: 2533:        bitcastOp, bitcastOp.getType(), newCastSrcOp, newCastDstOp, newOffsets,
    #####: 2534:        insertOp.getStrides());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2535:
    #####: 2536:    return success();
branch  0 never executed
branch  1 never executed
        -: 2537:  }
        -: 2538:};
        -: 2539:
        -: 2540:// Helper that returns a vector comparison that constructs a mask:
        -: 2541://     mask = [0,1,..,n-1] + [o,o,..,o] < [b,b,..,b]
        -: 2542://
        -: 2543:// If `dim == 0` then the result will be a 0-D vector.
        -: 2544://
        -: 2545:// NOTE: The LLVM::GetActiveLaneMaskOp intrinsic would provide an alternative,
        -: 2546://       much more compact, IR for this operation, but LLVM eventually
        -: 2547://       generates more elaborate instructions for this intrinsic since it
        -: 2548://       is very conservative on the boundary conditions.
function _ZL21buildVectorComparisonRN4mlir15PatternRewriterEPNS_9OperationEblNS_5ValueEPS4_ called 0 returned 0% blocks executed 0%
    #####: 2549:static Value buildVectorComparison(PatternRewriter &rewriter, Operation *op,
        -: 2550:                                   bool force32BitVectorIndices, int64_t dim,
        -: 2551:                                   Value b, Value *off = nullptr) {
    #####: 2552:  auto loc = op->getLoc();
branch  0 never executed
branch  1 never executed
        -: 2553:  // If we can assume all indices fit in 32-bit, we perform the vector
        -: 2554:  // comparison in 32-bit to get a higher degree of SIMD parallelism.
        -: 2555:  // Otherwise we perform the vector comparison using 64-bit indices.
    #####: 2556:  Type idxType =
    #####: 2557:      force32BitVectorIndices ? rewriter.getI32Type() : rewriter.getI64Type();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2558:  DenseIntElementsAttr indicesAttr;
    #####: 2559:  if (dim == 0 && force32BitVectorIndices) {
branch  0 never executed
branch  1 never executed
    #####: 2560:    indicesAttr = DenseIntElementsAttr::get(
    #####: 2561:        VectorType::get(ArrayRef<int64_t>{}, idxType), ArrayRef<int32_t>{0});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2562:  } else if (dim == 0) {
branch  0 never executed
branch  1 never executed
    #####: 2563:    indicesAttr = DenseIntElementsAttr::get(
    #####: 2564:        VectorType::get(ArrayRef<int64_t>{}, idxType), ArrayRef<int64_t>{0});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2565:  } else if (force32BitVectorIndices) {
branch  0 never executed
branch  1 never executed
    #####: 2566:    indicesAttr = rewriter.getI32VectorAttr(
    #####: 2567:        llvm::to_vector<4>(llvm::seq<int32_t>(0, dim)));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2568:  } else {
    #####: 2569:    indicesAttr = rewriter.getI64VectorAttr(
    #####: 2570:        llvm::to_vector<4>(llvm::seq<int64_t>(0, dim)));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2571:  }
    #####: 2572:  Value indices = rewriter.create<arith::ConstantOp>(loc, indicesAttr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2573:  // Add in an offset if requested.
    #####: 2574:  if (off) {
branch  0 never executed
branch  1 never executed
    #####: 2575:    Value o = getValueOrCreateCastToIndexLike(rewriter, loc, idxType, *off);
call    0 never executed
    #####: 2576:    Value ov = rewriter.create<vector::SplatOp>(loc, indices.getType(), o);
call    0 never executed
call    1 never executed
    #####: 2577:    indices = rewriter.create<arith::AddIOp>(loc, ov, indices);
call    0 never executed
        -: 2578:  }
        -: 2579:  // Construct the vector comparison.
    #####: 2580:  Value bound = getValueOrCreateCastToIndexLike(rewriter, loc, idxType, b);
call    0 never executed
    #####: 2581:  Value bounds =
    #####: 2582:      rewriter.create<vector::SplatOp>(loc, indices.getType(), bound);
call    0 never executed
call    1 never executed
    #####: 2583:  return rewriter.create<arith::CmpIOp>(loc, arith::CmpIPredicate::slt, indices,
    #####: 2584:                                        bounds);
call    0 never executed
        -: 2585:}
        -: 2586:
        -: 2587:template <typename ConcreteOp>
        -: 2588:struct MaterializeTransferMask : public OpRewritePattern<ConcreteOp> {
        -: 2589:public:
        -: 2590:  explicit MaterializeTransferMask(MLIRContext *context, bool enableIndexOpt,
        -: 2591:                                   PatternBenefit benefit = 1)
        -: 2592:      : mlir::OpRewritePattern<ConcreteOp>(context, benefit),
        -: 2593:        force32BitVectorIndices(enableIndexOpt) {}
        -: 2594:
    #####: 2595:  LogicalResult matchAndRewrite(ConcreteOp xferOp,
        -: 2596:                                PatternRewriter &rewriter) const override {
    #####: 2597:    if (!xferOp.hasOutOfBoundsDim())
    #####: 2598:      return failure();
        -: 2599:
    #####: 2600:    if (xferOp.getVectorType().getRank() > 1 || xferOp.getIndices().empty())
    #####: 2601:      return failure();
        -: 2602:
    #####: 2603:    Location loc = xferOp->getLoc();
    #####: 2604:    VectorType vtp = xferOp.getVectorType();
        -: 2605:
        -: 2606:    // Create the in-bounds mask with all elements between [0 .. dim - offset)
        -: 2607:    // set and [dim - offset .. vector_length) unset.
        -: 2608:    //
        -: 2609:    // TODO: when the leaf transfer rank is k > 1, we need the last `k`
        -: 2610:    //       dimensions here.
    #####: 2611:    unsigned lastIndex = llvm::size(xferOp.getIndices()) - 1;
    #####: 2612:    Value off = xferOp.getIndices()[lastIndex];
        -: 2613:    Value dim =
    #####: 2614:        vector::createOrFoldDimOp(rewriter, loc, xferOp.getSource(), lastIndex);
    #####: 2615:    Value b = rewriter.create<arith::SubIOp>(loc, dim.getType(), dim, off);
    #####: 2616:    Value mask = rewriter.create<vector::CreateMaskOp>(
        -: 2617:        loc,
    #####: 2618:        VectorType::get(vtp.getShape(), rewriter.getI1Type(),
        -: 2619:                        vtp.getNumScalableDims()),
        -: 2620:        b);
    #####: 2621:    if (xferOp.getMask()) {
        -: 2622:      // Intersect the in-bounds with the mask specified as an op parameter.
    #####: 2623:      mask = rewriter.create<arith::AndIOp>(loc, mask, xferOp.getMask());
        -: 2624:    }
        -: 2625:
    #####: 2626:    rewriter.updateRootInPlace(xferOp, [&]() {
    #####: 2627:      xferOp.getMaskMutable().assign(mask);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2628:      xferOp.setInBoundsAttr(rewriter.getBoolArrayAttr({true}));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2629:    });
        -: 2630:
    #####: 2631:    return success();
        -: 2632:  }
------------------
_ZNK23MaterializeTransferMaskIN4mlir6vector14TransferReadOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE:
function _ZNK23MaterializeTransferMaskIN4mlir6vector14TransferReadOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2595:  LogicalResult matchAndRewrite(ConcreteOp xferOp,
        -: 2596:                                PatternRewriter &rewriter) const override {
    #####: 2597:    if (!xferOp.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2598:      return failure();
        -: 2599:
    #####: 2600:    if (xferOp.getVectorType().getRank() > 1 || xferOp.getIndices().empty())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2601:      return failure();
        -: 2602:
    #####: 2603:    Location loc = xferOp->getLoc();
call    0 never executed
    #####: 2604:    VectorType vtp = xferOp.getVectorType();
call    0 never executed
        -: 2605:
        -: 2606:    // Create the in-bounds mask with all elements between [0 .. dim - offset)
        -: 2607:    // set and [dim - offset .. vector_length) unset.
        -: 2608:    //
        -: 2609:    // TODO: when the leaf transfer rank is k > 1, we need the last `k`
        -: 2610:    //       dimensions here.
    #####: 2611:    unsigned lastIndex = llvm::size(xferOp.getIndices()) - 1;
call    0 never executed
call    1 never executed
    #####: 2612:    Value off = xferOp.getIndices()[lastIndex];
call    0 never executed
call    1 never executed
        -: 2613:    Value dim =
    #####: 2614:        vector::createOrFoldDimOp(rewriter, loc, xferOp.getSource(), lastIndex);
call    0 never executed
call    1 never executed
    #####: 2615:    Value b = rewriter.create<arith::SubIOp>(loc, dim.getType(), dim, off);
call    0 never executed
call    1 never executed
    #####: 2616:    Value mask = rewriter.create<vector::CreateMaskOp>(
call    0 never executed
call    1 never executed
        -: 2617:        loc,
    #####: 2618:        VectorType::get(vtp.getShape(), rewriter.getI1Type(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2619:                        vtp.getNumScalableDims()),
        -: 2620:        b);
    #####: 2621:    if (xferOp.getMask()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2622:      // Intersect the in-bounds with the mask specified as an op parameter.
    #####: 2623:      mask = rewriter.create<arith::AndIOp>(loc, mask, xferOp.getMask());
call    0 never executed
call    1 never executed
        -: 2624:    }
        -: 2625:
    #####: 2626:    rewriter.updateRootInPlace(xferOp, [&]() {
call    0 never executed
        -: 2627:      xferOp.getMaskMutable().assign(mask);
        -: 2628:      xferOp.setInBoundsAttr(rewriter.getBoolArrayAttr({true}));
        -: 2629:    });
        -: 2630:
    #####: 2631:    return success();
        -: 2632:  }
------------------
_ZNK23MaterializeTransferMaskIN4mlir6vector15TransferWriteOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE:
function _ZNK23MaterializeTransferMaskIN4mlir6vector15TransferWriteOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2595:  LogicalResult matchAndRewrite(ConcreteOp xferOp,
        -: 2596:                                PatternRewriter &rewriter) const override {
    #####: 2597:    if (!xferOp.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2598:      return failure();
        -: 2599:
    #####: 2600:    if (xferOp.getVectorType().getRank() > 1 || xferOp.getIndices().empty())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2601:      return failure();
        -: 2602:
    #####: 2603:    Location loc = xferOp->getLoc();
call    0 never executed
    #####: 2604:    VectorType vtp = xferOp.getVectorType();
call    0 never executed
        -: 2605:
        -: 2606:    // Create the in-bounds mask with all elements between [0 .. dim - offset)
        -: 2607:    // set and [dim - offset .. vector_length) unset.
        -: 2608:    //
        -: 2609:    // TODO: when the leaf transfer rank is k > 1, we need the last `k`
        -: 2610:    //       dimensions here.
    #####: 2611:    unsigned lastIndex = llvm::size(xferOp.getIndices()) - 1;
call    0 never executed
call    1 never executed
    #####: 2612:    Value off = xferOp.getIndices()[lastIndex];
call    0 never executed
call    1 never executed
        -: 2613:    Value dim =
    #####: 2614:        vector::createOrFoldDimOp(rewriter, loc, xferOp.getSource(), lastIndex);
call    0 never executed
call    1 never executed
    #####: 2615:    Value b = rewriter.create<arith::SubIOp>(loc, dim.getType(), dim, off);
call    0 never executed
call    1 never executed
    #####: 2616:    Value mask = rewriter.create<vector::CreateMaskOp>(
call    0 never executed
call    1 never executed
        -: 2617:        loc,
    #####: 2618:        VectorType::get(vtp.getShape(), rewriter.getI1Type(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2619:                        vtp.getNumScalableDims()),
        -: 2620:        b);
    #####: 2621:    if (xferOp.getMask()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2622:      // Intersect the in-bounds with the mask specified as an op parameter.
    #####: 2623:      mask = rewriter.create<arith::AndIOp>(loc, mask, xferOp.getMask());
call    0 never executed
call    1 never executed
        -: 2624:    }
        -: 2625:
    #####: 2626:    rewriter.updateRootInPlace(xferOp, [&]() {
call    0 never executed
        -: 2627:      xferOp.getMaskMutable().assign(mask);
        -: 2628:      xferOp.setInBoundsAttr(rewriter.getBoolArrayAttr({true}));
        -: 2629:    });
        -: 2630:
    #####: 2631:    return success();
        -: 2632:  }
------------------
        -: 2633:
        -: 2634:private:
        -: 2635:  const bool force32BitVectorIndices;
        -: 2636:};
        -: 2637:
        -: 2638:/// Conversion pattern for a `vector.create_mask` (0-D and 1-D only).
        -: 2639:class VectorCreateMaskOpConversion
        -: 2640:    : public OpRewritePattern<vector::CreateMaskOp> {
        -: 2641:public:
        -: 2642:  explicit VectorCreateMaskOpConversion(MLIRContext *context,
        -: 2643:                                        bool enableIndexOpt,
        -: 2644:                                        PatternBenefit benefit = 1)
        -: 2645:      : mlir::OpRewritePattern<vector::CreateMaskOp>(context, benefit),
        -: 2646:        force32BitVectorIndices(enableIndexOpt) {}
        -: 2647:
function _ZNK28VectorCreateMaskOpConversion15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2648:  LogicalResult matchAndRewrite(vector::CreateMaskOp op,
        -: 2649:                                PatternRewriter &rewriter) const override {
    #####: 2650:    auto dstType = op.getType();
call    0 never executed
    #####: 2651:    if (dstType.cast<VectorType>().isScalable())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2652:      return failure();
    #####: 2653:    int64_t rank = dstType.getRank();
call    0 never executed
    #####: 2654:    if (rank > 1)
branch  0 never executed
branch  1 never executed
    #####: 2655:      return failure();
    #####: 2656:    rewriter.replaceOp(
call    0 never executed
    #####: 2657:        op, buildVectorComparison(rewriter, op, force32BitVectorIndices,
    #####: 2658:                                  rank == 0 ? 0 : dstType.getDimSize(0),
call    0 never executed
    #####: 2659:                                  op.getOperand(0)));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####: 2660:    return success();
        -: 2661:  }
        -: 2662:
        -: 2663:private:
        -: 2664:  const bool force32BitVectorIndices;
        -: 2665:};
        -: 2666:
        -: 2667:// Drop inner most contiguous unit dimensions from transfer_read operand.
        -: 2668:class DropInnerMostUnitDims : public OpRewritePattern<vector::TransferReadOp> {
        -: 2669:  using OpRewritePattern::OpRewritePattern;
        -: 2670:
function _ZNK21DropInnerMostUnitDims15matchAndRewriteEN4mlir6vector14TransferReadOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2671:  LogicalResult matchAndRewrite(vector::TransferReadOp readOp,
        -: 2672:                                PatternRewriter &rewriter) const override {
        -: 2673:    // TODO: support 0-d corner case.
    #####: 2674:    if (readOp.getTransferRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2675:      return failure();
        -: 2676:
        -: 2677:    // TODO: support mask.
    #####: 2678:    if (readOp.getMask())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2679:      return failure();
        -: 2680:
    #####: 2681:    auto srcType = readOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2682:    if (!srcType || !srcType.hasStaticShape())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2683:      return failure();
        -: 2684:
    #####: 2685:    if (!readOp.getPermutationMap().isMinorIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2686:      return failure();
        -: 2687:
    #####: 2688:    auto targetType = readOp.getVectorType();
call    0 never executed
    #####: 2689:    if (targetType.getRank() <= 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2690:      return failure();
        -: 2691:
    #####: 2692:    SmallVector<int64_t> srcStrides;
call    0 never executed
    #####: 2693:    int64_t srcOffset;
    #####: 2694:    if (failed(getStridesAndOffset(srcType, srcStrides, srcOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2695:      return failure();
        -: 2696:
        -: 2697:    size_t dimsToDrop = 0;
    #####: 2698:    for (size_t i = 1; i < srcStrides.size(); ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2699:      int dim = srcType.getRank() - i - 1;
call    0 never executed
    #####: 2700:      if (srcStrides[dim] == 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2701:        dimsToDrop++;
        -: 2702:      } else {
        -: 2703:        break;
        -: 2704:      }
        -: 2705:    }
    #####: 2706:    if (dimsToDrop == 0)
branch  0 never executed
branch  1 never executed
    #####: 2707:      return failure();
        -: 2708:
    #####: 2709:    auto resultTargetVecType =
    #####: 2710:        VectorType::get(targetType.getShape().drop_back(dimsToDrop),
call    0 never executed
    #####: 2711:                        targetType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2712:
    #####: 2713:    MemRefType resultMemrefType;
    #####: 2714:    MemRefLayoutAttrInterface layout = srcType.getLayout();
call    0 never executed
    #####: 2715:    if (layout.isa<AffineMapAttr>() && layout.isIdentity()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2716:      resultMemrefType = MemRefType::get(
    #####: 2717:          srcType.getShape().drop_back(dimsToDrop), srcType.getElementType(),
call    0 never executed
    #####: 2718:          nullptr, srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2719:    } else {
    #####: 2720:      MemRefLayoutAttrInterface updatedLayout;
call    0 never executed
    #####: 2721:      if (auto strided = layout.dyn_cast<StridedLayoutAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2722:        auto strides = llvm::to_vector(strided.getStrides().drop_back(dimsToDrop));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2723:        updatedLayout = StridedLayoutAttr::get(strided.getContext(), strided.getOffset(), strides);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2724:      } else {
    #####: 2725:        AffineMap map = srcType.getLayout().getAffineMap();
call    0 never executed
call    1 never executed
    #####: 2726:        int numSymbols = map.getNumSymbols();
    #####: 2727:        for (size_t i = 0; i < dimsToDrop; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2728:          int dim = srcType.getRank() - i - 1;
call    0 never executed
    #####: 2729:          map = map.replace(rewriter.getAffineDimExpr(dim),
        -: 2730:                            rewriter.getAffineConstantExpr(0),
    #####: 2731:                            map.getNumDims() - 1, numSymbols);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2732:        }
        -: 2733:      }
    #####: 2734:      resultMemrefType = MemRefType::get(
    #####: 2735:          srcType.getShape().drop_back(dimsToDrop), srcType.getElementType(),
call    0 never executed
    #####: 2736:          updatedLayout, srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2737:    }
        -: 2738:
    #####: 2739:    auto loc = readOp.getLoc();
call    0 never executed
    #####: 2740:    SmallVector<int64_t> offsets(srcType.getRank(), 0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2741:    SmallVector<int64_t> strides(srcType.getRank(), 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2742:
    #####: 2743:    ArrayAttr inBoundsAttr =
    #####: 2744:        readOp.getInBounds()
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2745:            ? rewriter.getArrayAttr(
    #####: 2746:                  readOp.getInBoundsAttr().getValue().drop_back(dimsToDrop))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2747:            : ArrayAttr();
branch  0 never executed
branch  1 never executed
    #####: 2748:    Value rankedReducedView = rewriter.create<memref::SubViewOp>(
    #####: 2749:        loc, resultMemrefType, readOp.getSource(), offsets, srcType.getShape(),
call    0 never executed
    #####: 2750:        strides);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2751:    auto permMap = getTransferMinorIdentityMap(
    #####: 2752:        rankedReducedView.getType().cast<ShapedType>(), resultTargetVecType);
call    0 never executed
call    1 never executed
    #####: 2753:    Value result = rewriter.create<vector::TransferReadOp>(
        -: 2754:        loc, resultTargetVecType, rankedReducedView,
    #####: 2755:        readOp.getIndices().drop_back(dimsToDrop), AffineMapAttr::get(permMap),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2756:        readOp.getPadding(),
call    0 never executed
        -: 2757:        // TODO: support mask.
    #####: 2758:        /*mask=*/Value(), inBoundsAttr);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2759:    rewriter.replaceOpWithNewOp<vector::ShapeCastOp>(readOp, targetType,
    #####: 2760:                                                     result);
call    0 never executed
    #####: 2761:    return success();
branch  0 never executed
branch  1 never executed
        -: 2762:  }
        -: 2763:};
        -: 2764:
        -: 2765:namespace {
        -: 2766:
        -: 2767:/// This function checks to see if the vector combining kind
        -: 2768:/// is consistent with the integer or float element type.
function _ZN12_GLOBAL__N_1L11isValidKindEbN4mlir6vector13CombiningKindE called 0 returned 0% blocks executed 0%
    #####: 2769:static bool isValidKind(bool isInt, vector::CombiningKind kind) {
    #####: 2770:  using vector::CombiningKind;
    #####: 2771:  enum class KindType { FLOAT, INT, INVALID };
    #####: 2772:  KindType type{KindType::INVALID};
    #####: 2773:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2774:  case CombiningKind::MINF:
    #####: 2775:  case CombiningKind::MAXF:
    #####: 2776:    type = KindType::FLOAT;
    #####: 2777:    break;
    #####: 2778:  case CombiningKind::MINUI:
    #####: 2779:  case CombiningKind::MINSI:
    #####: 2780:  case CombiningKind::MAXUI:
    #####: 2781:  case CombiningKind::MAXSI:
    #####: 2782:  case CombiningKind::AND:
    #####: 2783:  case CombiningKind::OR:
    #####: 2784:  case CombiningKind::XOR:
    #####: 2785:    type = KindType::INT;
    #####: 2786:    break;
    #####: 2787:  case CombiningKind::ADD:
    #####: 2788:  case CombiningKind::MUL:
    #####: 2789:    type = isInt ? KindType::INT : KindType::FLOAT;
branch  0 never executed
branch  1 never executed
        -: 2790:    break;
        -: 2791:  }
    #####: 2792:  bool isValidIntKind = (type == KindType::INT) && isInt;
    #####: 2793:  bool isValidFloatKind = (type == KindType::FLOAT) && (!isInt);
    #####: 2794:  return (isValidIntKind || isValidFloatKind);
        -: 2795:}
        -: 2796:
        -: 2797:/// This function constructs the appropriate integer or float
        -: 2798:/// operation given the vector combining kind and operands. The
        -: 2799:/// supported int operations are : add, mul, min (signed/unsigned),
        -: 2800:/// max(signed/unsigned), and, or, xor. The supported float
        -: 2801:/// operations are : add, mul, min and max.
function _ZN12_GLOBAL__N_1L11genOperatorEN4mlir8LocationENS0_5ValueES2_NS0_6vector13CombiningKindERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2802:static Value genOperator(Location loc, Value x, Value y,
        -: 2803:                         vector::CombiningKind kind,
        -: 2804:                         PatternRewriter &rewriter) {
    #####: 2805:  using vector::CombiningKind;
        -: 2806:
    #####: 2807:  auto elType = x.getType().cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 2808:  bool isInt = elType.isIntOrIndex();
call    0 never executed
        -: 2809:
    #####: 2810:  Value combinedResult{nullptr};
    #####: 2811:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 2812:  case CombiningKind::ADD:
    #####: 2813:    if (isInt)
branch  0 never executed
branch  1 never executed
    #####: 2814:      combinedResult = rewriter.create<arith::AddIOp>(loc, x, y);
call    0 never executed
        -: 2815:    else
    #####: 2816:      combinedResult = rewriter.create<arith::AddFOp>(loc, x, y);
call    0 never executed
        -: 2817:    break;
    #####: 2818:  case CombiningKind::MUL:
    #####: 2819:    if (isInt)
branch  0 never executed
branch  1 never executed
    #####: 2820:      combinedResult = rewriter.create<arith::MulIOp>(loc, x, y);
call    0 never executed
        -: 2821:    else
    #####: 2822:      combinedResult = rewriter.create<arith::MulFOp>(loc, x, y);
call    0 never executed
        -: 2823:    break;
    #####: 2824:  case CombiningKind::MINUI:
    #####: 2825:    combinedResult = rewriter.create<arith::MinUIOp>(loc, x, y);
call    0 never executed
    #####: 2826:    break;
    #####: 2827:  case CombiningKind::MINSI:
    #####: 2828:    combinedResult = rewriter.create<arith::MinSIOp>(loc, x, y);
call    0 never executed
    #####: 2829:    break;
    #####: 2830:  case CombiningKind::MAXUI:
    #####: 2831:    combinedResult = rewriter.create<arith::MaxUIOp>(loc, x, y);
call    0 never executed
    #####: 2832:    break;
    #####: 2833:  case CombiningKind::MAXSI:
    #####: 2834:    combinedResult = rewriter.create<arith::MaxSIOp>(loc, x, y);
call    0 never executed
    #####: 2835:    break;
    #####: 2836:  case CombiningKind::AND:
    #####: 2837:    combinedResult = rewriter.create<arith::AndIOp>(loc, x, y);
call    0 never executed
    #####: 2838:    break;
    #####: 2839:  case CombiningKind::OR:
    #####: 2840:    combinedResult = rewriter.create<arith::OrIOp>(loc, x, y);
call    0 never executed
    #####: 2841:    break;
    #####: 2842:  case CombiningKind::XOR:
    #####: 2843:    combinedResult = rewriter.create<arith::XOrIOp>(loc, x, y);
call    0 never executed
    #####: 2844:    break;
    #####: 2845:  case CombiningKind::MINF:
    #####: 2846:    combinedResult = rewriter.create<arith::MinFOp>(loc, x, y);
call    0 never executed
    #####: 2847:    break;
    #####: 2848:  case CombiningKind::MAXF:
    #####: 2849:    combinedResult = rewriter.create<arith::MaxFOp>(loc, x, y);
call    0 never executed
    #####: 2850:    break;
        -: 2851:  }
    #####: 2852:  return combinedResult;
        -: 2853:}
        -: 2854:
        -: 2855:/// Convert vector.scan op into arith ops and
        -: 2856:/// vector.insert_strided_slice/extract_strided_slice
        -: 2857:///
        -: 2858:/// Ex:
        -: 2859:/// ```
        -: 2860:///   %0:2 = vector.scan <add>, %arg0, %arg1 {inclusive = true, reduction_dim =
        -: 2861:///   1} :
        -: 2862:///     (vector<2x3xi32>, vector<2xi32>) to (vector<2x3xi32>, vector<2xi32>)
        -: 2863:/// ```
        -: 2864:/// Gets converted to:
        -: 2865:/// ```
        -: 2866:///   %cst = arith.constant dense<0> : vector<2x3xi32>
        -: 2867:///   %0 = vector.extract_strided_slice %arg0 {offsets = [0, 0], sizes = [2, 1],
        -: 2868:///   strides = [1, 1]} : vector<2x3xi32> to vector<2x1xi32> %1 =
        -: 2869:///   vector.insert_strided_slice %0, %cst {offsets = [0, 0], strides = [1, 1]}
        -: 2870:///   : vector<2x1xi32> into vector<2x3xi32> %2 = vector.extract_strided_slice
        -: 2871:///   %arg0 {offsets = [0, 1], sizes = [2, 1], strides = [1, 1]} :
        -: 2872:///   vector<2x3xi32> to vector<2x1xi32> %3 = arith.muli %0, %2 :
        -: 2873:///   vector<2x1xi32> %4 = vector.insert_strided_slice %3, %1 {offsets = [0, 1],
        -: 2874:///   strides = [1, 1]} : vector<2x1xi32> into vector<2x3xi32> %5 =
        -: 2875:///   vector.extract_strided_slice %arg0 {offsets = [0, 2], sizes = [2, 1],
        -: 2876:///   strides = [1, 1]} : vector<2x3xi32> to vector<2x1xi32> %6 = arith.muli %3,
        -: 2877:///   %5 : vector<2x1xi32> %7 = vector.insert_strided_slice %6, %4 {offsets =
        -: 2878:///   [0, 2], strides = [1, 1]} : vector<2x1xi32> into vector<2x3xi32> %8 =
        -: 2879:///   vector.shape_cast %6 : vector<2x1xi32> to vector<2xi32> return %7, %8 :
        -: 2880:///   vector<2x3xi32>, vector<2xi32>
        -: 2881:/// ```
        -: 2882:struct ScanToArithOps : public OpRewritePattern<vector::ScanOp> {
        -: 2883:  using OpRewritePattern::OpRewritePattern;
        -: 2884:
function _ZNK12_GLOBAL__N_114ScanToArithOps15matchAndRewriteEN4mlir6vector6ScanOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2885:  LogicalResult matchAndRewrite(vector::ScanOp scanOp,
        -: 2886:                                PatternRewriter &rewriter) const override {
    #####: 2887:    auto loc = scanOp.getLoc();
call    0 never executed
    #####: 2888:    VectorType destType = scanOp.getDestType();
call    0 never executed
    #####: 2889:    ArrayRef<int64_t> destShape = destType.getShape();
call    0 never executed
    #####: 2890:    auto elType = destType.getElementType();
call    0 never executed
    #####: 2891:    bool isInt = elType.isIntOrIndex();
call    0 never executed
    #####: 2892:    if (!isValidKind(isInt, scanOp.getKind()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2893:      return failure();
        -: 2894:
    #####: 2895:    VectorType resType = VectorType::get(destShape, elType);
call    0 never executed
    #####: 2896:    Value result = rewriter.create<arith::ConstantOp>(
    #####: 2897:        loc, resType, rewriter.getZeroAttr(resType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2898:    int64_t reductionDim = scanOp.getReductionDim();
call    0 never executed
    #####: 2899:    bool inclusive = scanOp.getInclusive();
call    0 never executed
    #####: 2900:    int64_t destRank = destType.getRank();
call    0 never executed
    #####: 2901:    VectorType initialValueType = scanOp.getInitialValueType();
call    0 never executed
    #####: 2902:    int64_t initialValueRank = initialValueType.getRank();
call    0 never executed
        -: 2903:
    #####: 2904:    SmallVector<int64_t> reductionShape(destShape.begin(), destShape.end());
call    0 never executed
    #####: 2905:    reductionShape[reductionDim] = 1;
branch  0 never executed
branch  1 never executed
    #####: 2906:    VectorType reductionType = VectorType::get(reductionShape, elType);
call    0 never executed
    #####: 2907:    SmallVector<int64_t> offsets(destRank, 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2908:    SmallVector<int64_t> strides(destRank, 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2909:    SmallVector<int64_t> sizes(destShape.begin(), destShape.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2910:    sizes[reductionDim] = 1;
branch  0 never executed
branch  1 never executed
    #####: 2911:    ArrayAttr scanSizes = rewriter.getI64ArrayAttr(sizes);
call    0 never executed
    #####: 2912:    ArrayAttr scanStrides = rewriter.getI64ArrayAttr(strides);
call    0 never executed
        -: 2913:
    #####: 2914:    Value lastOutput, lastInput;
    #####: 2915:    for (int i = 0; i < destShape[reductionDim]; i++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2916:      offsets[reductionDim] = i;
branch  0 never executed
branch  1 never executed
    #####: 2917:      ArrayAttr scanOffsets = rewriter.getI64ArrayAttr(offsets);
call    0 never executed
    #####: 2918:      Value input = rewriter.create<vector::ExtractStridedSliceOp>(
    #####: 2919:          loc, reductionType, scanOp.getSource(), scanOffsets, scanSizes,
call    0 never executed
    #####: 2920:          scanStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2921:      Value output;
    #####: 2922:      if (i == 0) {
branch  0 never executed
branch  1 never executed
    #####: 2923:        if (inclusive) {
branch  0 never executed
branch  1 never executed
    #####: 2924:          output = input;
        -: 2925:        } else {
    #####: 2926:          if (initialValueRank == 0) {
branch  0 never executed
branch  1 never executed
        -: 2927:            // ShapeCastOp cannot handle 0-D vectors
    #####: 2928:            output = rewriter.create<vector::BroadcastOp>(
    #####: 2929:                loc, input.getType(), scanOp.getInitialValue());
call    0 never executed
call    1 never executed
        -: 2930:          } else {
    #####: 2931:            output = rewriter.create<vector::ShapeCastOp>(
    #####: 2932:                loc, input.getType(), scanOp.getInitialValue());
call    0 never executed
call    1 never executed
        -: 2933:          }
        -: 2934:        }
        -: 2935:      } else {
    #####: 2936:        Value y = inclusive ? input : lastInput;
branch  0 never executed
branch  1 never executed
    #####: 2937:        output = genOperator(loc, lastOutput, y, scanOp.getKind(), rewriter);
call    0 never executed
call    1 never executed
    #####: 2938:        assert(output != nullptr);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2939:      }
    #####: 2940:      result = rewriter.create<vector::InsertStridedSliceOp>(
    #####: 2941:          loc, output, result, offsets, strides);
call    0 never executed
    #####: 2942:      lastOutput = output;
    #####: 2943:      lastInput = input;
        -: 2944:    }
        -: 2945:
    #####: 2946:    Value reduction;
    #####: 2947:    if (initialValueRank == 0) {
branch  0 never executed
branch  1 never executed
    #####: 2948:      Value v = rewriter.create<vector::ExtractOp>(loc, lastOutput, 0);
call    0 never executed
call    1 never executed
    #####: 2949:      reduction =
    #####: 2950:          rewriter.create<vector::BroadcastOp>(loc, initialValueType, v);
call    0 never executed
        -: 2951:    } else {
    #####: 2952:      reduction = rewriter.create<vector::ShapeCastOp>(loc, initialValueType,
    #####: 2953:                                                       lastOutput);
call    0 never executed
        -: 2954:    }
        -: 2955:
    #####: 2956:    rewriter.replaceOp(scanOp, {result, reduction});
call    0 never executed
call    1 never executed
    #####: 2957:    return success();
branch  0 never executed
branch  1 never executed
        -: 2958:  }
        -: 2959:};
        -: 2960:
        -: 2961:} // namespace
        -: 2962:
function _ZN4mlir6vector41populateVectorMaskMaterializationPatternsERNS_17RewritePatternSetEbNS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 2963:void mlir::vector::populateVectorMaskMaterializationPatterns(
        -: 2964:    RewritePatternSet &patterns, bool force32BitVectorIndices,
        -: 2965:    PatternBenefit benefit) {
     1034: 2966:  patterns.add<VectorCreateMaskOpConversion,
        -: 2967:               MaterializeTransferMask<vector::TransferReadOp>,
        -: 2968:               MaterializeTransferMask<vector::TransferWriteOp>>(
     1034: 2969:      patterns.getContext(), force32BitVectorIndices, benefit);
call    0 returned 100%
     1034: 2970:}
        -: 2971:
function _ZN4mlir6vector32populateShapeCastFoldingPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####: 2972:void mlir::vector::populateShapeCastFoldingPatterns(RewritePatternSet &patterns,
        -: 2973:                                                    PatternBenefit benefit) {
    #####: 2974:  patterns.add<ShapeCastOpFolder>(patterns.getContext(), benefit);
call    0 never executed
    #####: 2975:}
        -: 2976:
function _ZN4mlir6vector37populateBubbleVectorBitCastOpPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####: 2977:void mlir::vector::populateBubbleVectorBitCastOpPatterns(
        -: 2978:    RewritePatternSet &patterns, PatternBenefit benefit) {
    #####: 2979:  patterns.add<BubbleDownVectorBitCastForExtract,
        -: 2980:               BubbleDownBitCastForStridedSliceExtract,
    #####: 2981:               BubbleUpBitCastForStridedSliceInsert>(patterns.getContext(),
call    0 never executed
    #####: 2982:                                                     benefit);
call    0 never executed
    #####: 2983:}
        -: 2984:
function _ZN4mlir6vector39populateVectorBroadcastLoweringPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 2985:void mlir::vector::populateVectorBroadcastLoweringPatterns(
        -: 2986:    RewritePatternSet &patterns, PatternBenefit benefit) {
     1034: 2987:  patterns.add<BroadcastOpLowering>(patterns.getContext(), benefit);
call    0 returned 100%
     1034: 2988:}
        -: 2989:
function _ZN4mlir6vector36populateVectorMaskOpLoweringPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 2990:void mlir::vector::populateVectorMaskOpLoweringPatterns(
        -: 2991:    RewritePatternSet &patterns, PatternBenefit benefit) {
     1034: 2992:  patterns.add<CreateMaskOpLowering, ConstantMaskOpLowering>(
     1034: 2993:      patterns.getContext(), benefit);
call    0 returned 100%
     1034: 2994:}
        -: 2995:
function _ZN4mlir6vector39populateVectorShapeCastLoweringPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 2996:void mlir::vector::populateVectorShapeCastLoweringPatterns(
        -: 2997:    RewritePatternSet &patterns, PatternBenefit benefit) {
     1034: 2998:  patterns.add<ShapeCastOp2DDownCastRewritePattern,
        -: 2999:               ShapeCastOp2DUpCastRewritePattern, ShapeCastOpRewritePattern>(
     1034: 3000:      patterns.getContext(), benefit);
call    0 returned 100%
     1034: 3001:}
        -: 3002:
function _ZN4mlir6vector38populateVectorContractLoweringPatternsERNS_17RewritePatternSetENS0_23VectorTransformsOptionsENS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 3003:void mlir::vector::populateVectorContractLoweringPatterns(
        -: 3004:    RewritePatternSet &patterns, VectorTransformsOptions options,
        -: 3005:    PatternBenefit benefit) {
     1034: 3006:  patterns.add<OuterProductOpLowering>(patterns.getContext(), benefit);
call    0 returned 100%
     1034: 3007:  patterns.add<ContractionOpLowering, ContractionOpToMatmulOpLowering,
        -: 3008:               ContractionOpToOuterProductOpLowering>(
     1034: 3009:      options, patterns.getContext(), benefit);
call    0 returned 100%
     1034: 3010:}
        -: 3011:
function _ZN4mlir6vector39populateVectorTransposeLoweringPatternsERNS_17RewritePatternSetENS0_23VectorTransformsOptionsENS_14PatternBenefitE called 1034 returned 100% blocks executed 100%
     1034: 3012:void mlir::vector::populateVectorTransposeLoweringPatterns(
        -: 3013:    RewritePatternSet &patterns, VectorTransformsOptions options,
        -: 3014:    PatternBenefit benefit) {
     1034: 3015:  patterns.add<TransposeOpLowering, TransposeOp2DToShuffleLowering>(
     1034: 3016:      options, patterns.getContext(), benefit);
call    0 returned 100%
     1034: 3017:}
        -: 3018:
function _ZN4mlir6vector41populateVectorReductionToContractPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####: 3019:void mlir::vector::populateVectorReductionToContractPatterns(
        -: 3020:    RewritePatternSet &patterns, PatternBenefit benefit) {
    #####: 3021:  patterns.add<MultiReduceToContract, CombineContractBroadcast,
        -: 3022:               CombineContractABTranspose, CombineContractResultTranspose,
        -: 3023:               ReorderCastOpsOnBroadcast, ReorderElementwiseOpsOnTranspose>(
    #####: 3024:      patterns.getContext(), benefit);
call    0 never executed
    #####: 3025:}
        -: 3026:
function _ZN4mlir6vector61populateVectorTransferCollapseInnerMostContiguousDimsPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####: 3027:void mlir::vector::
        -: 3028:    populateVectorTransferCollapseInnerMostContiguousDimsPatterns(
        -: 3029:        RewritePatternSet &patterns, PatternBenefit benefit) {
    #####: 3030:  patterns.add<DropInnerMostUnitDims>(patterns.getContext(), benefit);
call    0 never executed
    #####: 3031:}
        -: 3032:
function _ZN4mlir6vector38populateVectorTransferLoweringPatternsERNS_17RewritePatternSetEN4llvm8OptionalIjEENS_14PatternBenefitE called 3635 returned 100% blocks executed 100%
     3635: 3033:void mlir::vector::populateVectorTransferLoweringPatterns(
        -: 3034:    RewritePatternSet &patterns, llvm::Optional<unsigned> maxTransferRank,
        -: 3035:    PatternBenefit benefit) {
     3635: 3036:  patterns.add<TransferReadToVectorLoadLowering,
     3635: 3037:               TransferWriteToVectorStoreLowering>(patterns.getContext(),
call    0 returned 100%
     3635: 3038:                                                   maxTransferRank, benefit);
call    0 returned 100%
     3635: 3039:  patterns
        -: 3040:      .add<VectorLoadToMemrefLoadLowering, VectorStoreToMemrefStoreLowering>(
     3635: 3041:          patterns.getContext(), benefit);
call    0 returned 100%
     3635: 3042:}
        -: 3043:
function _ZN4mlir6vector34populateVectorScanLoweringPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####: 3044:void mlir::vector::populateVectorScanLoweringPatterns(
        -: 3045:    RewritePatternSet &patterns, PatternBenefit benefit) {
    #####: 3046:  patterns.add<ScanToArithOps>(patterns.getContext(), benefit);
call    0 never executed
    #####: 3047:}
