        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Transform/IR/TransformInterfaces.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Transform/IR/CMakeFiles/obj.MLIRTransformDialect.dir/TransformInterfaces.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Transform/IR/CMakeFiles/obj.MLIRTransformDialect.dir/TransformInterfaces.cpp.gcda
        -:    0:Runs:128633
        -:    1://===- TransformInterfaces.cpp - Transform Dialect Interfaces -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Transform/IR/TransformInterfaces.h"
        -:   10:#include "mlir/Dialect/Transform/IR/TransformTypes.h"
        -:   11:#include "mlir/IR/Diagnostics.h"
        -:   12:#include "mlir/IR/Operation.h"
        -:   13:#include "llvm/ADT/STLExtras.h"
        -:   14:#include "llvm/Support/Debug.h"
        -:   15:#include "llvm/Support/ErrorHandling.h"
        -:   16:
        -:   17:#define DEBUG_TYPE "transform-dialect"
        -:   18:#define DEBUG_PRINT_AFTER_ALL "transform-dialect-print-top-level-after-all"
        -:   19:#define DBGS() (llvm::dbgs() << "[" DEBUG_TYPE "] ")
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23://===----------------------------------------------------------------------===//
        -:   24:// TransformState
        -:   25://===----------------------------------------------------------------------===//
        -:   26:
        -:   27:constexpr const Value transform::TransformState::kTopLevelValue;
        -:   28:
function _ZN4mlir9transform14TransformStateC2EPNS_6RegionEPNS_9OperationERKNS0_16TransformOptionsE called 0 returned 0% blocks executed 0%
    #####:   29:transform::TransformState::TransformState(Region *region,
        -:   30:                                          Operation *payloadRoot,
    #####:   31:                                          const TransformOptions &options)
    #####:   32:    : topLevel(payloadRoot), options(options) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   33:  auto result = mappings.try_emplace(region);
call    0 never executed
    #####:   34:  assert(result.second && "the region scope is already present");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   35:  (void)result;
        -:   36:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
    #####:   37:  regionStack.push_back(region);
call    0 never executed
        -:   38:#endif // LLVM_ENABLE_ABI_BREAKING_CHECKS
    #####:   39:}
        -:   40:
function _ZNK4mlir9transform14TransformState11getTopLevelEv called 0 returned 0% blocks executed 0%
    #####:   41:Operation *transform::TransformState::getTopLevel() const { return topLevel; }
        -:   42:
        -:   43:ArrayRef<Operation *>
function _ZNK4mlir9transform14TransformState13getPayloadOpsENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   44:transform::TransformState::getPayloadOps(Value value) const {
    #####:   45:  const TransformOpMapping &operationMapping = getMapping(value).direct;
call    0 never executed
    #####:   46:  auto iter = operationMapping.find(value);
call    0 never executed
    #####:   47:  assert(iter != operationMapping.end() && "unknown handle");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   48:  return iter->getSecond();
call    0 never executed
        -:   49:}
        -:   50:
function _ZNK4mlir9transform14TransformState22getHandlesForPayloadOpEPNS_9OperationERN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:   51:LogicalResult transform::TransformState::getHandlesForPayloadOp(
        -:   52:    Operation *op, SmallVectorImpl<Value> &handles) const {
    #####:   53:  bool found = false;
    #####:   54:  for (const Mappings &mapping : llvm::make_second_range(mappings)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   55:    auto iterator = mapping.reverse.find(op);
call    0 never executed
    #####:   56:    if (iterator != mapping.reverse.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      llvm::append_range(handles, iterator->getSecond());
call    0 never executed
call    1 never executed
    #####:   58:      found = true;
call    0 never executed
        -:   59:    }
        -:   60:  }
        -:   61:
    #####:   62:  return success(found);
        -:   63:}
        -:   64:
        -:   65:LogicalResult
function _ZN4mlir9transform14TransformState13setPayloadOpsENS_5ValueEN4llvm8ArrayRefIPNS_9OperationEEE called 0 returned 0% blocks executed 0%
    #####:   66:transform::TransformState::setPayloadOps(Value value,
        -:   67:                                         ArrayRef<Operation *> targets) {
    #####:   68:  assert(value != kTopLevelValue &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   69:         "attempting to reset the transformation root");
        -:   70:
    #####:   71:  auto iface = value.getType().cast<TransformTypeInterface>();
call    0 never executed
    #####:   72:  DiagnosedSilenceableFailure result =
    #####:   73:      iface.checkPayload(value.getLoc(), targets);
call    0 never executed
call    1 never executed
    #####:   74:  if (failed(result.checkAndReport()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   75:    return failure();
        -:   76:
        -:   77:  // Setting new payload for the value without cleaning it first is a misuse of
        -:   78:  // the API, assert here.
    #####:   79:  SmallVector<Operation *> storedTargets(targets.begin(), targets.end());
call    0 never executed
call    1 never executed
    #####:   80:  Mappings &mappings = getMapping(value);
call    0 never executed
    #####:   81:  bool inserted =
    #####:   82:      mappings.direct.insert({value, std::move(storedTargets)}).second;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   83:  assert(inserted && "value is already associated with another list");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   84:  (void)inserted;
        -:   85:
    #####:   86:  for (Operation *op : targets)
branch  0 never executed
branch  1 never executed
    #####:   87:    mappings.reverse[op].push_back(value);
call    0 never executed
call    1 never executed
        -:   88:
    #####:   89:  return success();
branch  0 never executed
branch  1 never executed
        -:   90:}
        -:   91:
function _ZN4mlir9transform14TransformState18dropReverseMappingERNS1_8MappingsEPNS_9OperationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   92:void transform::TransformState::dropReverseMapping(Mappings &mappings,
        -:   93:                                                   Operation *op, Value value) {
    #####:   94:  auto it = mappings.reverse.find(op);
call    0 never executed
    #####:   95:  if (it == mappings.reverse.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:    return;
        -:   97:
    #####:   98:  llvm::erase_value(it->getSecond(), value);
call    0 never executed
call    1 never executed
    #####:   99:  if (it->getSecond().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:    mappings.reverse.erase(it);
call    0 never executed
        -:  101:}
        -:  102:
function _ZN4mlir9transform14TransformState16removePayloadOpsENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  103:void transform::TransformState::removePayloadOps(Value value) {
    #####:  104:  Mappings &mappings = getMapping(value);
call    0 never executed
    #####:  105:  for (Operation *op : mappings.direct[value])
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  106:    dropReverseMapping(mappings, op, value);
call    0 never executed
    #####:  107:  mappings.direct.erase(value);
call    0 never executed
    #####:  108:}
        -:  109:
function _ZN4mlir9transform14TransformState16updatePayloadOpsENS_5ValueEN4llvm12function_refIFPNS_9OperationES6_EEE called 0 returned 0% blocks executed 0%
    #####:  110:LogicalResult transform::TransformState::updatePayloadOps(
        -:  111:    Value value, function_ref<Operation *(Operation *)> callback) {
    #####:  112:  Mappings &mappings = getMapping(value);
call    0 never executed
    #####:  113:  auto it = mappings.direct.find(value);
call    0 never executed
    #####:  114:  assert(it != mappings.direct.end() && "unknown handle");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  115:  SmallVector<Operation *> &association = it->getSecond();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  116:  SmallVector<Operation *> updated;
branch  0 never executed
branch  1 never executed
    #####:  117:  updated.reserve(association.size());
branch  0 never executed
branch  1 never executed
        -:  118:
    #####:  119:  for (Operation *op : association) {
branch  0 never executed
branch  1 never executed
    #####:  120:    dropReverseMapping(mappings, op, value);
call    0 never executed
    #####:  121:    if (Operation *updatedOp = callback(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  122:      updated.push_back(updatedOp);
call    0 never executed
    #####:  123:      mappings.reverse[updatedOp].push_back(value);
call    0 never executed
call    1 never executed
        -:  124:    }
        -:  125:  }
        -:  126:
    #####:  127:  auto iface = value.getType().cast<TransformTypeInterface>();
call    0 never executed
    #####:  128:  DiagnosedSilenceableFailure result =
call    0 never executed
    #####:  129:      iface.checkPayload(value.getLoc(), updated);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  130:  if (failed(result.checkAndReport()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:    return failure();
        -:  132:
    #####:  133:  std::swap(association, updated);
call    0 never executed
    #####:  134:  return success();
call    0 never executed
        -:  135:}
        -:  136:
function _ZN4mlir9transform14TransformState27recordHandleInvalidationOneERNS_9OpOperandEPNS_9OperationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  137:void transform::TransformState::recordHandleInvalidationOne(
        -:  138:    OpOperand &handle, Operation *payloadOp, Value otherHandle) {
    #####:  139:  ArrayRef<Operation *> potentialAncestors = getPayloadOps(handle.get());
call    0 never executed
        -:  140:  // If the op is associated with invalidated handle, skip the check as it
        -:  141:  // may be reading invalid IR.
    #####:  142:  if (invalidatedHandles.count(otherHandle))
call    0 never executed
    #####:  143:    return;
        -:  144:
    #####:  145:  for (Operation *ancestor : potentialAncestors) {
branch  0 never executed
branch  1 never executed
    #####:  146:    if (!ancestor->isAncestor(payloadOp))
branch  0 never executed
branch  1 never executed
    #####:  147:      continue;
        -:  148:
        -:  149:    // Make sure the error-reporting lambda doesn't capture anything
        -:  150:    // by-reference because it will go out of scope. Additionally, extract
        -:  151:    // location from Payload IR ops because the ops themselves may be
        -:  152:    // deleted before the lambda gets called.
    #####:  153:    Location ancestorLoc = ancestor->getLoc();
call    0 never executed
        -:  154:    Location opLoc = payloadOp->getLoc();
    #####:  155:    Operation *owner = handle.getOwner();
call    0 never executed
    #####:  156:    unsigned operandNo = handle.getOperandNumber();
call    0 never executed
function _ZZN4mlir9transform14TransformState27recordHandleInvalidationOneERNS_9OpOperandEPNS_9OperationENS_5ValueEENKUlNS_8LocationEE_clES7_ called 0 returned 0% blocks executed 0%
    #####:  157:    invalidatedHandles[otherHandle] = [ancestorLoc, opLoc, owner, operandNo,
    #####:  158:                                       otherHandle](Location currentLoc) {
    #####:  159:      InFlightDiagnostic diag = emitError(currentLoc)
call    0 never executed
call    1 never executed
        -:  160:                                << "op uses a handle invalidated by a "
    #####:  161:                                   "previously executed transform op";
call    0 never executed
    #####:  162:      diag.attachNote(otherHandle.getLoc()) << "handle to invalidated ops";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  163:      diag.attachNote(owner->getLoc())
call    0 never executed
    #####:  164:          << "invalidated by this transform op that consumes its operand #"
call    0 never executed
    #####:  165:          << operandNo
call    0 never executed
        -:  166:          << " and invalidates handles to payload ops nested in payload "
    #####:  167:             "ops associated with the consumed handle";
call    0 never executed
    #####:  168:      diag.attachNote(ancestorLoc) << "ancestor payload op";
call    0 never executed
call    1 never executed
    #####:  169:      diag.attachNote(opLoc) << "nested payload op";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  170:    };
call    0 never executed
call    1 never executed
        -:  171:  }
        -:  172:}
        -:  173:
function _ZN4mlir9transform14TransformState24recordHandleInvalidationERNS_9OpOperandE called 0 returned 0% blocks executed 0%
    #####:  174:void transform::TransformState::recordHandleInvalidation(OpOperand &handle) {
    #####:  175:  for (const Mappings &mapping : llvm::make_second_range(mappings))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  176:    for (const auto &[payloadOp, otherHandles] : mapping.reverse)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  177:      for (Value otherHandle : otherHandles)
branch  0 never executed
branch  1 never executed
    #####:  178:        recordHandleInvalidationOne(handle, payloadOp, otherHandle);
call    0 never executed
    #####:  179:}
        -:  180:
function _ZN4mlir9transform14TransformState32checkAndRecordHandleInvalidationENS0_20TransformOpInterfaceE called 0 returned 0% blocks executed 0%
    #####:  181:LogicalResult transform::TransformState::checkAndRecordHandleInvalidation(
        -:  182:    TransformOpInterface transform) {
    #####:  183:  auto memoryEffectsIface =
    #####:  184:      cast<MemoryEffectOpInterface>(transform.getOperation());
call    0 never executed
    #####:  185:  SmallVector<MemoryEffects::EffectInstance> effects;
call    0 never executed
    #####:  186:  memoryEffectsIface.getEffectsOnResource(
    #####:  187:      transform::TransformMappingResource::get(), effects);
call    0 never executed
call    1 never executed
        -:  188:
    #####:  189:  for (OpOperand &target : transform->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  190:    // If the operand uses an invalidated handle, report it.
    #####:  191:    auto it = invalidatedHandles.find(target.get());
call    0 never executed
    #####:  192:    if (it != invalidatedHandles.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  193:      return it->getSecond()(transform->getLoc()), failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  194:
        -:  195:    // Invalidate handles pointing to the operations nested in the operation
        -:  196:    // associated with the handle consumed by this operation.
function _ZZN4mlir9transform14TransformState32checkAndRecordHandleInvalidationENS0_20TransformOpInterfaceEENKUlRKNS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEE_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  197:    auto consumesTarget = [&](const MemoryEffects::EffectInstance &effect) {
    #####:  198:      return isa<MemoryEffects::Free>(effect.getEffect()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  199:             effect.getValue() == target.get();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  200:    };
    #####:  201:    if (llvm::any_of(effects, consumesTarget))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  202:      recordHandleInvalidation(target);
call    0 never executed
        -:  203:  }
    #####:  204:  return success();
branch  0 never executed
branch  1 never executed
        -:  205:}
        -:  206:
        -:  207:DiagnosedSilenceableFailure
function _ZN4mlir9transform14TransformState14applyTransformENS0_20TransformOpInterfaceE called 0 returned 0% blocks executed 0%
    #####:  208:transform::TransformState::applyTransform(TransformOpInterface transform) {
    #####:  209:  LLVM_DEBUG(DBGS() << "applying: " << transform << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
function _ZZN4mlir9transform14TransformState14applyTransformENS0_20TransformOpInterfaceEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  210:  auto printOnFailureRAII = llvm::make_scope_exit([this] {
    #####:  211:    (void)this;
    #####:  212:    DEBUG_WITH_TYPE(DEBUG_PRINT_AFTER_ALL, {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -:  213:      DBGS() << "Top-level payload:\n";
        -:  214:      getTopLevel()->print(llvm::dbgs(),
        -:  215:                           mlir::OpPrintingFlags().printGenericOpForm());
        -:  216:    });
    #####:  217:  });
branch  0 never executed
branch  1 never executed
    #####:  218:  if (options.getExpensiveChecksEnabled()) {
branch  0 never executed
branch  1 never executed
    #####:  219:    if (failed(checkAndRecordHandleInvalidation(transform)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  220:      return DiagnosedSilenceableFailure::definiteFailure();
        -:  221:
    #####:  222:    for (OpOperand &operand : transform->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  223:      if (!isHandleConsumed(operand.get(), transform))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  224:        continue;
        -:  225:
    #####:  226:      DenseSet<Operation *> seen;
call    0 never executed
    #####:  227:      for (Operation *op : getPayloadOps(operand.get())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  228:        if (!seen.insert(op).second) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  229:          DiagnosedSilenceableFailure diag =
    #####:  230:              transform.emitSilenceableError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  231:              << "a handle passed as operand #" << operand.getOperandNumber()
call    0 never executed
call    1 never executed
call    2 never executed
        -:  232:              << " and consumed by this operation points to a payload "
    #####:  233:                 "operation more than once";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  234:          diag.attachNote(op->getLoc()) << "repeated target op";
call    0 never executed
call    1 never executed
    #####:  235:          return diag;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  236:        }
        -:  237:      }
        -:  238:    }
        -:  239:  }
        -:  240:
    #####:  241:  transform::TransformResults results(transform->getNumResults());
call    0 never executed
        -:  242:  // Compute the result but do not short-circuit the silenceable failure case as
        -:  243:  // we still want the handles to propagate properly so the "suppress" mode can
        -:  244:  // proceed on a best effort basis.
    #####:  245:  DiagnosedSilenceableFailure result(transform.apply(results, *this));
call    0 never executed
    #####:  246:  if (result.isDefiniteFailure())
branch  0 never executed
branch  1 never executed
    #####:  247:    return result;
        -:  248:
        -:  249:  // Remove the mapping for the operand if it is consumed by the operation. This
        -:  250:  // allows us to catch use-after-free with assertions later on.
    #####:  251:  auto memEffectInterface =
    #####:  252:      cast<MemoryEffectOpInterface>(transform.getOperation());
call    0 never executed
    #####:  253:  SmallVector<MemoryEffects::EffectInstance, 2> effects;
call    0 never executed
call    1 never executed
    #####:  254:  for (OpOperand &target : transform->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  255:    effects.clear();
call    0 never executed
    #####:  256:    memEffectInterface.getEffectsOnValue(target.get(), effects);
call    0 never executed
function _ZZN4mlir9transform14TransformState14applyTransformENS0_20TransformOpInterfaceEENKUlRKNS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEE0_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  257:    if (llvm::any_of(effects, [](const MemoryEffects::EffectInstance &effect) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  258:          return isa<transform::TransformMappingResource>(
    #####:  259:                     effect.getResource()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  260:                 isa<MemoryEffects::Free>(effect.getEffect());
call    0 never executed
        -:  261:        })) {
    #####:  262:      removePayloadOps(target.get());
call    0 never executed
        -:  263:    }
        -:  264:  }
        -:  265:
    #####:  266:  for (OpResult result : transform->getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  267:    assert(result.getDefiningOp() == transform.getOperation() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  268:           "payload IR association for a value other than the result of the "
        -:  269:           "current transform op");
    #####:  270:    if (failed(setPayloadOps(result, results.get(result.getResultNumber()))))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  271:      return DiagnosedSilenceableFailure::definiteFailure();
        -:  272:  }
        -:  273:
    #####:  274:  printOnFailureRAII.release();
branch  0 never executed
branch  1 never executed
    #####:  275:  DEBUG_WITH_TYPE(DEBUG_PRINT_AFTER_ALL, {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  276:    DBGS() << "Top-level payload:\n";
        -:  277:    getTopLevel()->print(llvm::dbgs());
        -:  278:  });
    #####:  279:  return result;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  280:}
        -:  281:
        -:  282://===----------------------------------------------------------------------===//
        -:  283:// TransformState::Extension
        -:  284://===----------------------------------------------------------------------===//
        -:  285:
        -:  286:transform::TransformState::Extension::~Extension() = default;
        -:  287:
        -:  288:LogicalResult
function _ZN4mlir9transform14TransformState9Extension16replacePayloadOpEPNS_9OperationES4_ called 0 returned 0% blocks executed 0%
    #####:  289:transform::TransformState::Extension::replacePayloadOp(Operation *op,
        -:  290:                                                       Operation *replacement) {
    #####:  291:  SmallVector<Value> handles;
call    0 never executed
    #####:  292:  if (failed(state.getHandlesForPayloadOp(op, handles)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  293:    return failure();
        -:  294:
    #####:  295:  for (Value handle : handles) {
branch  0 never executed
branch  1 never executed
    #####:  296:    LogicalResult result =
    #####:  297:        state.updatePayloadOps(handle, [&](Operation *current) {
    #####:  298:          return current == op ? replacement : current;
branch  0 never executed
branch  1 never executed
    #####:  299:        });
call    0 never executed
    #####:  300:    if (failed(result))
branch  0 never executed
branch  1 never executed
    #####:  301:      return failure();
        -:  302:  }
    #####:  303:  return success();
branch  0 never executed
branch  1 never executed
        -:  304:}
        -:  305:
        -:  306://===----------------------------------------------------------------------===//
        -:  307:// TransformResults
        -:  308://===----------------------------------------------------------------------===//
        -:  309:
function _ZN4mlir9transform16TransformResultsC2Ej called 0 returned 0% blocks executed 0%
    #####:  310:transform::TransformResults::TransformResults(unsigned numSegments) {
call    0 never executed
call    1 never executed
    #####:  311:  segments.resize(numSegments,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  312:                  ArrayRef<Operation *>(nullptr, static_cast<size_t>(0)));
    #####:  313:}
        -:  314:
function _ZN4mlir9transform16TransformResults3setENS_8OpResultEN4llvm8ArrayRefIPNS_9OperationEEE called 0 returned 0% blocks executed 0%
    #####:  315:void transform::TransformResults::set(OpResult value,
        -:  316:                                      ArrayRef<Operation *> ops) {
    #####:  317:  unsigned position = value.getResultNumber();
call    0 never executed
    #####:  318:  assert(position < segments.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  319:         "setting results for a non-existent handle");
    #####:  320:  assert(segments[position].data() == nullptr && "results already set");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  321:  unsigned start = operations.size();
call    0 never executed
    #####:  322:  llvm::append_range(operations, ops);
call    0 never executed
    #####:  323:  segments[position] = makeArrayRef(operations).drop_front(start);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  324:}
        -:  325:
        -:  326:ArrayRef<Operation *>
function _ZNK4mlir9transform16TransformResults3getEj called 0 returned 0% blocks executed 0%
    #####:  327:transform::TransformResults::get(unsigned resultNumber) const {
    #####:  328:  assert(resultNumber < segments.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  329:         "querying results for a non-existent handle");
    #####:  330:  assert(segments[resultNumber].data() != nullptr && "querying unset results");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  331:  return segments[resultNumber];
        -:  332:}
        -:  333:
        -:  334://===----------------------------------------------------------------------===//
        -:  335:// Utilities for PossibleTopLevelTransformOpTrait.
        -:  336://===----------------------------------------------------------------------===//
        -:  337:
function _ZN4mlir9transform6detail44mapPossibleTopLevelTransformOpBlockArgumentsERNS0_14TransformStateEPNS_9OperationERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  338:LogicalResult transform::detail::mapPossibleTopLevelTransformOpBlockArguments(
        -:  339:    TransformState &state, Operation *op, Region &region) {
    #####:  340:  SmallVector<Operation *> targets;
branch  0 never executed
branch  1 never executed
    #####:  341:  if (op->getNumOperands() != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  342:    llvm::append_range(targets, state.getPayloadOps(op->getOperand(0)));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  343:  else
    #####:  344:    targets.push_back(state.getTopLevel());
call    0 never executed
        -:  345:
    #####:  346:  return state.mapBlockArguments(region.front().getArgument(0), targets);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  347:}
        -:  348:
        -:  349:LogicalResult
function _ZN4mlir9transform6detail38verifyPossibleTopLevelTransformOpTraitEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  350:transform::detail::verifyPossibleTopLevelTransformOpTrait(Operation *op) {
        -:  351:  // Attaching this trait without the interface is a misuse of the API, but it
        -:  352:  // cannot be caught via a static_assert because interface registration is
        -:  353:  // dynamic.
    #####:  354:  assert(isa<TransformOpInterface>(op) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  355:         "should implement TransformOpInterface to have "
        -:  356:         "PossibleTopLevelTransformOpTrait");
        -:  357:
    #####:  358:  if (op->getNumRegions() < 1)
branch  0 never executed
branch  1 never executed
    #####:  359:    return op->emitOpError() << "expects at least one region";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  360:
    #####:  361:  Region *bodyRegion = &op->getRegion(0);
call    0 never executed
    #####:  362:  if (!llvm::hasNItems(*bodyRegion, 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  363:    return op->emitOpError() << "expects a single-block region";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  364:
    #####:  365:  Block *body = &bodyRegion->front();
call    0 never executed
    #####:  366:  if (body->getNumArguments() != 1 ||
branch  0 never executed
branch  1 never executed
    #####:  367:      !body->getArgumentTypes()[0].isa<TransformTypeInterface>()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  368:    return op->emitOpError() << "expects the entry block to have one argument "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  369:                                "of type implementing TransformTypeInterface";
call    0 never executed
        -:  370:  }
        -:  371:
    #####:  372:  if (auto *parent =
    #####:  373:          op->getParentWithTrait<PossibleTopLevelTransformOpTrait>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  374:    if (op->getNumOperands() == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  375:      InFlightDiagnostic diag =
    #####:  376:          op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  377:          << "expects the root operation to be provided for a nested op";
call    0 never executed
call    1 never executed
    #####:  378:      diag.attachNote(parent->getLoc())
call    0 never executed
    #####:  379:          << "nested in another possible top-level op";
call    0 never executed
    #####:  380:      return diag;
call    0 never executed
        -:  381:    }
        -:  382:  }
        -:  383:
    #####:  384:  return success();
        -:  385:}
        -:  386:
        -:  387://===----------------------------------------------------------------------===//
        -:  388:// Memory effects.
        -:  389://===----------------------------------------------------------------------===//
        -:  390:
function _ZN4mlir9transform14consumesHandleENS_10ValueRangeERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  391:void transform::consumesHandle(
        -:  392:    ValueRange handles,
        -:  393:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  394:  for (Value handle : handles) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  395:    effects.emplace_back(MemoryEffects::Read::get(), handle,
    #####:  396:                         TransformMappingResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  397:    effects.emplace_back(MemoryEffects::Free::get(), handle,
    #####:  398:                         TransformMappingResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  399:  }
    #####:  400:}
        -:  401:
        -:  402:/// Returns `true` if the given list of effects instances contains an instance
        -:  403:/// with the effect type specified as template parameter.
        -:  404:template <typename EffectTy, typename ResourceTy = SideEffects::DefaultResource>
    #####:  405:static bool hasEffect(ArrayRef<MemoryEffects::EffectInstance> effects) {
    #####:  406:  return llvm::any_of(effects, [](const MemoryEffects::EffectInstance &effect) {
call    0 never executed
------------------
_ZZ9hasEffectIN4mlir13MemoryEffects4ReadENS0_9transform24TransformMappingResourceEEbN4llvm8ArrayRefINS0_11SideEffects14EffectInstanceINS1_6EffectEEEEEENKUlRKSA_E_clESD_.isra.0:
function _ZZ9hasEffectIN4mlir13MemoryEffects4ReadENS0_9transform24TransformMappingResourceEEbN4llvm8ArrayRefINS0_11SideEffects14EffectInstanceINS1_6EffectEEEEEENKUlRKSA_E_clESD_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  406:  return llvm::any_of(effects, [](const MemoryEffects::EffectInstance &effect) {
------------------
_ZZ9hasEffectIN4mlir13MemoryEffects4FreeENS0_9transform24TransformMappingResourceEEbN4llvm8ArrayRefINS0_11SideEffects14EffectInstanceINS1_6EffectEEEEEENKUlRKSA_E_clESD_.isra.0:
function _ZZ9hasEffectIN4mlir13MemoryEffects4FreeENS0_9transform24TransformMappingResourceEEbN4llvm8ArrayRefINS0_11SideEffects14EffectInstanceINS1_6EffectEEEEEENKUlRKSA_E_clESD_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  406:  return llvm::any_of(effects, [](const MemoryEffects::EffectInstance &effect) {
------------------
    #####:  407:    return isa<EffectTy>(effect.getEffect()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  408:           isa<ResourceTy>(effect.getResource());
call    0 never executed
call    1 never executed
        -:  409:  });
        -:  410:}
        -:  411:
function _ZN4mlir9transform16isHandleConsumedENS_5ValueENS0_20TransformOpInterfaceE called 0 returned 0% blocks executed 0%
    #####:  412:bool transform::isHandleConsumed(Value handle,
        -:  413:                                 transform::TransformOpInterface transform) {
    #####:  414:  auto iface = cast<MemoryEffectOpInterface>(transform.getOperation());
call    0 never executed
    #####:  415:  SmallVector<MemoryEffects::EffectInstance> effects;
call    0 never executed
    #####:  416:  iface.getEffectsOnValue(handle, effects);
call    0 never executed
    #####:  417:  return ::hasEffect<MemoryEffects::Read, TransformMappingResource>(effects) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  418:         ::hasEffect<MemoryEffects::Free, TransformMappingResource>(effects);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  419:}
        -:  420:
function _ZN4mlir9transform14producesHandleENS_10ValueRangeERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  421:void transform::producesHandle(
        -:  422:    ValueRange handles,
        -:  423:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  424:  for (Value handle : handles) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  425:    effects.emplace_back(MemoryEffects::Allocate::get(), handle,
    #####:  426:                         TransformMappingResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  427:    effects.emplace_back(MemoryEffects::Write::get(), handle,
    #####:  428:                         TransformMappingResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  429:  }
    #####:  430:}
        -:  431:
function _ZN4mlir9transform15onlyReadsHandleENS_10ValueRangeERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  432:void transform::onlyReadsHandle(
        -:  433:    ValueRange handles,
        -:  434:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  435:  for (Value handle : handles) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  436:    effects.emplace_back(MemoryEffects::Read::get(), handle,
    #####:  437:                         TransformMappingResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  438:  }
    #####:  439:}
        -:  440:
function _ZN4mlir9transform15modifiesPayloadERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  441:void transform::modifiesPayload(
        -:  442:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  443:  effects.emplace_back(MemoryEffects::Read::get(), PayloadIRResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  444:  effects.emplace_back(MemoryEffects::Write::get(), PayloadIRResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  445:}
        -:  446:
function _ZN4mlir9transform16onlyReadsPayloadERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  447:void transform::onlyReadsPayload(
        -:  448:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  449:  effects.emplace_back(MemoryEffects::Read::get(), PayloadIRResource::get());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  450:}
        -:  451:
        -:  452://===----------------------------------------------------------------------===//
        -:  453:// Entry point.
        -:  454://===----------------------------------------------------------------------===//
        -:  455:
function _ZN4mlir9transform15applyTransformsEPNS_9OperationENS0_20TransformOpInterfaceERKNS0_16TransformOptionsE called 0 returned 0% blocks executed 0%
    #####:  456:LogicalResult transform::applyTransforms(Operation *payloadRoot,
        -:  457:                                         TransformOpInterface transform,
        -:  458:                                         const TransformOptions &options) {
        -:  459:#ifndef NDEBUG
    #####:  460:  if (!transform->hasTrait<PossibleTopLevelTransformOpTrait>() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  461:      transform->getNumOperands() != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  462:    transform->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  463:        << "expected transform to start at the top-level transform op";
call    0 never executed
    #####:  464:    llvm::report_fatal_error("could not run transforms",
call    0 never executed
        -:  465:                             /*gen_crash_diag=*/false);
        -:  466:  }
        -:  467:#endif // NDEBUG
        -:  468:
    #####:  469:  TransformState state(transform->getParentRegion(), payloadRoot, options);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  470:  return state.applyTransform(transform).checkAndReport();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  471:}
        -:  472:
        -:  473://===----------------------------------------------------------------------===//
        -:  474:// Generated interface implementation.
        -:  475://===----------------------------------------------------------------------===//
        -:  476:
        -:  477:#include "mlir/Dialect/Transform/IR/TransformInterfaces.cpp.inc"
