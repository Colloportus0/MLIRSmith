        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/MDBuilder.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===---- llvm/MDBuilder.h - Builder for LLVM metadata ----------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the MDBuilder class, which is used as a convenient way to
        -:   10:// create LLVM metadata with a consistent and simplified interface.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_IR_MDBUILDER_H
        -:   15:#define LLVM_IR_MDBUILDER_H
        -:   16:
        -:   17:#include "llvm/ADT/DenseSet.h"
        -:   18:#include "llvm/ADT/SmallVector.h"
        -:   19:#include "llvm/ADT/StringRef.h"
        -:   20:#include "llvm/IR/GlobalValue.h"
        -:   21:#include "llvm/Support/DataTypes.h"
        -:   22:#include <utility>
        -:   23:
        -:   24:namespace llvm {
        -:   25:
        -:   26:class APInt;
        -:   27:template <typename T> class ArrayRef;
        -:   28:class LLVMContext;
        -:   29:class Constant;
        -:   30:class ConstantAsMetadata;
        -:   31:class Function;
        -:   32:class MDNode;
        -:   33:class MDString;
        -:   34:class Metadata;
        -:   35:
        -:   36:class MDBuilder {
        -:   37:  LLVMContext &Context;
        -:   38:
        -:   39:public:
    #####:   40:  MDBuilder(LLVMContext &context) : Context(context) {}
call    0 never executed
call    1 never executed
        -:   41:
        -:   42:  /// Return the given string as metadata.
        -:   43:  MDString *createString(StringRef Str);
        -:   44:
        -:   45:  /// Return the given constant as metadata.
        -:   46:  ConstantAsMetadata *createConstant(Constant *C);
        -:   47:
        -:   48:  //===------------------------------------------------------------------===//
        -:   49:  // FPMath metadata.
        -:   50:  //===------------------------------------------------------------------===//
        -:   51:
        -:   52:  /// Return metadata with the given settings.  The special value 0.0
        -:   53:  /// for the Accuracy parameter indicates the default (maximal precision)
        -:   54:  /// setting.
        -:   55:  MDNode *createFPMath(float Accuracy);
        -:   56:
        -:   57:  //===------------------------------------------------------------------===//
        -:   58:  // Prof metadata.
        -:   59:  //===------------------------------------------------------------------===//
        -:   60:
        -:   61:  /// Return metadata containing two branch weights.
        -:   62:  MDNode *createBranchWeights(uint32_t TrueWeight, uint32_t FalseWeight);
        -:   63:
        -:   64:  /// Return metadata containing a number of branch weights.
        -:   65:  MDNode *createBranchWeights(ArrayRef<uint32_t> Weights);
        -:   66:
        -:   67:  /// Return metadata specifying that a branch or switch is unpredictable.
        -:   68:  MDNode *createUnpredictable();
        -:   69:
        -:   70:  /// Return metadata containing the entry \p Count for a function, a boolean
        -:   71:  /// \Synthetic indicating whether the counts were synthetized, and the
        -:   72:  /// GUIDs stored in \p Imports that need to be imported for sample PGO, to
        -:   73:  /// enable the same inlines as the profiled optimized binary
        -:   74:  MDNode *createFunctionEntryCount(uint64_t Count, bool Synthetic,
        -:   75:                                   const DenseSet<GlobalValue::GUID> *Imports);
        -:   76:
        -:   77:  /// Return metadata containing the section prefix for a function.
        -:   78:  MDNode *createFunctionSectionPrefix(StringRef Prefix);
        -:   79:
        -:   80:  /// Return metadata containing the pseudo probe descriptor for a function.
        -:   81:  MDNode *createPseudoProbeDesc(uint64_t GUID, uint64_t Hash, Function *F);
        -:   82:
        -:   83:  //===------------------------------------------------------------------===//
        -:   84:  // Range metadata.
        -:   85:  //===------------------------------------------------------------------===//
        -:   86:
        -:   87:  /// Return metadata describing the range [Lo, Hi).
        -:   88:  MDNode *createRange(const APInt &Lo, const APInt &Hi);
        -:   89:
        -:   90:  /// Return metadata describing the range [Lo, Hi).
        -:   91:  MDNode *createRange(Constant *Lo, Constant *Hi);
        -:   92:
        -:   93:  //===------------------------------------------------------------------===//
        -:   94:  // Callees metadata.
        -:   95:  //===------------------------------------------------------------------===//
        -:   96:
        -:   97:  /// Return metadata indicating the possible callees of indirect
        -:   98:  /// calls.
        -:   99:  MDNode *createCallees(ArrayRef<Function *> Callees);
        -:  100:
        -:  101:  //===------------------------------------------------------------------===//
        -:  102:  // Callback metadata.
        -:  103:  //===------------------------------------------------------------------===//
        -:  104:
        -:  105:  /// Return metadata describing a callback (see llvm::AbstractCallSite).
        -:  106:  MDNode *createCallbackEncoding(unsigned CalleeArgNo, ArrayRef<int> Arguments,
        -:  107:                                 bool VarArgsArePassed);
        -:  108:
        -:  109:  /// Merge the new callback encoding \p NewCB into \p ExistingCallbacks.
        -:  110:  MDNode *mergeCallbackEncodings(MDNode *ExistingCallbacks, MDNode *NewCB);
        -:  111:
        -:  112:  /// Return metadata feeding to the CodeGen about how to generate a function
        -:  113:  /// prologue for the "function" santizier.
        -:  114:  MDNode *createRTTIPointerPrologue(Constant *PrologueSig, Constant *RTTI);
        -:  115:
        -:  116:  //===------------------------------------------------------------------===//
        -:  117:  // PC sections metadata.
        -:  118:  //===------------------------------------------------------------------===//
        -:  119:
        -:  120:  /// A pair of PC section name with auxilliary constant data.
        -:  121:  using PCSection = std::pair<StringRef, SmallVector<Constant *>>;
        -:  122:
        -:  123:  /// Return metadata for PC sections.
        -:  124:  MDNode *createPCSections(ArrayRef<PCSection> Sections);
        -:  125:
        -:  126:  //===------------------------------------------------------------------===//
        -:  127:  // AA metadata.
        -:  128:  //===------------------------------------------------------------------===//
        -:  129:
        -:  130:protected:
        -:  131:  /// Return metadata appropriate for a AA root node (scope or TBAA).
        -:  132:  /// Each returned node is distinct from all other metadata and will never
        -:  133:  /// be identified (uniqued) with anything else.
        -:  134:  MDNode *createAnonymousAARoot(StringRef Name = StringRef(),
        -:  135:                                MDNode *Extra = nullptr);
        -:  136:
        -:  137:public:
        -:  138:  /// Return metadata appropriate for a TBAA root node. Each returned
        -:  139:  /// node is distinct from all other metadata and will never be identified
        -:  140:  /// (uniqued) with anything else.
        -:  141:  MDNode *createAnonymousTBAARoot() {
        -:  142:    return createAnonymousAARoot();
        -:  143:  }
        -:  144:
        -:  145:  /// Return metadata appropriate for an alias scope domain node.
        -:  146:  /// Each returned node is distinct from all other metadata and will never
        -:  147:  /// be identified (uniqued) with anything else.
        -:  148:  MDNode *createAnonymousAliasScopeDomain(StringRef Name = StringRef()) {
        -:  149:    return createAnonymousAARoot(Name);
        -:  150:  }
        -:  151:
        -:  152:  /// Return metadata appropriate for an alias scope root node.
        -:  153:  /// Each returned node is distinct from all other metadata and will never
        -:  154:  /// be identified (uniqued) with anything else.
        -:  155:  MDNode *createAnonymousAliasScope(MDNode *Domain,
        -:  156:                                    StringRef Name = StringRef()) {
        -:  157:    return createAnonymousAARoot(Name, Domain);
        -:  158:  }
        -:  159:
        -:  160:  /// Return metadata appropriate for a TBAA root node with the given
        -:  161:  /// name.  This may be identified (uniqued) with other roots with the same
        -:  162:  /// name.
        -:  163:  MDNode *createTBAARoot(StringRef Name);
        -:  164:
        -:  165:  /// Return metadata appropriate for an alias scope domain node with
        -:  166:  /// the given name. This may be identified (uniqued) with other roots with
        -:  167:  /// the same name.
        -:  168:  MDNode *createAliasScopeDomain(StringRef Name);
        -:  169:
        -:  170:  /// Return metadata appropriate for an alias scope node with
        -:  171:  /// the given name. This may be identified (uniqued) with other scopes with
        -:  172:  /// the same name and domain.
        -:  173:  MDNode *createAliasScope(StringRef Name, MDNode *Domain);
        -:  174:
        -:  175:  /// Return metadata for a non-root TBAA node with the given name,
        -:  176:  /// parent in the TBAA tree, and value for 'pointsToConstantMemory'.
        -:  177:  MDNode *createTBAANode(StringRef Name, MDNode *Parent,
        -:  178:                         bool isConstant = false);
        -:  179:
        -:  180:  struct TBAAStructField {
        -:  181:    uint64_t Offset;
        -:  182:    uint64_t Size;
        -:  183:    MDNode *Type;
        -:  184:    TBAAStructField(uint64_t Offset, uint64_t Size, MDNode *Type) :
        -:  185:      Offset(Offset), Size(Size), Type(Type) {}
        -:  186:  };
        -:  187:
        -:  188:  /// Return metadata for a tbaa.struct node with the given
        -:  189:  /// struct field descriptions.
        -:  190:  MDNode *createTBAAStructNode(ArrayRef<TBAAStructField> Fields);
        -:  191:
        -:  192:  /// Return metadata for a TBAA struct node in the type DAG
        -:  193:  /// with the given name, a list of pairs (offset, field type in the type DAG).
        -:  194:  MDNode *
        -:  195:  createTBAAStructTypeNode(StringRef Name,
        -:  196:                           ArrayRef<std::pair<MDNode *, uint64_t>> Fields);
        -:  197:
        -:  198:  /// Return metadata for a TBAA scalar type node with the
        -:  199:  /// given name, an offset and a parent in the TBAA type DAG.
        -:  200:  MDNode *createTBAAScalarTypeNode(StringRef Name, MDNode *Parent,
        -:  201:                                   uint64_t Offset = 0);
        -:  202:
        -:  203:  /// Return metadata for a TBAA tag node with the given
        -:  204:  /// base type, access type and offset relative to the base type.
        -:  205:  MDNode *createTBAAStructTagNode(MDNode *BaseType, MDNode *AccessType,
        -:  206:                                  uint64_t Offset, bool IsConstant = false);
        -:  207:
        -:  208:  /// Return metadata for a TBAA type node in the TBAA type DAG with the
        -:  209:  /// given parent type, size in bytes, type identifier and a list of fields.
        -:  210:  MDNode *createTBAATypeNode(MDNode *Parent, uint64_t Size, Metadata *Id,
        -:  211:                             ArrayRef<TBAAStructField> Fields =
        -:  212:                                 ArrayRef<TBAAStructField>());
        -:  213:
        -:  214:  /// Return metadata for a TBAA access tag with the given base type,
        -:  215:  /// final access type, offset of the access relative to the base type, size of
        -:  216:  /// the access and flag indicating whether the accessed object can be
        -:  217:  /// considered immutable for the purposes of the TBAA analysis.
        -:  218:  MDNode *createTBAAAccessTag(MDNode *BaseType, MDNode *AccessType,
        -:  219:                              uint64_t Offset, uint64_t Size,
        -:  220:                              bool IsImmutable = false);
        -:  221:
        -:  222:  /// Return mutable version of the given mutable or immutable TBAA
        -:  223:  /// access tag.
        -:  224:  MDNode *createMutableTBAAAccessTag(MDNode *Tag);
        -:  225:
        -:  226:  /// Return metadata containing an irreducible loop header weight.
        -:  227:  MDNode *createIrrLoopHeaderWeight(uint64_t Weight);
        -:  228:};
        -:  229:
        -:  230:} // end namespace llvm
        -:  231:
        -:  232:#endif
