        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Support/Timing.cpp
        -:    0:Graph:../tools/mlir/lib/Support/CMakeFiles/obj.MLIRSupport.dir/Timing.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Support/CMakeFiles/obj.MLIRSupport.dir/Timing.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- Timing.cpp - Execution time measurement facilities -----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Facilities to measure and provide statistics on execution time.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Support/Timing.h"
        -:   14:#include "mlir/Support/ThreadLocalCache.h"
        -:   15:#include "llvm/ADT/MapVector.h"
        -:   16:#include "llvm/ADT/Statistic.h"
        -:   17:#include "llvm/ADT/StringMap.h"
        -:   18:#include "llvm/ADT/StringSet.h"
        -:   19:#include "llvm/Support/Allocator.h"
        -:   20:#include "llvm/Support/CommandLine.h"
        -:   21:#include "llvm/Support/Format.h"
        -:   22:#include "llvm/Support/FormatVariadic.h"
        -:   23:#include "llvm/Support/ManagedStatic.h"
        -:   24:#include "llvm/Support/RWMutex.h"
        -:   25:#include "llvm/Support/Threading.h"
        -:   26:#include "llvm/Support/raw_ostream.h"
        -:   27:
        -:   28:#include <atomic>
        -:   29:#include <chrono>
        -:   30:
        -:   31:using namespace mlir;
        -:   32:using namespace detail;
        -:   33:using DisplayMode = DefaultTimingManager::DisplayMode;
        -:   34:
        -:   35:constexpr llvm::StringLiteral kTimingDescription =
        -:   36:    "... Execution time report ...";
        -:   37:
        -:   38://===----------------------------------------------------------------------===//
        -:   39:// TimingManager
        -:   40://===----------------------------------------------------------------------===//
        -:   41:
        -:   42:namespace mlir {
        -:   43:namespace detail {
        -:   44:/// Private implementation details of the `TimingManager`.
        -:   45:class TimingManagerImpl {
        -:   46:public:
        -:   47:  // Identifier allocator, map, and mutex for thread safety.
        -:   48:  llvm::BumpPtrAllocator identifierAllocator;
        -:   49:  llvm::StringSet<llvm::BumpPtrAllocator &> identifiers;
        -:   50:  llvm::sys::SmartRWMutex<true> identifierMutex;
        -:   51:
        -:   52:  /// A thread local cache of identifiers to reduce lock contention.
        -:   53:  ThreadLocalCache<llvm::StringMap<llvm::StringMapEntry<llvm::NoneType> *>>
        -:   54:      localIdentifierCache;
        -:   55:
function _ZN4mlir6detail17TimingManagerImplC2Ev called 103693 returned 100% blocks executed 100%
   103693:   56:  TimingManagerImpl() : identifiers(identifierAllocator) {}
        -:   57:};
        -:   58:} // namespace detail
        -:   59:} // namespace mlir
        -:   60:
function _ZN4mlir13TimingManagerC2Ev called 0 returned 0% blocks executed 0%
    #####:   61:TimingManager::TimingManager() : impl(std::make_unique<TimingManagerImpl>()) {}
call    0 never executed
        -:   62:
        -:   63:TimingManager::~TimingManager() = default;
        -:   64:
        -:   65:/// Get the root timer of this timing manager.
function _ZN4mlir13TimingManager12getRootTimerEv called 0 returned 0% blocks executed 0%
  103693*:   66:Timer TimingManager::getRootTimer() {
    #####:   67:  auto rt = rootTimer();
call    0 never executed
  103693*:   68:  return rt ? Timer(*this, *rt) : Timer();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 never executed
branch  3 never executed
        -:   69:}
        -:   70:
        -:   71:/// Get the root timer of this timing manager wrapped in a `TimingScope`.
function _ZN4mlir13TimingManager12getRootScopeEv called 103693 returned 100% blocks executed 100%
   103693:   72:TimingScope TimingManager::getRootScope() {
   207386:   73:  return TimingScope(getRootTimer());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        -:   74:}
        -:   75:
        -:   76://===----------------------------------------------------------------------===//
        -:   77:// Identifier uniquing
        -:   78://===----------------------------------------------------------------------===//
        -:   79:
        -:   80:/// Return an identifier for the specified string.
function _ZN4mlir16TimingIdentifier3getEN4llvm9StringRefERNS_13TimingManagerE called 1171 returned 100% blocks executed 76%
     1171:   81:TimingIdentifier TimingIdentifier::get(StringRef str, TimingManager &tm) {
        -:   82:  // Check for an existing instance in the local cache.
     1171:   83:  auto &impl = *tm.impl;
call    0 returned 100%
     1171:   84:  auto *&localEntry = (*impl.localIdentifierCache)[str];
call    0 returned 100%
call    1 returned 100%
     1171:   85:  if (localEntry)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   86:    return TimingIdentifier(localEntry);
        -:   87:
        -:   88:  // Check for an existing identifier in read-only mode.
     1171:   89:  {
     1171:   90:    llvm::sys::SmartScopedReader<true> contextLock(impl.identifierMutex);
call    0 returned 100%
     1171:   91:    auto it = impl.identifiers.find(str);
call    0 returned 100%
     1171:   92:    if (it != impl.identifiers.end()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   93:      localEntry = &*it;
branch  0 never executed
branch  1 never executed
    #####:   94:      return TimingIdentifier(localEntry);
branch  0 never executed
branch  1 never executed
        -:   95:    }
        -:   96:  }
        -:   97:
        -:   98:  // Acquire a writer-lock so that we can safely create the new instance.
     1171:   99:  llvm::sys::SmartScopedWriter<true> contextLock(impl.identifierMutex);
call    0 returned 100%
     1171:  100:  auto it = impl.identifiers.insert(str).first;
call    0 returned 100%
     1171:  101:  localEntry = &*it;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1171:  102:  return TimingIdentifier(localEntry);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  103:}
        -:  104:
        -:  105://===----------------------------------------------------------------------===//
        -:  106:// Helpers for time record printing
        -:  107://===----------------------------------------------------------------------===//
        -:  108:
        -:  109:namespace {
        -:  110:
        -:  111:/// Simple record class to record timing information.
        -:  112:struct TimeRecord {
      59*:  113:  TimeRecord(double wall = 0.0, double user = 0.0) : wall(wall), user(user) {}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  114:
       64:  115:  TimeRecord &operator+=(const TimeRecord &other) {
       64:  116:    wall += other.wall;
       64:  117:    user += other.user;
       64:  118:    return *this;
        -:  119:  }
        -:  120:
     2877:  121:  TimeRecord &operator-=(const TimeRecord &other) {
     2877:  122:    wall -= other.wall;
     2877:  123:    user -= other.user;
     2877:  124:    return *this;
        -:  125:  }
        -:  126:
        -:  127:  /// Print the current time record to 'os', with a breakdown showing
        -:  128:  /// contributions to the give 'total' time record.
        -:  129:  void print(raw_ostream &os, const TimeRecord &total) {
        -:  130:    if (total.user != total.wall)
        -:  131:      os << llvm::format("  %8.4f (%5.1f%%)", user, 100.0 * user / total.user);
        -:  132:    os << llvm::format("  %8.4f (%5.1f%%)  ", wall, 100.0 * wall / total.wall);
        -:  133:  }
        -:  134:
        -:  135:  double wall, user;
        -:  136:};
        -:  137:
        -:  138:} // namespace
        -:  139:
        -:  140:/// Utility to print a single line entry in the timer output.
function _ZL14printTimeEntryRN4llvm11raw_ostreamEjNS_9StringRefEN12_GLOBAL__N_110TimeRecordES4_ called 3877 returned 100% blocks executed 100%
     3877:  141:static void printTimeEntry(raw_ostream &os, unsigned indent, StringRef name,
        -:  142:                           TimeRecord time, TimeRecord total) {
     3877:  143:  time.print(os, total);
call    0 returned 100%
     3877:  144:  os.indent(indent) << name << "\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3877:  145:}
        -:  146:
        -:  147:/// Utility to print the timer heading information.
function _ZL15printTimeHeaderRN4llvm11raw_ostreamEN12_GLOBAL__N_110TimeRecordE called 644 returned 100% blocks executed 92%
      644:  148:static void printTimeHeader(raw_ostream &os, TimeRecord total) {
        -:  149:  // Figure out how many spaces to description name.
      644:  150:  unsigned padding = (80 - kTimingDescription.size()) / 2;
      644:  151:  os << "===" << std::string(73, '-') << "===\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      644:  152:  os.indent(padding) << kTimingDescription << '\n';
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      644:  153:  os << "===" << std::string(73, '-') << "===\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  154:
        -:  155:  // Print the total time followed by the section headers.
      644:  156:  os << llvm::format("  Total Execution Time: %.4f seconds\n\n", total.wall);
call    0 returned 100%
      644:  157:  if (total.user != total.wall)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  158:    os << "  ----User Time----";
call    0 never executed
      644:  159:  os << "  ----Wall Time----  ----Name----\n";
call    0 returned 100%
      644:  160:}
        -:  161:
        -:  162://===----------------------------------------------------------------------===//
        -:  163:// Timer Implementation for DefaultTimingManager
        -:  164://===----------------------------------------------------------------------===//
        -:  165:
        -:  166:namespace {
        -:  167:
        -:  168:/// A timer used to sample execution time.
        -:  169:///
        -:  170:/// Separately tracks wall time and user time to account for parallel threads of
        -:  171:/// execution. Timers are intended to be started and stopped multiple times.
        -:  172:/// Each start and stop will add to the timer's wall and user time.
        -:  173:class TimerImpl {
        -:  174:public:
        -:  175:  using ChildrenMap = llvm::MapVector<const void *, std::unique_ptr<TimerImpl>>;
        -:  176:  using AsyncChildrenMap = llvm::DenseMap<uint64_t, ChildrenMap>;
        -:  177:
function _ZN12_GLOBAL__N_19TimerImplC2EONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 210369 returned 100% blocks executed 100%
   210369:  178:  TimerImpl(std::string &&name) : threadId(llvm::get_threadid()), name(name) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  179:
        -:  180:  /// Start the timer.
     3919:  181:  void start() { startTime = std::chrono::steady_clock::now(); }
        -:  182:
        -:  183:  /// Stop the timer.
     3916:  184:  void stop() {
     7832:  185:    auto newTime = std::chrono::steady_clock::now() - startTime;
     3916:  186:    wallTime += newTime;
     3916:  187:    userTime += newTime;
        -:  188:  }
        -:  189:
        -:  190:  /// Create a child timer nested within this one. Multiple calls to this
        -:  191:  /// function with the same unique identifier `id` will return the same child
        -:  192:  /// timer.
        -:  193:  ///
        -:  194:  /// This function can be called from other threads, as long as this timer
        -:  195:  /// outlives any uses of the child timer on the other thread.
function _ZN12_GLOBAL__N_19TimerImpl4nestEPKvN4llvm12function_refIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEE called 3272 returned 100% blocks executed 42%
     3272:  196:  TimerImpl *nest(const void *id, function_ref<std::string()> nameBuilder) {
     3272:  197:    auto tid = llvm::get_threadid();
call    0 returned 100%
     3272:  198:    if (tid == threadId)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3272:  199:      return nestTail(children[id], nameBuilder);
call    0 returned 100%
call    1 returned 100%
    #####:  200:    std::unique_lock<std::mutex> lock(asyncMutex);
call    0 never executed
    #####:  201:    return nestTail(asyncChildren[tid][id], nameBuilder);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  202:  }
        -:  203:
        -:  204:  /// Tail-called from `nest()`.
        -:  205:  TimerImpl *nestTail(std::unique_ptr<TimerImpl> &child,
        -:  206:                      function_ref<std::string()> nameBuilder) {
        -:  207:    if (!child)
        -:  208:      child = std::make_unique<TimerImpl>(nameBuilder());
        -:  209:    return child.get();
        -:  210:  }
        -:  211:
        -:  212:  /// Finalize this timer and all its children.
        -:  213:  ///
        -:  214:  /// If this timer has async children, which happens if `nest()` was called
        -:  215:  /// from another thread, this function merges the async childr timers into the
        -:  216:  /// main list of child timers.
        -:  217:  ///
        -:  218:  /// Caution: Call this function only after all nested timers running on other
        -:  219:  /// threads no longer need their timers!
     644*:  220:  void finalize() {
     644*:  221:    addAsyncUserTime();
call    0 never executed
call    1 never executed
call    2 returned 100%
     644*:  222:    mergeAsyncChildren();
call    0 never executed
call    1 never executed
call    2 returned 100%
        -:  223:  }
        -:  224:
        -:  225:  /// Add the user time of all async children to this timer's user time. This is
        -:  226:  /// necessary since the user time already contains all regular child timers,
        -:  227:  /// but not the asynchronous ones (by the nesting nature of the timers).
function _ZN12_GLOBAL__N_19TimerImpl16addAsyncUserTimeEv called 3635 returned 100% blocks executed 62%
     3635:  228:  std::chrono::nanoseconds addAsyncUserTime() {
     3635:  229:    auto added = std::chrono::nanoseconds(0);
     6626:  230:    for (auto &child : children)
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
call    2 returned 100%
     2991:  231:      added += child.second->addAsyncUserTime();
call    0 returned 100%
    7270*:  232:    for (auto &thread : asyncChildren) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
    #####:  233:      for (auto &child : thread.second) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  234:        child.second->addAsyncUserTime();
call    0 never executed
    #####:  235:        added += child.second->userTime;
        -:  236:      }
        -:  237:    }
     3635:  238:    userTime += added;
     3635:  239:    return added;
        -:  240:  }
        -:  241:
        -:  242:  /// Ensure that this timer and recursively all its children have their async
        -:  243:  /// children folded into the main map of children.
function _ZN12_GLOBAL__N_19TimerImpl18mergeAsyncChildrenEv called 3635 returned 100% blocks executed 88%
     3635:  244:  void mergeAsyncChildren() {
     6626:  245:    for (auto &child : children)
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
call    2 returned 100%
     2991:  246:      child.second->mergeAsyncChildren();
call    0 returned 100%
     3635:  247:    mergeChildren(std::move(asyncChildren));
call    0 returned 100%
    3635*:  248:    assert(asyncChildren.empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     3635:  249:  }
        -:  250:
        -:  251:  /// Merge multiple child timers into this timer.
        -:  252:  ///
        -:  253:  /// Children in `other` are added as children to this timer, or, if this timer
        -:  254:  /// already contains a child with the corresponding unique identifier, are
        -:  255:  /// merged into the existing child.
function _ZN12_GLOBAL__N_19TimerImpl13mergeChildrenEON4llvm9MapVectorIPKvSt10unique_ptrIS0_St14default_deleteIS0_EENS1_8DenseMapIS4_jNS1_12DenseMapInfoIS4_vEENS1_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S8_ESaISI_EEEE called 0 returned 0% blocks executed 0%
    #####:  256:  void mergeChildren(ChildrenMap &&other) {
    #####:  257:    if (children.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  258:      children = std::move(other);
call    0 never executed
    #####:  259:      for (auto &child : children)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  260:        child.second->mergeAsyncChildren();
call    0 never executed
        -:  261:    } else {
    #####:  262:      for (auto &child : other)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  263:        mergeChild(child.first, std::move(child.second));
call    0 never executed
    #####:  264:      other.clear();
call    0 never executed
        -:  265:    }
    #####:  266:  }
        -:  267:
        -:  268:  /// See above.
function _ZN12_GLOBAL__N_19TimerImpl13mergeChildrenEON4llvm8DenseMapImNS1_9MapVectorIPKvSt10unique_ptrIS0_St14default_deleteIS0_EENS2_IS5_jNS1_12DenseMapInfoIS5_vEENS1_6detail12DenseMapPairIS5_jEEEESt6vectorISt4pairIS5_S9_ESaISI_EEEENSA_ImvEENSD_ImSL_EEEE called 3635 returned 100% blocks executed 58%
     3635:  269:  void mergeChildren(AsyncChildrenMap &&other) {
    7270*:  270:    for (auto &thread : other) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
    #####:  271:      mergeChildren(std::move(thread.second));
call    0 never executed
    #####:  272:      assert(thread.second.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  273:    }
     3635:  274:    other.clear();
call    0 returned 100%
     3635:  275:  }
        -:  276:
        -:  277:  /// Merge a child timer into this timer for a given unique identifier.
        -:  278:  ///
        -:  279:  /// Moves all child and async child timers of `other` into this timer's child
        -:  280:  /// for the given unique identifier.
function _ZN12_GLOBAL__N_19TimerImpl10mergeChildEPKvOSt10unique_ptrIS0_St14default_deleteIS0_EE called 0 returned 0% blocks executed 0%
    #####:  281:  void mergeChild(const void *id, std::unique_ptr<TimerImpl> &&other) {
    #####:  282:    auto &into = children[id];
call    0 never executed
    #####:  283:    if (!into) {
branch  0 never executed
branch  1 never executed
    #####:  284:      into = std::move(other);
branch  0 never executed
branch  1 never executed
    #####:  285:      into->mergeAsyncChildren();
call    0 never executed
        -:  286:    } else {
    #####:  287:      into->wallTime = std::max(into->wallTime, other->wallTime);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  288:      into->userTime += other->userTime;
call    0 never executed
    #####:  289:      into->mergeChildren(std::move(other->children));
call    0 never executed
    #####:  290:      into->mergeChildren(std::move(other->asyncChildren));
call    0 never executed
    #####:  291:      other.reset();
branch  0 never executed
branch  1 never executed
        -:  292:    }
    #####:  293:  }
        -:  294:
        -:  295:  /// Dump a human-readable tree representation of the timer and its children.
        -:  296:  /// This is useful for debugging the timing mechanisms and structure of the
        -:  297:  /// timers.
function _ZN12_GLOBAL__N_19TimerImpl4dumpERN4llvm11raw_ostreamEjj called 0 returned 0% blocks executed 0%
    #####:  298:  void dump(raw_ostream &os, unsigned indent = 0, unsigned markThreadId = 0) {
    #####:  299:    auto time = getTimeRecord();
    #####:  300:    os << std::string(indent * 2, ' ') << name << " [" << threadId << "]"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  301:       << llvm::format("  %7.4f / %7.4f", time.user, time.wall);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  302:    if (threadId != markThreadId && markThreadId != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  303:      os << " (*)";
call    0 never executed
    #####:  304:    os << "\n";
call    0 never executed
    #####:  305:    for (auto &child : children)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  306:      child.second->dump(os, indent + 1, threadId);
call    0 never executed
    #####:  307:    for (auto &thread : asyncChildren)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  308:      for (auto &child : thread.second)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  309:        child.second->dump(os, indent + 1, threadId);
call    0 never executed
    #####:  310:  }
        -:  311:
        -:  312:  /// Returns the time for this timer in seconds.
    6115*:  313:  TimeRecord getTimeRecord() {
    6115*:  314:    return TimeRecord(
    5471*:  315:        std::chrono::duration_cast<std::chrono::duration<double>>(wallTime)
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:  316:            .count(),
    2877*:  317:        std::chrono::duration_cast<std::chrono::duration<double>>(userTime)
call    0 never executed
        -:  318:            .count());
        -:  319:  }
        -:  320:
        -:  321:  /// Print the timing result in list mode.
function _ZN12_GLOBAL__N_19TimerImpl11printAsListERN4llvm11raw_ostreamENS_10TimeRecordE called 8 returned 100% blocks executed 100%
        8:  322:  void printAsList(raw_ostream &os, TimeRecord total) {
        -:  323:    // Flatten the leaf timers in the tree and merge them by name.
        8:  324:    llvm::StringMap<TimeRecord> mergedTimers;
call    0 returned 100%
function _ZZN12_GLOBAL__N_19TimerImpl11printAsListERN4llvm11raw_ostreamENS_10TimeRecordEENKUlPS0_E_clES5_.isra.0 called 64 returned 100% blocks executed 89%
       64:  325:    std::function<void(TimerImpl *)> addTimer = [&](TimerImpl *timer) {
       64:  326:      mergedTimers[timer->name] += timer->getTimeRecord();
call    0 returned 100%
      120:  327:      for (auto &children : timer->children)
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      112:  328:        addTimer(children.second.get());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16:  329:    };
call    0 returned 100%
call    1 returned 100%
        8:  330:    addTimer(this);
call    0 returned 100%
        -:  331:
        -:  332:    // Sort the timing information by wall time.
       16:  333:    std::vector<std::pair<StringRef, TimeRecord>> timerNameAndTime;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       75:  334:    for (auto &it : mergedTimers)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 88% (fallthrough)
branch  3 taken 12%
call    4 returned 100%
       59:  335:      timerNameAndTime.emplace_back(it.first(), it.second);
call    0 returned 100%
        8:  336:    llvm::array_pod_sort(timerNameAndTime.begin(), timerNameAndTime.end(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  337:                         [](const std::pair<StringRef, TimeRecord> *lhs,
        -:  338:                            const std::pair<StringRef, TimeRecord> *rhs) {
        -:  339:                           return llvm::array_pod_sort_comparator<double>(
        -:  340:                               &rhs->second.wall, &lhs->second.wall);
        -:  341:                         });
        -:  342:
        -:  343:    // Print the timing information sequentially.
       67:  344:    for (auto &timeData : timerNameAndTime)
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
       59:  345:      printTimeEntry(os, 0, timeData.first, timeData.second, total);
call    0 returned 100%
        8:  346:  }
        -:  347:
        -:  348:  /// Print the timing result in tree mode.
function _ZN12_GLOBAL__N_19TimerImpl11printAsTreeERN4llvm11raw_ostreamENS_10TimeRecordEj called 3571 returned 100% blocks executed 100%
     3571:  349:  void printAsTree(raw_ostream &os, TimeRecord total, unsigned indent = 0) {
     3571:  350:    unsigned childIndent = indent;
     3571:  351:    if (!hidden) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
     2530:  352:      printTimeEntry(os, indent, name, getTimeRecord(), total);
call    0 returned 100%
     2530:  353:      childIndent += 2;
        -:  354:    }
     6506:  355:    for (auto &child : children) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
call    2 returned 100%
     2935:  356:      child.second->printAsTree(os, total, childIndent);
call    0 returned 100%
        -:  357:    }
     3571:  358:  }
        -:  359:
        -:  360:  /// Print the current timing information.
function _ZN12_GLOBAL__N_19TimerImpl5printERN4llvm11raw_ostreamEN4mlir20DefaultTimingManager11DisplayModeE called 644 returned 100% blocks executed 93%
      644:  361:  void print(raw_ostream &os, DisplayMode displayMode) {
        -:  362:    // Print the banner.
      644:  363:    auto total = getTimeRecord();
call    0 returned 100%
      644:  364:    printTimeHeader(os, total);
call    0 returned 100%
        -:  365:
        -:  366:    // Defer to a specialized printer for each display mode.
      644:  367:    switch (displayMode) {
branch  0 taken 1%
branch  1 taken 99%
branch  2 taken 0%
        8:  368:    case DisplayMode::List:
        8:  369:      printAsList(os, total);
        8:  370:      break;
call    0 returned 100%
      636:  371:    case DisplayMode::Tree:
      636:  372:      printAsTree(os, total);
      636:  373:      break;
call    0 returned 100%
        -:  374:    }
        -:  375:
        -:  376:    // Print the top-level time not accounted for by child timers, and the
        -:  377:    // total.
      644:  378:    auto rest = total;
     3521:  379:    for (auto &child : children)
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
     2877:  380:      rest -= child.second->getTimeRecord();
      644:  381:    printTimeEntry(os, 0, "Rest", rest, total);
call    0 returned 100%
      644:  382:    printTimeEntry(os, 0, "Total", total, total);
call    0 returned 100%
      644:  383:    os.flush();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      644:  384:  }
        -:  385:
        -:  386:  /// The last time instant at which the timer was started.
        -:  387:  std::chrono::time_point<std::chrono::steady_clock> startTime;
        -:  388:
        -:  389:  /// Accumulated wall time. If multiple threads of execution are merged into
        -:  390:  /// this timer, the wall time will hold the maximum wall time of each thread
        -:  391:  /// of execution.
        -:  392:  std::chrono::nanoseconds wallTime = std::chrono::nanoseconds(0);
        -:  393:
        -:  394:  /// Accumulated user time. If multiple threads of execution are merged into
        -:  395:  /// this timer, each thread's user time is added here.
        -:  396:  std::chrono::nanoseconds userTime = std::chrono::nanoseconds(0);
        -:  397:
        -:  398:  /// The thread on which this timer is running.
        -:  399:  uint64_t threadId;
        -:  400:
        -:  401:  /// A descriptive name for this timer.
        -:  402:  std::string name;
        -:  403:
        -:  404:  /// Whether to omit this timer from reports and directly show its children.
        -:  405:  bool hidden = false;
        -:  406:
        -:  407:  /// Child timers on the same thread the timer itself. We keep at most one
        -:  408:  /// timer per unique identifier.
        -:  409:  ChildrenMap children;
        -:  410:
        -:  411:  /// Child timers on other threads. We keep at most one timer per unique
        -:  412:  /// identifier.
        -:  413:  AsyncChildrenMap asyncChildren;
        -:  414:
        -:  415:  /// Mutex for the async children.
        -:  416:  std::mutex asyncMutex;
        -:  417:};
        -:  418:
        -:  419:} // namespace
        -:  420:
        -:  421://===----------------------------------------------------------------------===//
        -:  422:// DefaultTimingManager
        -:  423://===----------------------------------------------------------------------===//
        -:  424:
        -:  425:namespace mlir {
        -:  426:namespace detail {
        -:  427:
        -:  428:/// Implementation details of the `DefaultTimingManager`.
   103693:  429:class DefaultTimingManagerImpl {
call    0 returned 100%
        -:  430:public:
        -:  431:  /// Whether we should do our work or not.
        -:  432:  bool enabled = false;
        -:  433:
        -:  434:  /// The configured display mode.
        -:  435:  DisplayMode displayMode = DisplayMode::Tree;
        -:  436:
        -:  437:  /// The stream where we should print our output. This will always be non-null.
        -:  438:  raw_ostream *output = &llvm::errs();
        -:  439:
        -:  440:  /// The root timer.
        -:  441:  std::unique_ptr<TimerImpl> rootTimer;
        -:  442:};
        -:  443:
        -:  444:} // namespace detail
        -:  445:} // namespace mlir
        -:  446:
function _ZN4mlir20DefaultTimingManagerC2Ev called 103693 returned 100% blocks executed 100%
   103693:  447:DefaultTimingManager::DefaultTimingManager()
   207386:  448:    : impl(std::make_unique<DefaultTimingManagerImpl>()) {
call    0 returned 100%
call    1 returned 100%
   103693:  449:  clear(); // initializes the root timer
call    0 returned 100%
   103693:  450:}
        -:  451:
  207340*:  452:DefaultTimingManager::~DefaultTimingManager() { print(); }
------------------
_ZN4mlir20DefaultTimingManagerD0Ev:
function _ZN4mlir20DefaultTimingManagerD0Ev called 0 returned 0% blocks executed 0%
    #####:  452:DefaultTimingManager::~DefaultTimingManager() { print(); }
call    0 never executed
call    1 never executed
------------------
_ZN4mlir20DefaultTimingManagerD2Ev:
function _ZN4mlir20DefaultTimingManagerD2Ev called 103670 returned 100% blocks executed 100%
   207340:  452:DefaultTimingManager::~DefaultTimingManager() { print(); }
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
------------------
        -:  453:
        -:  454:/// Enable or disable execution time sampling.
function _ZN4mlir20DefaultTimingManager10setEnabledEb called 0 returned 0% blocks executed 0%
  103693*:  455:void DefaultTimingManager::setEnabled(bool enabled) { impl->enabled = enabled; }
call    0 returned 100%
        -:  456:
        -:  457:/// Return whether execution time sampling is enabled.
function _ZNK4mlir20DefaultTimingManager9isEnabledEv called 0 returned 0% blocks executed 0%
    #####:  458:bool DefaultTimingManager::isEnabled() const { return impl->enabled; }
        -:  459:
        -:  460:/// Change the display mode.
function _ZN4mlir20DefaultTimingManager14setDisplayModeENS0_11DisplayModeE called 0 returned 0% blocks executed 0%
  103693*:  461:void DefaultTimingManager::setDisplayMode(DisplayMode displayMode) {
  103693*:  462:  impl->displayMode = displayMode;
  103693*:  463:}
        -:  464:
        -:  465:/// Return the current display mode;
function _ZNK4mlir20DefaultTimingManager14getDisplayModeEv called 0 returned 0% blocks executed 0%
    #####:  466:DefaultTimingManager::DisplayMode DefaultTimingManager::getDisplayMode() const {
    #####:  467:  return impl->displayMode;
        -:  468:}
        -:  469:
        -:  470:/// Change the stream where the output will be printed to.
function _ZN4mlir20DefaultTimingManager9setOutputERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  471:void DefaultTimingManager::setOutput(raw_ostream &os) { impl->output = &os; }
        -:  472:
        -:  473:/// Return the current output stream where the output will be printed to.
function _ZNK4mlir20DefaultTimingManager9getOutputEv called 0 returned 0% blocks executed 0%
    #####:  474:raw_ostream &DefaultTimingManager::getOutput() const {
    #####:  475:  assert(impl->output);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  476:  return *impl->output;
        -:  477:}
        -:  478:
        -:  479:/// Print and clear the timing results.
function _ZN4mlir20DefaultTimingManager5printEv called 103670 returned 100% blocks executed 100%
   103670:  480:void DefaultTimingManager::print() {
   103670:  481:  if (impl->enabled) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      644:  482:    impl->rootTimer->finalize();
call    0 returned 100%
      644:  483:    impl->rootTimer->print(*impl->output, impl->displayMode);
call    0 returned 100%
        -:  484:  }
   103670:  485:  clear();
call    0 returned 100%
   103670:  486:}
        -:  487:
        -:  488:/// Clear the timing results.
function _ZN4mlir20DefaultTimingManager5clearEv called 207363 returned 100% blocks executed 83%
   207363:  489:void DefaultTimingManager::clear() {
   311033:  490:  impl->rootTimer = std::make_unique<TimerImpl>("root");
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   207363:  491:  impl->rootTimer->hidden = true;
   207363:  492:}
        -:  493:
        -:  494:/// Debug print the timer data structures to an output stream.
function _ZN4mlir20DefaultTimingManager10dumpTimersERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  495:void DefaultTimingManager::dumpTimers(raw_ostream &os) {
    #####:  496:  impl->rootTimer->dump(os);
call    0 never executed
    #####:  497:}
        -:  498:
        -:  499:/// Debug print the timers as a list.
function _ZN4mlir20DefaultTimingManager10dumpAsListERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  500:void DefaultTimingManager::dumpAsList(raw_ostream &os) {
    #####:  501:  impl->rootTimer->finalize();
call    0 never executed
    #####:  502:  impl->rootTimer->print(os, DisplayMode::List);
call    0 never executed
    #####:  503:}
        -:  504:
        -:  505:/// Debug print the timers as a tree.
function _ZN4mlir20DefaultTimingManager10dumpAsTreeERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  506:void DefaultTimingManager::dumpAsTree(raw_ostream &os) {
    #####:  507:  impl->rootTimer->finalize();
call    0 never executed
    #####:  508:  impl->rootTimer->print(os, DisplayMode::Tree);
call    0 never executed
    #####:  509:}
        -:  510:
function _ZN4mlir20DefaultTimingManager9rootTimerEv called 103693 returned 100% blocks executed 100%
   103693:  511:Optional<void *> DefaultTimingManager::rootTimer() {
   103693:  512:  if (impl->enabled)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      647:  513:    return impl->rootTimer.get();
   103046:  514:  return llvm::None;
        -:  515:}
        -:  516:
function _ZN4mlir20DefaultTimingManager10startTimerEPv called 3919 returned 100% blocks executed 100%
     3919:  517:void DefaultTimingManager::startTimer(void *handle) {
     3919:  518:  static_cast<TimerImpl *>(handle)->start();
call    0 returned 100%
     3919:  519:}
        -:  520:
function _ZN4mlir20DefaultTimingManager9stopTimerEPv called 3916 returned 100% blocks executed 100%
     3916:  521:void DefaultTimingManager::stopTimer(void *handle) {
     3916:  522:  static_cast<TimerImpl *>(handle)->stop();
call    0 returned 100%
     3916:  523:}
        -:  524:
function _ZN4mlir20DefaultTimingManager9nestTimerEPvPKvN4llvm12function_refIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEE called 3272 returned 100% blocks executed 100%
     3272:  525:void *DefaultTimingManager::nestTimer(void *handle, const void *id,
        -:  526:                                      function_ref<std::string()> nameBuilder) {
     3272:  527:  return static_cast<TimerImpl *>(handle)->nest(id, nameBuilder);
call    0 returned 100%
        -:  528:}
        -:  529:
function _ZN4mlir20DefaultTimingManager9hideTimerEPv called 422 returned 100% blocks executed 100%
      422:  530:void DefaultTimingManager::hideTimer(void *handle) {
      422:  531:  static_cast<TimerImpl *>(handle)->hidden = true;
      422:  532:}
        -:  533:
        -:  534://===----------------------------------------------------------------------===//
        -:  535:// DefaultTimingManager Command Line Options
        -:  536://===----------------------------------------------------------------------===//
        -:  537:
        -:  538:namespace {
   104316:  539:struct DefaultTimingManagerOptions {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  540:  llvm::cl::opt<bool> timing{"mlir-timing",
        -:  541:                             llvm::cl::desc("Display execution times"),
        -:  542:                             llvm::cl::init(false)};
        -:  543:  llvm::cl::opt<DisplayMode> displayMode{
        -:  544:      "mlir-timing-display", llvm::cl::desc("Display method for timing data"),
        -:  545:      llvm::cl::init(DisplayMode::Tree),
        -:  546:      llvm::cl::values(
        -:  547:          clEnumValN(DisplayMode::List, "list",
        -:  548:                     "display the results in a list sorted by total time"),
        -:  549:          clEnumValN(DisplayMode::Tree, "tree",
        -:  550:                     "display the results ina with a nested tree view"))};
        -:  551:};
        -:  552:} // namespace
        -:  553:
        -:  554:static llvm::ManagedStatic<DefaultTimingManagerOptions> options;
        -:  555:
function _ZN4mlir37registerDefaultTimingManagerCLOptionsEv called 128638 returned 100% blocks executed 100%
   128638:  556:void mlir::registerDefaultTimingManagerCLOptions() {
        -:  557:  // Make sure that the options struct has been constructed.
   128638:  558:  *options;
call    0 returned 100%
   128638:  559:}
        -:  560:
function _ZN4mlir34applyDefaultTimingManagerCLOptionsERNS_20DefaultTimingManagerE called 103693 returned 100% blocks executed 100%
   103693:  561:void mlir::applyDefaultTimingManagerCLOptions(DefaultTimingManager &tm) {
   103693:  562:  if (!options.isConstructed())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  563:    return;
   103693:  564:  tm.setEnabled(options->timing);
call    0 returned 100%
call    1 returned 100%
   103693:  565:  tm.setDisplayMode(options->displayMode);
call    0 returned 100%
        -:  566:}
