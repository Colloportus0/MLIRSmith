        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/IR/AffineExpr.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineExpr.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineExpr.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- AffineExpr.cpp - MLIR Affine Expr Classes --------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include <utility>
        -:   10:
        -:   11:#include "AffineExprDetail.h"
        -:   12:#include "mlir/IR/AffineExpr.h"
        -:   13:#include "mlir/IR/AffineExprVisitor.h"
        -:   14:#include "mlir/IR/AffineMap.h"
        -:   15:#include "mlir/IR/IntegerSet.h"
        -:   16:#include "mlir/Support/MathExtras.h"
        -:   17:#include "mlir/Support/TypeID.h"
        -:   18:#include "llvm/ADT/STLExtras.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:using namespace mlir::detail;
        -:   23:
function _ZNK4mlir10AffineExpr10getContextEv called 0 returned 0% blocks executed 0%
    #####:   24:MLIRContext *AffineExpr::getContext() const { return expr->context; }
        -:   25:
function _ZNK4mlir10AffineExpr7getKindEv called 0 returned 0% blocks executed 0%
    #####:   26:AffineExprKind AffineExpr::getKind() const { return expr->kind; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
branch 62 never executed
branch 63 never executed
branch 64 never executed
branch 65 never executed
branch 66 never executed
branch 67 never executed
branch 68 never executed
branch 69 never executed
branch 70 never executed
branch 71 never executed
call   72 never executed
branch 73 never executed
branch 74 never executed
branch 75 never executed
branch 76 never executed
branch 77 never executed
branch 78 never executed
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 never executed
branch 84 never executed
branch 85 never executed
branch 86 never executed
branch 87 never executed
branch 88 never executed
branch 89 never executed
branch 90 never executed
branch 91 never executed
branch 92 never executed
branch 93 never executed
branch 94 never executed
branch 95 never executed
branch 96 never executed
branch 97 never executed
branch 98 never executed
branch 99 never executed
branch 100 never executed
branch 101 never executed
branch 102 never executed
branch 103 never executed
branch 104 never executed
branch 105 never executed
branch 106 never executed
branch 107 never executed
branch 108 never executed
branch 109 never executed
branch 110 never executed
branch 111 never executed
branch 112 never executed
branch 113 never executed
branch 114 never executed
branch 115 never executed
branch 116 never executed
branch 117 never executed
branch 118 never executed
branch 119 never executed
branch 120 never executed
branch 121 never executed
branch 122 never executed
branch 123 never executed
branch 124 never executed
branch 125 never executed
branch 126 never executed
branch 127 never executed
branch 128 never executed
branch 129 never executed
branch 130 never executed
branch 131 never executed
branch 132 never executed
branch 133 never executed
branch 134 never executed
branch 135 never executed
branch 136 never executed
branch 137 never executed
branch 138 never executed
branch 139 never executed
branch 140 never executed
branch 141 never executed
branch 142 never executed
branch 143 never executed
branch 144 never executed
branch 145 never executed
branch 146 never executed
branch 147 never executed
branch 148 never executed
branch 149 never executed
branch 150 never executed
branch 151 never executed
branch 152 never executed
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 never executed
branch 164 never executed
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 never executed
branch 178 never executed
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 never executed
branch 186 never executed
branch 187 never executed
branch 188 never executed
branch 189 never executed
branch 190 never executed
branch 191 never executed
branch 192 never executed
branch 193 never executed
branch 194 never executed
branch 195 never executed
branch 196 never executed
branch 197 never executed
branch 198 never executed
branch 199 never executed
branch 200 never executed
branch 201 never executed
branch 202 never executed
branch 203 never executed
branch 204 never executed
call   205 never executed
branch 206 never executed
branch 207 never executed
branch 208 never executed
branch 209 never executed
branch 210 never executed
branch 211 never executed
        -:   27:
        -:   28:/// Walk all of the AffineExprs in this subgraph in postorder.
function _ZNK4mlir10AffineExpr4walkESt8functionIFvS0_EE called 0 returned 0% blocks executed 0%
    #####:   29:void AffineExpr::walk(std::function<void(AffineExpr)> callback) const {
    #####:   30:  struct AffineExprWalker : public AffineExprVisitor<AffineExprWalker> {
        -:   31:    std::function<void(AffineExpr)> callback;
        -:   32:
    #####:   33:    AffineExprWalker(std::function<void(AffineExpr)> callback)
    #####:   34:        : callback(std::move(callback)) {}
call    0 never executed
        -:   35:
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker23visitAffineBinaryOpExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   36:    void visitAffineBinaryOpExpr(AffineBinaryOpExpr expr) { callback(expr); }
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker17visitConstantExprENS_18AffineConstantExprE called 0 returned 0% blocks executed 0%
    #####:   37:    void visitConstantExpr(AffineConstantExpr expr) { callback(expr); }
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker12visitDimExprENS_13AffineDimExprE called 0 returned 0% blocks executed 0%
    #####:   38:    void visitDimExpr(AffineDimExpr expr) { callback(expr); }
branch  0 never executed
branch  1 never executed
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker15visitSymbolExprENS_16AffineSymbolExprE called 0 returned 0% blocks executed 0%
    #####:   39:    void visitSymbolExpr(AffineSymbolExpr expr) { callback(expr); }
branch  0 never executed
branch  1 never executed
        -:   40:  };
        -:   41:
    #####:   42:  AffineExprWalker(std::move(callback)).walkPostOrder(*this);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   43:}
        -:   44:
        -:   45:// Dispatch affine expression construction based on kind.
function _ZN4mlir21getAffineBinaryOpExprENS_14AffineExprKindENS_10AffineExprES1_ called 0 returned 0% blocks executed 0%
    #####:   46:AffineExpr mlir::getAffineBinaryOpExpr(AffineExprKind kind, AffineExpr lhs,
        -:   47:                                       AffineExpr rhs) {
    #####:   48:  if (kind == AffineExprKind::Add)
branch  0 never executed
branch  1 never executed
    #####:   49:    return lhs + rhs;
call    0 never executed
    #####:   50:  if (kind == AffineExprKind::Mul)
branch  0 never executed
branch  1 never executed
    #####:   51:    return lhs * rhs;
call    0 never executed
    #####:   52:  if (kind == AffineExprKind::FloorDiv)
branch  0 never executed
branch  1 never executed
    #####:   53:    return lhs.floorDiv(rhs);
call    0 never executed
    #####:   54:  if (kind == AffineExprKind::CeilDiv)
branch  0 never executed
branch  1 never executed
    #####:   55:    return lhs.ceilDiv(rhs);
call    0 never executed
    #####:   56:  if (kind == AffineExprKind::Mod)
branch  0 never executed
branch  1 never executed
    #####:   57:    return lhs % rhs;
call    0 never executed
        -:   58:
    #####:   59:  llvm_unreachable("unknown binary operation on affine expressions");
call    0 never executed
        -:   60:}
        -:   61:
        -:   62:/// This method substitutes any uses of dimensions and symbols (e.g.
        -:   63:/// dim#0 with dimReplacements[0]) and returns the modified expression tree.
        -:   64:AffineExpr
function _ZNK4mlir10AffineExpr21replaceDimsAndSymbolsEN4llvm8ArrayRefIS0_EES3_ called 0 returned 0% blocks executed 0%
    #####:   65:AffineExpr::replaceDimsAndSymbols(ArrayRef<AffineExpr> dimReplacements,
        -:   66:                                  ArrayRef<AffineExpr> symReplacements) const {
    #####:   67:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   68:  case AffineExprKind::Constant:
    #####:   69:    return *this;
    #####:   70:  case AffineExprKind::DimId: {
    #####:   71:    unsigned dimId = cast<AffineDimExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####:   72:    if (dimId >= dimReplacements.size())
    #####:   73:      return *this;
    #####:   74:    return dimReplacements[dimId];
        -:   75:  }
    #####:   76:  case AffineExprKind::SymbolId: {
    #####:   77:    unsigned symId = cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####:   78:    if (symId >= symReplacements.size())
    #####:   79:      return *this;
    #####:   80:    return symReplacements[symId];
        -:   81:  }
    #####:   82:  case AffineExprKind::Add:
    #####:   83:  case AffineExprKind::Mul:
    #####:   84:  case AffineExprKind::FloorDiv:
    #####:   85:  case AffineExprKind::CeilDiv:
    #####:   86:  case AffineExprKind::Mod:
    #####:   87:    auto binOp = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:   88:    auto lhs = binOp.getLHS(), rhs = binOp.getRHS();
    #####:   89:    auto newLHS = lhs.replaceDimsAndSymbols(dimReplacements, symReplacements);
    #####:   90:    auto newRHS = rhs.replaceDimsAndSymbols(dimReplacements, symReplacements);
call    0 never executed
    #####:   91:    if (newLHS == lhs && newRHS == rhs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   92:      return *this;
    #####:   93:    return getAffineBinaryOpExpr(getKind(), newLHS, newRHS);
call    0 never executed
        -:   94:  }
    #####:   95:  llvm_unreachable("Unknown AffineExpr");
        -:   96:}
        -:   97:
function _ZNK4mlir10AffineExpr11replaceDimsEN4llvm8ArrayRefIS0_EE called 0 returned 0% blocks executed 0%
    #####:   98:AffineExpr AffineExpr::replaceDims(ArrayRef<AffineExpr> dimReplacements) const {
    #####:   99:  return replaceDimsAndSymbols(dimReplacements, {});
call    0 never executed
        -:  100:}
        -:  101:
        -:  102:AffineExpr
function _ZNK4mlir10AffineExpr14replaceSymbolsEN4llvm8ArrayRefIS0_EE called 0 returned 0% blocks executed 0%
    #####:  103:AffineExpr::replaceSymbols(ArrayRef<AffineExpr> symReplacements) const {
    #####:  104:  return replaceDimsAndSymbols({}, symReplacements);
call    0 never executed
        -:  105:}
        -:  106:
        -:  107:/// Replace dims[offset ... numDims)
        -:  108:/// by dims[offset + shift ... shift + numDims).
function _ZNK4mlir10AffineExpr9shiftDimsEjjj called 0 returned 0% blocks executed 0%
    #####:  109:AffineExpr AffineExpr::shiftDims(unsigned numDims, unsigned shift,
        -:  110:                                 unsigned offset) const {
    #####:  111:  SmallVector<AffineExpr, 4> dims;
    #####:  112:  for (unsigned idx = 0; idx < offset; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  113:    dims.push_back(getAffineDimExpr(idx, getContext()));
call    0 never executed
    #####:  114:  for (unsigned idx = offset; idx < numDims; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  115:    dims.push_back(getAffineDimExpr(idx + shift, getContext()));
call    0 never executed
    #####:  116:  return replaceDimsAndSymbols(dims, {});
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  117:}
        -:  118:
        -:  119:/// Replace symbols[offset ... numSymbols)
        -:  120:/// by symbols[offset + shift ... shift + numSymbols).
function _ZNK4mlir10AffineExpr12shiftSymbolsEjjj called 0 returned 0% blocks executed 0%
    #####:  121:AffineExpr AffineExpr::shiftSymbols(unsigned numSymbols, unsigned shift,
        -:  122:                                    unsigned offset) const {
    #####:  123:  SmallVector<AffineExpr, 4> symbols;
    #####:  124:  for (unsigned idx = 0; idx < offset; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  125:    symbols.push_back(getAffineSymbolExpr(idx, getContext()));
    #####:  126:  for (unsigned idx = offset; idx < numSymbols; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  127:    symbols.push_back(getAffineSymbolExpr(idx + shift, getContext()));
    #####:  128:  return replaceDimsAndSymbols({}, symbols);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  129:}
        -:  130:
        -:  131:/// Sparse replace method. Return the modified expression tree.
        -:  132:AffineExpr
function _ZNK4mlir10AffineExpr7replaceERKN4llvm8DenseMapIS0_S0_NS1_12DenseMapInfoIS0_vEENS1_6detail12DenseMapPairIS0_S0_EEEE called 0 returned 0% blocks executed 0%
    #####:  133:AffineExpr::replace(const DenseMap<AffineExpr, AffineExpr> &map) const {
    #####:  134:  auto it = map.find(*this);
call    0 never executed
    #####:  135:  if (it != map.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  136:    return it->second;
call    0 never executed
    #####:  137:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
    #####:  138:  default:
    #####:  139:    return *this;
    #####:  140:  case AffineExprKind::Add:
    #####:  141:  case AffineExprKind::Mul:
    #####:  142:  case AffineExprKind::FloorDiv:
    #####:  143:  case AffineExprKind::CeilDiv:
    #####:  144:  case AffineExprKind::Mod:
    #####:  145:    auto binOp = cast<AffineBinaryOpExpr>();
call    0 never executed
    #####:  146:    auto lhs = binOp.getLHS(), rhs = binOp.getRHS();
    #####:  147:    auto newLHS = lhs.replace(map);
    #####:  148:    auto newRHS = rhs.replace(map);
call    0 never executed
    #####:  149:    if (newLHS == lhs && newRHS == rhs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  150:      return *this;
    #####:  151:    return getAffineBinaryOpExpr(getKind(), newLHS, newRHS);
call    0 never executed
        -:  152:  }
        -:  153:  llvm_unreachable("Unknown AffineExpr");
        -:  154:}
        -:  155:
        -:  156:/// Sparse replace method. Return the modified expression tree.
function _ZNK4mlir10AffineExpr7replaceES0_S0_ called 0 returned 0% blocks executed 0%
    #####:  157:AffineExpr AffineExpr::replace(AffineExpr expr, AffineExpr replacement) const {
    #####:  158:  DenseMap<AffineExpr, AffineExpr> map;
call    0 never executed
    #####:  159:  map.insert(std::make_pair(expr, replacement));
call    0 never executed
    #####:  160:  return replace(map);
call    0 never executed
call    1 never executed
        -:  161:}
        -:  162:/// Returns true if this expression is made out of only symbols and
        -:  163:/// constants (no dimensional identifiers).
function _ZNK4mlir10AffineExpr20isSymbolicOrConstantEv called 0 returned 0% blocks executed 0%
    #####:  164:bool AffineExpr::isSymbolicOrConstant() const {
    #####:  165:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  166:  case AffineExprKind::Constant:
        -:  167:    return true;
    #####:  168:  case AffineExprKind::DimId:
    #####:  169:    return false;
        -:  170:  case AffineExprKind::SymbolId:
        -:  171:    return true;
        -:  172:
    #####:  173:  case AffineExprKind::Add:
    #####:  174:  case AffineExprKind::Mul:
    #####:  175:  case AffineExprKind::FloorDiv:
    #####:  176:  case AffineExprKind::CeilDiv:
    #####:  177:  case AffineExprKind::Mod: {
    #####:  178:    auto expr = this->cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  179:    return expr.getLHS().isSymbolicOrConstant() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  180:           expr.getRHS().isSymbolicOrConstant();
        -:  181:  }
        -:  182:  }
    #####:  183:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  184:}
        -:  185:
        -:  186:/// Returns true if this is a pure affine expression, i.e., multiplication,
        -:  187:/// floordiv, ceildiv, and mod is only allowed w.r.t constants.
function _ZNK4mlir10AffineExpr12isPureAffineEv called 0 returned 0% blocks executed 0%
    #####:  188:bool AffineExpr::isPureAffine() const {
    #####:  189:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  190:  case AffineExprKind::SymbolId:
        -:  191:  case AffineExprKind::DimId:
        -:  192:  case AffineExprKind::Constant:
        -:  193:    return true;
    #####:  194:  case AffineExprKind::Add: {
    #####:  195:    auto op = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  196:    return op.getLHS().isPureAffine() && op.getRHS().isPureAffine();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  197:  }
        -:  198:
    #####:  199:  case AffineExprKind::Mul: {
        -:  200:    // TODO: Canonicalize the constants in binary operators to the RHS when
        -:  201:    // possible, allowing this to merge into the next case.
    #####:  202:    auto op = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  203:    return op.getLHS().isPureAffine() && op.getRHS().isPureAffine() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  204:           (op.getLHS().template isa<AffineConstantExpr>() ||
branch  0 never executed
branch  1 never executed
    #####:  205:            op.getRHS().template isa<AffineConstantExpr>());
        -:  206:  }
    #####:  207:  case AffineExprKind::FloorDiv:
    #####:  208:  case AffineExprKind::CeilDiv:
    #####:  209:  case AffineExprKind::Mod: {
    #####:  210:    auto op = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  211:    return op.getLHS().isPureAffine() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  212:           op.getRHS().template isa<AffineConstantExpr>();
        -:  213:  }
        -:  214:  }
    #####:  215:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  216:}
        -:  217:
        -:  218:// Returns the greatest known integral divisor of this affine expression.
function _ZNK4mlir10AffineExpr22getLargestKnownDivisorEv called 0 returned 0% blocks executed 0%
    #####:  219:int64_t AffineExpr::getLargestKnownDivisor() const {
    #####:  220:  AffineBinaryOpExpr binExpr(nullptr);
    #####:  221:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  222:  case AffineExprKind::CeilDiv:
        -:  223:    [[fallthrough]];
        -:  224:  case AffineExprKind::DimId:
        -:  225:  case AffineExprKind::FloorDiv:
        -:  226:  case AffineExprKind::SymbolId:
        -:  227:    return 1;
    #####:  228:  case AffineExprKind::Constant:
    #####:  229:    return std::abs(this->cast<AffineConstantExpr>().getValue());
branch  0 never executed
branch  1 never executed
    #####:  230:  case AffineExprKind::Mul: {
    #####:  231:    binExpr = this->cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  232:    return binExpr.getLHS().getLargestKnownDivisor() *
    #####:  233:           binExpr.getRHS().getLargestKnownDivisor();
        -:  234:  }
    #####:  235:  case AffineExprKind::Add:
    #####:  236:    [[fallthrough]];
    #####:  237:  case AffineExprKind::Mod: {
    #####:  238:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  239:    return std::gcd((uint64_t)binExpr.getLHS().getLargestKnownDivisor(),
    #####:  240:                    (uint64_t)binExpr.getRHS().getLargestKnownDivisor());
        -:  241:  }
        -:  242:  }
    #####:  243:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  244:}
        -:  245:
function _ZNK4mlir10AffineExpr12isMultipleOfEl called 0 returned 0% blocks executed 0%
    #####:  246:bool AffineExpr::isMultipleOf(int64_t factor) const {
    #####:  247:  AffineBinaryOpExpr binExpr(nullptr);
    #####:  248:  uint64_t l, u;
    #####:  249:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  250:  case AffineExprKind::SymbolId:
    #####:  251:    [[fallthrough]];
    #####:  252:  case AffineExprKind::DimId:
    #####:  253:    return factor * factor == 1;
    #####:  254:  case AffineExprKind::Constant:
    #####:  255:    return cast<AffineConstantExpr>().getValue() % factor == 0;
branch  0 never executed
branch  1 never executed
    #####:  256:  case AffineExprKind::Mul: {
    #####:  257:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
        -:  258:    // It's probably not worth optimizing this further (to not traverse the
        -:  259:    // whole sub-tree under - it that would require a version of isMultipleOf
        -:  260:    // that on a 'false' return also returns the largest known divisor).
    #####:  261:    return (l = binExpr.getLHS().getLargestKnownDivisor()) % factor == 0 ||
    #####:  262:           (u = binExpr.getRHS().getLargestKnownDivisor()) % factor == 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  263:           (l * u) % factor == 0;
branch  0 never executed
branch  1 never executed
        -:  264:  }
    #####:  265:  case AffineExprKind::Add:
    #####:  266:  case AffineExprKind::FloorDiv:
    #####:  267:  case AffineExprKind::CeilDiv:
    #####:  268:  case AffineExprKind::Mod: {
    #####:  269:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  270:    return std::gcd((uint64_t)binExpr.getLHS().getLargestKnownDivisor(),
    #####:  271:                    (uint64_t)binExpr.getRHS().getLargestKnownDivisor()) %
    #####:  272:               factor ==
    #####:  273:           0;
        -:  274:  }
        -:  275:  }
    #####:  276:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  277:}
        -:  278:
function _ZNK4mlir10AffineExpr15isFunctionOfDimEj called 0 returned 0% blocks executed 0%
    #####:  279:bool AffineExpr::isFunctionOfDim(unsigned position) const {
    #####:  280:  if (getKind() == AffineExprKind::DimId) {
branch  0 never executed
branch  1 never executed
    #####:  281:    return *this == mlir::getAffineDimExpr(position, getContext());
        -:  282:  }
    #####:  283:  if (auto expr = this->dyn_cast<AffineBinaryOpExpr>()) {
branch  0 never executed
branch  1 never executed
    #####:  284:    return expr.getLHS().isFunctionOfDim(position) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  285:           expr.getRHS().isFunctionOfDim(position);
        -:  286:  }
        -:  287:  return false;
        -:  288:}
        -:  289:
function _ZNK4mlir10AffineExpr18isFunctionOfSymbolEj called 0 returned 0% blocks executed 0%
    #####:  290:bool AffineExpr::isFunctionOfSymbol(unsigned position) const {
    #####:  291:  if (getKind() == AffineExprKind::SymbolId) {
branch  0 never executed
branch  1 never executed
    #####:  292:    return *this == mlir::getAffineSymbolExpr(position, getContext());
        -:  293:  }
    #####:  294:  if (auto expr = this->dyn_cast<AffineBinaryOpExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  295:    return expr.getLHS().isFunctionOfSymbol(position) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  296:           expr.getRHS().isFunctionOfSymbol(position);
        -:  297:  }
        -:  298:  return false;
        -:  299:}
        -:  300:
function _ZN4mlir18AffineBinaryOpExprC2EPNS_6detail17AffineExprStorageE called 0 returned 0% blocks executed 0%
    #####:  301:AffineBinaryOpExpr::AffineBinaryOpExpr(AffineExpr::ImplType *ptr)
    #####:  302:    : AffineExpr(ptr) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
call   52 never executed
call   53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
function _ZNK4mlir18AffineBinaryOpExpr6getLHSEv called 0 returned 0% blocks executed 0%
    #####:  303:AffineExpr AffineBinaryOpExpr::getLHS() const {
    #####:  304:  return static_cast<ImplType *>(expr)->lhs;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
call   13 never executed
        -:  305:}
function _ZNK4mlir18AffineBinaryOpExpr6getRHSEv called 0 returned 0% blocks executed 0%
    #####:  306:AffineExpr AffineBinaryOpExpr::getRHS() const {
    #####:  307:  return static_cast<ImplType *>(expr)->rhs;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
        -:  308:}
        -:  309:
function _ZN4mlir13AffineDimExprC2EPNS_6detail17AffineExprStorageE called 0 returned 0% blocks executed 0%
    #####:  310:AffineDimExpr::AffineDimExpr(AffineExpr::ImplType *ptr) : AffineExpr(ptr) {}
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
function _ZNK4mlir13AffineDimExpr11getPositionEv called 0 returned 0% blocks executed 0%
    #####:  311:unsigned AffineDimExpr::getPosition() const {
    #####:  312:  return static_cast<ImplType *>(expr)->position;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  313:}
        -:  314:
        -:  315:/// Returns true if the expression is divisible by the given symbol with
        -:  316:/// position `symbolPos`. The argument `opKind` specifies here what kind of
        -:  317:/// division or mod operation called this division. It helps in implementing the
        -:  318:/// commutative property of the floordiv and ceildiv operations. If the argument
        -:  319:///`exprKind` is floordiv and `expr` is also a binary expression of a floordiv
        -:  320:/// operation, then the commutative property can be used otherwise, the floordiv
        -:  321:/// operation is not divisible. The same argument holds for ceildiv operation.
function _ZL19isDivisibleBySymbolN4mlir10AffineExprEjNS_14AffineExprKindE called 0 returned 0% blocks executed 0%
    #####:  322:static bool isDivisibleBySymbol(AffineExpr expr, unsigned symbolPos,
        -:  323:                                AffineExprKind opKind) {
        -:  324:  // The argument `opKind` can either be Modulo, Floordiv or Ceildiv only.
    #####:  325:  assert((opKind == AffineExprKind::Mod || opKind == AffineExprKind::FloorDiv ||
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  326:          opKind == AffineExprKind::CeilDiv) &&
        -:  327:         "unexpected opKind");
    #####:  328:  switch (expr.getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  329:  case AffineExprKind::Constant:
    #####:  330:    return expr.cast<AffineConstantExpr>().getValue() == 0;
branch  0 never executed
branch  1 never executed
        -:  331:  case AffineExprKind::DimId:
        -:  332:    return false;
    #####:  333:  case AffineExprKind::SymbolId:
    #####:  334:    return (expr.cast<AffineSymbolExpr>().getPosition() == symbolPos);
branch  0 never executed
branch  1 never executed
        -:  335:  // Checks divisibility by the given symbol for both operands.
    #####:  336:  case AffineExprKind::Add: {
    #####:  337:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  338:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  339:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
        -:  340:  }
        -:  341:  // Checks divisibility by the given symbol for both operands. Consider the
        -:  342:  // expression `(((s1*s0) floordiv w) mod ((s1 * s2) floordiv p)) floordiv s1`,
        -:  343:  // this is a division by s1 and both the operands of modulo are divisible by
        -:  344:  // s1 but it is not divisible by s1 always. The third argument is
        -:  345:  // `AffineExprKind::Mod` for this reason.
    #####:  346:  case AffineExprKind::Mod: {
    #####:  347:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  348:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos,
call    0 never executed
    #####:  349:                               AffineExprKind::Mod) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  350:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos,
call    0 never executed
        -:  351:                               AffineExprKind::Mod);
        -:  352:  }
        -:  353:  // Checks if any of the operand divisible by the given symbol.
    #####:  354:  case AffineExprKind::Mul: {
    #####:  355:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  356:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  357:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
        -:  358:  }
        -:  359:  // Floordiv and ceildiv are divisible by the given symbol when the first
        -:  360:  // operand is divisible, and the affine expression kind of the argument expr
        -:  361:  // is same as the argument `opKind`. This can be inferred from commutative
        -:  362:  // property of floordiv and ceildiv operations and are as follow:
        -:  363:  // (exp1 floordiv exp2) floordiv exp3 = (exp1 floordiv exp3) floordiv exp2
        -:  364:  // (exp1 ceildiv exp2) ceildiv exp3 = (exp1 ceildiv exp3) ceildiv expr2
        -:  365:  // It will fail if operations are not same. For example:
        -:  366:  // (exps1 ceildiv exp2) floordiv exp3 can not be simplified.
    #####:  367:  case AffineExprKind::FloorDiv:
    #####:  368:  case AffineExprKind::CeilDiv: {
    #####:  369:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  370:    if (opKind != expr.getKind())
branch  0 never executed
branch  1 never executed
        -:  371:      return false;
    #####:  372:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, expr.getKind());
call    0 never executed
        -:  373:  }
        -:  374:  }
    #####:  375:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  376:}
        -:  377:
        -:  378:/// Divides the given expression by the given symbol at position `symbolPos`. It
        -:  379:/// considers the divisibility condition is checked before calling itself. A
        -:  380:/// null expression is returned whenever the divisibility condition fails.
function _ZL14symbolicDivideN4mlir10AffineExprEjNS_14AffineExprKindE called 0 returned 0% blocks executed 0%
    #####:  381:static AffineExpr symbolicDivide(AffineExpr expr, unsigned symbolPos,
        -:  382:                                 AffineExprKind opKind) {
        -:  383:  // THe argument `opKind` can either be Modulo, Floordiv or Ceildiv only.
    #####:  384:  assert((opKind == AffineExprKind::Mod || opKind == AffineExprKind::FloorDiv ||
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  385:          opKind == AffineExprKind::CeilDiv) &&
        -:  386:         "unexpected opKind");
    #####:  387:  switch (expr.getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  388:  case AffineExprKind::Constant:
    #####:  389:    if (expr.cast<AffineConstantExpr>().getValue() != 0)
branch  0 never executed
branch  1 never executed
    #####:  390:      return nullptr;
    #####:  391:    return getAffineConstantExpr(0, expr.getContext());
call    0 never executed
    #####:  392:  case AffineExprKind::DimId:
    #####:  393:    return nullptr;
    #####:  394:  case AffineExprKind::SymbolId:
    #####:  395:    return getAffineConstantExpr(1, expr.getContext());
call    0 never executed
        -:  396:  // Dividing both operands by the given symbol.
    #####:  397:  case AffineExprKind::Add: {
    #####:  398:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  399:    return getAffineBinaryOpExpr(
        -:  400:        expr.getKind(), symbolicDivide(binaryExpr.getLHS(), symbolPos, opKind),
    #####:  401:        symbolicDivide(binaryExpr.getRHS(), symbolPos, opKind));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  402:  }
        -:  403:  // Dividing both operands by the given symbol.
    #####:  404:  case AffineExprKind::Mod: {
    #####:  405:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  406:    return getAffineBinaryOpExpr(
        -:  407:        expr.getKind(),
        -:  408:        symbolicDivide(binaryExpr.getLHS(), symbolPos, expr.getKind()),
    #####:  409:        symbolicDivide(binaryExpr.getRHS(), symbolPos, expr.getKind()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  410:  }
        -:  411:  // Dividing any of the operand by the given symbol.
    #####:  412:  case AffineExprKind::Mul: {
    #####:  413:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  414:    if (!isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  415:      return binaryExpr.getLHS() *
    #####:  416:             symbolicDivide(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
call    1 never executed
    #####:  417:    return symbolicDivide(binaryExpr.getLHS(), symbolPos, opKind) *
    #####:  418:           binaryExpr.getRHS();
call    0 never executed
call    1 never executed
        -:  419:  }
        -:  420:  // Dividing first operand only by the given symbol.
    #####:  421:  case AffineExprKind::FloorDiv:
    #####:  422:  case AffineExprKind::CeilDiv: {
    #####:  423:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  424:    return getAffineBinaryOpExpr(
        -:  425:        expr.getKind(),
        -:  426:        symbolicDivide(binaryExpr.getLHS(), symbolPos, expr.getKind()),
    #####:  427:        binaryExpr.getRHS());
call    0 never executed
call    1 never executed
        -:  428:  }
        -:  429:  }
    #####:  430:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  431:}
        -:  432:
        -:  433:/// Simplify a semi-affine expression by handling modulo, floordiv, or ceildiv
        -:  434:/// operations when the second operand simplifies to a symbol and the first
        -:  435:/// operand is divisible by that symbol. It can be applied to any semi-affine
        -:  436:/// expression. Returned expression can either be a semi-affine or pure affine
        -:  437:/// expression.
function _ZL18simplifySemiAffineN4mlir10AffineExprE called 0 returned 0% blocks executed 0%
    #####:  438:static AffineExpr simplifySemiAffine(AffineExpr expr) {
    #####:  439:  switch (expr.getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  440:  case AffineExprKind::Constant:
    #####:  441:  case AffineExprKind::DimId:
    #####:  442:  case AffineExprKind::SymbolId:
    #####:  443:    return expr;
    #####:  444:  case AffineExprKind::Add:
    #####:  445:  case AffineExprKind::Mul: {
    #####:  446:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  447:    return getAffineBinaryOpExpr(expr.getKind(),
        -:  448:                                 simplifySemiAffine(binaryExpr.getLHS()),
    #####:  449:                                 simplifySemiAffine(binaryExpr.getRHS()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  450:  }
        -:  451:  // Check if the simplification of the second operand is a symbol, and the
        -:  452:  // first operand is divisible by it. If the operation is a modulo, a constant
        -:  453:  // zero expression is returned. In the case of floordiv and ceildiv, the
        -:  454:  // symbol from the simplification of the second operand divides the first
        -:  455:  // operand. Otherwise, simplification is not possible.
    #####:  456:  case AffineExprKind::FloorDiv:
    #####:  457:  case AffineExprKind::CeilDiv:
    #####:  458:  case AffineExprKind::Mod: {
    #####:  459:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  460:    AffineExpr sLHS = simplifySemiAffine(binaryExpr.getLHS());
call    0 never executed
    #####:  461:    AffineExpr sRHS = simplifySemiAffine(binaryExpr.getRHS());
call    0 never executed
    #####:  462:    AffineSymbolExpr symbolExpr =
    #####:  463:        simplifySemiAffine(binaryExpr.getRHS()).dyn_cast<AffineSymbolExpr>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  464:    if (!symbolExpr)
branch  0 never executed
branch  1 never executed
    #####:  465:      return getAffineBinaryOpExpr(expr.getKind(), sLHS, sRHS);
call    0 never executed
    #####:  466:    unsigned symbolPos = symbolExpr.getPosition();
    #####:  467:    if (!isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, expr.getKind()))
branch  0 never executed
branch  1 never executed
    #####:  468:      return getAffineBinaryOpExpr(expr.getKind(), sLHS, sRHS);
call    0 never executed
    #####:  469:    if (expr.getKind() == AffineExprKind::Mod)
branch  0 never executed
branch  1 never executed
    #####:  470:      return getAffineConstantExpr(0, expr.getContext());
call    0 never executed
    #####:  471:    return symbolicDivide(sLHS, symbolPos, expr.getKind());
call    0 never executed
        -:  472:  }
        -:  473:  }
    #####:  474:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  475:}
        -:  476:
function _ZL20getAffineDimOrSymbolN4mlir14AffineExprKindEjPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  477:static AffineExpr getAffineDimOrSymbol(AffineExprKind kind, unsigned position,
        -:  478:                                       MLIRContext *context) {
    #####:  479:  auto assignCtx = [context](AffineDimExprStorage *storage) {
    #####:  480:    storage->context = context;
    #####:  481:  };
        -:  482:
    #####:  483:  StorageUniquer &uniquer = context->getAffineUniquer();
call    0 never executed
    #####:  484:  return uniquer.get<AffineDimExprStorage>(
    #####:  485:      assignCtx, static_cast<unsigned>(kind), position);
call    0 never executed
        -:  486:}
        -:  487:
function _ZN4mlir16getAffineDimExprEjPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  488:AffineExpr mlir::getAffineDimExpr(unsigned position, MLIRContext *context) {
    #####:  489:  return getAffineDimOrSymbol(AffineExprKind::DimId, position, context);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  490:}
        -:  491:
function _ZN4mlir16AffineSymbolExprC2EPNS_6detail17AffineExprStorageE called 0 returned 0% blocks executed 0%
    #####:  492:AffineSymbolExpr::AffineSymbolExpr(AffineExpr::ImplType *ptr)
    #####:  493:    : AffineExpr(ptr) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
function _ZNK4mlir16AffineSymbolExpr11getPositionEv called 0 returned 0% blocks executed 0%
    #####:  494:unsigned AffineSymbolExpr::getPosition() const {
    #####:  495:  return static_cast<ImplType *>(expr)->position;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  496:}
        -:  497:
function _ZN4mlir19getAffineSymbolExprEjPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  498:AffineExpr mlir::getAffineSymbolExpr(unsigned position, MLIRContext *context) {
    #####:  499:  return getAffineDimOrSymbol(AffineExprKind::SymbolId, position, context);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  500:  ;
call    0 never executed
call    1 never executed
        -:  501:}
        -:  502:
function _ZN4mlir18AffineConstantExprC2EPNS_6detail17AffineExprStorageE called 0 returned 0% blocks executed 0%
    #####:  503:AffineConstantExpr::AffineConstantExpr(AffineExpr::ImplType *ptr)
    #####:  504:    : AffineExpr(ptr) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
function _ZNK4mlir18AffineConstantExpr8getValueEv called 0 returned 0% blocks executed 0%
    #####:  505:int64_t AffineConstantExpr::getValue() const {
    #####:  506:  return static_cast<ImplType *>(expr)->constant;
branch  0 never executed
branch  1 never executed
        -:  507:}
        -:  508:
function _ZNK4mlir10AffineExpreqEl called 0 returned 0% blocks executed 0%
    #####:  509:bool AffineExpr::operator==(int64_t v) const {
    #####:  510:  return *this == getAffineConstantExpr(v, getContext());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  511:}
        -:  512:
function _ZN4mlir21getAffineConstantExprElPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  513:AffineExpr mlir::getAffineConstantExpr(int64_t constant, MLIRContext *context) {
    #####:  514:  auto assignCtx = [context](AffineConstantExprStorage *storage) {
    #####:  515:    storage->context = context;
    #####:  516:  };
        -:  517:
    #####:  518:  StorageUniquer &uniquer = context->getAffineUniquer();
call    0 never executed
    #####:  519:  return uniquer.get<AffineConstantExprStorage>(assignCtx, constant);
call    0 never executed
        -:  520:}
        -:  521:
        -:  522:/// Simplify add expression. Return nullptr if it can't be simplified.
function _ZL11simplifyAddN4mlir10AffineExprES0_ called 0 returned 0% blocks executed 0%
    #####:  523:static AffineExpr simplifyAdd(AffineExpr lhs, AffineExpr rhs) {
    #####:  524:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  525:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
        -:  526:  // Fold if both LHS, RHS are a constant.
    #####:  527:  if (lhsConst && rhsConst)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  528:    return getAffineConstantExpr(lhsConst.getValue() + rhsConst.getValue(),
    #####:  529:                                 lhs.getContext());
call    0 never executed
        -:  530:
        -:  531:  // Canonicalize so that only the RHS is a constant. (4 + d0 becomes d0 + 4).
        -:  532:  // If only one of them is a symbolic expressions, make it the RHS.
    #####:  533:  if (lhs.isa<AffineConstantExpr>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  534:      (lhs.isSymbolicOrConstant() && !rhs.isSymbolicOrConstant())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  535:    return rhs + lhs;
call    0 never executed
        -:  536:  }
        -:  537:
        -:  538:  // At this point, if there was a constant, it would be on the right.
        -:  539:
        -:  540:  // Addition with a zero is a noop, return the other input.
    #####:  541:  if (rhsConst) {
branch  0 never executed
branch  1 never executed
    #####:  542:    if (rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  543:      return lhs;
        -:  544:  }
        -:  545:  // Fold successive additions like (d0 + 2) + 3 into d0 + 5.
    #####:  546:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  547:  if (lBin && rhsConst && lBin.getKind() == AffineExprKind::Add) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  548:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  549:      return lBin.getLHS() + (lrhs.getValue() + rhsConst.getValue());
call    0 never executed
        -:  550:  }
        -:  551:
        -:  552:  // Detect "c1 * expr + c_2 * expr" as "(c1 + c2) * expr".
        -:  553:  // c1 is rRhsConst, c2 is rLhsConst; firstExpr, secondExpr are their
        -:  554:  // respective multiplicands.
    #####:  555:  Optional<int64_t> rLhsConst, rRhsConst;
    #####:  556:  AffineExpr firstExpr, secondExpr;
    #####:  557:  AffineConstantExpr rLhsConstExpr;
branch  0 never executed
branch  1 never executed
    #####:  558:  auto lBinOpExpr = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  559:  if (lBinOpExpr && lBinOpExpr.getKind() == AffineExprKind::Mul &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  560:      (rLhsConstExpr = lBinOpExpr.getRHS().dyn_cast<AffineConstantExpr>())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  561:    rLhsConst = rLhsConstExpr.getValue();
    #####:  562:    firstExpr = lBinOpExpr.getLHS();
        -:  563:  } else {
    #####:  564:    rLhsConst = 1;
        -:  565:    firstExpr = lhs;
        -:  566:  }
        -:  567:
    #####:  568:  auto rBinOpExpr = rhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  569:  AffineConstantExpr rRhsConstExpr;
branch  0 never executed
branch  1 never executed
    #####:  570:  if (rBinOpExpr && rBinOpExpr.getKind() == AffineExprKind::Mul &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  571:      (rRhsConstExpr = rBinOpExpr.getRHS().dyn_cast<AffineConstantExpr>())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  572:    rRhsConst = rRhsConstExpr.getValue();
    #####:  573:    secondExpr = rBinOpExpr.getLHS();
        -:  574:  } else {
    #####:  575:    rRhsConst = 1;
        -:  576:    secondExpr = rhs;
        -:  577:  }
        -:  578:
    #####:  579:  if (rLhsConst && rRhsConst && firstExpr == secondExpr)
branch  0 never executed
branch  1 never executed
    #####:  580:    return getAffineBinaryOpExpr(
        -:  581:        AffineExprKind::Mul, firstExpr,
    #####:  582:        getAffineConstantExpr(*rLhsConst + *rRhsConst, lhs.getContext()));
call    0 never executed
call    1 never executed
        -:  583:
        -:  584:  // When doing successive additions, bring constant to the right: turn (d0 + 2)
        -:  585:  // + d1 into (d0 + d1) + 2.
    #####:  586:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  587:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  588:      return lBin.getLHS() + rhs + lrhs;
call    0 never executed
call    1 never executed
        -:  589:    }
        -:  590:  }
        -:  591:
        -:  592:  // Detect and transform "expr - q * (expr floordiv q)" to "expr mod q", where
        -:  593:  // q may be a constant or symbolic expression. This leads to a much more
        -:  594:  // efficient form when 'c' is a power of two, and in general a more compact
        -:  595:  // and readable form.
        -:  596:
        -:  597:  // Process '(expr floordiv c) * (-c)'.
    #####:  598:  if (!rBinOpExpr)
branch  0 never executed
branch  1 never executed
    #####:  599:    return nullptr;
        -:  600:
    #####:  601:  auto lrhs = rBinOpExpr.getLHS();
    #####:  602:  auto rrhs = rBinOpExpr.getRHS();
        -:  603:
    #####:  604:  AffineExpr llrhs, rlrhs;
        -:  605:
        -:  606:  // Check if lrhsBinOpExpr is of the form (expr floordiv q) * q, where q is a
        -:  607:  // symbolic expression.
    #####:  608:  auto lrhsBinOpExpr = lrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
        -:  609:  // Check rrhsConstOpExpr = -1.
    #####:  610:  auto rrhsConstOpExpr = rrhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  611:  if (rrhsConstOpExpr && rrhsConstOpExpr.getValue() == -1 && lrhsBinOpExpr &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  612:      lrhsBinOpExpr.getKind() == AffineExprKind::Mul) {
branch  0 never executed
branch  1 never executed
        -:  613:    // Check llrhs = expr floordiv q.
    #####:  614:    llrhs = lrhsBinOpExpr.getLHS();
        -:  615:    // Check rlrhs = q.
    #####:  616:    rlrhs = lrhsBinOpExpr.getRHS();
    #####:  617:    auto llrhsBinOpExpr = llrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  618:    if (!llrhsBinOpExpr || llrhsBinOpExpr.getKind() != AffineExprKind::FloorDiv)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  619:      return nullptr;
    #####:  620:    if (llrhsBinOpExpr.getRHS() == rlrhs && lhs == llrhsBinOpExpr.getLHS())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  621:      return lhs % rlrhs;
call    0 never executed
        -:  622:  }
        -:  623:
        -:  624:  // Process lrhs, which is 'expr floordiv c'.
    #####:  625:  AffineBinaryOpExpr lrBinOpExpr = lrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  626:  if (!lrBinOpExpr || lrBinOpExpr.getKind() != AffineExprKind::FloorDiv)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  627:    return nullptr;
        -:  628:
    #####:  629:  llrhs = lrBinOpExpr.getLHS();
    #####:  630:  rlrhs = lrBinOpExpr.getRHS();
        -:  631:
    #####:  632:  if (lhs == llrhs && rlrhs == -rrhs) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  633:    return lhs % rlrhs;
call    0 never executed
        -:  634:  }
    #####:  635:  return nullptr;
        -:  636:}
        -:  637:
function _ZNK4mlir10AffineExprplEl called 0 returned 0% blocks executed 0%
    #####:  638:AffineExpr AffineExpr::operator+(int64_t v) const {
    #####:  639:  return *this + getAffineConstantExpr(v, getContext());
call    0 never executed
call    1 never executed
        -:  640:}
function _ZNK4mlir10AffineExprplES0_ called 0 returned 0% blocks executed 0%
    #####:  641:AffineExpr AffineExpr::operator+(AffineExpr other) const {
    #####:  642:  if (auto simplified = simplifyAdd(*this, other))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  643:    return simplified;
        -:  644:
    #####:  645:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 never executed
    #####:  646:  return uniquer.get<AffineBinaryOpExprStorage>(
    #####:  647:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Add), *this, other);
call    0 never executed
        -:  648:}
        -:  649:
        -:  650:/// Simplify a multiply expression. Return nullptr if it can't be simplified.
function _ZL11simplifyMulN4mlir10AffineExprES0_ called 0 returned 0% blocks executed 0%
    #####:  651:static AffineExpr simplifyMul(AffineExpr lhs, AffineExpr rhs) {
    #####:  652:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  653:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
        -:  654:
    #####:  655:  if (lhsConst && rhsConst)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  656:    return getAffineConstantExpr(lhsConst.getValue() * rhsConst.getValue(),
    #####:  657:                                 lhs.getContext());
call    0 never executed
        -:  658:
    #####:  659:  assert(lhs.isSymbolicOrConstant() || rhs.isSymbolicOrConstant());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  660:
        -:  661:  // Canonicalize the mul expression so that the constant/symbolic term is the
        -:  662:  // RHS. If both the lhs and rhs are symbolic, swap them if the lhs is a
        -:  663:  // constant. (Note that a constant is trivially symbolic).
    #####:  664:  if (!rhs.isSymbolicOrConstant() || lhs.isa<AffineConstantExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  665:    // At least one of them has to be symbolic.
    #####:  666:    return rhs * lhs;
call    0 never executed
        -:  667:  }
        -:  668:
        -:  669:  // At this point, if there was a constant, it would be on the right.
        -:  670:
        -:  671:  // Multiplication with a one is a noop, return the other input.
    #####:  672:  if (rhsConst) {
branch  0 never executed
branch  1 never executed
    #####:  673:    if (rhsConst.getValue() == 1)
branch  0 never executed
branch  1 never executed
    #####:  674:      return lhs;
        -:  675:    // Multiplication with zero.
    #####:  676:    if (rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  677:      return rhsConst;
        -:  678:  }
        -:  679:
        -:  680:  // Fold successive multiplications: eg: (d0 * 2) * 3 into d0 * 6.
    #####:  681:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  682:  if (lBin && rhsConst && lBin.getKind() == AffineExprKind::Mul) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  683:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  684:      return lBin.getLHS() * (lrhs.getValue() * rhsConst.getValue());
call    0 never executed
        -:  685:  }
        -:  686:
        -:  687:  // When doing successive multiplication, bring constant to the right: turn (d0
        -:  688:  // * 2) * d1 into (d0 * d1) * 2.
    #####:  689:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  690:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  691:      return (lBin.getLHS() * rhs) * lrhs;
call    0 never executed
call    1 never executed
        -:  692:    }
        -:  693:  }
        -:  694:
    #####:  695:  return nullptr;
        -:  696:}
        -:  697:
function _ZNK4mlir10AffineExprmlEl called 0 returned 0% blocks executed 0%
    #####:  698:AffineExpr AffineExpr::operator*(int64_t v) const {
    #####:  699:  return *this * getAffineConstantExpr(v, getContext());
call    0 never executed
call    1 never executed
        -:  700:}
function _ZNK4mlir10AffineExprmlES0_ called 0 returned 0% blocks executed 0%
    #####:  701:AffineExpr AffineExpr::operator*(AffineExpr other) const {
    #####:  702:  if (auto simplified = simplifyMul(*this, other))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  703:    return simplified;
        -:  704:
    #####:  705:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 never executed
    #####:  706:  return uniquer.get<AffineBinaryOpExprStorage>(
    #####:  707:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Mul), *this, other);
call    0 never executed
        -:  708:}
        -:  709:
        -:  710:// Unary minus, delegate to operator*.
function _ZNK4mlir10AffineExprngEv called 0 returned 0% blocks executed 0%
    #####:  711:AffineExpr AffineExpr::operator-() const {
    #####:  712:  return *this * getAffineConstantExpr(-1, getContext());
call    0 never executed
call    1 never executed
        -:  713:}
        -:  714:
        -:  715:// Delegate to operator+.
function _ZNK4mlir10AffineExprmiEl called 0 returned 0% blocks executed 0%
    #####:  716:AffineExpr AffineExpr::operator-(int64_t v) const { return *this + (-v); }
call    0 never executed
function _ZNK4mlir10AffineExprmiES0_ called 0 returned 0% blocks executed 0%
    #####:  717:AffineExpr AffineExpr::operator-(AffineExpr other) const {
    #####:  718:  return *this + (-other);
call    0 never executed
call    1 never executed
        -:  719:}
        -:  720:
function _ZL16simplifyFloorDivN4mlir10AffineExprES0_ called 0 returned 0% blocks executed 0%
    #####:  721:static AffineExpr simplifyFloorDiv(AffineExpr lhs, AffineExpr rhs) {
    #####:  722:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  723:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
        -:  724:
        -:  725:  // mlir floordiv by zero or negative numbers is undefined and preserved as is.
    #####:  726:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  727:    return nullptr;
        -:  728:
    #####:  729:  if (lhsConst)
branch  0 never executed
branch  1 never executed
    #####:  730:    return getAffineConstantExpr(
    #####:  731:        floorDiv(lhsConst.getValue(), rhsConst.getValue()), lhs.getContext());
call    0 never executed
call    1 never executed
        -:  732:
        -:  733:  // Fold floordiv of a multiply with a constant that is a multiple of the
        -:  734:  // divisor. Eg: (i * 128) floordiv 64 = i * 2.
    #####:  735:  if (rhsConst == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  736:    return lhs;
        -:  737:
        -:  738:  // Simplify (expr * const) floordiv divConst when expr is known to be a
        -:  739:  // multiple of divConst.
    #####:  740:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  741:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  742:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  743:      // rhsConst is known to be a positive constant.
    #####:  744:      if (lrhs.getValue() % rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  745:        return lBin.getLHS() * (lrhs.getValue() / rhsConst.getValue());
call    0 never executed
        -:  746:    }
        -:  747:  }
        -:  748:
        -:  749:  // Simplify (expr1 + expr2) floordiv divConst when either expr1 or expr2 is
        -:  750:  // known to be a multiple of divConst.
    #####:  751:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  752:    int64_t llhsDiv = lBin.getLHS().getLargestKnownDivisor();
call    0 never executed
    #####:  753:    int64_t lrhsDiv = lBin.getRHS().getLargestKnownDivisor();
call    0 never executed
        -:  754:    // rhsConst is known to be a positive constant.
    #####:  755:    if (llhsDiv % rhsConst.getValue() == 0 ||
branch  0 never executed
branch  1 never executed
    #####:  756:        lrhsDiv % rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  757:      return lBin.getLHS().floorDiv(rhsConst.getValue()) +
    #####:  758:             lBin.getRHS().floorDiv(rhsConst.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  759:  }
        -:  760:
    #####:  761:  return nullptr;
        -:  762:}
        -:  763:
function _ZNK4mlir10AffineExpr8floorDivEm called 0 returned 0% blocks executed 0%
    #####:  764:AffineExpr AffineExpr::floorDiv(uint64_t v) const {
    #####:  765:  return floorDiv(getAffineConstantExpr(v, getContext()));
call    0 never executed
call    1 never executed
        -:  766:}
function _ZNK4mlir10AffineExpr8floorDivES0_ called 0 returned 0% blocks executed 0%
    #####:  767:AffineExpr AffineExpr::floorDiv(AffineExpr other) const {
    #####:  768:  if (auto simplified = simplifyFloorDiv(*this, other))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    return simplified;
        -:  770:
    #####:  771:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 never executed
    #####:  772:  return uniquer.get<AffineBinaryOpExprStorage>(
    #####:  773:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::FloorDiv), *this,
call    0 never executed
    #####:  774:      other);
        -:  775:}
        -:  776:
function _ZL15simplifyCeilDivN4mlir10AffineExprES0_ called 0 returned 0% blocks executed 0%
    #####:  777:static AffineExpr simplifyCeilDiv(AffineExpr lhs, AffineExpr rhs) {
    #####:  778:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  779:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
        -:  780:
    #####:  781:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  782:    return nullptr;
        -:  783:
    #####:  784:  if (lhsConst)
branch  0 never executed
branch  1 never executed
    #####:  785:    return getAffineConstantExpr(
    #####:  786:        ceilDiv(lhsConst.getValue(), rhsConst.getValue()), lhs.getContext());
call    0 never executed
call    1 never executed
        -:  787:
        -:  788:  // Fold ceildiv of a multiply with a constant that is a multiple of the
        -:  789:  // divisor. Eg: (i * 128) ceildiv 64 = i * 2.
    #####:  790:  if (rhsConst.getValue() == 1)
branch  0 never executed
branch  1 never executed
    #####:  791:    return lhs;
        -:  792:
        -:  793:  // Simplify (expr * const) ceildiv divConst when const is known to be a
        -:  794:  // multiple of divConst.
    #####:  795:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  796:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  797:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  798:      // rhsConst is known to be a positive constant.
    #####:  799:      if (lrhs.getValue() % rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  800:        return lBin.getLHS() * (lrhs.getValue() / rhsConst.getValue());
call    0 never executed
        -:  801:    }
        -:  802:  }
        -:  803:
    #####:  804:  return nullptr;
        -:  805:}
        -:  806:
function _ZNK4mlir10AffineExpr7ceilDivEm called 0 returned 0% blocks executed 0%
    #####:  807:AffineExpr AffineExpr::ceilDiv(uint64_t v) const {
    #####:  808:  return ceilDiv(getAffineConstantExpr(v, getContext()));
call    0 never executed
call    1 never executed
        -:  809:}
function _ZNK4mlir10AffineExpr7ceilDivES0_ called 0 returned 0% blocks executed 0%
    #####:  810:AffineExpr AffineExpr::ceilDiv(AffineExpr other) const {
    #####:  811:  if (auto simplified = simplifyCeilDiv(*this, other))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  812:    return simplified;
        -:  813:
    #####:  814:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 never executed
    #####:  815:  return uniquer.get<AffineBinaryOpExprStorage>(
    #####:  816:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::CeilDiv), *this,
call    0 never executed
    #####:  817:      other);
        -:  818:}
        -:  819:
function _ZL11simplifyModN4mlir10AffineExprES0_ called 0 returned 0% blocks executed 0%
    #####:  820:static AffineExpr simplifyMod(AffineExpr lhs, AffineExpr rhs) {
    #####:  821:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  822:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
        -:  823:
        -:  824:  // mod w.r.t zero or negative numbers is undefined and preserved as is.
    #####:  825:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  826:    return nullptr;
        -:  827:
    #####:  828:  if (lhsConst)
branch  0 never executed
branch  1 never executed
    #####:  829:    return getAffineConstantExpr(mod(lhsConst.getValue(), rhsConst.getValue()),
    #####:  830:                                 lhs.getContext());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  831:
        -:  832:  // Fold modulo of an expression that is known to be a multiple of a constant
        -:  833:  // to zero if that constant is a multiple of the modulo factor. Eg: (i * 128)
        -:  834:  // mod 64 is folded to 0, and less trivially, (i*(j*4*(k*32))) mod 128 = 0.
    #####:  835:  if (lhs.getLargestKnownDivisor() % rhsConst.getValue() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  836:    return getAffineConstantExpr(0, lhs.getContext());
call    0 never executed
        -:  837:
        -:  838:  // Simplify (expr1 + expr2) mod divConst when either expr1 or expr2 is
        -:  839:  // known to be a multiple of divConst.
    #####:  840:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  841:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  842:    int64_t llhsDiv = lBin.getLHS().getLargestKnownDivisor();
call    0 never executed
    #####:  843:    int64_t lrhsDiv = lBin.getRHS().getLargestKnownDivisor();
call    0 never executed
        -:  844:    // rhsConst is known to be a positive constant.
    #####:  845:    if (llhsDiv % rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  846:      return lBin.getRHS() % rhsConst.getValue();
call    0 never executed
    #####:  847:    if (lrhsDiv % rhsConst.getValue() == 0)
branch  0 never executed
branch  1 never executed
    #####:  848:      return lBin.getLHS() % rhsConst.getValue();
call    0 never executed
        -:  849:  }
        -:  850:
        -:  851:  // Simplify (e % a) % b to e % b when b evenly divides a
    #####:  852:  if (lBin && lBin.getKind() == AffineExprKind::Mod) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  853:    auto intermediate = lBin.getRHS().dyn_cast<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
    #####:  854:    if (intermediate && intermediate.getValue() >= 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  855:        mod(intermediate.getValue(), rhsConst.getValue()) == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  856:      return lBin.getLHS() % rhsConst.getValue();
call    0 never executed
        -:  857:    }
        -:  858:  }
        -:  859:
    #####:  860:  return nullptr;
        -:  861:}
        -:  862:
function _ZNK4mlir10AffineExprrmEm called 0 returned 0% blocks executed 0%
    #####:  863:AffineExpr AffineExpr::operator%(uint64_t v) const {
    #####:  864:  return *this % getAffineConstantExpr(v, getContext());
call    0 never executed
call    1 never executed
        -:  865:}
function _ZNK4mlir10AffineExprrmES0_ called 0 returned 0% blocks executed 0%
    #####:  866:AffineExpr AffineExpr::operator%(AffineExpr other) const {
    #####:  867:  if (auto simplified = simplifyMod(*this, other))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  868:    return simplified;
        -:  869:
    #####:  870:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 never executed
    #####:  871:  return uniquer.get<AffineBinaryOpExprStorage>(
    #####:  872:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Mod), *this, other);
call    0 never executed
        -:  873:}
        -:  874:
function _ZNK4mlir10AffineExpr7composeENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  875:AffineExpr AffineExpr::compose(AffineMap map) const {
    #####:  876:  SmallVector<AffineExpr, 8> dimReplacements(map.getResults().begin(),
call    0 never executed
    #####:  877:                                             map.getResults().end());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  878:  return replaceDimsAndSymbols(dimReplacements, {});
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  879:}
function _ZN4mlirlsERN4llvm11raw_ostreamENS_10AffineExprE called 0 returned 0% blocks executed 0%
    #####:  880:raw_ostream &mlir::operator<<(raw_ostream &os, AffineExpr expr) {
    #####:  881:  expr.print(os);
call    0 never executed
    #####:  882:  return os;
        -:  883:}
        -:  884:
        -:  885:/// Constructs an affine expression from a flat ArrayRef. If there are local
        -:  886:/// identifiers (neither dimensional nor symbolic) that appear in the sum of
        -:  887:/// products expression, `localExprs` is expected to have the AffineExpr
        -:  888:/// for it, and is substituted into. The ArrayRef `flatExprs` is expected to be
        -:  889:/// in the format [dims, symbols, locals, constant term].
function _ZN4mlir25getAffineExprFromFlatFormEN4llvm8ArrayRefIlEEjjNS1_INS_10AffineExprEEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  890:AffineExpr mlir::getAffineExprFromFlatForm(ArrayRef<int64_t> flatExprs,
        -:  891:                                           unsigned numDims,
        -:  892:                                           unsigned numSymbols,
        -:  893:                                           ArrayRef<AffineExpr> localExprs,
        -:  894:                                           MLIRContext *context) {
        -:  895:  // Assert expected numLocals = flatExprs.size() - numDims - numSymbols - 1.
    #####:  896:  assert(flatExprs.size() - numDims - numSymbols - 1 == localExprs.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  897:         "unexpected number of local expressions");
        -:  898:
    #####:  899:  auto expr = getAffineConstantExpr(0, context);
        -:  900:  // Dimensions and symbols.
    #####:  901:  for (unsigned j = 0; j < numDims + numSymbols; j++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  902:    if (flatExprs[j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  903:      continue;
    #####:  904:    auto id = j < numDims ? getAffineDimExpr(j, context)
    #####:  905:                          : getAffineSymbolExpr(j - numDims, context);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  906:    expr = expr + id * flatExprs[j];
call    0 never executed
call    1 never executed
        -:  907:  }
        -:  908:
        -:  909:  // Local identifiers.
    #####:  910:  for (unsigned j = numDims + numSymbols, e = flatExprs.size() - 1; j < e;
branch  0 never executed
branch  1 never executed
        -:  911:       j++) {
    #####:  912:    if (flatExprs[j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  913:      continue;
    #####:  914:    auto term = localExprs[j - numDims - numSymbols] * flatExprs[j];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  915:    expr = expr + term;
call    0 never executed
        -:  916:  }
        -:  917:
        -:  918:  // Constant term.
    #####:  919:  int64_t constTerm = flatExprs[flatExprs.size() - 1];
branch  0 never executed
branch  1 never executed
    #####:  920:  if (constTerm != 0)
branch  0 never executed
branch  1 never executed
    #####:  921:    expr = expr + constTerm;
call    0 never executed
    #####:  922:  return expr;
        -:  923:}
        -:  924:
        -:  925:/// Constructs a semi-affine expression from a flat ArrayRef. If there are
        -:  926:/// local identifiers (neither dimensional nor symbolic) that appear in the sum
        -:  927:/// of products expression, `localExprs` is expected to have the AffineExprs for
        -:  928:/// it, and is substituted into. The ArrayRef `flatExprs` is expected to be in
        -:  929:/// the format [dims, symbols, locals, constant term]. The semi-affine
        -:  930:/// expression is constructed in the sorted order of dimension and symbol
        -:  931:/// position numbers. Note:  local expressions/ids are used for mod, div as well
        -:  932:/// as symbolic RHS terms for terms that are not pure affine.
function _ZL29getSemiAffineExprFromFlatFormN4llvm8ArrayRefIlEEjjNS0_IN4mlir10AffineExprEEEPNS2_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  933:static AffineExpr getSemiAffineExprFromFlatForm(ArrayRef<int64_t> flatExprs,
        -:  934:                                                unsigned numDims,
        -:  935:                                                unsigned numSymbols,
        -:  936:                                                ArrayRef<AffineExpr> localExprs,
        -:  937:                                                MLIRContext *context) {
    #####:  938:  assert(!flatExprs.empty() && "flatExprs cannot be empty");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  939:
        -:  940:  // Assert expected numLocals = flatExprs.size() - numDims - numSymbols - 1.
    #####:  941:  assert(flatExprs.size() - numDims - numSymbols - 1 == localExprs.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  942:         "unexpected number of local expressions");
        -:  943:
    #####:  944:  AffineExpr expr = getAffineConstantExpr(0, context);
call    0 never executed
        -:  945:
        -:  946:  // We design indices as a pair which help us present the semi-affine map as
        -:  947:  // sum of product where terms are sorted based on dimension or symbol
        -:  948:  // position: <keyA, keyB> for expressions of the form dimension * symbol,
        -:  949:  // where keyA is the position number of the dimension and keyB is the
        -:  950:  // position number of the symbol. For dimensional expressions we set the index
        -:  951:  // as (position number of the dimension, -1), as we want dimensional
        -:  952:  // expressions to appear before symbolic and product of dimensional and
        -:  953:  // symbolic expressions having the dimension with the same position number.
        -:  954:  // For symbolic expression set the index as (position number of the symbol,
        -:  955:  // maximum of last dimension and symbol position) number. For example, we want
        -:  956:  // the expression we are constructing to look something like: d0 + d0 * s0 +
        -:  957:  // s0 + d1*s1 + s1.
        -:  958:
        -:  959:  // Stores the affine expression corresponding to a given index.
    #####:  960:  DenseMap<std::pair<unsigned, signed>, AffineExpr> indexToExprMap;
call    0 never executed
        -:  961:  // Stores the constant coefficient value corresponding to a given
        -:  962:  // dimension, symbol or a non-pure affine expression stored in `localExprs`.
    #####:  963:  DenseMap<std::pair<unsigned, signed>, int64_t> coefficients;
call    0 never executed
call    1 never executed
        -:  964:  // Stores the indices as defined above, and later sorted to produce
        -:  965:  // the semi-affine expression in the desired form.
    #####:  966:  SmallVector<std::pair<unsigned, signed>, 8> indices;
call    0 never executed
        -:  967:
        -:  968:  // Example: expression = d0 + d0 * s0 + 2 * s0.
        -:  969:  // indices = [{0,-1}, {0, 0}, {0, 1}]
        -:  970:  // coefficients = [{{0, -1}, 1}, {{0, 0}, 1}, {{0, 1}, 2}]
        -:  971:  // indexToExprMap = [{{0, -1}, d0}, {{0, 0}, d0 * s0}, {{0, 1}, s0}]
        -:  972:
        -:  973:  // Adds entries to `indexToExprMap`, `coefficients` and `indices`.
function _ZZL29getSemiAffineExprFromFlatFormN4llvm8ArrayRefIlEEjjNS0_IN4mlir10AffineExprEEEPNS2_11MLIRContextEENKUlSt4pairIjiElS3_E_clES8_lS3_ called 0 returned 0% blocks executed 0%
    #####:  974:  auto addEntry = [&](std::pair<unsigned, signed> index, int64_t coefficient,
        -:  975:                      AffineExpr expr) {
    #####:  976:    assert(!llvm::is_contained(indices, index) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  977:           "Key is already present in indices vector and overwriting will "
        -:  978:           "happen in `indexToExprMap` and `coefficients`!");
        -:  979:
    #####:  980:    indices.push_back(index);
call    0 never executed
    #####:  981:    coefficients.insert({index, coefficient});
call    0 never executed
    #####:  982:    indexToExprMap.insert({index, expr});
call    0 never executed
    #####:  983:  };
        -:  984:
        -:  985:  // Design indices for dimensional or symbolic terms, and store the indices,
        -:  986:  // constant coefficient corresponding to the indices in `coefficients` map,
        -:  987:  // and affine expression corresponding to indices in `indexToExprMap` map.
        -:  988:
    #####:  989:  for (unsigned j = 0; j < numDims; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  990:    if (flatExprs[j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  991:      continue;
        -:  992:    // For dimensional expressions we set the index as <position number of the
        -:  993:    // dimension, 0>, as we want dimensional expressions to appear before
        -:  994:    // symbolic ones and products of dimensional and symbolic expressions
        -:  995:    // having the dimension with the same position number.
    #####:  996:    std::pair<unsigned, signed> indexEntry(j, -1);
call    0 never executed
    #####:  997:    addEntry(indexEntry, flatExprs[j], getAffineDimExpr(j, context));
call    0 never executed
call    1 never executed
        -:  998:  }
        -:  999:  // Ensure we do not have duplicate keys in `indexToExpr` map.
        -: 1000:  unsigned offset = 0;
    #####: 1001:  for (unsigned j = numDims; j < numDims + numSymbols; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 1002:    if (flatExprs[j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1003:      continue;
        -: 1004:    // For symbolic expression set the index as <position number
        -: 1005:    // of the symbol, max(dimCount, symCount)> number,
        -: 1006:    // as we want symbolic expressions with the same positional number to
        -: 1007:    // appear after dimensional expressions having the same positional number.
    #####: 1008:    std::pair<unsigned, signed> indexEntry(
branch  0 never executed
branch  1 never executed
    #####: 1009:        j - numDims, std::max(numDims, numSymbols) + offset++);
call    0 never executed
    #####: 1010:    addEntry(indexEntry, flatExprs[j],
call    0 never executed
call    1 never executed
        -: 1011:             getAffineSymbolExpr(j - numDims, context));
        -: 1012:  }
        -: 1013:
        -: 1014:  // Denotes semi-affine product, modulo or division terms, which has been added
        -: 1015:  // to the `indexToExpr` map.
    #####: 1016:  SmallVector<bool, 4> addedToMap(flatExprs.size() - numDims - numSymbols - 1,
call    0 never executed
    #####: 1017:                                  false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1018:  unsigned lhsPos, rhsPos;
        -: 1019:  // Construct indices for product terms involving dimension, symbol or constant
        -: 1020:  // as lhs/rhs, and store the indices, constant coefficient corresponding to
        -: 1021:  // the indices in `coefficients` map, and affine expression corresponding to
        -: 1022:  // in indices in `indexToExprMap` map.
    #####: 1023:  for (const auto &it : llvm::enumerate(localExprs)) {
branch  0 never executed
branch  1 never executed
    #####: 1024:    AffineExpr expr = it.value();
branch  0 never executed
branch  1 never executed
    #####: 1025:    if (flatExprs[numDims + numSymbols + it.index()] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1026:      continue;
call    0 never executed
    #####: 1027:    AffineExpr lhs = expr.cast<AffineBinaryOpExpr>().getLHS();
branch  0 never executed
branch  1 never executed
    #####: 1028:    AffineExpr rhs = expr.cast<AffineBinaryOpExpr>().getRHS();
branch  0 never executed
branch  1 never executed
    #####: 1029:    if (!((lhs.isa<AffineDimExpr>() || lhs.isa<AffineSymbolExpr>()) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1030:          (rhs.isa<AffineDimExpr>() || rhs.isa<AffineSymbolExpr>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1031:           rhs.isa<AffineConstantExpr>()))) {
branch  0 never executed
branch  1 never executed
    #####: 1032:      continue;
        -: 1033:    }
    #####: 1034:    if (rhs.isa<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
        -: 1035:      // For product/modulo/division expressions, when rhs of modulo/division
        -: 1036:      // expression is constant, we put 0 in place of keyB, because we want
        -: 1037:      // them to appear earlier in the semi-affine expression we are
        -: 1038:      // constructing. When rhs is constant, we place 0 in place of keyB.
    #####: 1039:      if (lhs.isa<AffineDimExpr>()) {
branch  0 never executed
branch  1 never executed
    #####: 1040:        lhsPos = lhs.cast<AffineDimExpr>().getPosition();
call    0 never executed
    #####: 1041:        std::pair<unsigned, signed> indexEntry(lhsPos, -1);
call    0 never executed
    #####: 1042:        addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()],
call    0 never executed
        -: 1043:                 expr);
        -: 1044:      } else {
    #####: 1045:        lhsPos = lhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1046:        std::pair<unsigned, signed> indexEntry(
branch  0 never executed
branch  1 never executed
    #####: 1047:            lhsPos, std::max(numDims, numSymbols) + offset++);
call    0 never executed
    #####: 1048:        addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()],
call    0 never executed
        -: 1049:                 expr);
        -: 1050:      }
    #####: 1051:    } else if (lhs.isa<AffineDimExpr>()) {
branch  0 never executed
branch  1 never executed
        -: 1052:      // For product/modulo/division expressions having lhs as dimension and rhs
        -: 1053:      // as symbol, we order the terms in the semi-affine expression based on
        -: 1054:      // the pair: <keyA, keyB> for expressions of the form dimension * symbol,
        -: 1055:      // where keyA is the position number of the dimension and keyB is the
        -: 1056:      // position number of the symbol.
    #####: 1057:      lhsPos = lhs.cast<AffineDimExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1058:      rhsPos = rhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1059:      std::pair<unsigned, signed> indexEntry(lhsPos, rhsPos);
call    0 never executed
    #####: 1060:      addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()], expr);
call    0 never executed
        -: 1061:    } else {
        -: 1062:      // For product/modulo/division expressions having both lhs and rhs as
        -: 1063:      // symbol, we design indices as a pair: <keyA, keyB> for expressions
        -: 1064:      // of the form dimension * symbol, where keyA is the position number of
        -: 1065:      // the dimension and keyB is the position number of the symbol.
    #####: 1066:      lhsPos = lhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1067:      rhsPos = rhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1068:      std::pair<unsigned, signed> indexEntry(
branch  0 never executed
branch  1 never executed
    #####: 1069:          lhsPos, std::max(numDims, numSymbols) + offset++);
call    0 never executed
    #####: 1070:      addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()], expr);
call    0 never executed
        -: 1071:    }
    #####: 1072:    addedToMap[it.index()] = true;
branch  0 never executed
branch  1 never executed
        -: 1073:  }
        -: 1074:
        -: 1075:  // Constructing the simplified semi-affine sum of product/division/mod
        -: 1076:  // expression from the flattened form in the desired sorted order of indices
        -: 1077:  // of the various individual product/division/mod expressions.
    #####: 1078:  llvm::sort(indices);
call    0 never executed
    #####: 1079:  for (const std::pair<unsigned, unsigned> index : indices) {
branch  0 never executed
branch  1 never executed
    #####: 1080:    assert(indexToExprMap.lookup(index) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1081:           "cannot find key in `indexToExprMap` map");
    #####: 1082:    expr = expr + indexToExprMap.lookup(index) * coefficients.lookup(index);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1083:  }
        -: 1084:
        -: 1085:  // Local identifiers.
    #####: 1086:  for (unsigned j = numDims + numSymbols, e = flatExprs.size() - 1; j < e;
branch  0 never executed
branch  1 never executed
        -: 1087:       j++) {
        -: 1088:    // If the coefficient of the local expression is 0, continue as we need not
        -: 1089:    // add it in out final expression.
    #####: 1090:    if (flatExprs[j] == 0 || addedToMap[j - numDims - numSymbols])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1091:      continue;
    #####: 1092:    auto term = localExprs[j - numDims - numSymbols] * flatExprs[j];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1093:    expr = expr + term;
call    0 never executed
        -: 1094:  }
        -: 1095:
        -: 1096:  // Constant term.
    #####: 1097:  int64_t constTerm = flatExprs.back();
call    0 never executed
    #####: 1098:  if (constTerm != 0)
branch  0 never executed
branch  1 never executed
    #####: 1099:    expr = expr + constTerm;
call    0 never executed
    #####: 1100:  return expr;
branch  0 never executed
branch  1 never executed
        -: 1101:}
        -: 1102:
function _ZN4mlir25SimpleAffineExprFlattenerC2Ejj called 0 returned 0% blocks executed 0%
    #####: 1103:SimpleAffineExprFlattener::SimpleAffineExprFlattener(unsigned numDims,
    #####: 1104:                                                     unsigned numSymbols)
    #####: 1105:    : numDims(numDims), numSymbols(numSymbols), numLocals(0) {
call    0 never executed
    #####: 1106:  operandExprStack.reserve(8);
call    0 never executed
call    1 never executed
    #####: 1107:}
        -: 1108:
        -: 1109:// In pure affine t = expr * c, we multiply each coefficient of lhs with c.
        -: 1110://
        -: 1111:// In case of semi affine multiplication expressions, t = expr * symbolic_expr,
        -: 1112:// introduce a local variable p (= expr * symbolic_expr), and the affine
        -: 1113:// expression expr * symbolic_expr is added to `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitMulExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####: 1114:void SimpleAffineExprFlattener::visitMulExpr(AffineBinaryOpExpr expr) {
    #####: 1115:  assert(operandExprStack.size() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1116:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1117:  operandExprStack.pop_back();
branch  0 never executed
branch  1 never executed
    #####: 1118:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
        -: 1119:
        -: 1120:  // Flatten semi-affine multiplication expressions by introducing a local
        -: 1121:  // variable in place of the product; the affine expression
        -: 1122:  // corresponding to the quantifier is added to `localExprs`.
    #####: 1123:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
    #####: 1124:    MLIRContext *context = expr.getContext();
    #####: 1125:    AffineExpr a = getAffineExprFromFlatForm(lhs, numDims, numSymbols,
    #####: 1126:                                             localExprs, context);
call    0 never executed
    #####: 1127:    AffineExpr b = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
    #####: 1128:                                             localExprs, context);
call    0 never executed
    #####: 1129:    addLocalVariableSemiAffine(a * b, lhs, lhs.size());
call    0 never executed
call    1 never executed
    #####: 1130:    return;
branch  0 never executed
branch  1 never executed
        -: 1131:  }
        -: 1132:
        -: 1133:  // Get the RHS constant.
    #####: 1134:  auto rhsConst = rhs[getConstantIndex()];
branch  0 never executed
branch  1 never executed
    #####: 1135:  for (unsigned i = 0, e = lhs.size(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1136:    lhs[i] *= rhsConst;
branch  0 never executed
branch  1 never executed
        -: 1137:  }
        -: 1138:}
        -: 1139:
function _ZN4mlir25SimpleAffineExprFlattener12visitAddExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####: 1140:void SimpleAffineExprFlattener::visitAddExpr(AffineBinaryOpExpr expr) {
    #####: 1141:  assert(operandExprStack.size() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1142:  const auto &rhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1143:  auto &lhs = operandExprStack[operandExprStack.size() - 2];
branch  0 never executed
branch  1 never executed
    #####: 1144:  assert(lhs.size() == rhs.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1145:  // Update the LHS in place.
    #####: 1146:  for (unsigned i = 0, e = rhs.size(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1147:    lhs[i] += rhs[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1148:  }
        -: 1149:  // Pop off the RHS.
    #####: 1150:  operandExprStack.pop_back();
branch  0 never executed
branch  1 never executed
    #####: 1151:}
        -: 1152:
        -: 1153://
        -: 1154:// t = expr mod c   <=>  t = expr - c*q and c*q <= expr <= c*q + c - 1
        -: 1155://
        -: 1156:// A mod expression "expr mod c" is thus flattened by introducing a new local
        -: 1157:// variable q (= expr floordiv c), such that expr mod c is replaced with
        -: 1158:// 'expr - c * q' and c * q <= expr <= c * q + c - 1 are added to localVarCst.
        -: 1159://
        -: 1160:// In case of semi-affine modulo expressions, t = expr mod symbolic_expr,
        -: 1161:// introduce a local variable m (= expr mod symbolic_expr), and the affine
        -: 1162:// expression expr mod symbolic_expr is added to `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitModExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####: 1163:void SimpleAffineExprFlattener::visitModExpr(AffineBinaryOpExpr expr) {
    #####: 1164:  assert(operandExprStack.size() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1165:
    #####: 1166:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1167:  operandExprStack.pop_back();
branch  0 never executed
branch  1 never executed
    #####: 1168:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1169:  MLIRContext *context = expr.getContext();
        -: 1170:
        -: 1171:  // Flatten semi affine modulo expressions by introducing a local
        -: 1172:  // variable in place of the modulo value, and the affine expression
        -: 1173:  // corresponding to the quantifier is added to `localExprs`.
    #####: 1174:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
    #####: 1175:    AffineExpr dividendExpr = getAffineExprFromFlatForm(
    #####: 1176:        lhs, numDims, numSymbols, localExprs, context);
call    0 never executed
    #####: 1177:    AffineExpr divisorExpr = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
    #####: 1178:                                                       localExprs, context);
call    0 never executed
    #####: 1179:    AffineExpr modExpr = dividendExpr % divisorExpr;
call    0 never executed
    #####: 1180:    addLocalVariableSemiAffine(modExpr, lhs, lhs.size());
call    0 never executed
    #####: 1181:    return;
        -: 1182:  }
        -: 1183:
    #####: 1184:  int64_t rhsConst = rhs[getConstantIndex()];
branch  0 never executed
branch  1 never executed
        -: 1185:  // TODO: handle modulo by zero case when this issue is fixed
        -: 1186:  // at the other places in the IR.
    #####: 1187:  assert(rhsConst > 0 && "RHS constant has to be positive");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1188:
        -: 1189:  // Check if the LHS expression is a multiple of modulo factor.
    #####: 1190:  unsigned i, e;
    #####: 1191:  for (i = 0, e = lhs.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1192:    if (lhs[i] % rhsConst != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1193:      break;
        -: 1194:  // If yes, modulo expression here simplifies to zero.
    #####: 1195:  if (i == lhs.size()) {
branch  0 never executed
branch  1 never executed
    #####: 1196:    std::fill(lhs.begin(), lhs.end(), 0);
branch  0 never executed
branch  1 never executed
        -: 1197:    return;
        -: 1198:  }
        -: 1199:
        -: 1200:  // Add a local variable for the quotient, i.e., expr % c is replaced by
        -: 1201:  // (expr - q * c) where q = expr floordiv c. Do this while canceling out
        -: 1202:  // the GCD of expr and c.
    #####: 1203:  SmallVector<int64_t, 8> floorDividend(lhs);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1204:  uint64_t gcd = rhsConst;
    #####: 1205:  for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1206:    gcd = std::gcd(gcd, (uint64_t)std::abs(lhs[i]));
branch  0 never executed
branch  1 never executed
        -: 1207:  // Simplify the numerator and the denominator.
    #####: 1208:  if (gcd != 1) {
branch  0 never executed
branch  1 never executed
    #####: 1209:    for (unsigned i = 0, e = floorDividend.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1210:      floorDividend[i] = floorDividend[i] / static_cast<int64_t>(gcd);
branch  0 never executed
branch  1 never executed
        -: 1211:  }
    #####: 1212:  int64_t floorDivisor = rhsConst / static_cast<int64_t>(gcd);
        -: 1213:
        -: 1214:  // Construct the AffineExpr form of the floordiv to store in localExprs.
        -: 1215:
    #####: 1216:  AffineExpr dividendExpr = getAffineExprFromFlatForm(
    #####: 1217:      floorDividend, numDims, numSymbols, localExprs, context);
call    0 never executed
    #####: 1218:  AffineExpr divisorExpr = getAffineConstantExpr(floorDivisor, context);
call    0 never executed
    #####: 1219:  AffineExpr floorDivExpr = dividendExpr.floorDiv(divisorExpr);
call    0 never executed
    #####: 1220:  int loc;
    #####: 1221:  if ((loc = findLocalId(floorDivExpr)) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1222:    addLocalFloorDivId(floorDividend, floorDivisor, floorDivExpr);
call    0 never executed
        -: 1223:    // Set result at top of stack to "lhs - rhsConst * q".
    #####: 1224:    lhs[getLocalVarStartIndex() + numLocals - 1] = -rhsConst;
branch  0 never executed
branch  1 never executed
        -: 1225:  } else {
        -: 1226:    // Reuse the existing local id.
    #####: 1227:    lhs[getLocalVarStartIndex() + loc] = -rhsConst;
branch  0 never executed
branch  1 never executed
        -: 1228:  }
        -: 1229:}
        -: 1230:
function _ZN4mlir25SimpleAffineExprFlattener16visitCeilDivExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####: 1231:void SimpleAffineExprFlattener::visitCeilDivExpr(AffineBinaryOpExpr expr) {
    #####: 1232:  visitDivExpr(expr, /*isCeil=*/true);
call    0 never executed
call    1 never executed
    #####: 1233:}
function _ZN4mlir25SimpleAffineExprFlattener17visitFloorDivExprENS_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####: 1234:void SimpleAffineExprFlattener::visitFloorDivExpr(AffineBinaryOpExpr expr) {
    #####: 1235:  visitDivExpr(expr, /*isCeil=*/false);
call    0 never executed
call    1 never executed
    #####: 1236:}
        -: 1237:
function _ZN4mlir25SimpleAffineExprFlattener12visitDimExprENS_13AffineDimExprE called 0 returned 0% blocks executed 0%
    #####: 1238:void SimpleAffineExprFlattener::visitDimExpr(AffineDimExpr expr) {
    #####: 1239:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1240:  auto &eq = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1241:  assert(expr.getPosition() < numDims && "Inconsistent number of dims");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1242:  eq[getDimStartIndex() + expr.getPosition()] = 1;
branch  0 never executed
branch  1 never executed
    #####: 1243:}
        -: 1244:
function _ZN4mlir25SimpleAffineExprFlattener15visitSymbolExprENS_16AffineSymbolExprE called 0 returned 0% blocks executed 0%
    #####: 1245:void SimpleAffineExprFlattener::visitSymbolExpr(AffineSymbolExpr expr) {
    #####: 1246:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1247:  auto &eq = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1248:  assert(expr.getPosition() < numSymbols && "inconsistent number of symbols");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1249:  eq[getSymbolStartIndex() + expr.getPosition()] = 1;
branch  0 never executed
branch  1 never executed
    #####: 1250:}
        -: 1251:
function _ZN4mlir25SimpleAffineExprFlattener17visitConstantExprENS_18AffineConstantExprE called 0 returned 0% blocks executed 0%
    #####: 1252:void SimpleAffineExprFlattener::visitConstantExpr(AffineConstantExpr expr) {
    #####: 1253:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1254:  auto &eq = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1255:  eq[getConstantIndex()] = expr.getValue();
branch  0 never executed
branch  1 never executed
    #####: 1256:}
        -: 1257:
function _ZN4mlir25SimpleAffineExprFlattener26addLocalVariableSemiAffineENS_10AffineExprERN4llvm15SmallVectorImplIlEEm called 0 returned 0% blocks executed 0%
    #####: 1258:void SimpleAffineExprFlattener::addLocalVariableSemiAffine(
        -: 1259:    AffineExpr expr, SmallVectorImpl<int64_t> &result,
        -: 1260:    unsigned long resultSize) {
    #####: 1261:  assert(result.size() == resultSize &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1262:         "`result` vector passed is not of correct size");
    #####: 1263:  int loc;
    #####: 1264:  if ((loc = findLocalId(expr)) == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1265:    addLocalIdSemiAffine(expr);
call    0 never executed
    #####: 1266:  std::fill(result.begin(), result.end(), 0);
    #####: 1267:  if (loc == -1)
branch  0 never executed
branch  1 never executed
    #####: 1268:    result[getLocalVarStartIndex() + numLocals - 1] = 1;
branch  0 never executed
branch  1 never executed
        -: 1269:  else
    #####: 1270:    result[getLocalVarStartIndex() + loc] = 1;
branch  0 never executed
branch  1 never executed
    #####: 1271:}
        -: 1272:
        -: 1273:// t = expr floordiv c   <=> t = q, c * q <= expr <= c * q + c - 1
        -: 1274:// A floordiv is thus flattened by introducing a new local variable q, and
        -: 1275:// replacing that expression with 'q' while adding the constraints
        -: 1276:// c * q <= expr <= c * q + c - 1 to localVarCst (done by
        -: 1277:// FlatAffineConstraints::addLocalFloorDiv).
        -: 1278://
        -: 1279:// A ceildiv is similarly flattened:
        -: 1280:// t = expr ceildiv c   <=> t =  (expr + c - 1) floordiv c
        -: 1281://
        -: 1282:// In case of semi affine division expressions, t = expr floordiv symbolic_expr
        -: 1283:// or t = expr ceildiv symbolic_expr, introduce a local variable q (= expr
        -: 1284:// floordiv/ceildiv symbolic_expr), and the affine floordiv/ceildiv is added to
        -: 1285:// `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitDivExprENS_18AffineBinaryOpExprEb called 0 returned 0% blocks executed 0%
    #####: 1286:void SimpleAffineExprFlattener::visitDivExpr(AffineBinaryOpExpr expr,
        -: 1287:                                             bool isCeil) {
    #####: 1288:  assert(operandExprStack.size() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1289:
    #####: 1290:  MLIRContext *context = expr.getContext();
    #####: 1291:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
    #####: 1292:  operandExprStack.pop_back();
branch  0 never executed
branch  1 never executed
    #####: 1293:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 never executed
branch  1 never executed
        -: 1294:
        -: 1295:  // Flatten semi affine division expressions by introducing a local
        -: 1296:  // variable in place of the quotient, and the affine expression corresponding
        -: 1297:  // to the quantifier is added to `localExprs`.
    #####: 1298:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 never executed
branch  1 never executed
    #####: 1299:    AffineExpr a = getAffineExprFromFlatForm(lhs, numDims, numSymbols,
    #####: 1300:                                             localExprs, context);
call    0 never executed
    #####: 1301:    AffineExpr b = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
    #####: 1302:                                             localExprs, context);
call    0 never executed
    #####: 1303:    AffineExpr divExpr = isCeil ? a.ceilDiv(b) : a.floorDiv(b);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1304:    addLocalVariableSemiAffine(divExpr, lhs, lhs.size());
call    0 never executed
    #####: 1305:    return;
        -: 1306:  }
        -: 1307:
        -: 1308:  // This is a pure affine expr; the RHS is a positive constant.
    #####: 1309:  int64_t rhsConst = rhs[getConstantIndex()];
branch  0 never executed
branch  1 never executed
        -: 1310:  // TODO: handle division by zero at the same time the issue is
        -: 1311:  // fixed at other places.
    #####: 1312:  assert(rhsConst > 0 && "RHS constant has to be positive");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1313:
        -: 1314:  // Simplify the floordiv, ceildiv if possible by canceling out the greatest
        -: 1315:  // common divisors of the numerator and denominator.
    #####: 1316:  uint64_t gcd = std::abs(rhsConst);
    #####: 1317:  for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1318:    gcd = std::gcd(gcd, (uint64_t)std::abs(lhs[i]));
branch  0 never executed
branch  1 never executed
        -: 1319:  // Simplify the numerator and the denominator.
    #####: 1320:  if (gcd != 1) {
branch  0 never executed
branch  1 never executed
    #####: 1321:    for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1322:      lhs[i] = lhs[i] / static_cast<int64_t>(gcd);
branch  0 never executed
branch  1 never executed
        -: 1323:  }
    #####: 1324:  int64_t divisor = rhsConst / static_cast<int64_t>(gcd);
        -: 1325:  // If the divisor becomes 1, the updated LHS is the result. (The
        -: 1326:  // divisor can't be negative since rhsConst is positive).
    #####: 1327:  if (divisor == 1)
branch  0 never executed
branch  1 never executed
        -: 1328:    return;
        -: 1329:
        -: 1330:  // If the divisor cannot be simplified to one, we will have to retain
        -: 1331:  // the ceil/floor expr (simplified up until here). Add an existential
        -: 1332:  // quantifier to express its result, i.e., expr1 div expr2 is replaced
        -: 1333:  // by a new identifier, q.
    #####: 1334:  AffineExpr a =
    #####: 1335:      getAffineExprFromFlatForm(lhs, numDims, numSymbols, localExprs, context);
call    0 never executed
    #####: 1336:  AffineExpr b = getAffineConstantExpr(divisor, context);
call    0 never executed
        -: 1337:
    #####: 1338:  int loc;
    #####: 1339:  AffineExpr divExpr = isCeil ? a.ceilDiv(b) : a.floorDiv(b);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1340:  if ((loc = findLocalId(divExpr)) == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1341:    if (!isCeil) {
branch  0 never executed
branch  1 never executed
    #####: 1342:      SmallVector<int64_t, 8> dividend(lhs);
branch  0 never executed
branch  1 never executed
    #####: 1343:      addLocalFloorDivId(dividend, divisor, divExpr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1344:    } else {
        -: 1345:      // lhs ceildiv c <=>  (lhs + c - 1) floordiv c
    #####: 1346:      SmallVector<int64_t, 8> dividend(lhs);
branch  0 never executed
branch  1 never executed
    #####: 1347:      dividend.back() += divisor - 1;
call    0 never executed
    #####: 1348:      addLocalFloorDivId(dividend, divisor, divExpr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1349:    }
        -: 1350:  }
        -: 1351:  // Set the expression on stack to the local var introduced to capture the
        -: 1352:  // result of the division (floor or ceil).
    #####: 1353:  std::fill(lhs.begin(), lhs.end(), 0);
    #####: 1354:  if (loc == -1)
branch  0 never executed
branch  1 never executed
    #####: 1355:    lhs[getLocalVarStartIndex() + numLocals - 1] = 1;
branch  0 never executed
branch  1 never executed
        -: 1356:  else
    #####: 1357:    lhs[getLocalVarStartIndex() + loc] = 1;
branch  0 never executed
branch  1 never executed
        -: 1358:}
        -: 1359:
        -: 1360:// Add a local identifier (needed to flatten a mod, floordiv, ceildiv expr).
        -: 1361:// The local identifier added is always a floordiv of a pure add/mul affine
        -: 1362:// function of other identifiers, coefficients of which are specified in
        -: 1363:// dividend and with respect to a positive constant divisor. localExpr is the
        -: 1364:// simplified tree expression (AffineExpr) corresponding to the quantifier.
function _ZN4mlir25SimpleAffineExprFlattener18addLocalFloorDivIdEN4llvm8ArrayRefIlEElNS_10AffineExprE called 0 returned 0% blocks executed 0%
    #####: 1365:void SimpleAffineExprFlattener::addLocalFloorDivId(ArrayRef<int64_t> dividend,
        -: 1366:                                                   int64_t divisor,
        -: 1367:                                                   AffineExpr localExpr) {
    #####: 1368:  assert(divisor > 0 && "positive constant divisor expected");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1369:  for (SmallVector<int64_t, 8> &subExpr : operandExprStack)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1370:    subExpr.insert(subExpr.begin() + getLocalVarStartIndex() + numLocals, 0);
call    0 never executed
    #####: 1371:  localExprs.push_back(localExpr);
call    0 never executed
    #####: 1372:  numLocals++;
        -: 1373:  // dividend and divisor are not used here; an override of this method uses it.
    #####: 1374:}
        -: 1375:
function _ZN4mlir25SimpleAffineExprFlattener20addLocalIdSemiAffineENS_10AffineExprE called 0 returned 0% blocks executed 0%
    #####: 1376:void SimpleAffineExprFlattener::addLocalIdSemiAffine(AffineExpr localExpr) {
    #####: 1377:  for (SmallVector<int64_t, 8> &subExpr : operandExprStack)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1378:    subExpr.insert(subExpr.begin() + getLocalVarStartIndex() + numLocals, 0);
call    0 never executed
    #####: 1379:  localExprs.push_back(localExpr);
call    0 never executed
    #####: 1380:  ++numLocals;
    #####: 1381:}
        -: 1382:
function _ZN4mlir25SimpleAffineExprFlattener11findLocalIdENS_10AffineExprE called 0 returned 0% blocks executed 0%
    #####: 1383:int SimpleAffineExprFlattener::findLocalId(AffineExpr localExpr) {
    #####: 1384:  SmallVectorImpl<AffineExpr>::iterator it;
    #####: 1385:  if ((it = llvm::find(localExprs, localExpr)) == localExprs.end())
branch  0 never executed
branch  1 never executed
        -: 1386:    return -1;
    #####: 1387:  return it - localExprs.begin();
        -: 1388:}
        -: 1389:
        -: 1390:/// Simplify the affine expression by flattening it and reconstructing it.
function _ZN4mlir18simplifyAffineExprENS_10AffineExprEjj called 0 returned 0% blocks executed 0%
    #####: 1391:AffineExpr mlir::simplifyAffineExpr(AffineExpr expr, unsigned numDims,
        -: 1392:                                    unsigned numSymbols) {
        -: 1393:  // Simplify semi-affine expressions separately.
    #####: 1394:  if (!expr.isPureAffine())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1395:    expr = simplifySemiAffine(expr);
call    0 never executed
        -: 1396:
    #####: 1397:  SimpleAffineExprFlattener flattener(numDims, numSymbols);
call    0 never executed
call    1 never executed
    #####: 1398:  flattener.walkPostOrder(expr);
call    0 never executed
    #####: 1399:  ArrayRef<int64_t> flattenedExpr = flattener.operandExprStack.back();
call    0 never executed
    #####: 1400:  if (!expr.isPureAffine() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1401:      expr == getAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1402:                                        flattener.localExprs,
        -: 1403:                                        expr.getContext()))
    #####: 1404:    return expr;
    #####: 1405:  AffineExpr simplifiedExpr =
    #####: 1406:      expr.isPureAffine()
call    0 never executed
        -: 1407:          ? getAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
    #####: 1408:                                      flattener.localExprs, expr.getContext())
call    0 never executed
        -: 1409:          : getSemiAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
        -: 1410:                                          flattener.localExprs,
    #####: 1411:                                          expr.getContext());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1412:
    #####: 1413:  flattener.operandExprStack.pop_back();
branch  0 never executed
branch  1 never executed
    #####: 1414:  assert(flattener.operandExprStack.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1415:  return simplifiedExpr;
        -: 1416:}
