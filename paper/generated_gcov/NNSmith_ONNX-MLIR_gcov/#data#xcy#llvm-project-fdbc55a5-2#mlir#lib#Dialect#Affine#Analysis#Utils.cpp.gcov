        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Affine/Analysis/Utils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/Utils.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- Utils.cpp ---- Misc utilities for analysis -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements miscellaneous analysis routines for non-loop IR
        -:   10:// structures.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/Affine/Analysis/Utils.h"
        -:   15:#include "mlir/Analysis/Presburger/PresburgerRelation.h"
        -:   16:#include "mlir/Dialect/Affine/Analysis/AffineAnalysis.h"
        -:   17:#include "mlir/Dialect/Affine/Analysis/LoopAnalysis.h"
        -:   18:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   19:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   20:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   21:#include "mlir/IR/IntegerSet.h"
        -:   22:#include "llvm/ADT/SmallPtrSet.h"
        -:   23:#include "llvm/Support/Debug.h"
        -:   24:#include "llvm/Support/raw_ostream.h"
        -:   25:
        -:   26:#define DEBUG_TYPE "analysis-utils"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:using namespace presburger;
        -:   30:
        -:   31:using llvm::SmallDenseMap;
        -:   32:
        -:   33:/// Populates 'loops' with IVs of the loops surrounding 'op' ordered from
        -:   34:/// the outermost 'affine.for' operation to the innermost one.
function _ZN4mlir10getLoopIVsERNS_9OperationEPN4llvm15SmallVectorImplINS_11AffineForOpEEE called 0 returned 0% blocks executed 0%
    #####:   35:void mlir::getLoopIVs(Operation &op, SmallVectorImpl<AffineForOp> *loops) {
    #####:   36:  auto *currOp = op.getParentOp();
branch  0 never executed
branch  1 never executed
    #####:   37:  AffineForOp currAffineForOp;
        -:   38:  // Traverse up the hierarchy collecting all 'affine.for' operation while
        -:   39:  // skipping over 'affine.if' operations.
    #####:   40:  while (currOp) {
branch  0 never executed
branch  1 never executed
    #####:   41:    if (AffineForOp currAffineForOp = dyn_cast<AffineForOp>(currOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   42:      loops->push_back(currAffineForOp);
call    0 never executed
    #####:   43:    currOp = currOp->getParentOp();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   44:  }
    #####:   45:  std::reverse(loops->begin(), loops->end());
branch  0 never executed
branch  1 never executed
    #####:   46:}
        -:   47:
function _ZN4mlir21getEnclosingAffineOpsERNS_9OperationEPN4llvm15SmallVectorImplIPS0_EE called 0 returned 0% blocks executed 0%
    #####:   48:void mlir::getEnclosingAffineOps(Operation &op,
        -:   49:                                 SmallVectorImpl<Operation *> *ops) {
    #####:   50:  ops->clear();
branch  0 never executed
branch  1 never executed
    #####:   51:  Operation *currOp = op.getParentOp();
branch  0 never executed
branch  1 never executed
        -:   52:
        -:   53:  // Traverse up the hierarchy collecting all `affine.for`, `affine.if`, and
        -:   54:  // affine.parallel operations.
    #####:   55:  while (currOp) {
branch  0 never executed
branch  1 never executed
    #####:   56:    if (isa<AffineIfOp, AffineForOp, AffineParallelOp>(currOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   57:      ops->push_back(currOp);
call    0 never executed
    #####:   58:    currOp = currOp->getParentOp();
branch  0 never executed
branch  1 never executed
        -:   59:  }
    #####:   60:  std::reverse(ops->begin(), ops->end());
branch  0 never executed
branch  1 never executed
    #####:   61:}
        -:   62:
        -:   63:// Populates 'cst' with FlatAffineValueConstraints which represent original
        -:   64:// domain of the loop bounds that define 'ivs'.
        -:   65:LogicalResult
function _ZN4mlir21ComputationSliceState22getSourceAsConstraintsERNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:   66:ComputationSliceState::getSourceAsConstraints(FlatAffineValueConstraints &cst) {
    #####:   67:  assert(!ivs.empty() && "Cannot have a slice without its IVs");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   68:  cst.reset(/*numDims=*/ivs.size(), /*numSymbols=*/0, /*numLocals=*/0, ivs);
call    0 never executed
    #####:   69:  for (Value iv : ivs) {
branch  0 never executed
branch  1 never executed
    #####:   70:    AffineForOp loop = getForInductionVarOwner(iv);
call    0 never executed
    #####:   71:    assert(loop && "Expected affine for");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   72:    if (failed(cst.addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   73:      return failure();
        -:   74:  }
    #####:   75:  return success();
        -:   76:}
        -:   77:
        -:   78:// Populates 'cst' with FlatAffineValueConstraints which represent slice bounds.
        -:   79:LogicalResult
function _ZN4mlir21ComputationSliceState16getAsConstraintsEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:   80:ComputationSliceState::getAsConstraints(FlatAffineValueConstraints *cst) {
    #####:   81:  assert(!lbOperands.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   82:  // Adds src 'ivs' as dimension variables in 'cst'.
    #####:   83:  unsigned numDims = ivs.size();
branch  0 never executed
branch  1 never executed
        -:   84:  // Adds operands (dst ivs and symbols) as symbols in 'cst'.
    #####:   85:  unsigned numSymbols = lbOperands[0].size();
branch  0 never executed
branch  1 never executed
        -:   86:
    #####:   87:  SmallVector<Value, 4> values(ivs);
branch  0 never executed
branch  1 never executed
        -:   88:  // Append 'ivs' then 'operands' to 'values'.
    #####:   89:  values.append(lbOperands[0].begin(), lbOperands[0].end());
call    0 never executed
    #####:   90:  cst->reset(numDims, numSymbols, 0, values);
call    0 never executed
        -:   91:
        -:   92:  // Add loop bound constraints for values which are loop IVs of the destination
        -:   93:  // of fusion and equality constraints for symbols which are constants.
    #####:   94:  for (unsigned i = numDims, end = values.size(); i < end; ++i) {
branch  0 never executed
branch  1 never executed
    #####:   95:    Value value = values[i];
branch  0 never executed
branch  1 never executed
    #####:   96:    assert(cst->containsVar(value) && "value expected to be present");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   97:    if (isValidSymbol(value)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   98:      // Check if the symbol is a constant.
    #####:   99:      if (auto cOp = value.getDefiningOp<arith::ConstantIndexOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:        cst->addBound(FlatAffineValueConstraints::EQ, value, cOp.value());
call    0 never executed
call    1 never executed
    #####:  101:    } else if (auto loop = getForInductionVarOwner(value)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  102:      if (failed(cst->addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:        return failure();
        -:  104:    }
        -:  105:  }
        -:  106:
        -:  107:  // Add slices bounds on 'ivs' using maps 'lbs'/'ubs' with 'lbOperands[0]'
    #####:  108:  LogicalResult ret = cst->addSliceBounds(ivs, lbs, ubs, lbOperands[0]);
call    0 never executed
    #####:  109:  assert(succeeded(ret) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  110:         "should not fail as we never have semi-affine slice maps");
    #####:  111:  (void)ret;
    #####:  112:  return success();
branch  0 never executed
branch  1 never executed
        -:  113:}
        -:  114:
        -:  115:// Clears state bounds and operand state.
function _ZN4mlir21ComputationSliceState11clearBoundsEv called 0 returned 0% blocks executed 0%
    #####:  116:void ComputationSliceState::clearBounds() {
    #####:  117:  lbs.clear();
call    0 never executed
    #####:  118:  ubs.clear();
    #####:  119:  lbOperands.clear();
call    0 never executed
    #####:  120:  ubOperands.clear();
call    0 never executed
    #####:  121:}
        -:  122:
function _ZNK4mlir21ComputationSliceState4dumpEv called 0 returned 0% blocks executed 0%
    #####:  123:void ComputationSliceState::dump() const {
    #####:  124:  llvm::errs() << "\tIVs:\n";
call    0 never executed
call    1 never executed
    #####:  125:  for (Value iv : ivs)
branch  0 never executed
branch  1 never executed
    #####:  126:    llvm::errs() << "\t\t" << iv << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  127:
    #####:  128:  llvm::errs() << "\tLBs:\n";
call    0 never executed
call    1 never executed
    #####:  129:  for (auto &en : llvm::enumerate(lbs)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  130:    llvm::errs() << "\t\t" << en.value() << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  131:    llvm::errs() << "\t\tOperands:\n";
call    0 never executed
call    1 never executed
    #####:  132:    for (Value lbOp : lbOperands[en.index()])
branch  0 never executed
branch  1 never executed
    #####:  133:      llvm::errs() << "\t\t\t" << lbOp << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  134:  }
        -:  135:
    #####:  136:  llvm::errs() << "\tUBs:\n";
call    0 never executed
call    1 never executed
    #####:  137:  for (auto &en : llvm::enumerate(ubs)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  138:    llvm::errs() << "\t\t" << en.value() << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  139:    llvm::errs() << "\t\tOperands:\n";
call    0 never executed
call    1 never executed
    #####:  140:    for (Value ubOp : ubOperands[en.index()])
branch  0 never executed
branch  1 never executed
    #####:  141:      llvm::errs() << "\t\t\t" << ubOp << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  142:  }
    #####:  143:}
        -:  144:
        -:  145:/// Fast check to determine if the computation slice is maximal. Returns true if
        -:  146:/// each slice dimension maps to an existing dst dimension and both the src
        -:  147:/// and the dst loops for those dimensions have the same bounds. Returns false
        -:  148:/// if both the src and the dst loops don't have the same bounds. Returns
        -:  149:/// llvm::None if none of the above can be proven.
function _ZNK4mlir21ComputationSliceState23isSliceMaximalFastCheckEv called 0 returned 0% blocks executed 0%
    #####:  150:Optional<bool> ComputationSliceState::isSliceMaximalFastCheck() const {
    #####:  151:  assert(lbs.size() == ubs.size() && !lbs.empty() && !ivs.empty() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  152:         "Unexpected number of lbs, ubs and ivs in slice");
        -:  153:
    #####:  154:  for (unsigned i = 0, end = lbs.size(); i < end; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  155:    AffineMap lbMap = lbs[i];
branch  0 never executed
branch  1 never executed
    #####:  156:    AffineMap ubMap = ubs[i];
branch  0 never executed
branch  1 never executed
        -:  157:
        -:  158:    // Check if this slice is just an equality along this dimension.
    #####:  159:    if (!lbMap || !ubMap || lbMap.getNumResults() != 1 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  160:        ubMap.getNumResults() != 1 ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  161:        lbMap.getResult(0) + 1 != ubMap.getResult(0) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  162:        // The condition above will be true for maps describing a single
        -:  163:        // iteration (e.g., lbMap.getResult(0) = 0, ubMap.getResult(0) = 1).
        -:  164:        // Make sure we skip those cases by checking that the lb result is not
        -:  165:        // just a constant.
    #####:  166:        lbMap.getResult(0).isa<AffineConstantExpr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  167:      return llvm::None;
        -:  168:
        -:  169:    // Limited support: we expect the lb result to be just a loop dimension for
        -:  170:    // now.
    #####:  171:    AffineDimExpr result = lbMap.getResult(0).dyn_cast<AffineDimExpr>();
call    0 never executed
call    1 never executed
    #####:  172:    if (!result)
branch  0 never executed
branch  1 never executed
    #####:  173:      return llvm::None;
        -:  174:
        -:  175:    // Retrieve dst loop bounds.
    #####:  176:    AffineForOp dstLoop =
    #####:  177:        getForInductionVarOwner(lbOperands[i][result.getPosition()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  178:    if (!dstLoop)
branch  0 never executed
branch  1 never executed
    #####:  179:      return llvm::None;
    #####:  180:    AffineMap dstLbMap = dstLoop.getLowerBoundMap();
call    0 never executed
    #####:  181:    AffineMap dstUbMap = dstLoop.getUpperBoundMap();
call    0 never executed
        -:  182:
        -:  183:    // Retrieve src loop bounds.
    #####:  184:    AffineForOp srcLoop = getForInductionVarOwner(ivs[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  185:    assert(srcLoop && "Expected affine for");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  186:    AffineMap srcLbMap = srcLoop.getLowerBoundMap();
call    0 never executed
    #####:  187:    AffineMap srcUbMap = srcLoop.getUpperBoundMap();
call    0 never executed
        -:  188:
        -:  189:    // Limited support: we expect simple src and dst loops with a single
        -:  190:    // constant component per bound for now.
    #####:  191:    if (srcLbMap.getNumResults() != 1 || srcUbMap.getNumResults() != 1 ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  192:        dstLbMap.getNumResults() != 1 || dstUbMap.getNumResults() != 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  193:      return llvm::None;
        -:  194:
    #####:  195:    AffineExpr srcLbResult = srcLbMap.getResult(0);
call    0 never executed
    #####:  196:    AffineExpr dstLbResult = dstLbMap.getResult(0);
call    0 never executed
    #####:  197:    AffineExpr srcUbResult = srcUbMap.getResult(0);
call    0 never executed
    #####:  198:    AffineExpr dstUbResult = dstUbMap.getResult(0);
call    0 never executed
    #####:  199:    if (!srcLbResult.isa<AffineConstantExpr>() ||
call    0 never executed
    #####:  200:        !srcUbResult.isa<AffineConstantExpr>() ||
branch  0 never executed
branch  1 never executed
    #####:  201:        !dstLbResult.isa<AffineConstantExpr>() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  202:        !dstUbResult.isa<AffineConstantExpr>())
branch  0 never executed
branch  1 never executed
    #####:  203:      return llvm::None;
        -:  204:
        -:  205:    // Check if src and dst loop bounds are the same. If not, we can guarantee
        -:  206:    // that the slice is not maximal.
    #####:  207:    if (srcLbResult != dstLbResult || srcUbResult != dstUbResult ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  208:        srcLoop.getStep() != dstLoop.getStep())
call    0 never executed
call    1 never executed
    #####:  209:      return false;
        -:  210:  }
        -:  211:
    #####:  212:  return true;
        -:  213:}
        -:  214:
        -:  215:/// Returns true if it is deterministically verified that the original iteration
        -:  216:/// space of the slice is contained within the new iteration space that is
        -:  217:/// created after fusing 'this' slice into its destination.
function _ZN4mlir21ComputationSliceState12isSliceValidEv called 0 returned 0% blocks executed 0%
    #####:  218:Optional<bool> ComputationSliceState::isSliceValid() {
        -:  219:  // Fast check to determine if the slice is valid. If the following conditions
        -:  220:  // are verified to be true, slice is declared valid by the fast check:
        -:  221:  // 1. Each slice loop is a single iteration loop bound in terms of a single
        -:  222:  //    destination loop IV.
        -:  223:  // 2. Loop bounds of the destination loop IV (from above) and those of the
        -:  224:  //    source loop IV are exactly the same.
        -:  225:  // If the fast check is inconclusive or false, we proceed with a more
        -:  226:  // expensive analysis.
        -:  227:  // TODO: Store the result of the fast check, as it might be used again in
        -:  228:  // `canRemoveSrcNodeAfterFusion`.
    #####:  229:  Optional<bool> isValidFastCheck = isSliceMaximalFastCheck();
call    0 never executed
    #####:  230:  if (isValidFastCheck && *isValidFastCheck)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  231:    return true;
        -:  232:
        -:  233:  // Create constraints for the source loop nest using which slice is computed.
    #####:  234:  FlatAffineValueConstraints srcConstraints;
call    0 never executed
call    1 never executed
        -:  235:  // TODO: Store the source's domain to avoid computation at each depth.
    #####:  236:  if (failed(getSourceAsConstraints(srcConstraints))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  237:    LLVM_DEBUG(llvm::dbgs() << "Unable to compute source's domain\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  238:    return llvm::None;
        -:  239:  }
        -:  240:  // As the set difference utility currently cannot handle symbols in its
        -:  241:  // operands, validity of the slice cannot be determined.
    #####:  242:  if (srcConstraints.getNumSymbolVars() > 0) {
branch  0 never executed
branch  1 never executed
    #####:  243:    LLVM_DEBUG(llvm::dbgs() << "Cannot handle symbols in source domain\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  244:    return llvm::None;
        -:  245:  }
        -:  246:  // TODO: Handle local vars in the source domains while using the 'projectOut'
        -:  247:  // utility below. Currently, aligning is not done assuming that there will be
        -:  248:  // no local vars in the source domain.
    #####:  249:  if (srcConstraints.getNumLocalVars() != 0) {
branch  0 never executed
branch  1 never executed
    #####:  250:    LLVM_DEBUG(llvm::dbgs() << "Cannot handle locals in source domain\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  251:    return llvm::None;
        -:  252:  }
        -:  253:
        -:  254:  // Create constraints for the slice loop nest that would be created if the
        -:  255:  // fusion succeeds.
    #####:  256:  FlatAffineValueConstraints sliceConstraints;
call    0 never executed
    #####:  257:  if (failed(getAsConstraints(&sliceConstraints))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  258:    LLVM_DEBUG(llvm::dbgs() << "Unable to compute slice's domain\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  259:    return llvm::None;
        -:  260:  }
        -:  261:
        -:  262:  // Projecting out every dimension other than the 'ivs' to express slice's
        -:  263:  // domain completely in terms of source's IVs.
    #####:  264:  sliceConstraints.projectOut(ivs.size(),
call    0 never executed
    #####:  265:                              sliceConstraints.getNumVars() - ivs.size());
call    0 never executed
        -:  266:
    #####:  267:  LLVM_DEBUG(llvm::dbgs() << "Domain of the source of the slice:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  268:  LLVM_DEBUG(srcConstraints.dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  269:  LLVM_DEBUG(llvm::dbgs() << "Domain of the slice if this fusion succeeds "
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  270:                             "(expressed in terms of its source's IVs):\n");
    #####:  271:  LLVM_DEBUG(sliceConstraints.dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  272:
        -:  273:  // TODO: Store 'srcSet' to avoid recalculating for each depth.
    #####:  274:  PresburgerSet srcSet(srcConstraints);
call    0 never executed
call    1 never executed
    #####:  275:  PresburgerSet sliceSet(sliceConstraints);
call    0 never executed
call    1 never executed
    #####:  276:  PresburgerSet diffSet = sliceSet.subtract(srcSet);
call    0 never executed
call    1 never executed
        -:  277:
    #####:  278:  if (!diffSet.isIntegerEmpty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  279:    LLVM_DEBUG(llvm::dbgs() << "Incorrect slice\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  280:    return false;
        -:  281:  }
    #####:  282:  return true;
        -:  283:}
        -:  284:
        -:  285:/// Returns true if the computation slice encloses all the iterations of the
        -:  286:/// sliced loop nest. Returns false if it does not. Returns llvm::None if it
        -:  287:/// cannot determine if the slice is maximal or not.
function _ZNK4mlir21ComputationSliceState9isMaximalEv called 0 returned 0% blocks executed 0%
    #####:  288:Optional<bool> ComputationSliceState::isMaximal() const {
        -:  289:  // Fast check to determine if the computation slice is maximal. If the result
        -:  290:  // is inconclusive, we proceed with a more expensive analysis.
    #####:  291:  Optional<bool> isMaximalFastCheck = isSliceMaximalFastCheck();
call    0 never executed
    #####:  292:  if (isMaximalFastCheck)
branch  0 never executed
branch  1 never executed
    #####:  293:    return isMaximalFastCheck;
        -:  294:
        -:  295:  // Create constraints for the src loop nest being sliced.
    #####:  296:  FlatAffineValueConstraints srcConstraints;
call    0 never executed
    #####:  297:  srcConstraints.reset(/*numDims=*/ivs.size(), /*numSymbols=*/0,
call    0 never executed
        -:  298:                       /*numLocals=*/0, ivs);
    #####:  299:  for (Value iv : ivs) {
branch  0 never executed
branch  1 never executed
    #####:  300:    AffineForOp loop = getForInductionVarOwner(iv);
call    0 never executed
    #####:  301:    assert(loop && "Expected affine for");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  302:    if (failed(srcConstraints.addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  303:      return llvm::None;
        -:  304:  }
        -:  305:
        -:  306:  // Create constraints for the slice using the dst loop nest information. We
        -:  307:  // retrieve existing dst loops from the lbOperands.
    #####:  308:  SmallVector<Value, 8> consumerIVs;
call    0 never executed
    #####:  309:  for (Value lbOp : lbOperands[0])
branch  0 never executed
branch  1 never executed
    #####:  310:    if (getForInductionVarOwner(lbOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  311:      consumerIVs.push_back(lbOp);
call    0 never executed
        -:  312:
        -:  313:  // Add empty IV Values for those new loops that are not equalities and,
        -:  314:  // therefore, are not yet materialized in the IR.
    #####:  315:  for (int i = consumerIVs.size(), end = ivs.size(); i < end; ++i)
branch  0 never executed
branch  1 never executed
    #####:  316:    consumerIVs.push_back(Value());
call    0 never executed
        -:  317:
    #####:  318:  FlatAffineValueConstraints sliceConstraints;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  319:  sliceConstraints.reset(/*numDims=*/consumerIVs.size(), /*numSymbols=*/0,
call    0 never executed
        -:  320:                         /*numLocals=*/0, consumerIVs);
        -:  321:
    #####:  322:  if (failed(sliceConstraints.addDomainFromSliceMaps(lbs, ubs, lbOperands[0])))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  323:    return llvm::None;
        -:  324:
    #####:  325:  if (srcConstraints.getNumDimVars() != sliceConstraints.getNumDimVars())
branch  0 never executed
branch  1 never executed
        -:  326:    // Constraint dims are different. The integer set difference can't be
        -:  327:    // computed so we don't know if the slice is maximal.
    #####:  328:    return llvm::None;
        -:  329:
        -:  330:  // Compute the difference between the src loop nest and the slice integer
        -:  331:  // sets.
    #####:  332:  PresburgerSet srcSet(srcConstraints);
call    0 never executed
call    1 never executed
    #####:  333:  PresburgerSet sliceSet(sliceConstraints);
call    0 never executed
call    1 never executed
    #####:  334:  PresburgerSet diffSet = srcSet.subtract(sliceSet);
call    0 never executed
call    1 never executed
    #####:  335:  return diffSet.isIntegerEmpty();
call    0 never executed
call    1 never executed
        -:  336:}
        -:  337:
function _ZNK4mlir12MemRefRegion7getRankEv called 0 returned 0% blocks executed 0%
    #####:  338:unsigned MemRefRegion::getRank() const {
    #####:  339:  return memref.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
        -:  340:}
        -:  341:
function _ZNK4mlir12MemRefRegion31getConstantBoundingSizeAndShapeEPN4llvm15SmallVectorImplIlEEPSt6vectorINS1_11SmallVectorIlLj4EEESaIS7_EES4_ called 0 returned 0% blocks executed 0%
    #####:  342:Optional<int64_t> MemRefRegion::getConstantBoundingSizeAndShape(
        -:  343:    SmallVectorImpl<int64_t> *shape, std::vector<SmallVector<int64_t, 4>> *lbs,
        -:  344:    SmallVectorImpl<int64_t> *lbDivisors) const {
    #####:  345:  auto memRefType = memref.getType().cast<MemRefType>();
call    0 never executed
    #####:  346:  unsigned rank = memRefType.getRank();
call    0 never executed
    #####:  347:  if (shape)
branch  0 never executed
branch  1 never executed
    #####:  348:    shape->reserve(rank);
branch  0 never executed
branch  1 never executed
        -:  349:
    #####:  350:  assert(rank == cst.getNumDimVars() && "inconsistent memref region");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  351:
        -:  352:  // Use a copy of the region constraints that has upper/lower bounds for each
        -:  353:  // memref dimension with static size added to guard against potential
        -:  354:  // over-approximation from projection or union bounding box. We may not add
        -:  355:  // this on the region itself since they might just be redundant constraints
        -:  356:  // that will need non-trivials means to eliminate.
    #####:  357:  FlatAffineValueConstraints cstWithShapeBounds(cst);
call    0 never executed
    #####:  358:  for (unsigned r = 0; r < rank; r++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  359:    cstWithShapeBounds.addBound(FlatAffineValueConstraints::LB, r, 0);
call    0 never executed
    #####:  360:    int64_t dimSize = memRefType.getDimSize(r);
call    0 never executed
    #####:  361:    if (ShapedType::isDynamic(dimSize))
branch  0 never executed
branch  1 never executed
    #####:  362:      continue;
    #####:  363:    cstWithShapeBounds.addBound(FlatAffineValueConstraints::UB, r, dimSize - 1);
call    0 never executed
        -:  364:  }
        -:  365:
        -:  366:  // Find a constant upper bound on the extent of this memref region along each
        -:  367:  // dimension.
        -:  368:  int64_t numElements = 1;
        -:  369:  int64_t diffConstant;
        -:  370:  int64_t lbDivisor;
    #####:  371:  for (unsigned d = 0; d < rank; d++) {
branch  0 never executed
branch  1 never executed
    #####:  372:    SmallVector<int64_t, 4> lb;
call    0 never executed
    #####:  373:    Optional<int64_t> diff =
    #####:  374:        cstWithShapeBounds.getConstantBoundOnDimSize64(d, &lb, &lbDivisor);
call    0 never executed
    #####:  375:    if (diff.has_value()) {
branch  0 never executed
branch  1 never executed
    #####:  376:      diffConstant = diff.value();
branch  0 never executed
branch  1 never executed
    #####:  377:      assert(diffConstant >= 0 && "Dim size bound can't be negative");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  378:      assert(lbDivisor > 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  379:    } else {
        -:  380:      // If no constant bound is found, then it can always be bound by the
        -:  381:      // memref's dim size if the latter has a constant size along this dim.
    #####:  382:      auto dimSize = memRefType.getDimSize(d);
call    0 never executed
    #####:  383:      if (dimSize == -1)
branch  0 never executed
branch  1 never executed
    #####:  384:        return None;
branch  0 never executed
branch  1 never executed
    #####:  385:      diffConstant = dimSize;
        -:  386:      // Lower bound becomes 0.
    #####:  387:      lb.resize(cstWithShapeBounds.getNumSymbolVars() + 1, 0);
call    0 never executed
    #####:  388:      lbDivisor = 1;
        -:  389:    }
    #####:  390:    numElements *= diffConstant;
    #####:  391:    if (lbs) {
branch  0 never executed
branch  1 never executed
    #####:  392:      lbs->push_back(lb);
call    0 never executed
    #####:  393:      assert(lbDivisors && "both lbs and lbDivisor or none");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  394:      lbDivisors->push_back(lbDivisor);
call    0 never executed
        -:  395:    }
    #####:  396:    if (shape) {
branch  0 never executed
branch  1 never executed
    #####:  397:      shape->push_back(diffConstant);
call    0 never executed
        -:  398:    }
        -:  399:  }
    #####:  400:  return numElements;
        -:  401:}
        -:  402:
function _ZNK4mlir12MemRefRegion21getLowerAndUpperBoundEjRNS_9AffineMapES2_ called 0 returned 0% blocks executed 0%
    #####:  403:void MemRefRegion::getLowerAndUpperBound(unsigned pos, AffineMap &lbMap,
        -:  404:                                         AffineMap &ubMap) const {
    #####:  405:  assert(pos < cst.getNumDimVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  406:  auto memRefType = memref.getType().cast<MemRefType>();
call    0 never executed
    #####:  407:  unsigned rank = memRefType.getRank();
call    0 never executed
        -:  408:
    #####:  409:  assert(rank == cst.getNumDimVars() && "inconsistent memref region");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  410:
    #####:  411:  auto boundPairs = cst.getLowerAndUpperBound(
        -:  412:      pos, /*offset=*/0, /*num=*/rank, cst.getNumDimAndSymbolVars(),
    #####:  413:      /*localExprs=*/{}, memRefType.getContext());
call    0 never executed
call    1 never executed
    #####:  414:  lbMap = boundPairs.first;
    #####:  415:  ubMap = boundPairs.second;
    #####:  416:  assert(lbMap && "lower bound for a region must exist");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  417:  assert(ubMap && "upper bound for a region must exist");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  418:  assert(lbMap.getNumInputs() == cst.getNumDimAndSymbolVars() - rank);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  419:  assert(ubMap.getNumInputs() == cst.getNumDimAndSymbolVars() - rank);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  420:}
        -:  421:
function _ZN4mlir12MemRefRegion16unionBoundingBoxERKS0_ called 0 returned 0% blocks executed 0%
    #####:  422:LogicalResult MemRefRegion::unionBoundingBox(const MemRefRegion &other) {
    #####:  423:  assert(memref == other.memref);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  424:  return cst.unionBoundingBox(*other.getConstraints());
call    0 never executed
        -:  425:}
        -:  426:
        -:  427:/// Computes the memory region accessed by this memref with the region
        -:  428:/// represented as constraints symbolic/parametric in 'loopDepth' loops
        -:  429:/// surrounding opInst and any additional Function symbols.
        -:  430://  For example, the memref region for this load operation at loopDepth = 1 will
        -:  431://  be as below:
        -:  432://
        -:  433://    affine.for %i = 0 to 32 {
        -:  434://      affine.for %ii = %i to (d0) -> (d0 + 8) (%i) {
        -:  435://        load %A[%ii]
        -:  436://      }
        -:  437://    }
        -:  438://
        -:  439:// region:  {memref = %A, write = false, {%i <= m0 <= %i + 7} }
        -:  440:// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.
        -:  441://
        -:  442:// TODO: extend this to any other memref dereferencing ops
        -:  443:// (dma_start, dma_wait).
function _ZN4mlir12MemRefRegion7computeEPNS_9OperationEjPKNS_21ComputationSliceStateEb called 0 returned 0% blocks executed 0%
    #####:  444:LogicalResult MemRefRegion::compute(Operation *op, unsigned loopDepth,
        -:  445:                                    const ComputationSliceState *sliceState,
        -:  446:                                    bool addMemRefDimBounds) {
    #####:  447:  assert((isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  448:         "affine read/write op expected");
        -:  449:
    #####:  450:  MemRefAccess access(op);
call    0 never executed
    #####:  451:  memref = access.memref;
    #####:  452:  write = access.isStore();
        -:  453:
    #####:  454:  unsigned rank = access.getRank();
call    0 never executed
        -:  455:
    #####:  456:  LLVM_DEBUG(llvm::dbgs() << "MemRefRegion::compute: " << *op
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  457:                          << "depth: " << loopDepth << "\n";);
        -:  458:
        -:  459:  // 0-d memrefs.
    #####:  460:  if (rank == 0) {
branch  0 never executed
branch  1 never executed
    #####:  461:    SmallVector<AffineForOp, 4> ivs;
call    0 never executed
    #####:  462:    getLoopIVs(*op, &ivs);
call    0 never executed
    #####:  463:    assert(loopDepth <= ivs.size() && "invalid 'loopDepth'");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  464:    // The first 'loopDepth' IVs are symbols for this region.
    #####:  465:    ivs.resize(loopDepth);
call    0 never executed
    #####:  466:    SmallVector<Value, 4> regionSymbols;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  467:    extractForInductionVars(ivs, &regionSymbols);
call    0 never executed
        -:  468:    // A 0-d memref has a 0-d region.
    #####:  469:    cst.reset(rank, loopDepth, /*numLocals=*/0, regionSymbols);
call    0 never executed
    #####:  470:    return success();
branch  0 never executed
branch  1 never executed
        -:  471:  }
        -:  472:
        -:  473:  // Build the constraints for this region.
    #####:  474:  AffineValueMap accessValueMap;
call    0 never executed
    #####:  475:  access.getAccessMap(&accessValueMap);
call    0 never executed
    #####:  476:  AffineMap accessMap = accessValueMap.getAffineMap();
call    0 never executed
        -:  477:
    #####:  478:  unsigned numDims = accessMap.getNumDims();
call    0 never executed
    #####:  479:  unsigned numSymbols = accessMap.getNumSymbols();
call    0 never executed
    #####:  480:  unsigned numOperands = accessValueMap.getNumOperands();
call    0 never executed
        -:  481:  // Merge operands with slice operands.
    #####:  482:  SmallVector<Value, 4> operands;
call    0 never executed
call    1 never executed
    #####:  483:  operands.resize(numOperands);
call    0 never executed
    #####:  484:  for (unsigned i = 0; i < numOperands; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  485:    operands[i] = accessValueMap.getOperand(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  486:
    #####:  487:  if (sliceState != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  488:    operands.reserve(operands.size() + sliceState->lbOperands[0].size());
branch  0 never executed
branch  1 never executed
        -:  489:    // Append slice operands to 'operands' as symbols.
    #####:  490:    for (auto extraOperand : sliceState->lbOperands[0]) {
branch  0 never executed
branch  1 never executed
    #####:  491:      if (!llvm::is_contained(operands, extraOperand)) {
branch  0 never executed
branch  1 never executed
    #####:  492:        operands.push_back(extraOperand);
call    0 never executed
    #####:  493:        numSymbols++;
        -:  494:      }
        -:  495:    }
        -:  496:  }
        -:  497:  // We'll first associate the dims and symbols of the access map to the dims
        -:  498:  // and symbols resp. of cst. This will change below once cst is
        -:  499:  // fully constructed out.
    #####:  500:  cst.reset(numDims, numSymbols, 0, operands);
call    0 never executed
        -:  501:
        -:  502:  // Add equality constraints.
        -:  503:  // Add inequalities for loop lower/upper bounds.
    #####:  504:  for (unsigned i = 0; i < numDims + numSymbols; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  505:    auto operand = operands[i];
branch  0 never executed
branch  1 never executed
    #####:  506:    if (auto loop = getForInductionVarOwner(operand)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  507:      // Note that cst can now have more dimensions than accessMap if the
        -:  508:      // bounds expressions involve outer loops or other symbols.
        -:  509:      // TODO: rewrite this to use getInstIndexSet; this way
        -:  510:      // conditionals will be handled when the latter supports it.
    #####:  511:      if (failed(cst.addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  512:        return failure();
        -:  513:    } else {
        -:  514:      // Has to be a valid symbol.
    #####:  515:      auto symbol = operand;
    #####:  516:      assert(isValidSymbol(symbol));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  517:      // Check if the symbol is a constant.
    #####:  518:      if (auto *op = symbol.getDefiningOp()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  519:        if (auto constOp = dyn_cast<arith::ConstantIndexOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  520:          cst.addBound(FlatAffineValueConstraints::EQ, symbol, constOp.value());
call    0 never executed
call    1 never executed
        -:  521:        }
        -:  522:      }
        -:  523:    }
        -:  524:  }
        -:  525:
        -:  526:  // Add lower/upper bounds on loop IVs using bounds from 'sliceState'.
    #####:  527:  if (sliceState != nullptr) {
branch  0 never executed
branch  1 never executed
        -:  528:    // Add dim and symbol slice operands.
    #####:  529:    for (auto operand : sliceState->lbOperands[0]) {
branch  0 never executed
branch  1 never executed
    #####:  530:      cst.addInductionVarOrTerminalSymbol(operand);
call    0 never executed
        -:  531:    }
        -:  532:    // Add upper/lower bounds from 'sliceState' to 'cst'.
    #####:  533:    LogicalResult ret =
        -:  534:        cst.addSliceBounds(sliceState->ivs, sliceState->lbs, sliceState->ubs,
    #####:  535:                           sliceState->lbOperands[0]);
call    0 never executed
    #####:  536:    assert(succeeded(ret) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  537:           "should not fail as we never have semi-affine slice maps");
    #####:  538:    (void)ret;
        -:  539:  }
        -:  540:
        -:  541:  // Add access function equalities to connect loop IVs to data dimensions.
    #####:  542:  if (failed(cst.composeMap(&accessValueMap))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  543:    op->emitError("getMemRefRegion: compose affine map failed");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  544:    LLVM_DEBUG(accessValueMap.getAffineMap().dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  545:    return failure();
        -:  546:  }
        -:  547:
        -:  548:  // Set all variables appearing after the first 'rank' variables as
        -:  549:  // symbolic variables - so that the ones corresponding to the memref
        -:  550:  // dimensions are the dimensional variables for the memref region.
    #####:  551:  cst.setDimSymbolSeparation(cst.getNumDimAndSymbolVars() - rank);
call    0 never executed
        -:  552:
        -:  553:  // Eliminate any loop IVs other than the outermost 'loopDepth' IVs, on which
        -:  554:  // this memref region is symbolic.
    #####:  555:  SmallVector<AffineForOp, 4> enclosingIVs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  556:  getLoopIVs(*op, &enclosingIVs);
call    0 never executed
    #####:  557:  assert(loopDepth <= enclosingIVs.size() && "invalid loop depth");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  558:  enclosingIVs.resize(loopDepth);
call    0 never executed
    #####:  559:  SmallVector<Value, 4> vars;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  560:  cst.getValues(cst.getNumDimVars(), cst.getNumDimAndSymbolVars(), &vars);
call    0 never executed
    #####:  561:  for (auto var : vars) {
branch  0 never executed
branch  1 never executed
    #####:  562:    AffineForOp iv;
call    0 never executed
    #####:  563:    if ((iv = getForInductionVarOwner(var)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  564:        !llvm::is_contained(enclosingIVs, iv)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  565:      cst.projectOut(var);
call    0 never executed
        -:  566:    }
        -:  567:  }
        -:  568:
        -:  569:  // Project out any local variables (these would have been added for any
        -:  570:  // mod/divs).
    #####:  571:  cst.projectOut(cst.getNumDimAndSymbolVars(), cst.getNumLocalVars());
call    0 never executed
        -:  572:
        -:  573:  // Constant fold any symbolic variables.
    #####:  574:  cst.constantFoldVarRange(/*pos=*/cst.getNumDimVars(),
call    0 never executed
        -:  575:                           /*num=*/cst.getNumSymbolVars());
        -:  576:
    #####:  577:  assert(cst.getNumDimVars() == rank && "unexpected MemRefRegion format");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  578:
        -:  579:  // Add upper/lower bounds for each memref dimension with static size
        -:  580:  // to guard against potential over-approximation from projection.
        -:  581:  // TODO: Support dynamic memref dimensions.
    #####:  582:  if (addMemRefDimBounds) {
branch  0 never executed
branch  1 never executed
    #####:  583:    auto memRefType = memref.getType().cast<MemRefType>();
call    0 never executed
    #####:  584:    for (unsigned r = 0; r < rank; r++) {
branch  0 never executed
branch  1 never executed
    #####:  585:      cst.addBound(FlatAffineValueConstraints::LB, /*pos=*/r, /*value=*/0);
call    0 never executed
    #####:  586:      if (memRefType.isDynamicDim(r))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  587:        continue;
    #####:  588:      cst.addBound(FlatAffineValueConstraints::UB, /*pos=*/r,
call    0 never executed
    #####:  589:                   memRefType.getDimSize(r) - 1);
call    0 never executed
        -:  590:    }
        -:  591:  }
    #####:  592:  cst.removeTrivialRedundancy();
call    0 never executed
        -:  593:
    #####:  594:  LLVM_DEBUG(llvm::dbgs() << "Memory region:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  595:  LLVM_DEBUG(cst.dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  596:  return success();
branch  0 never executed
branch  1 never executed
        -:  597:}
        -:  598:
function _ZL23getMemRefEltSizeInBytesN4mlir10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  599:static unsigned getMemRefEltSizeInBytes(MemRefType memRefType) {
    #####:  600:  auto elementType = memRefType.getElementType();
call    0 never executed
        -:  601:
    #####:  602:  unsigned sizeInBits;
    #####:  603:  if (elementType.isIntOrFloat()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  604:    sizeInBits = elementType.getIntOrFloatBitWidth();
call    0 never executed
        -:  605:  } else {
    #####:  606:    auto vectorType = elementType.cast<VectorType>();
call    0 never executed
    #####:  607:    sizeInBits =
call    0 never executed
    #####:  608:        vectorType.getElementTypeBitWidth() * vectorType.getNumElements();
call    0 never executed
        -:  609:  }
    #####:  610:  return llvm::divideCeil(sizeInBits, 8);
        -:  611:}
        -:  612:
        -:  613:// Returns the size of the region.
function _ZN4mlir12MemRefRegion13getRegionSizeEv called 0 returned 0% blocks executed 0%
    #####:  614:Optional<int64_t> MemRefRegion::getRegionSize() {
    #####:  615:  auto memRefType = memref.getType().cast<MemRefType>();
call    0 never executed
        -:  616:
    #####:  617:  if (!memRefType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  618:    LLVM_DEBUG(llvm::dbgs() << "Non-identity layout map not yet supported\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  619:    return false;
        -:  620:  }
        -:  621:
        -:  622:  // Indices to use for the DmaStart op.
        -:  623:  // Indices for the original memref being DMAed from/to.
    #####:  624:  SmallVector<Value, 4> memIndices;
call    0 never executed
        -:  625:  // Indices for the faster buffer being DMAed into/from.
    #####:  626:  SmallVector<Value, 4> bufIndices;
        -:  627:
        -:  628:  // Compute the extents of the buffer.
    #####:  629:  Optional<int64_t> numElements = getConstantBoundingSizeAndShape();
call    0 never executed
    #####:  630:  if (!numElements) {
branch  0 never executed
branch  1 never executed
    #####:  631:    LLVM_DEBUG(llvm::dbgs() << "Dynamic shapes not yet supported\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  632:    return None;
        -:  633:  }
    #####:  634:  return getMemRefEltSizeInBytes(memRefType) * *numElements;
call    0 never executed
        -:  635:}
        -:  636:
        -:  637:/// Returns the size of memref data in bytes if it's statically shaped, None
        -:  638:/// otherwise.  If the element of the memref has vector type, takes into account
        -:  639:/// size of the vector as well.
        -:  640://  TODO: improve/complete this when we have target data.
function _ZN4mlir20getMemRefSizeInBytesENS_10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  641:Optional<uint64_t> mlir::getMemRefSizeInBytes(MemRefType memRefType) {
    #####:  642:  if (!memRefType.hasStaticShape())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  643:    return None;
    #####:  644:  auto elementType = memRefType.getElementType();
call    0 never executed
    #####:  645:  if (!elementType.isIntOrFloat() && !elementType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  646:    return None;
        -:  647:
    #####:  648:  uint64_t sizeInBytes = getMemRefEltSizeInBytes(memRefType);
call    0 never executed
    #####:  649:  for (unsigned i = 0, e = memRefType.getRank(); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  650:    sizeInBytes = sizeInBytes * memRefType.getDimSize(i);
call    0 never executed
        -:  651:  }
    #####:  652:  return sizeInBytes;
        -:  653:}
        -:  654:
        -:  655:template <typename LoadOrStoreOp>
    #####:  656:LogicalResult mlir::boundCheckLoadOrStoreOp(LoadOrStoreOp loadOrStoreOp,
        -:  657:                                            bool emitError) {
        -:  658:  static_assert(llvm::is_one_of<LoadOrStoreOp, AffineReadOpInterface,
        -:  659:                                AffineWriteOpInterface>::value,
        -:  660:                "argument should be either a AffineReadOpInterface or a "
        -:  661:                "AffineWriteOpInterface");
        -:  662:
    #####:  663:  Operation *op = loadOrStoreOp.getOperation();
    #####:  664:  MemRefRegion region(op->getLoc());
    #####:  665:  if (failed(region.compute(op, /*loopDepth=*/0, /*sliceState=*/nullptr,
        -:  666:                            /*addMemRefDimBounds=*/false)))
    #####:  667:    return success();
        -:  668:
    #####:  669:  LLVM_DEBUG(llvm::dbgs() << "Memory region");
    #####:  670:  LLVM_DEBUG(region.getConstraints()->dump());
        -:  671:
    #####:  672:  bool outOfBounds = false;
    #####:  673:  unsigned rank = loadOrStoreOp.getMemRefType().getRank();
        -:  674:
        -:  675:  // For each dimension, check for out of bounds.
    #####:  676:  for (unsigned r = 0; r < rank; r++) {
    #####:  677:    FlatAffineValueConstraints ucst(*region.getConstraints());
        -:  678:
        -:  679:    // Intersect memory region with constraint capturing out of bounds (both out
        -:  680:    // of upper and out of lower), and check if the constraint system is
        -:  681:    // feasible. If it is, there is at least one point out of bounds.
    #####:  682:    SmallVector<int64_t, 4> ineq(rank + 1, 0);
    #####:  683:    int64_t dimSize = loadOrStoreOp.getMemRefType().getDimSize(r);
        -:  684:    // TODO: handle dynamic dim sizes.
    #####:  685:    if (dimSize == -1)
    #####:  686:      continue;
        -:  687:
        -:  688:    // Check for overflow: d_i >= memref dim size.
    #####:  689:    ucst.addBound(FlatAffineValueConstraints::LB, r, dimSize);
    #####:  690:    outOfBounds = !ucst.isEmpty();
    #####:  691:    if (outOfBounds && emitError) {
        -:  692:      loadOrStoreOp.emitOpError()
    #####:  693:          << "memref out of upper bound access along dimension #" << (r + 1);
        -:  694:    }
        -:  695:
        -:  696:    // Check for a negative index.
    #####:  697:    FlatAffineValueConstraints lcst(*region.getConstraints());
    #####:  698:    std::fill(ineq.begin(), ineq.end(), 0);
        -:  699:    // d_i <= -1;
    #####:  700:    lcst.addBound(FlatAffineValueConstraints::UB, r, -1);
    #####:  701:    outOfBounds = !lcst.isEmpty();
    #####:  702:    if (outOfBounds && emitError) {
        -:  703:      loadOrStoreOp.emitOpError()
    #####:  704:          << "memref out of lower bound access along dimension #" << (r + 1);
        -:  705:    }
        -:  706:  }
    #####:  707:  return failure(outOfBounds);
        -:  708:}
------------------
_ZN4mlir23boundCheckLoadOrStoreOpINS_22AffineWriteOpInterfaceEEENS_13LogicalResultET_b:
function _ZN4mlir23boundCheckLoadOrStoreOpINS_22AffineWriteOpInterfaceEEENS_13LogicalResultET_b called 0 returned 0% blocks executed 0%
    #####:  656:LogicalResult mlir::boundCheckLoadOrStoreOp(LoadOrStoreOp loadOrStoreOp,
        -:  657:                                            bool emitError) {
        -:  658:  static_assert(llvm::is_one_of<LoadOrStoreOp, AffineReadOpInterface,
        -:  659:                                AffineWriteOpInterface>::value,
        -:  660:                "argument should be either a AffineReadOpInterface or a "
        -:  661:                "AffineWriteOpInterface");
        -:  662:
    #####:  663:  Operation *op = loadOrStoreOp.getOperation();
call    0 never executed
    #####:  664:  MemRefRegion region(op->getLoc());
call    0 never executed
    #####:  665:  if (failed(region.compute(op, /*loopDepth=*/0, /*sliceState=*/nullptr,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  666:                            /*addMemRefDimBounds=*/false)))
    #####:  667:    return success();
        -:  668:
    #####:  669:  LLVM_DEBUG(llvm::dbgs() << "Memory region");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  670:  LLVM_DEBUG(region.getConstraints()->dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  671:
    #####:  672:  bool outOfBounds = false;
    #####:  673:  unsigned rank = loadOrStoreOp.getMemRefType().getRank();
call    0 never executed
call    1 never executed
        -:  674:
        -:  675:  // For each dimension, check for out of bounds.
    #####:  676:  for (unsigned r = 0; r < rank; r++) {
branch  0 never executed
branch  1 never executed
    #####:  677:    FlatAffineValueConstraints ucst(*region.getConstraints());
call    0 never executed
        -:  678:
        -:  679:    // Intersect memory region with constraint capturing out of bounds (both out
        -:  680:    // of upper and out of lower), and check if the constraint system is
        -:  681:    // feasible. If it is, there is at least one point out of bounds.
    #####:  682:    SmallVector<int64_t, 4> ineq(rank + 1, 0);
call    0 never executed
call    1 never executed
    #####:  683:    int64_t dimSize = loadOrStoreOp.getMemRefType().getDimSize(r);
call    0 never executed
call    1 never executed
        -:  684:    // TODO: handle dynamic dim sizes.
    #####:  685:    if (dimSize == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  686:      continue;
call    0 never executed
        -:  687:
        -:  688:    // Check for overflow: d_i >= memref dim size.
    #####:  689:    ucst.addBound(FlatAffineValueConstraints::LB, r, dimSize);
call    0 never executed
    #####:  690:    outOfBounds = !ucst.isEmpty();
call    0 never executed
    #####:  691:    if (outOfBounds && emitError) {
branch  0 never executed
branch  1 never executed
        -:  692:      loadOrStoreOp.emitOpError()
    #####:  693:          << "memref out of upper bound access along dimension #" << (r + 1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  694:    }
        -:  695:
        -:  696:    // Check for a negative index.
    #####:  697:    FlatAffineValueConstraints lcst(*region.getConstraints());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  698:    std::fill(ineq.begin(), ineq.end(), 0);
        -:  699:    // d_i <= -1;
    #####:  700:    lcst.addBound(FlatAffineValueConstraints::UB, r, -1);
call    0 never executed
    #####:  701:    outOfBounds = !lcst.isEmpty();
call    0 never executed
    #####:  702:    if (outOfBounds && emitError) {
branch  0 never executed
branch  1 never executed
        -:  703:      loadOrStoreOp.emitOpError()
    #####:  704:          << "memref out of lower bound access along dimension #" << (r + 1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  705:    }
        -:  706:  }
    #####:  707:  return failure(outOfBounds);
call    0 never executed
        -:  708:}
------------------
_ZN4mlir23boundCheckLoadOrStoreOpINS_21AffineReadOpInterfaceEEENS_13LogicalResultET_b:
function _ZN4mlir23boundCheckLoadOrStoreOpINS_21AffineReadOpInterfaceEEENS_13LogicalResultET_b called 0 returned 0% blocks executed 0%
    #####:  656:LogicalResult mlir::boundCheckLoadOrStoreOp(LoadOrStoreOp loadOrStoreOp,
        -:  657:                                            bool emitError) {
        -:  658:  static_assert(llvm::is_one_of<LoadOrStoreOp, AffineReadOpInterface,
        -:  659:                                AffineWriteOpInterface>::value,
        -:  660:                "argument should be either a AffineReadOpInterface or a "
        -:  661:                "AffineWriteOpInterface");
        -:  662:
    #####:  663:  Operation *op = loadOrStoreOp.getOperation();
call    0 never executed
    #####:  664:  MemRefRegion region(op->getLoc());
call    0 never executed
    #####:  665:  if (failed(region.compute(op, /*loopDepth=*/0, /*sliceState=*/nullptr,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  666:                            /*addMemRefDimBounds=*/false)))
    #####:  667:    return success();
        -:  668:
    #####:  669:  LLVM_DEBUG(llvm::dbgs() << "Memory region");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  670:  LLVM_DEBUG(region.getConstraints()->dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  671:
    #####:  672:  bool outOfBounds = false;
    #####:  673:  unsigned rank = loadOrStoreOp.getMemRefType().getRank();
call    0 never executed
call    1 never executed
        -:  674:
        -:  675:  // For each dimension, check for out of bounds.
    #####:  676:  for (unsigned r = 0; r < rank; r++) {
branch  0 never executed
branch  1 never executed
    #####:  677:    FlatAffineValueConstraints ucst(*region.getConstraints());
call    0 never executed
        -:  678:
        -:  679:    // Intersect memory region with constraint capturing out of bounds (both out
        -:  680:    // of upper and out of lower), and check if the constraint system is
        -:  681:    // feasible. If it is, there is at least one point out of bounds.
    #####:  682:    SmallVector<int64_t, 4> ineq(rank + 1, 0);
call    0 never executed
call    1 never executed
    #####:  683:    int64_t dimSize = loadOrStoreOp.getMemRefType().getDimSize(r);
call    0 never executed
call    1 never executed
        -:  684:    // TODO: handle dynamic dim sizes.
    #####:  685:    if (dimSize == -1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  686:      continue;
call    0 never executed
        -:  687:
        -:  688:    // Check for overflow: d_i >= memref dim size.
    #####:  689:    ucst.addBound(FlatAffineValueConstraints::LB, r, dimSize);
call    0 never executed
    #####:  690:    outOfBounds = !ucst.isEmpty();
call    0 never executed
    #####:  691:    if (outOfBounds && emitError) {
branch  0 never executed
branch  1 never executed
        -:  692:      loadOrStoreOp.emitOpError()
    #####:  693:          << "memref out of upper bound access along dimension #" << (r + 1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  694:    }
        -:  695:
        -:  696:    // Check for a negative index.
    #####:  697:    FlatAffineValueConstraints lcst(*region.getConstraints());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  698:    std::fill(ineq.begin(), ineq.end(), 0);
        -:  699:    // d_i <= -1;
    #####:  700:    lcst.addBound(FlatAffineValueConstraints::UB, r, -1);
call    0 never executed
    #####:  701:    outOfBounds = !lcst.isEmpty();
call    0 never executed
    #####:  702:    if (outOfBounds && emitError) {
branch  0 never executed
branch  1 never executed
        -:  703:      loadOrStoreOp.emitOpError()
    #####:  704:          << "memref out of lower bound access along dimension #" << (r + 1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  705:    }
        -:  706:  }
    #####:  707:  return failure(outOfBounds);
call    0 never executed
        -:  708:}
------------------
        -:  709:
        -:  710:// Explicitly instantiate the template so that the compiler knows we need them!
        -:  711:template LogicalResult
        -:  712:mlir::boundCheckLoadOrStoreOp(AffineReadOpInterface loadOp, bool emitError);
        -:  713:template LogicalResult
        -:  714:mlir::boundCheckLoadOrStoreOp(AffineWriteOpInterface storeOp, bool emitError);
        -:  715:
        -:  716:// Returns in 'positions' the Block positions of 'op' in each ancestor
        -:  717:// Block from the Block containing operation, stopping at 'limitBlock'.
function _ZL16findInstPositionPN4mlir9OperationEPNS_5BlockEPN4llvm15SmallVectorImplIjEE called 0 returned 0% blocks executed 0%
    #####:  718:static void findInstPosition(Operation *op, Block *limitBlock,
        -:  719:                             SmallVectorImpl<unsigned> *positions) {
    #####:  720:  Block *block = op->getBlock();
    #####:  721:  while (block != limitBlock) {
branch  0 never executed
branch  1 never executed
        -:  722:    // FIXME: This algorithm is unnecessarily O(n) and should be improved to not
        -:  723:    // rely on linear scans.
    #####:  724:    int instPosInBlock = std::distance(block->begin(), op->getIterator());
    #####:  725:    positions->push_back(instPosInBlock);
call    0 never executed
    #####:  726:    op = block->getParentOp();
call    0 never executed
    #####:  727:    block = op->getBlock();
        -:  728:  }
    #####:  729:  std::reverse(positions->begin(), positions->end());
branch  0 never executed
branch  1 never executed
    #####:  730:}
        -:  731:
        -:  732:// Returns the Operation in a possibly nested set of Blocks, where the
        -:  733:// position of the operation is represented by 'positions', which has a
        -:  734:// Block position for each level of nesting.
function _ZL17getInstAtPositionN4llvm8ArrayRefIjEEjPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  735:static Operation *getInstAtPosition(ArrayRef<unsigned> positions,
        -:  736:                                    unsigned level, Block *block) {
    #####:  737:  unsigned i = 0;
    #####:  738:  for (auto &op : *block) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  739:    if (i != positions[level]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  740:      ++i;
    #####:  741:      continue;
        -:  742:    }
    #####:  743:    if (level == positions.size() - 1)
branch  0 never executed
branch  1 never executed
        -:  744:      return &op;
    #####:  745:    if (auto childAffineForOp = dyn_cast<AffineForOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  746:      return getInstAtPosition(positions, level + 1,
call    0 never executed
call    1 never executed
    #####:  747:                               childAffineForOp.getBody());
        -:  748:
    #####:  749:    for (auto &region : op.getRegions()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  750:      for (auto &b : region)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  751:        if (auto *ret = getInstAtPosition(positions, level + 1, &b))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  752:          return ret;
        -:  753:    }
        -:  754:    return nullptr;
        -:  755:  }
        -:  756:  return nullptr;
        -:  757:}
        -:  758:
        -:  759:// Adds loop IV bounds to 'cst' for loop IVs not found in 'ivs'.
function _ZL22addMissingLoopIVBoundsRN4llvm11SmallPtrSetIN4mlir5ValueELj8EEEPNS1_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  760:static LogicalResult addMissingLoopIVBounds(SmallPtrSet<Value, 8> &ivs,
        -:  761:                                            FlatAffineValueConstraints *cst) {
    #####:  762:  for (unsigned i = 0, e = cst->getNumDimVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  763:    auto value = cst->getValue(i);
call    0 never executed
    #####:  764:    if (ivs.count(value) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  765:      assert(isForInductionVar(value));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  766:      auto loop = getForInductionVarOwner(value);
call    0 never executed
    #####:  767:      if (failed(cst->addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  768:        return failure();
        -:  769:    }
        -:  770:  }
    #####:  771:  return success();
        -:  772:}
        -:  773:
        -:  774:/// Returns the innermost common loop depth for the set of operations in 'ops'.
        -:  775:// TODO: Move this to LoopUtils.
function _ZN4mlir27getInnermostCommonLoopDepthEN4llvm8ArrayRefIPNS_9OperationEEEPNS0_15SmallVectorImplINS_11AffineForOpEEE called 0 returned 0% blocks executed 0%
    #####:  776:unsigned mlir::getInnermostCommonLoopDepth(
        -:  777:    ArrayRef<Operation *> ops, SmallVectorImpl<AffineForOp> *surroundingLoops) {
    #####:  778:  unsigned numOps = ops.size();
branch  0 never executed
branch  1 never executed
    #####:  779:  assert(numOps > 0 && "Expected at least one operation");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  780:
    #####:  781:  std::vector<SmallVector<AffineForOp, 4>> loops(numOps);
call    0 never executed
call    1 never executed
    #####:  782:  unsigned loopDepthLimit = std::numeric_limits<unsigned>::max();
    #####:  783:  for (unsigned i = 0; i < numOps; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  784:    getLoopIVs(*ops[i], &loops[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  785:    loopDepthLimit =
    #####:  786:        std::min(loopDepthLimit, static_cast<unsigned>(loops[i].size()));
branch  0 never executed
branch  1 never executed
        -:  787:  }
        -:  788:
        -:  789:  unsigned loopDepth = 0;
    #####:  790:  for (unsigned d = 0; d < loopDepthLimit; ++d) {
branch  0 never executed
branch  1 never executed
        -:  791:    unsigned i;
    #####:  792:    for (i = 1; i < numOps; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  793:      if (loops[i - 1][d] != loops[i][d])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  794:        return loopDepth;
        -:  795:    }
    #####:  796:    if (surroundingLoops)
branch  0 never executed
branch  1 never executed
    #####:  797:      surroundingLoops->push_back(loops[i - 1][d]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  798:    ++loopDepth;
        -:  799:  }
        -:  800:  return loopDepth;
        -:  801:}
        -:  802:
        -:  803:/// Computes in 'sliceUnion' the union of all slice bounds computed at
        -:  804:/// 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and
        -:  805:/// then verifies if it is valid. Returns 'SliceComputationResult::Success' if
        -:  806:/// union was computed correctly, an appropriate failure otherwise.
        -:  807:SliceComputationResult
function _ZN4mlir17computeSliceUnionEN4llvm8ArrayRefIPNS_9OperationEEES4_jjbPNS_21ComputationSliceStateE called 0 returned 0% blocks executed 0%
    #####:  808:mlir::computeSliceUnion(ArrayRef<Operation *> opsA, ArrayRef<Operation *> opsB,
        -:  809:                        unsigned loopDepth, unsigned numCommonLoops,
        -:  810:                        bool isBackwardSlice,
        -:  811:                        ComputationSliceState *sliceUnion) {
        -:  812:  // Compute the union of slice bounds between all pairs in 'opsA' and
        -:  813:  // 'opsB' in 'sliceUnionCst'.
    #####:  814:  FlatAffineValueConstraints sliceUnionCst;
call    0 never executed
    #####:  815:  assert(sliceUnionCst.getNumDimAndSymbolVars() == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  816:  std::vector<std::pair<Operation *, Operation *>> dependentOpPairs;
call    0 never executed
    #####:  817:  for (auto *i : opsA) {
branch  0 never executed
branch  1 never executed
    #####:  818:    MemRefAccess srcAccess(i);
call    0 never executed
    #####:  819:    for (auto *j : opsB) {
branch  0 never executed
branch  1 never executed
    #####:  820:      MemRefAccess dstAccess(j);
call    0 never executed
    #####:  821:      if (srcAccess.memref != dstAccess.memref)
branch  0 never executed
branch  1 never executed
    #####:  822:        continue;
        -:  823:      // Check if 'loopDepth' exceeds nesting depth of src/dst ops.
    #####:  824:      if ((!isBackwardSlice && loopDepth > getNestingDepth(i)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  825:          (isBackwardSlice && loopDepth > getNestingDepth(j))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  826:        LLVM_DEBUG(llvm::dbgs() << "Invalid loop depth\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  827:        return SliceComputationResult::GenericFailure;
        -:  828:      }
        -:  829:
    #####:  830:      bool readReadAccesses = isa<AffineReadOpInterface>(srcAccess.opInst) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  831:                              isa<AffineReadOpInterface>(dstAccess.opInst);
call    0 never executed
    #####:  832:      FlatAffineValueConstraints dependenceConstraints;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  833:      // Check dependence between 'srcAccess' and 'dstAccess'.
    #####:  834:      DependenceResult result = checkMemrefAccessDependence(
        -:  835:          srcAccess, dstAccess, /*loopDepth=*/numCommonLoops + 1,
        -:  836:          &dependenceConstraints, /*dependenceComponents=*/nullptr,
    #####:  837:          /*allowRAR=*/readReadAccesses);
call    0 never executed
    #####:  838:      if (result.value == DependenceResult::Failure) {
branch  0 never executed
branch  1 never executed
    #####:  839:        LLVM_DEBUG(llvm::dbgs() << "Dependence check failed\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  840:        return SliceComputationResult::GenericFailure;
        -:  841:      }
    #####:  842:      if (result.value == DependenceResult::NoDependence)
branch  0 never executed
branch  1 never executed
    #####:  843:        continue;
call    0 never executed
    #####:  844:      dependentOpPairs.emplace_back(i, j);
call    0 never executed
        -:  845:
        -:  846:      // Compute slice bounds for 'srcAccess' and 'dstAccess'.
    #####:  847:      ComputationSliceState tmpSliceState;
call    0 never executed
call    1 never executed
    #####:  848:      mlir::getComputationSliceState(i, j, &dependenceConstraints, loopDepth,
call    0 never executed
        -:  849:                                     isBackwardSlice, &tmpSliceState);
        -:  850:
    #####:  851:      if (sliceUnionCst.getNumDimAndSymbolVars() == 0) {
branch  0 never executed
branch  1 never executed
        -:  852:        // Initialize 'sliceUnionCst' with the bounds computed in previous step.
    #####:  853:        if (failed(tmpSliceState.getAsConstraints(&sliceUnionCst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:          LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  855:                     << "Unable to compute slice bound constraints\n");
    #####:  856:          return SliceComputationResult::GenericFailure;
        -:  857:        }
    #####:  858:        assert(sliceUnionCst.getNumDimAndSymbolVars() > 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  859:        continue;
call    0 never executed
        -:  860:      }
        -:  861:
        -:  862:      // Compute constraints for 'tmpSliceState' in 'tmpSliceCst'.
    #####:  863:      FlatAffineValueConstraints tmpSliceCst;
call    0 never executed
call    1 never executed
    #####:  864:      if (failed(tmpSliceState.getAsConstraints(&tmpSliceCst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  865:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  866:                   << "Unable to compute slice bound constraints\n");
    #####:  867:        return SliceComputationResult::GenericFailure;
        -:  868:      }
        -:  869:
        -:  870:      // Align coordinate spaces of 'sliceUnionCst' and 'tmpSliceCst' if needed.
    #####:  871:      if (!sliceUnionCst.areVarsAlignedWithOther(tmpSliceCst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  872:
        -:  873:        // Pre-constraint var alignment: record loop IVs used in each constraint
        -:  874:        // system.
    #####:  875:        SmallPtrSet<Value, 8> sliceUnionIVs;
call    0 never executed
    #####:  876:        for (unsigned k = 0, l = sliceUnionCst.getNumDimVars(); k < l; ++k)
branch  0 never executed
branch  1 never executed
    #####:  877:          sliceUnionIVs.insert(sliceUnionCst.getValue(k));
call    0 never executed
call    1 never executed
    #####:  878:        SmallPtrSet<Value, 8> tmpSliceIVs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  879:        for (unsigned k = 0, l = tmpSliceCst.getNumDimVars(); k < l; ++k)
branch  0 never executed
branch  1 never executed
    #####:  880:          tmpSliceIVs.insert(tmpSliceCst.getValue(k));
call    0 never executed
call    1 never executed
        -:  881:
    #####:  882:        sliceUnionCst.mergeAndAlignVarsWithOther(/*offset=*/0, &tmpSliceCst);
call    0 never executed
        -:  883:
        -:  884:        // Post-constraint var alignment: add loop IV bounds missing after
        -:  885:        // var alignment to constraint systems. This can occur if one constraint
        -:  886:        // system uses an loop IV that is not used by the other. The call
        -:  887:        // to unionBoundingBox below expects constraints for each Loop IV, even
        -:  888:        // if they are the unsliced full loop bounds added here.
    #####:  889:        if (failed(addMissingLoopIVBounds(sliceUnionIVs, &sliceUnionCst)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  890:          return SliceComputationResult::GenericFailure;
    #####:  891:        if (failed(addMissingLoopIVBounds(tmpSliceIVs, &tmpSliceCst)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  892:          return SliceComputationResult::GenericFailure;
        -:  893:      }
        -:  894:      // Compute union bounding box of 'sliceUnionCst' and 'tmpSliceCst'.
    #####:  895:      if (sliceUnionCst.getNumLocalVars() > 0 ||
branch  0 never executed
branch  1 never executed
    #####:  896:          tmpSliceCst.getNumLocalVars() > 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  897:          failed(sliceUnionCst.unionBoundingBox(tmpSliceCst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  899:                   << "Unable to compute union bounding box of slice bounds\n");
    #####:  900:        return SliceComputationResult::GenericFailure;
        -:  901:      }
        -:  902:    }
        -:  903:  }
        -:  904:
        -:  905:  // Empty union.
    #####:  906:  if (sliceUnionCst.getNumDimAndSymbolVars() == 0)
branch  0 never executed
branch  1 never executed
    #####:  907:    return SliceComputationResult::GenericFailure;
        -:  908:
        -:  909:  // Gather loops surrounding ops from loop nest where slice will be inserted.
    #####:  910:  SmallVector<Operation *, 4> ops;
branch  0 never executed
branch  1 never executed
    #####:  911:  for (auto &dep : dependentOpPairs) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  912:    ops.push_back(isBackwardSlice ? dep.second : dep.first);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  913:  }
    #####:  914:  SmallVector<AffineForOp, 4> surroundingLoops;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  915:  unsigned innermostCommonLoopDepth =
call    0 never executed
    #####:  916:      getInnermostCommonLoopDepth(ops, &surroundingLoops);
call    0 never executed
    #####:  917:  if (loopDepth > innermostCommonLoopDepth) {
branch  0 never executed
branch  1 never executed
    #####:  918:    LLVM_DEBUG(llvm::dbgs() << "Exceeds max loop depth\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  919:    return SliceComputationResult::GenericFailure;
        -:  920:  }
        -:  921:
        -:  922:  // Store 'numSliceLoopIVs' before converting dst loop IVs to dims.
    #####:  923:  unsigned numSliceLoopIVs = sliceUnionCst.getNumDimVars();
call    0 never executed
        -:  924:
        -:  925:  // Convert any dst loop IVs which are symbol variables to dim variables.
    #####:  926:  sliceUnionCst.convertLoopIVSymbolsToDims();
call    0 never executed
    #####:  927:  sliceUnion->clearBounds();
call    0 never executed
    #####:  928:  sliceUnion->lbs.resize(numSliceLoopIVs, AffineMap());
call    0 never executed
    #####:  929:  sliceUnion->ubs.resize(numSliceLoopIVs, AffineMap());
call    0 never executed
        -:  930:
        -:  931:  // Get slice bounds from slice union constraints 'sliceUnionCst'.
    #####:  932:  sliceUnionCst.getSliceBounds(/*offset=*/0, numSliceLoopIVs,
call    0 never executed
    #####:  933:                               opsA[0]->getContext(), &sliceUnion->lbs,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  934:                               &sliceUnion->ubs);
        -:  935:
        -:  936:  // Add slice bound operands of union.
    #####:  937:  SmallVector<Value, 4> sliceBoundOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:  sliceUnionCst.getValues(numSliceLoopIVs,
call    0 never executed
        -:  939:                          sliceUnionCst.getNumDimAndSymbolVars(),
        -:  940:                          &sliceBoundOperands);
        -:  941:
        -:  942:  // Copy src loop IVs from 'sliceUnionCst' to 'sliceUnion'.
    #####:  943:  sliceUnion->ivs.clear();
call    0 never executed
    #####:  944:  sliceUnionCst.getValues(0, numSliceLoopIVs, &sliceUnion->ivs);
call    0 never executed
        -:  945:
        -:  946:  // Set loop nest insertion point to block start at 'loopDepth'.
    #####:  947:  sliceUnion->insertPoint =
branch  0 never executed
branch  1 never executed
        -:  948:      isBackwardSlice
    #####:  949:          ? surroundingLoops[loopDepth - 1].getBody()->begin()
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  950:          : std::prev(surroundingLoops[loopDepth - 1].getBody()->end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  951:
        -:  952:  // Give each bound its own copy of 'sliceBoundOperands' for subsequent
        -:  953:  // canonicalization.
    #####:  954:  sliceUnion->lbOperands.resize(numSliceLoopIVs, sliceBoundOperands);
call    0 never executed
    #####:  955:  sliceUnion->ubOperands.resize(numSliceLoopIVs, sliceBoundOperands);
call    0 never executed
        -:  956:
        -:  957:  // Check if the slice computed is valid. Return success only if it is verified
        -:  958:  // that the slice is valid, otherwise return appropriate failure status.
    #####:  959:  Optional<bool> isSliceValid = sliceUnion->isSliceValid();
call    0 never executed
    #####:  960:  if (!isSliceValid) {
branch  0 never executed
branch  1 never executed
    #####:  961:    LLVM_DEBUG(llvm::dbgs() << "Cannot determine if the slice is valid\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  962:    return SliceComputationResult::GenericFailure;
        -:  963:  }
    #####:  964:  if (!*isSliceValid)
branch  0 never executed
branch  1 never executed
    #####:  965:    return SliceComputationResult::IncorrectSliceFailure;
        -:  966:
    #####:  967:  return SliceComputationResult::Success;
        -:  968:}
        -:  969:
        -:  970:// TODO: extend this to handle multiple result maps.
function _ZL18getConstDifferenceN4mlir9AffineMapES0_ called 0 returned 0% blocks executed 0%
    #####:  971:static Optional<uint64_t> getConstDifference(AffineMap lbMap, AffineMap ubMap) {
    #####:  972:  assert(lbMap.getNumResults() == 1 && "expected single result bound map");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  973:  assert(ubMap.getNumResults() == 1 && "expected single result bound map");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  974:  assert(lbMap.getNumDims() == ubMap.getNumDims());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  975:  assert(lbMap.getNumSymbols() == ubMap.getNumSymbols());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  976:  AffineExpr lbExpr(lbMap.getResult(0));
call    0 never executed
    #####:  977:  AffineExpr ubExpr(ubMap.getResult(0));
call    0 never executed
    #####:  978:  auto loopSpanExpr = simplifyAffineExpr(ubExpr - lbExpr, lbMap.getNumDims(),
    #####:  979:                                         lbMap.getNumSymbols());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  980:  auto cExpr = loopSpanExpr.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####:  981:  if (!cExpr)
branch  0 never executed
branch  1 never executed
    #####:  982:    return None;
    #####:  983:  return cExpr.getValue();
call    0 never executed
        -:  984:}
        -:  985:
        -:  986:// Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop
        -:  987:// nest surrounding represented by slice loop bounds in 'slice'. Returns true
        -:  988:// on success, false otherwise (if a non-constant trip count was encountered).
        -:  989:// TODO: Make this work with non-unit step loops.
function _ZN4mlir22buildSliceTripCountMapERKNS_21ComputationSliceStateEPN4llvm13SmallDenseMapIPNS_9OperationEmLj8ENS3_12DenseMapInfoIS6_vEENS3_6detail12DenseMapPairIS6_mEEEE called 0 returned 0% blocks executed 0%
    #####:  990:bool mlir::buildSliceTripCountMap(
        -:  991:    const ComputationSliceState &slice,
        -:  992:    llvm::SmallDenseMap<Operation *, uint64_t, 8> *tripCountMap) {
    #####:  993:  unsigned numSrcLoopIVs = slice.ivs.size();
        -:  994:  // Populate map from AffineForOp -> trip count
    #####:  995:  for (unsigned i = 0; i < numSrcLoopIVs; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  996:    AffineForOp forOp = getForInductionVarOwner(slice.ivs[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  997:    auto *op = forOp.getOperation();
branch  0 never executed
branch  1 never executed
    #####:  998:    AffineMap lbMap = slice.lbs[i];
branch  0 never executed
branch  1 never executed
    #####:  999:    AffineMap ubMap = slice.ubs[i];
branch  0 never executed
branch  1 never executed
        -: 1000:    // If lower or upper bound maps are null or provide no results, it implies
        -: 1001:    // that source loop was not at all sliced, and the entire loop will be a
        -: 1002:    // part of the slice.
    #####: 1003:    if (!lbMap || lbMap.getNumResults() == 0 || !ubMap ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1004:        ubMap.getNumResults() == 0) {
call    0 never executed
        -: 1005:      // The iteration of src loop IV 'i' was not sliced. Use full loop bounds.
    #####: 1006:      if (forOp.hasConstantLowerBound() && forOp.hasConstantUpperBound()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1007:        (*tripCountMap)[op] =
    #####: 1008:            forOp.getConstantUpperBound() - forOp.getConstantLowerBound();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1009:        continue;
        -: 1010:      }
    #####: 1011:      Optional<uint64_t> maybeConstTripCount = getConstantTripCount(forOp);
call    0 never executed
    #####: 1012:      if (maybeConstTripCount.has_value()) {
branch  0 never executed
branch  1 never executed
    #####: 1013:        (*tripCountMap)[op] = maybeConstTripCount.value();
call    0 never executed
    #####: 1014:        continue;
        -: 1015:      }
    #####: 1016:      return false;
        -: 1017:    }
    #####: 1018:    Optional<uint64_t> tripCount = getConstDifference(lbMap, ubMap);
call    0 never executed
        -: 1019:    // Slice bounds are created with a constant ub - lb difference.
    #####: 1020:    if (!tripCount.has_value())
branch  0 never executed
branch  1 never executed
        -: 1021:      return false;
    #####: 1022:    (*tripCountMap)[op] = tripCount.value();
call    0 never executed
        -: 1023:  }
        -: 1024:  return true;
        -: 1025:}
        -: 1026:
        -: 1027:// Return the number of iterations in the given slice.
function _ZN4mlir22getSliceIterationCountERKN4llvm13SmallDenseMapIPNS_9OperationEmLj8ENS0_12DenseMapInfoIS3_vEENS0_6detail12DenseMapPairIS3_mEEEE called 0 returned 0% blocks executed 0%
    #####: 1028:uint64_t mlir::getSliceIterationCount(
        -: 1029:    const llvm::SmallDenseMap<Operation *, uint64_t, 8> &sliceTripCountMap) {
    #####: 1030:  uint64_t iterCount = 1;
    #####: 1031:  for (const auto &count : sliceTripCountMap) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1032:    iterCount *= count.second;
call    0 never executed
        -: 1033:  }
    #####: 1034:  return iterCount;
        -: 1035:}
        -: 1036:
        -: 1037:const char *const kSliceFusionBarrierAttrName = "slice_fusion_barrier";
        -: 1038:// Computes slice bounds by projecting out any loop IVs from
        -: 1039:// 'dependenceConstraints' at depth greater than 'loopDepth', and computes slice
        -: 1040:// bounds in 'sliceState' which represent the one loop nest's IVs in terms of
        -: 1041:// the other loop nest's IVs, symbols and constants (using 'isBackwardsSlice').
function _ZN4mlir24getComputationSliceStateEPNS_9OperationES1_PNS_26FlatAffineValueConstraintsEjbPNS_21ComputationSliceStateE called 0 returned 0% blocks executed 0%
    #####: 1042:void mlir::getComputationSliceState(
        -: 1043:    Operation *depSourceOp, Operation *depSinkOp,
        -: 1044:    FlatAffineValueConstraints *dependenceConstraints, unsigned loopDepth,
        -: 1045:    bool isBackwardSlice, ComputationSliceState *sliceState) {
        -: 1046:  // Get loop nest surrounding src operation.
    #####: 1047:  SmallVector<AffineForOp, 4> srcLoopIVs;
call    0 never executed
    #####: 1048:  getLoopIVs(*depSourceOp, &srcLoopIVs);
call    0 never executed
    #####: 1049:  unsigned numSrcLoopIVs = srcLoopIVs.size();
call    0 never executed
        -: 1050:
        -: 1051:  // Get loop nest surrounding dst operation.
    #####: 1052:  SmallVector<AffineForOp, 4> dstLoopIVs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1053:  getLoopIVs(*depSinkOp, &dstLoopIVs);
call    0 never executed
    #####: 1054:  unsigned numDstLoopIVs = dstLoopIVs.size();
branch  0 never executed
branch  1 never executed
        -: 1055:
    #####: 1056:  assert((!isBackwardSlice && loopDepth <= numSrcLoopIVs) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 1057:         (isBackwardSlice && loopDepth <= numDstLoopIVs));
        -: 1058:
        -: 1059:  // Project out dimensions other than those up to 'loopDepth'.
    #####: 1060:  unsigned pos = isBackwardSlice ? numSrcLoopIVs + loopDepth : loopDepth;
branch  0 never executed
branch  1 never executed
    #####: 1061:  unsigned num =
    #####: 1062:      isBackwardSlice ? numDstLoopIVs - loopDepth : numSrcLoopIVs - loopDepth;
branch  0 never executed
branch  1 never executed
    #####: 1063:  dependenceConstraints->projectOut(pos, num);
call    0 never executed
        -: 1064:
        -: 1065:  // Add slice loop IV values to 'sliceState'.
    #####: 1066:  unsigned offset = isBackwardSlice ? 0 : loopDepth;
branch  0 never executed
branch  1 never executed
    #####: 1067:  unsigned numSliceLoopIVs = isBackwardSlice ? numSrcLoopIVs : numDstLoopIVs;
branch  0 never executed
branch  1 never executed
    #####: 1068:  dependenceConstraints->getValues(offset, offset + numSliceLoopIVs,
call    0 never executed
        -: 1069:                                   &sliceState->ivs);
        -: 1070:
        -: 1071:  // Set up lower/upper bound affine maps for the slice.
    #####: 1072:  sliceState->lbs.resize(numSliceLoopIVs, AffineMap());
call    0 never executed
    #####: 1073:  sliceState->ubs.resize(numSliceLoopIVs, AffineMap());
call    0 never executed
        -: 1074:
        -: 1075:  // Get bounds for slice IVs in terms of other IVs, symbols, and constants.
    #####: 1076:  dependenceConstraints->getSliceBounds(offset, numSliceLoopIVs,
call    0 never executed
call    1 never executed
        -: 1077:                                        depSourceOp->getContext(),
        -: 1078:                                        &sliceState->lbs, &sliceState->ubs);
        -: 1079:
        -: 1080:  // Set up bound operands for the slice's lower and upper bounds.
    #####: 1081:  SmallVector<Value, 4> sliceBoundOperands;
branch  0 never executed
branch  1 never executed
    #####: 1082:  unsigned numDimsAndSymbols = dependenceConstraints->getNumDimAndSymbolVars();
    #####: 1083:  for (unsigned i = 0; i < numDimsAndSymbols; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1084:    if (i < offset || i >= offset + numSliceLoopIVs) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1085:      sliceBoundOperands.push_back(dependenceConstraints->getValue(i));
call    0 never executed
call    1 never executed
        -: 1086:    }
        -: 1087:  }
        -: 1088:
        -: 1089:  // Give each bound its own copy of 'sliceBoundOperands' for subsequent
        -: 1090:  // canonicalization.
    #####: 1091:  sliceState->lbOperands.resize(numSliceLoopIVs, sliceBoundOperands);
call    0 never executed
    #####: 1092:  sliceState->ubOperands.resize(numSliceLoopIVs, sliceBoundOperands);
call    0 never executed
        -: 1093:
        -: 1094:  // Set destination loop nest insertion point to block start at 'dstLoopDepth'.
    #####: 1095:  sliceState->insertPoint =
branch  0 never executed
branch  1 never executed
    #####: 1096:      isBackwardSlice ? dstLoopIVs[loopDepth - 1].getBody()->begin()
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1097:                      : std::prev(srcLoopIVs[loopDepth - 1].getBody()->end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1098:
    #####: 1099:  llvm::SmallDenseSet<Value, 8> sequentialLoops;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1100:  if (isa<AffineReadOpInterface>(depSourceOp) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1101:      isa<AffineReadOpInterface>(depSinkOp)) {
call    0 never executed
        -: 1102:    // For read-read access pairs, clear any slice bounds on sequential loops.
        -: 1103:    // Get sequential loops in loop nest rooted at 'srcLoopIVs[0]'.
    #####: 1104:    getSequentialLoops(isBackwardSlice ? srcLoopIVs[0] : dstLoopIVs[0],
branch  0 never executed
branch  1 never executed
        -: 1105:                       &sequentialLoops);
        -: 1106:  }
function _ZZN4mlir24getComputationSliceStateEPNS_9OperationES1_PNS_26FlatAffineValueConstraintsEjbPNS_21ComputationSliceStateEENKUljE_clEj called 0 returned 0% blocks executed 0%
    #####: 1107:  auto getSliceLoop = [&](unsigned i) {
    #####: 1108:    return isBackwardSlice ? srcLoopIVs[i] : dstLoopIVs[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1109:  };
    #####: 1110:  auto isInnermostInsertion = [&]() {
    #####: 1111:    return (isBackwardSlice ? loopDepth >= srcLoopIVs.size()
branch  0 never executed
branch  1 never executed
    #####: 1112:                            : loopDepth >= dstLoopIVs.size());
    #####: 1113:  };
    #####: 1114:  llvm::SmallDenseMap<Operation *, uint64_t, 8> sliceTripCountMap;
call    0 never executed
call    1 never executed
function _ZZN4mlir24getComputationSliceStateEPNS_9OperationES1_PNS_26FlatAffineValueConstraintsEjbPNS_21ComputationSliceStateEENKUlvE1_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1115:  auto srcIsUnitSlice = [&]() {
    #####: 1116:    return (buildSliceTripCountMap(*sliceState, &sliceTripCountMap) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1117:            (getSliceIterationCount(sliceTripCountMap) == 1));
call    0 never executed
    #####: 1118:  };
        -: 1119:  // Clear all sliced loop bounds beginning at the first sequential loop, or
        -: 1120:  // first loop with a slice fusion barrier attribute..
        -: 1121:
    #####: 1122:  for (unsigned i = 0; i < numSliceLoopIVs; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1123:    Value iv = getSliceLoop(i).getInductionVar();
call    0 never executed
call    1 never executed
    #####: 1124:    if (sequentialLoops.count(iv) == 0 &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1125:        getSliceLoop(i)->getAttr(kSliceFusionBarrierAttrName) == nullptr)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1126:      continue;
        -: 1127:    // Skip reset of bounds of reduction loop inserted in the destination loop
        -: 1128:    // that meets the following conditions:
        -: 1129:    //    1. Slice is  single trip count.
        -: 1130:    //    2. Loop bounds of the source and destination match.
        -: 1131:    //    3. Is being inserted at the innermost insertion point.
    #####: 1132:    Optional<bool> isMaximal = sliceState->isMaximal();
call    0 never executed
    #####: 1133:    if (isLoopParallelAndContainsReduction(getSliceLoop(i)) &&
call    0 never executed
call    1 never executed
    #####: 1134:        isInnermostInsertion() && srcIsUnitSlice() && isMaximal && *isMaximal)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1135:      continue;
    #####: 1136:    for (unsigned j = i; j < numSliceLoopIVs; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 1137:      sliceState->lbs[j] = AffineMap();
branch  0 never executed
branch  1 never executed
    #####: 1138:      sliceState->ubs[j] = AffineMap();
branch  0 never executed
branch  1 never executed
        -: 1139:    }
    #####: 1140:    break;
        -: 1141:  }
    #####: 1142:}
        -: 1143:
        -: 1144:/// Creates a computation slice of the loop nest surrounding 'srcOpInst',
        -: 1145:/// updates the slice loop bounds with any non-null bound maps specified in
        -: 1146:/// 'sliceState', and inserts this slice into the loop nest surrounding
        -: 1147:/// 'dstOpInst' at loop depth 'dstLoopDepth'.
        -: 1148:// TODO: extend the slicing utility to compute slices that
        -: 1149:// aren't necessarily a one-to-one relation b/w the source and destination. The
        -: 1150:// relation between the source and destination could be many-to-many in general.
        -: 1151:// TODO: the slice computation is incorrect in the cases
        -: 1152:// where the dependence from the source to the destination does not cover the
        -: 1153:// entire destination index set. Subtract out the dependent destination
        -: 1154:// iterations from destination index set and check for emptiness --- this is one
        -: 1155:// solution.
        -: 1156:AffineForOp
function _ZN4mlir30insertBackwardComputationSliceEPNS_9OperationES1_jPNS_21ComputationSliceStateE called 0 returned 0% blocks executed 0%
    #####: 1157:mlir::insertBackwardComputationSlice(Operation *srcOpInst, Operation *dstOpInst,
        -: 1158:                                     unsigned dstLoopDepth,
        -: 1159:                                     ComputationSliceState *sliceState) {
        -: 1160:  // Get loop nest surrounding src operation.
    #####: 1161:  SmallVector<AffineForOp, 4> srcLoopIVs;
call    0 never executed
    #####: 1162:  getLoopIVs(*srcOpInst, &srcLoopIVs);
call    0 never executed
    #####: 1163:  unsigned numSrcLoopIVs = srcLoopIVs.size();
call    0 never executed
        -: 1164:
        -: 1165:  // Get loop nest surrounding dst operation.
    #####: 1166:  SmallVector<AffineForOp, 4> dstLoopIVs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1167:  getLoopIVs(*dstOpInst, &dstLoopIVs);
call    0 never executed
    #####: 1168:  unsigned dstLoopIVsSize = dstLoopIVs.size();
branch  0 never executed
branch  1 never executed
    #####: 1169:  if (dstLoopDepth > dstLoopIVsSize) {
branch  0 never executed
branch  1 never executed
    #####: 1170:    dstOpInst->emitError("invalid destination loop depth");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1171:    return AffineForOp();
        -: 1172:  }
        -: 1173:
        -: 1174:  // Find the op block positions of 'srcOpInst' within 'srcLoopIVs'.
    #####: 1175:  SmallVector<unsigned, 4> positions;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1176:  // TODO: This code is incorrect since srcLoopIVs can be 0-d.
    #####: 1177:  findInstPosition(srcOpInst, srcLoopIVs[0]->getBlock(), &positions);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1178:
        -: 1179:  // Clone src loop nest and insert it a the beginning of the operation block
        -: 1180:  // of the loop at 'dstLoopDepth' in 'dstLoopIVs'.
    #####: 1181:  auto dstAffineForOp = dstLoopIVs[dstLoopDepth - 1];
branch  0 never executed
branch  1 never executed
    #####: 1182:  OpBuilder b(dstAffineForOp.getBody(), dstAffineForOp.getBody()->begin());
call    0 never executed
call    1 never executed
    #####: 1183:  auto sliceLoopNest =
branch  0 never executed
branch  1 never executed
    #####: 1184:      cast<AffineForOp>(b.clone(*srcLoopIVs[0].getOperation()));
call    0 never executed
call    1 never executed
        -: 1185:
    #####: 1186:  Operation *sliceInst =
    #####: 1187:      getInstAtPosition(positions, /*level=*/0, sliceLoopNest.getBody());
call    0 never executed
call    1 never executed
        -: 1188:  // Get loop nest surrounding 'sliceInst'.
    #####: 1189:  SmallVector<AffineForOp, 4> sliceSurroundingLoops;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1190:  getLoopIVs(*sliceInst, &sliceSurroundingLoops);
call    0 never executed
        -: 1191:
        -: 1192:  // Sanity check.
    #####: 1193:  unsigned sliceSurroundingLoopsSize = sliceSurroundingLoops.size();
branch  0 never executed
branch  1 never executed
    #####: 1194:  (void)sliceSurroundingLoopsSize;
    #####: 1195:  assert(dstLoopDepth + numSrcLoopIVs >= sliceSurroundingLoopsSize);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1196:  unsigned sliceLoopLimit = dstLoopDepth + numSrcLoopIVs;
        -: 1197:  (void)sliceLoopLimit;
        -: 1198:  assert(sliceLoopLimit >= sliceSurroundingLoopsSize);
        -: 1199:
        -: 1200:  // Update loop bounds for loops in 'sliceLoopNest'.
    #####: 1201:  for (unsigned i = 0; i < numSrcLoopIVs; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1202:    auto forOp = sliceSurroundingLoops[dstLoopDepth + i];
branch  0 never executed
branch  1 never executed
    #####: 1203:    if (AffineMap lbMap = sliceState->lbs[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1204:      forOp.setLowerBound(sliceState->lbOperands[i], lbMap);
call    0 never executed
call    1 never executed
    #####: 1205:    if (AffineMap ubMap = sliceState->ubs[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1206:      forOp.setUpperBound(sliceState->ubOperands[i], ubMap);
call    0 never executed
call    1 never executed
        -: 1207:  }
    #####: 1208:  return sliceLoopNest;
branch  0 never executed
branch  1 never executed
        -: 1209:}
        -: 1210:
        -: 1211:// Constructs  MemRefAccess populating it with the memref, its indices and
        -: 1212:// opinst from 'loadOrStoreOpInst'.
function _ZN4mlir12MemRefAccessC2EPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1213:MemRefAccess::MemRefAccess(Operation *loadOrStoreOpInst) {
call    0 never executed
    #####: 1214:  if (auto loadOp = dyn_cast<AffineReadOpInterface>(loadOrStoreOpInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1215:    memref = loadOp.getMemRef();
call    0 never executed
    #####: 1216:    opInst = loadOrStoreOpInst;
    #####: 1217:    llvm::append_range(indices, loadOp.getMapOperands());
call    0 never executed
call    1 never executed
        -: 1218:  } else {
    #####: 1219:    assert(isa<AffineWriteOpInterface>(loadOrStoreOpInst) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1220:           "Affine read/write op expected");
    #####: 1221:    auto storeOp = cast<AffineWriteOpInterface>(loadOrStoreOpInst);
call    0 never executed
    #####: 1222:    opInst = loadOrStoreOpInst;
    #####: 1223:    memref = storeOp.getMemRef();
call    0 never executed
    #####: 1224:    llvm::append_range(indices, storeOp.getMapOperands());
call    0 never executed
call    1 never executed
        -: 1225:  }
    #####: 1226:}
        -: 1227:
function _ZNK4mlir12MemRefAccess7getRankEv called 0 returned 0% blocks executed 0%
    #####: 1228:unsigned MemRefAccess::getRank() const {
    #####: 1229:  return memref.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
        -: 1230:}
        -: 1231:
function _ZNK4mlir12MemRefAccess7isStoreEv called 0 returned 0% blocks executed 0%
    #####: 1232:bool MemRefAccess::isStore() const {
    #####: 1233:  return isa<AffineWriteOpInterface>(opInst);
call    0 never executed
call    1 never executed
        -: 1234:}
        -: 1235:
        -: 1236:/// Returns the nesting depth of this statement, i.e., the number of loops
        -: 1237:/// surrounding this statement.
function _ZN4mlir15getNestingDepthEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1238:unsigned mlir::getNestingDepth(Operation *op) {
    #####: 1239:  Operation *currOp = op;
    #####: 1240:  unsigned depth = 0;
    #####: 1241:  while ((currOp = currOp->getParentOp())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1242:    if (isa<AffineForOp>(currOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1243:      depth++;
        -: 1244:  }
    #####: 1245:  return depth;
        -: 1246:}
        -: 1247:
        -: 1248:/// Equal if both affine accesses are provably equivalent (at compile
        -: 1249:/// time) when considering the memref, the affine maps and their respective
        -: 1250:/// operands. The equality of access functions + operands is checked by
        -: 1251:/// subtracting fully composed value maps, and then simplifying the difference
        -: 1252:/// using the expression flattener.
        -: 1253:/// TODO: this does not account for aliasing of memrefs.
function _ZNK4mlir12MemRefAccesseqERKS0_ called 0 returned 0% blocks executed 0%
    #####: 1254:bool MemRefAccess::operator==(const MemRefAccess &rhs) const {
    #####: 1255:  if (memref != rhs.memref)
branch  0 never executed
branch  1 never executed
        -: 1256:    return false;
        -: 1257:
    #####: 1258:  AffineValueMap diff, thisMap, rhsMap;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1259:  getAccessMap(&thisMap);
call    0 never executed
    #####: 1260:  rhs.getAccessMap(&rhsMap);
call    0 never executed
    #####: 1261:  AffineValueMap::difference(thisMap, rhsMap, &diff);
call    0 never executed
    #####: 1262:  return llvm::all_of(diff.getAffineMap().getResults(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1263:                      [](AffineExpr e) { return e == 0; });
        -: 1264:}
        -: 1265:
        -: 1266:/// Returns the number of surrounding loops common to 'loopsA' and 'loopsB',
        -: 1267:/// where each lists loops from outer-most to inner-most in loop nest.
function _ZN4mlir28getNumCommonSurroundingLoopsERNS_9OperationES1_ called 0 returned 0% blocks executed 0%
    #####: 1268:unsigned mlir::getNumCommonSurroundingLoops(Operation &a, Operation &b) {
    #####: 1269:  SmallVector<AffineForOp, 4> loopsA, loopsB;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1270:  getLoopIVs(a, &loopsA);
call    0 never executed
    #####: 1271:  getLoopIVs(b, &loopsB);
call    0 never executed
        -: 1272:
    #####: 1273:  unsigned minNumLoops = std::min(loopsA.size(), loopsB.size());
branch  0 never executed
branch  1 never executed
    #####: 1274:  unsigned numCommonLoops = 0;
    #####: 1275:  for (unsigned i = 0; i < minNumLoops; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1276:    if (loopsA[i].getOperation() != loopsB[i].getOperation())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1277:      break;
    #####: 1278:    ++numCommonLoops;
        -: 1279:  }
    #####: 1280:  return numCommonLoops;
branch  0 never executed
branch  1 never executed
        -: 1281:}
        -: 1282:
        -: 1283:static Optional<int64_t> getMemoryFootprintBytes(Block &block,
        -: 1284:                                                 Block::iterator start,
        -: 1285:                                                 Block::iterator end,
        -: 1286:                                                 int memorySpace) {
        -: 1287:  SmallDenseMap<Value, std::unique_ptr<MemRefRegion>, 4> regions;
        -: 1288:
        -: 1289:  // Walk this 'affine.for' operation to gather all memory regions.
function _ZZL23getMemoryFootprintBytesRN4mlir5BlockEN4llvm14ilist_iteratorINS2_12ilist_detail12node_optionsINS_9OperationELb1ELb0EvEELb0ELb0EEES8_iENKUlPS6_E_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1290:  auto result = block.walk(start, end, [&](Operation *opInst) -> WalkResult {
    #####: 1291:    if (!isa<AffineReadOpInterface, AffineWriteOpInterface>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1292:      // Neither load nor a store op.
    #####: 1293:      return WalkResult::advance();
        -: 1294:    }
        -: 1295:
        -: 1296:    // Compute the memref region symbolic in any IVs enclosing this block.
    #####: 1297:    auto region = std::make_unique<MemRefRegion>(opInst->getLoc());
call    0 never executed
    #####: 1298:    if (failed(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1299:            region->compute(opInst,
    #####: 1300:                            /*loopDepth=*/getNestingDepth(&*block.begin())))) {
call    0 never executed
    #####: 1301:      return opInst->emitError("error obtaining memory region\n");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1302:    }
        -: 1303:
    #####: 1304:    auto it = regions.find(region->memref);
call    0 never executed
call    1 never executed
    #####: 1305:    if (it == regions.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1306:      regions[region->memref] = std::move(region);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1307:    } else if (failed(it->second->unionBoundingBox(*region))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1308:      return opInst->emitWarning(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1309:          "getMemoryFootprintBytes: unable to perform a union on a memory "
    #####: 1310:          "region");
call    0 never executed
        -: 1311:    }
    #####: 1312:    return WalkResult::advance();
        -: 1313:  });
        -: 1314:  if (result.wasInterrupted())
        -: 1315:    return None;
        -: 1316:
        -: 1317:  int64_t totalSizeInBytes = 0;
        -: 1318:  for (const auto &region : regions) {
        -: 1319:    Optional<int64_t> size = region.second->getRegionSize();
        -: 1320:    if (!size.has_value())
        -: 1321:      return None;
        -: 1322:    totalSizeInBytes += size.value();
        -: 1323:  }
        -: 1324:  return totalSizeInBytes;
        -: 1325:}
        -: 1326:
function _ZN4mlir23getMemoryFootprintBytesENS_11AffineForOpEi called 0 returned 0% blocks executed 0%
    #####: 1327:Optional<int64_t> mlir::getMemoryFootprintBytes(AffineForOp forOp,
        -: 1328:                                                int memorySpace) {
    #####: 1329:  auto *forInst = forOp.getOperation();
call    0 never executed
    #####: 1330:  return ::getMemoryFootprintBytes(
call    0 never executed
    #####: 1331:      *forInst->getBlock(), Block::iterator(forInst),
    #####: 1332:      std::next(Block::iterator(forInst)), memorySpace);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1333:}
        -: 1334:
        -: 1335:/// Returns whether a loop is parallel and contains a reduction loop.
function _ZN4mlir34isLoopParallelAndContainsReductionENS_11AffineForOpE called 0 returned 0% blocks executed 0%
    #####: 1336:bool mlir::isLoopParallelAndContainsReduction(AffineForOp forOp) {
    #####: 1337:  SmallVector<LoopReduction> reductions;
call    0 never executed
    #####: 1338:  if (!isLoopParallel(forOp, &reductions))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1339:    return false;
    #####: 1340:  return !reductions.empty();
        -: 1341:}
        -: 1342:
        -: 1343:/// Returns in 'sequentialLoops' all sequential loops in loop nest rooted
        -: 1344:/// at 'forOp'.
function _ZN4mlir18getSequentialLoopsENS_11AffineForOpEPN4llvm13SmallDenseSetINS_5ValueELj8ENS1_12DenseMapInfoIS3_vEEEE called 0 returned 0% blocks executed 0%
    #####: 1345:void mlir::getSequentialLoops(AffineForOp forOp,
        -: 1346:                              llvm::SmallDenseSet<Value, 8> *sequentialLoops) {
function _ZZN4mlir18getSequentialLoopsENS_11AffineForOpEPN4llvm13SmallDenseSetINS_5ValueELj8ENS1_12DenseMapInfoIS3_vEEEEENKUlPNS_9OperationEE_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1347:  forOp->walk([&](Operation *op) {
call    0 never executed
call    1 never executed
    #####: 1348:    if (auto innerFor = dyn_cast<AffineForOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1349:      if (!isLoopParallel(innerFor))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1350:        sequentialLoops->insert(innerFor.getInductionVar());
call    0 never executed
call    1 never executed
    #####: 1351:  });
    #####: 1352:}
        -: 1353:
function _ZN4mlir18simplifyIntegerSetENS_10IntegerSetE called 0 returned 0% blocks executed 0%
    #####: 1354:IntegerSet mlir::simplifyIntegerSet(IntegerSet set) {
    #####: 1355:  FlatAffineValueConstraints fac(set);
call    0 never executed
call    1 never executed
    #####: 1356:  if (fac.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1357:    return IntegerSet::getEmptySet(set.getNumDims(), set.getNumSymbols(),
    #####: 1358:                                   set.getContext());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1359:  fac.removeTrivialRedundancy();
call    0 never executed
        -: 1360:
    #####: 1361:  auto simplifiedSet = fac.getAsIntegerSet(set.getContext());
call    0 never executed
call    1 never executed
    #####: 1362:  assert(simplifiedSet && "guaranteed to succeed while roundtripping");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1363:  return simplifiedSet;
        -: 1364:}
