        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/MemRef/IR/MemRefOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/MemRef/IR/CMakeFiles/obj.MLIRMemRefDialect.dir/MemRefOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/MemRef/IR/CMakeFiles/obj.MLIRMemRefDialect.dir/MemRefOps.cpp.gcda
        -:    0:Runs:128628
        -:    1://===----------------------------------------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   10:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   11:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   12:#include "mlir/Dialect/MemRef/Utils/MemRefUtils.h"
        -:   13:#include "mlir/Dialect/Utils/StaticValueUtils.h"
        -:   14:#include "mlir/IR/AffineMap.h"
        -:   15:#include "mlir/IR/Builders.h"
        -:   16:#include "mlir/IR/BuiltinTypes.h"
        -:   17:#include "mlir/IR/Matchers.h"
        -:   18:#include "mlir/IR/PatternMatch.h"
        -:   19:#include "mlir/IR/TypeUtilities.h"
        -:   20:#include "mlir/Interfaces/InferTypeOpInterface.h"
        -:   21:#include "mlir/Interfaces/SideEffectInterfaces.h"
        -:   22:#include "mlir/Interfaces/ViewLikeInterface.h"
        -:   23:#include "llvm/ADT/STLExtras.h"
        -:   24:#include "llvm/ADT/SmallBitVector.h"
        -:   25:
        -:   26:using namespace mlir;
        -:   27:using namespace mlir::memref;
        -:   28:
        -:   29:namespace {
        -:   30:/// Idiomatic saturated operations on offsets, sizes and strides.
        -:   31:namespace saturated_arith {
        -:   32:struct Wrapper {
    #####:   33:  static Wrapper stride(int64_t v) {
    #####:   34:    return (ShapedType::isDynamicStrideOrOffset(v)) ? Wrapper{true, 0}
    #####:   35:                                                    : Wrapper{false, v};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -:   36:  }
    #####:   37:  static Wrapper offset(int64_t v) {
    #####:   38:    return (ShapedType::isDynamicStrideOrOffset(v)) ? Wrapper{true, 0}
    #####:   39:                                                    : Wrapper{false, v};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   40:  }
    #####:   41:  static Wrapper size(int64_t v) {
    #####:   42:    return (ShapedType::isDynamic(v)) ? Wrapper{true, 0} : Wrapper{false, v};
        -:   43:  }
    #####:   44:  int64_t asOffset() {
    #####:   45:    return saturated ? ShapedType::kDynamicStrideOrOffset : v;
        -:   46:  }
    #####:   47:  int64_t asSize() { return saturated ? ShapedType::kDynamicSize : v; }
    #####:   48:  int64_t asStride() {
    #####:   49:    return saturated ? ShapedType::kDynamicStrideOrOffset : v;
        -:   50:  }
    #####:   51:  bool operator==(Wrapper other) {
    #####:   52:    return (saturated && other.saturated) ||
    #####:   53:           (!saturated && !other.saturated && v == other.v);
        -:   54:  }
    #####:   55:  bool operator!=(Wrapper other) { return !(*this == other); }
    #####:   56:  Wrapper operator+(Wrapper other) {
    #####:   57:    if (saturated || other.saturated)
branch  0 never executed
branch  1 never executed
        -:   58:      return Wrapper{true, 0};
    #####:   59:    return Wrapper{false, other.v + v};
        -:   60:  }
    #####:   61:  Wrapper operator*(Wrapper other) {
    #####:   62:    if (saturated || other.saturated)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:   63:      return Wrapper{true, 0};
    #####:   64:    return Wrapper{false, other.v * v};
        -:   65:  }
        -:   66:  bool saturated;
        -:   67:  int64_t v;
        -:   68:};
        -:   69:} // namespace saturated_arith
        -:   70:} // namespace
        -:   71:
        -:   72:/// Materialize a single constant operation from a given attribute value with
        -:   73:/// the desired resultant type.
function _ZN4mlir6memref13MemRefDialect19materializeConstantERNS_9OpBuilderENS_9AttributeENS_4TypeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:   74:Operation *MemRefDialect::materializeConstant(OpBuilder &builder,
        -:   75:                                              Attribute value, Type type,
        -:   76:                                              Location loc) {
    #####:   77:  if (arith::ConstantOp::isBuildableWith(value, type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    return builder.create<arith::ConstantOp>(loc, value, type);
call    0 never executed
        -:   79:  return nullptr;
        -:   80:}
        -:   81:
        -:   82://===----------------------------------------------------------------------===//
        -:   83:// Common canonicalization pattern support logic
        -:   84://===----------------------------------------------------------------------===//
        -:   85:
        -:   86:/// This is a common class used for patterns of the form
        -:   87:/// "someop(memrefcast) -> someop".  It folds the source of any memref.cast
        -:   88:/// into the root operation directly.
function _ZN4mlir6memref14foldMemRefCastEPNS_9OperationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   89:LogicalResult mlir::memref::foldMemRefCast(Operation *op, Value inner) {
    #####:   90:  bool folded = false;
    #####:   91:  for (OpOperand &operand : op->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   92:    auto cast = operand.get().getDefiningOp<CastOp>();
call    0 never executed
    #####:   93:    if (cast && operand.get() != inner &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   94:        !cast.getOperand().getType().isa<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   95:      operand.set(cast.getOperand());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   96:      folded = true;
        -:   97:    }
        -:   98:  }
    #####:   99:  return success(folded);
        -:  100:}
        -:  101:
        -:  102:/// Return an unranked/ranked tensor type for the given unranked/ranked memref
        -:  103:/// type.
function _ZN4mlir6memref27getTensorTypeFromMemRefTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  104:Type mlir::memref::getTensorTypeFromMemRefType(Type type) {
    #####:  105:  if (auto memref = type.dyn_cast<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  106:    return RankedTensorType::get(memref.getShape(), memref.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  107:  if (auto memref = type.dyn_cast<UnrankedMemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:    return UnrankedTensorType::get(memref.getElementType());
call    0 never executed
call    1 never executed
    #####:  109:  return NoneType::get(type.getContext());
call    0 never executed
call    1 never executed
        -:  110:}
        -:  111:
        -:  112://===----------------------------------------------------------------------===//
        -:  113:// AllocOp / AllocaOp
        -:  114://===----------------------------------------------------------------------===//
        -:  115:
function _ZN4mlir6memref7AllocOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  116:void AllocOp::getAsmResultNames(
        -:  117:    function_ref<void(Value, StringRef)> setNameFn) {
    #####:  118:  setNameFn(getResult(), "alloc");
call    0 never executed
    #####:  119:}
        -:  120:
function _ZN4mlir6memref8AllocaOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  121:void AllocaOp::getAsmResultNames(
        -:  122:    function_ref<void(Value, StringRef)> setNameFn) {
    #####:  123:  setNameFn(getResult(), "alloca");
call    0 never executed
    #####:  124:}
        -:  125:
        -:  126:template <typename AllocLikeOp>
    #####:  127:static LogicalResult verifyAllocLikeOp(AllocLikeOp op) {
        -:  128:  static_assert(llvm::is_one_of<AllocLikeOp, AllocOp, AllocaOp>::value,
        -:  129:                "applies to only alloc or alloca");
    #####:  130:  auto memRefType = op.getResult().getType().template dyn_cast<MemRefType>();
    #####:  131:  if (!memRefType)
    #####:  132:    return op.emitOpError("result must be a memref");
        -:  133:
    #####:  134:  if (static_cast<int64_t>(op.getDynamicSizes().size()) !=
        -:  135:      memRefType.getNumDynamicDims())
        -:  136:    return op.emitOpError("dimension operand count does not equal memref "
    #####:  137:                          "dynamic dimension count");
        -:  138:
    #####:  139:  unsigned numSymbols = 0;
    #####:  140:  if (!memRefType.getLayout().isIdentity())
    #####:  141:    numSymbols = memRefType.getLayout().getAffineMap().getNumSymbols();
    #####:  142:  if (op.getSymbolOperands().size() != numSymbols)
        -:  143:    return op.emitOpError("symbol operand count does not equal memref symbol "
        -:  144:                          "count: expected ")
    #####:  145:           << numSymbols << ", got " << op.getSymbolOperands().size();
        -:  146:
    #####:  147:  return success();
        -:  148:}
------------------
_Z17verifyAllocLikeOpIN4mlir6memref8AllocaOpEENS0_13LogicalResultET_:
function _Z17verifyAllocLikeOpIN4mlir6memref8AllocaOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  127:static LogicalResult verifyAllocLikeOp(AllocLikeOp op) {
call    0 never executed
        -:  128:  static_assert(llvm::is_one_of<AllocLikeOp, AllocOp, AllocaOp>::value,
        -:  129:                "applies to only alloc or alloca");
    #####:  130:  auto memRefType = op.getResult().getType().template dyn_cast<MemRefType>();
call    0 never executed
    #####:  131:  if (!memRefType)
branch  0 never executed
branch  1 never executed
    #####:  132:    return op.emitOpError("result must be a memref");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  133:
    #####:  134:  if (static_cast<int64_t>(op.getDynamicSizes().size()) !=
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  135:      memRefType.getNumDynamicDims())
        -:  136:    return op.emitOpError("dimension operand count does not equal memref "
    #####:  137:                          "dynamic dimension count");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  138:
    #####:  139:  unsigned numSymbols = 0;
    #####:  140:  if (!memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  141:    numSymbols = memRefType.getLayout().getAffineMap().getNumSymbols();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  142:  if (op.getSymbolOperands().size() != numSymbols)
branch  0 never executed
branch  1 never executed
        -:  143:    return op.emitOpError("symbol operand count does not equal memref symbol "
        -:  144:                          "count: expected ")
    #####:  145:           << numSymbols << ", got " << op.getSymbolOperands().size();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  146:
    #####:  147:  return success();
        -:  148:}
------------------
_Z17verifyAllocLikeOpIN4mlir6memref7AllocOpEENS0_13LogicalResultET_:
function _Z17verifyAllocLikeOpIN4mlir6memref7AllocOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  127:static LogicalResult verifyAllocLikeOp(AllocLikeOp op) {
call    0 never executed
        -:  128:  static_assert(llvm::is_one_of<AllocLikeOp, AllocOp, AllocaOp>::value,
        -:  129:                "applies to only alloc or alloca");
    #####:  130:  auto memRefType = op.getResult().getType().template dyn_cast<MemRefType>();
call    0 never executed
    #####:  131:  if (!memRefType)
branch  0 never executed
branch  1 never executed
    #####:  132:    return op.emitOpError("result must be a memref");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  133:
    #####:  134:  if (static_cast<int64_t>(op.getDynamicSizes().size()) !=
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  135:      memRefType.getNumDynamicDims())
        -:  136:    return op.emitOpError("dimension operand count does not equal memref "
    #####:  137:                          "dynamic dimension count");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  138:
    #####:  139:  unsigned numSymbols = 0;
    #####:  140:  if (!memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  141:    numSymbols = memRefType.getLayout().getAffineMap().getNumSymbols();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  142:  if (op.getSymbolOperands().size() != numSymbols)
branch  0 never executed
branch  1 never executed
        -:  143:    return op.emitOpError("symbol operand count does not equal memref symbol "
        -:  144:                          "count: expected ")
    #####:  145:           << numSymbols << ", got " << op.getSymbolOperands().size();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  146:
    #####:  147:  return success();
        -:  148:}
------------------
        -:  149:
function _ZN4mlir6memref7AllocOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  150:LogicalResult AllocOp::verify() { return verifyAllocLikeOp(*this); }
call    0 never executed
call    1 never executed
        -:  151:
function _ZN4mlir6memref8AllocaOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  152:LogicalResult AllocaOp::verify() {
        -:  153:  // An alloca op needs to have an ancestor with an allocation scope trait.
    #####:  154:  if (!(*this)->getParentWithTrait<OpTrait::AutomaticAllocationScope>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  155:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  156:        "requires an ancestor op with AutomaticAllocationScope trait");
call    0 never executed
        -:  157:
    #####:  158:  return verifyAllocLikeOp(*this);
call    0 never executed
        -:  159:}
        -:  160:
        -:  161:namespace {
        -:  162:/// Fold constant dimensions into an alloc like operation.
        -:  163:template <typename AllocLikeOp>
        -:  164:struct SimplifyAllocConst : public OpRewritePattern<AllocLikeOp> {
        -:  165:  using OpRewritePattern<AllocLikeOp>::OpRewritePattern;
        -:  166:
    #####:  167:  LogicalResult matchAndRewrite(AllocLikeOp alloc,
        -:  168:                                PatternRewriter &rewriter) const override {
        -:  169:    // Check to see if any dimensions operands are constants.  If so, we can
        -:  170:    // substitute and drop them.
    #####:  171:    if (llvm::none_of(alloc.getDynamicSizes(), [](Value operand) {
        -:  172:          return matchPattern(operand, matchConstantIndex());
        -:  173:        }))
    #####:  174:      return failure();
        -:  175:
    #####:  176:    auto memrefType = alloc.getType();
        -:  177:
        -:  178:    // Ok, we have one or more constant operands.  Collect the non-constant ones
        -:  179:    // and keep track of the resultant memref type to build.
    #####:  180:    SmallVector<int64_t, 4> newShapeConstants;
    #####:  181:    newShapeConstants.reserve(memrefType.getRank());
    #####:  182:    SmallVector<Value, 4> dynamicSizes;
        -:  183:
    #####:  184:    unsigned dynamicDimPos = 0;
    #####:  185:    for (unsigned dim = 0, e = memrefType.getRank(); dim < e; ++dim) {
    #####:  186:      int64_t dimSize = memrefType.getDimSize(dim);
        -:  187:      // If this is already static dimension, keep it.
    #####:  188:      if (!ShapedType::isDynamic(dimSize)) {
    #####:  189:        newShapeConstants.push_back(dimSize);
    #####:  190:        continue;
        -:  191:      }
    #####:  192:      auto dynamicSize = alloc.getDynamicSizes()[dynamicDimPos];
    #####:  193:      auto *defOp = dynamicSize.getDefiningOp();
    #####:  194:      if (auto constantIndexOp =
    #####:  195:              dyn_cast_or_null<arith::ConstantIndexOp>(defOp)) {
        -:  196:        // Dynamic shape dimension will be folded.
    #####:  197:        newShapeConstants.push_back(constantIndexOp.value());
        -:  198:      } else {
        -:  199:        // Dynamic shape dimension not folded; copy dynamicSize from old memref.
    #####:  200:        newShapeConstants.push_back(ShapedType::kDynamicSize);
    #####:  201:        dynamicSizes.push_back(dynamicSize);
        -:  202:      }
    #####:  203:      dynamicDimPos++;
        -:  204:    }
        -:  205:
        -:  206:    // Create new memref type (which will have fewer dynamic dimensions).
    #####:  207:    MemRefType newMemRefType =
    #####:  208:        MemRefType::Builder(memrefType).setShape(newShapeConstants);
    #####:  209:    assert(static_cast<int64_t>(dynamicSizes.size()) ==
        -:  210:           newMemRefType.getNumDynamicDims());
        -:  211:
        -:  212:    // Create and insert the alloc op for the new memref.
    #####:  213:    auto newAlloc = rewriter.create<AllocLikeOp>(
        -:  214:        alloc.getLoc(), newMemRefType, dynamicSizes, alloc.getSymbolOperands(),
        -:  215:        alloc.getAlignmentAttr());
        -:  216:    // Insert a cast so we have the same type as the old alloc.
    #####:  217:    auto resultCast =
        -:  218:        rewriter.create<CastOp>(alloc.getLoc(), alloc.getType(), newAlloc);
        -:  219:
    #####:  220:    rewriter.replaceOp(alloc, {resultCast});
    #####:  221:    return success();
        -:  222:  }
------------------
_ZNK12_GLOBAL__N_118SimplifyAllocConstIN4mlir6memref7AllocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118SimplifyAllocConstIN4mlir6memref7AllocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  167:  LogicalResult matchAndRewrite(AllocLikeOp alloc,
call    0 never executed
        -:  168:                                PatternRewriter &rewriter) const override {
        -:  169:    // Check to see if any dimensions operands are constants.  If so, we can
        -:  170:    // substitute and drop them.
    #####:  171:    if (llvm::none_of(alloc.getDynamicSizes(), [](Value operand) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  172:          return matchPattern(operand, matchConstantIndex());
        -:  173:        }))
    #####:  174:      return failure();
        -:  175:
    #####:  176:    auto memrefType = alloc.getType();
call    0 never executed
        -:  177:
        -:  178:    // Ok, we have one or more constant operands.  Collect the non-constant ones
        -:  179:    // and keep track of the resultant memref type to build.
    #####:  180:    SmallVector<int64_t, 4> newShapeConstants;
    #####:  181:    newShapeConstants.reserve(memrefType.getRank());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  182:    SmallVector<Value, 4> dynamicSizes;
branch  0 never executed
branch  1 never executed
        -:  183:
    #####:  184:    unsigned dynamicDimPos = 0;
    #####:  185:    for (unsigned dim = 0, e = memrefType.getRank(); dim < e; ++dim) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:      int64_t dimSize = memrefType.getDimSize(dim);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  187:      // If this is already static dimension, keep it.
    #####:  188:      if (!ShapedType::isDynamic(dimSize)) {
branch  0 never executed
branch  1 never executed
    #####:  189:        newShapeConstants.push_back(dimSize);
call    0 never executed
    #####:  190:        continue;
        -:  191:      }
    #####:  192:      auto dynamicSize = alloc.getDynamicSizes()[dynamicDimPos];
call    0 never executed
    #####:  193:      auto *defOp = dynamicSize.getDefiningOp();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:      if (auto constantIndexOp =
branch  0 never executed
branch  1 never executed
    #####:  195:              dyn_cast_or_null<arith::ConstantIndexOp>(defOp)) {
branch  0 never executed
branch  1 never executed
        -:  196:        // Dynamic shape dimension will be folded.
    #####:  197:        newShapeConstants.push_back(constantIndexOp.value());
call    0 never executed
call    1 never executed
        -:  198:      } else {
        -:  199:        // Dynamic shape dimension not folded; copy dynamicSize from old memref.
    #####:  200:        newShapeConstants.push_back(ShapedType::kDynamicSize);
call    0 never executed
    #####:  201:        dynamicSizes.push_back(dynamicSize);
call    0 never executed
        -:  202:      }
    #####:  203:      dynamicDimPos++;
        -:  204:    }
        -:  205:
        -:  206:    // Create new memref type (which will have fewer dynamic dimensions).
    #####:  207:    MemRefType newMemRefType =
    #####:  208:        MemRefType::Builder(memrefType).setShape(newShapeConstants);
call    0 never executed
call    1 never executed
    #####:  209:    assert(static_cast<int64_t>(dynamicSizes.size()) ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  210:           newMemRefType.getNumDynamicDims());
        -:  211:
        -:  212:    // Create and insert the alloc op for the new memref.
    #####:  213:    auto newAlloc = rewriter.create<AllocLikeOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  214:        alloc.getLoc(), newMemRefType, dynamicSizes, alloc.getSymbolOperands(),
        -:  215:        alloc.getAlignmentAttr());
        -:  216:    // Insert a cast so we have the same type as the old alloc.
    #####:  217:    auto resultCast =
call    0 never executed
call    1 never executed
        -:  218:        rewriter.create<CastOp>(alloc.getLoc(), alloc.getType(), newAlloc);
        -:  219:
    #####:  220:    rewriter.replaceOp(alloc, {resultCast});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  221:    return success();
branch  0 never executed
branch  1 never executed
        -:  222:  }
------------------
_ZNK12_GLOBAL__N_118SimplifyAllocConstIN4mlir6memref8AllocaOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118SimplifyAllocConstIN4mlir6memref8AllocaOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  167:  LogicalResult matchAndRewrite(AllocLikeOp alloc,
call    0 never executed
        -:  168:                                PatternRewriter &rewriter) const override {
        -:  169:    // Check to see if any dimensions operands are constants.  If so, we can
        -:  170:    // substitute and drop them.
    #####:  171:    if (llvm::none_of(alloc.getDynamicSizes(), [](Value operand) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  172:          return matchPattern(operand, matchConstantIndex());
        -:  173:        }))
    #####:  174:      return failure();
        -:  175:
    #####:  176:    auto memrefType = alloc.getType();
call    0 never executed
        -:  177:
        -:  178:    // Ok, we have one or more constant operands.  Collect the non-constant ones
        -:  179:    // and keep track of the resultant memref type to build.
    #####:  180:    SmallVector<int64_t, 4> newShapeConstants;
    #####:  181:    newShapeConstants.reserve(memrefType.getRank());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  182:    SmallVector<Value, 4> dynamicSizes;
branch  0 never executed
branch  1 never executed
        -:  183:
    #####:  184:    unsigned dynamicDimPos = 0;
    #####:  185:    for (unsigned dim = 0, e = memrefType.getRank(); dim < e; ++dim) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:      int64_t dimSize = memrefType.getDimSize(dim);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  187:      // If this is already static dimension, keep it.
    #####:  188:      if (!ShapedType::isDynamic(dimSize)) {
branch  0 never executed
branch  1 never executed
    #####:  189:        newShapeConstants.push_back(dimSize);
call    0 never executed
    #####:  190:        continue;
        -:  191:      }
    #####:  192:      auto dynamicSize = alloc.getDynamicSizes()[dynamicDimPos];
call    0 never executed
    #####:  193:      auto *defOp = dynamicSize.getDefiningOp();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:      if (auto constantIndexOp =
branch  0 never executed
branch  1 never executed
    #####:  195:              dyn_cast_or_null<arith::ConstantIndexOp>(defOp)) {
branch  0 never executed
branch  1 never executed
        -:  196:        // Dynamic shape dimension will be folded.
    #####:  197:        newShapeConstants.push_back(constantIndexOp.value());
call    0 never executed
call    1 never executed
        -:  198:      } else {
        -:  199:        // Dynamic shape dimension not folded; copy dynamicSize from old memref.
    #####:  200:        newShapeConstants.push_back(ShapedType::kDynamicSize);
call    0 never executed
    #####:  201:        dynamicSizes.push_back(dynamicSize);
call    0 never executed
        -:  202:      }
    #####:  203:      dynamicDimPos++;
        -:  204:    }
        -:  205:
        -:  206:    // Create new memref type (which will have fewer dynamic dimensions).
    #####:  207:    MemRefType newMemRefType =
    #####:  208:        MemRefType::Builder(memrefType).setShape(newShapeConstants);
call    0 never executed
call    1 never executed
    #####:  209:    assert(static_cast<int64_t>(dynamicSizes.size()) ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  210:           newMemRefType.getNumDynamicDims());
        -:  211:
        -:  212:    // Create and insert the alloc op for the new memref.
    #####:  213:    auto newAlloc = rewriter.create<AllocLikeOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  214:        alloc.getLoc(), newMemRefType, dynamicSizes, alloc.getSymbolOperands(),
        -:  215:        alloc.getAlignmentAttr());
        -:  216:    // Insert a cast so we have the same type as the old alloc.
    #####:  217:    auto resultCast =
call    0 never executed
call    1 never executed
        -:  218:        rewriter.create<CastOp>(alloc.getLoc(), alloc.getType(), newAlloc);
        -:  219:
    #####:  220:    rewriter.replaceOp(alloc, {resultCast});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  221:    return success();
branch  0 never executed
branch  1 never executed
        -:  222:  }
------------------
        -:  223:};
        -:  224:
        -:  225:/// Fold alloc operations with no users or only store and dealloc uses.
        -:  226:template <typename T>
        -:  227:struct SimplifyDeadAlloc : public OpRewritePattern<T> {
        -:  228:  using OpRewritePattern<T>::OpRewritePattern;
        -:  229:
    #####:  230:  LogicalResult matchAndRewrite(T alloc,
        -:  231:                                PatternRewriter &rewriter) const override {
    #####:  232:    if (llvm::any_of(alloc->getUsers(), [&](Operation *op) {
    #####:  233:          if (auto storeOp = dyn_cast<StoreOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  234:            return storeOp.getValue() == alloc;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  235:          return !isa<DeallocOp>(op);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  236:        }))
    #####:  237:      return failure();
        -:  238:
    #####:  239:    for (Operation *user : llvm::make_early_inc_range(alloc->getUsers()))
    #####:  240:      rewriter.eraseOp(user);
        -:  241:
    #####:  242:    rewriter.eraseOp(alloc);
    #####:  243:    return success();
        -:  244:  }
------------------
_ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref7AllocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref7AllocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  230:  LogicalResult matchAndRewrite(T alloc,
        -:  231:                                PatternRewriter &rewriter) const override {
    #####:  232:    if (llvm::any_of(alloc->getUsers(), [&](Operation *op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  233:          if (auto storeOp = dyn_cast<StoreOp>(op))
        -:  234:            return storeOp.getValue() == alloc;
        -:  235:          return !isa<DeallocOp>(op);
        -:  236:        }))
    #####:  237:      return failure();
        -:  238:
    #####:  239:    for (Operation *user : llvm::make_early_inc_range(alloc->getUsers()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  240:      rewriter.eraseOp(user);
call    0 never executed
        -:  241:
    #####:  242:    rewriter.eraseOp(alloc);
call    0 never executed
    #####:  243:    return success();
        -:  244:  }
------------------
_ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref8AllocaOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref8AllocaOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  230:  LogicalResult matchAndRewrite(T alloc,
        -:  231:                                PatternRewriter &rewriter) const override {
    #####:  232:    if (llvm::any_of(alloc->getUsers(), [&](Operation *op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  233:          if (auto storeOp = dyn_cast<StoreOp>(op))
        -:  234:            return storeOp.getValue() == alloc;
        -:  235:          return !isa<DeallocOp>(op);
        -:  236:        }))
    #####:  237:      return failure();
        -:  238:
    #####:  239:    for (Operation *user : llvm::make_early_inc_range(alloc->getUsers()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  240:      rewriter.eraseOp(user);
call    0 never executed
        -:  241:
    #####:  242:    rewriter.eraseOp(alloc);
call    0 never executed
    #####:  243:    return success();
        -:  244:  }
------------------
_ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref9ReallocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_117SimplifyDeadAllocIN4mlir6memref9ReallocOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  230:  LogicalResult matchAndRewrite(T alloc,
        -:  231:                                PatternRewriter &rewriter) const override {
    #####:  232:    if (llvm::any_of(alloc->getUsers(), [&](Operation *op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  233:          if (auto storeOp = dyn_cast<StoreOp>(op))
        -:  234:            return storeOp.getValue() == alloc;
        -:  235:          return !isa<DeallocOp>(op);
        -:  236:        }))
    #####:  237:      return failure();
        -:  238:
    #####:  239:    for (Operation *user : llvm::make_early_inc_range(alloc->getUsers()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  240:      rewriter.eraseOp(user);
call    0 never executed
        -:  241:
    #####:  242:    rewriter.eraseOp(alloc);
call    0 never executed
    #####:  243:    return success();
        -:  244:  }
------------------
        -:  245:};
        -:  246:} // namespace
        -:  247:
function _ZN4mlir6memref7AllocOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446:  248:void AllocOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  249:                                          MLIRContext *context) {
     1446:  250:  results.add<SimplifyAllocConst<AllocOp>, SimplifyDeadAlloc<AllocOp>>(context);
call    0 returned 100%
     1446:  251:}
        -:  252:
function _ZN4mlir6memref8AllocaOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446:  253:void AllocaOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  254:                                           MLIRContext *context) {
     1446:  255:  results.add<SimplifyAllocConst<AllocaOp>, SimplifyDeadAlloc<AllocaOp>>(
     1446:  256:      context);
call    0 returned 100%
     1446:  257:}
        -:  258:
        -:  259://===----------------------------------------------------------------------===//
        -:  260:// ReallocOp
        -:  261://===----------------------------------------------------------------------===//
        -:  262:
function _ZN4mlir6memref9ReallocOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  263:LogicalResult ReallocOp::verify() {
    #####:  264:  auto sourceType = getOperand(0).getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  265:  MemRefType resultType = getType();
call    0 never executed
        -:  266:
        -:  267:  // The source memref should have identity layout (or none).
    #####:  268:  if (!sourceType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  269:    return emitError("unsupported layout for source memref type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  270:           << sourceType;
call    0 never executed
        -:  271:
        -:  272:  // The result memref should have identity layout (or none).
    #####:  273:  if (!resultType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  274:    return emitError("unsupported layout for result memref type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  275:           << resultType;
call    0 never executed
        -:  276:
        -:  277:  // The source memref and the result memref should be in the same memory space.
    #####:  278:  if (sourceType.getMemorySpace() != resultType.getMemorySpace())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  279:    return emitError("different memory spaces specified for source memref "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  280:                     "type ")
    #####:  281:           << sourceType << " and result memref type " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  282:
        -:  283:  // The source memref and the result memref should have the same element type.
    #####:  284:  if (sourceType.getElementType() != resultType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  285:    return emitError("different element types specified for source memref "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  286:                     "type ")
    #####:  287:           << sourceType << " and result memref type " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  288:
        -:  289:  // Verify that we have the dynamic dimension operand when it is needed.
    #####:  290:  if (resultType.getNumDynamicDims() && !getDynamicResultSize())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  291:    return emitError("missing dimension operand for result type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  292:           << resultType;
call    0 never executed
    #####:  293:  if (!resultType.getNumDynamicDims() && getDynamicResultSize())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  294:    return emitError("unnecessary dimension operand for result type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  295:           << resultType;
call    0 never executed
        -:  296:
    #####:  297:  return success();
        -:  298:}
        -:  299:
function _ZN4mlir6memref9ReallocOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446:  300:void ReallocOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  301:                                            MLIRContext *context) {
     1446:  302:  results.add<SimplifyDeadAlloc<ReallocOp>>(context);
call    0 returned 100%
     1446:  303:}
        -:  304:
        -:  305://===----------------------------------------------------------------------===//
        -:  306:// AllocaScopeOp
        -:  307://===----------------------------------------------------------------------===//
        -:  308:
function _ZN4mlir6memref13AllocaScopeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  309:void AllocaScopeOp::print(OpAsmPrinter &p) {
    #####:  310:  bool printBlockTerminators = false;
        -:  311:
    #####:  312:  p << ' ';
call    0 never executed
    #####:  313:  if (!getResults().empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  314:    p << " -> (" << getResultTypes() << ")";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  315:    printBlockTerminators = true;
        -:  316:  }
    #####:  317:  p << ' ';
call    0 never executed
    #####:  318:  p.printRegion(getBodyRegion(),
call    0 never executed
        -:  319:                /*printEntryBlockArgs=*/false,
    #####:  320:                /*printBlockTerminators=*/printBlockTerminators);
call    0 never executed
    #####:  321:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####:  322:}
        -:  323:
function _ZN4mlir6memref13AllocaScopeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  324:ParseResult AllocaScopeOp::parse(OpAsmParser &parser, OperationState &result) {
        -:  325:  // Create a region for the body.
    #####:  326:  result.regions.reserve(1);
branch  0 never executed
branch  1 never executed
    #####:  327:  Region *bodyRegion = result.addRegion();
call    0 never executed
        -:  328:
        -:  329:  // Parse optional results type list.
    #####:  330:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  331:    return failure();
        -:  332:
        -:  333:  // Parse the body region.
    #####:  334:  if (parser.parseRegion(*bodyRegion, /*arguments=*/{}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:    return failure();
    #####:  336:  AllocaScopeOp::ensureTerminator(*bodyRegion, parser.getBuilder(),
call    0 never executed
call    1 never executed
        -:  337:                                  result.location);
        -:  338:
        -:  339:  // Parse the optional attribute list.
    #####:  340:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  341:    return failure();
        -:  342:
    #####:  343:  return success();
        -:  344:}
        -:  345:
function _ZN4mlir6memref13AllocaScopeOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####:  346:void AllocaScopeOp::getSuccessorRegions(
        -:  347:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -:  348:    SmallVectorImpl<RegionSuccessor> &regions) {
    #####:  349:  if (index) {
branch  0 never executed
branch  1 never executed
    #####:  350:    regions.push_back(RegionSuccessor(getResults()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  351:    return;
        -:  352:  }
        -:  353:
    #####:  354:  regions.push_back(RegionSuccessor(&getBodyRegion()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  355:}
        -:  356:
        -:  357:/// Given an operation, return whether this op is guaranteed to
        -:  358:/// allocate an AutomaticAllocationScopeResource
function _ZL31isGuaranteedAutomaticAllocationPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  359:static bool isGuaranteedAutomaticAllocation(Operation *op) {
    #####:  360:  MemoryEffectOpInterface interface = dyn_cast<MemoryEffectOpInterface>(op);
call    0 never executed
    #####:  361:  if (!interface)
branch  0 never executed
branch  1 never executed
        -:  362:    return false;
    #####:  363:  for (auto res : op->getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  364:    if (auto effect =
branch  0 never executed
branch  1 never executed
    #####:  365:            interface.getEffectOnValue<MemoryEffects::Allocate>(res)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  366:      if (isa<SideEffects::AutomaticAllocationScopeResource>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  367:              effect->getResource()))
call    0 never executed
    #####:  368:        return true;
        -:  369:    }
        -:  370:  }
    #####:  371:  return false;
        -:  372:}
        -:  373:
        -:  374:/// Given an operation, return whether this op itself could
        -:  375:/// allocate an AutomaticAllocationScopeResource. Note that
        -:  376:/// this will not check whether an operation contained within
        -:  377:/// the op can allocate.
function _ZL38isOpItselfPotentialAutomaticAllocationPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  378:static bool isOpItselfPotentialAutomaticAllocation(Operation *op) {
        -:  379:  // This op itself doesn't create a stack allocation,
        -:  380:  // the inner allocation should be handled separately.
    #####:  381:  if (op->hasTrait<OpTrait::HasRecursiveMemoryEffects>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  382:    return false;
    #####:  383:  MemoryEffectOpInterface interface = dyn_cast<MemoryEffectOpInterface>(op);
call    0 never executed
    #####:  384:  if (!interface)
branch  0 never executed
branch  1 never executed
        -:  385:    return true;
    #####:  386:  for (auto res : op->getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  387:    if (auto effect =
branch  0 never executed
branch  1 never executed
    #####:  388:            interface.getEffectOnValue<MemoryEffects::Allocate>(res)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  389:      if (isa<SideEffects::AutomaticAllocationScopeResource>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  390:              effect->getResource()))
call    0 never executed
    #####:  391:        return true;
        -:  392:    }
        -:  393:  }
    #####:  394:  return false;
        -:  395:}
        -:  396:
        -:  397:/// Return whether this op is the last non terminating op
        -:  398:/// in a region. That is to say, it is in a one-block region
        -:  399:/// and is only followed by a terminator. This prevents
        -:  400:/// extending the lifetime of allocations.
function _ZL25lastNonTerminatorInRegionPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  401:static bool lastNonTerminatorInRegion(Operation *op) {
    #####:  402:  return op->getNextNode() == op->getBlock()->getTerminator() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  403:         op->getParentRegion()->getBlocks().size() == 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  404:}
        -:  405:
        -:  406:/// Inline an AllocaScopeOp if either the direct parent is an allocation scope
        -:  407:/// or it contains no allocation.
        -:  408:struct AllocaScopeInliner : public OpRewritePattern<AllocaScopeOp> {
        -:  409:  using OpRewritePattern<AllocaScopeOp>::OpRewritePattern;
        -:  410:
function _ZNK18AllocaScopeInliner15matchAndRewriteEN4mlir6memref13AllocaScopeOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  411:  LogicalResult matchAndRewrite(AllocaScopeOp op,
        -:  412:                                PatternRewriter &rewriter) const override {
    #####:  413:    bool hasPotentialAlloca =
function _ZZNK18AllocaScopeInliner15matchAndRewriteEN4mlir6memref13AllocaScopeOpERNS0_15PatternRewriterEENKUlPNS0_9OperationEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  414:        op->walk<WalkOrder::PreOrder>([&](Operation *alloc) {
    #####:  415:            if (alloc == op)
branch  0 never executed
branch  1 never executed
    #####:  416:              return WalkResult::advance();
    #####:  417:            if (isOpItselfPotentialAutomaticAllocation(alloc))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:              return WalkResult::interrupt();
    #####:  419:            if (alloc->hasTrait<OpTrait::AutomaticAllocationScope>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  420:              return WalkResult::skip();
    #####:  421:            return WalkResult::advance();
    #####:  422:          }).wasInterrupted();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  423:
        -:  424:    // If this contains no potential allocation, it is always legal to
        -:  425:    // inline. Otherwise, consider two conditions:
    #####:  426:    if (hasPotentialAlloca) {
branch  0 never executed
branch  1 never executed
        -:  427:      // If the parent isn't an allocation scope, or we are not the last
        -:  428:      // non-terminator op in the parent, we will extend the lifetime.
    #####:  429:      if (!op->getParentOp()->hasTrait<OpTrait::AutomaticAllocationScope>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  430:        return failure();
    #####:  431:      if (!lastNonTerminatorInRegion(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  432:        return failure();
        -:  433:    }
        -:  434:
    #####:  435:    Block *block = &op.getRegion().front();
call    0 never executed
call    1 never executed
    #####:  436:    Operation *terminator = block->getTerminator();
call    0 never executed
    #####:  437:    ValueRange results = terminator->getOperands();
call    0 never executed
call    1 never executed
    #####:  438:    rewriter.mergeBlockBefore(block, op);
call    0 never executed
call    1 never executed
    #####:  439:    rewriter.replaceOp(op, results);
call    0 never executed
    #####:  440:    rewriter.eraseOp(terminator);
call    0 never executed
    #####:  441:    return success();
        -:  442:  }
        -:  443:};
        -:  444:
        -:  445:/// Move allocations into an allocation scope, if it is legal to
        -:  446:/// move them (e.g. their operands are available at the location
        -:  447:/// the op would be moved to).
        -:  448:struct AllocaScopeHoister : public OpRewritePattern<AllocaScopeOp> {
        -:  449:  using OpRewritePattern<AllocaScopeOp>::OpRewritePattern;
        -:  450:
function _ZNK18AllocaScopeHoister15matchAndRewriteEN4mlir6memref13AllocaScopeOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  451:  LogicalResult matchAndRewrite(AllocaScopeOp op,
        -:  452:                                PatternRewriter &rewriter) const override {
        -:  453:
    #####:  454:    if (!op->getParentWithTrait<OpTrait::AutomaticAllocationScope>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  455:      return failure();
        -:  456:
    #####:  457:    Operation *lastParentWithoutScope = op->getParentOp();
branch  0 never executed
branch  1 never executed
        -:  458:
    #####:  459:    if (!lastParentWithoutScope ||
branch  0 never executed
branch  1 never executed
    #####:  460:        lastParentWithoutScope->hasTrait<OpTrait::AutomaticAllocationScope>())
branch  0 never executed
branch  1 never executed
    #####:  461:      return failure();
        -:  462:
        -:  463:    // Only apply to if this is this last non-terminator
        -:  464:    // op in the block (lest lifetime be extended) of a one
        -:  465:    // block region
    #####:  466:    if (!lastNonTerminatorInRegion(op) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  467:        !lastNonTerminatorInRegion(lastParentWithoutScope))
call    0 never executed
    #####:  468:      return failure();
        -:  469:
    #####:  470:    while (!lastParentWithoutScope->getParentOp()
    #####:  471:                ->hasTrait<OpTrait::AutomaticAllocationScope>()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  472:      lastParentWithoutScope = lastParentWithoutScope->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  473:      if (!lastParentWithoutScope ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  474:          !lastNonTerminatorInRegion(lastParentWithoutScope))
call    0 never executed
    #####:  475:        return failure();
        -:  476:    }
    #####:  477:    assert(lastParentWithoutScope->getParentOp()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  478:               ->hasTrait<OpTrait::AutomaticAllocationScope>());
        -:  479:
    #####:  480:    Region *containingRegion = nullptr;
    #####:  481:    for (auto &r : lastParentWithoutScope->getRegions()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  482:      if (r.isAncestor(op->getParentRegion())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:        assert(containingRegion == nullptr &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  484:               "only one region can contain the op");
    #####:  485:        containingRegion = &r;
        -:  486:      }
        -:  487:    }
    #####:  488:    assert(containingRegion && "op must be contained in a region");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  489:
    #####:  490:    SmallVector<Operation *> toHoist;
call    0 never executed
function _ZZNK18AllocaScopeHoister15matchAndRewriteEN4mlir6memref13AllocaScopeOpERNS0_15PatternRewriterEENKUlPNS0_9OperationEE_clES6_ called 0 returned 0% blocks executed 0%
    #####:  491:    op->walk([&](Operation *alloc) {
    #####:  492:      if (!isGuaranteedAutomaticAllocation(alloc))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  493:        return WalkResult::skip();
        -:  494:
        -:  495:      // If any operand is not defined before the location of
        -:  496:      // lastParentWithoutScope (i.e. where we would hoist to), skip.
function _ZZZNK18AllocaScopeHoister15matchAndRewriteEN4mlir6memref13AllocaScopeOpERNS0_15PatternRewriterEENKUlPNS0_9OperationEE_clES6_ENKUlNS0_5ValueEE_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  497:      if (llvm::any_of(alloc->getOperands(), [&](Value v) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  498:            return containingRegion->isAncestor(v.getParentRegion());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  499:          }))
    #####:  500:        return WalkResult::skip();
    #####:  501:      toHoist.push_back(alloc);
call    0 never executed
    #####:  502:      return WalkResult::advance();
    #####:  503:    });
call    0 never executed
        -:  504:
    #####:  505:    if (toHoist.empty())
branch  0 never executed
branch  1 never executed
    #####:  506:      return failure();
    #####:  507:    rewriter.setInsertionPoint(lastParentWithoutScope);
call    0 never executed
    #####:  508:    for (auto *op : toHoist) {
branch  0 never executed
branch  1 never executed
    #####:  509:      auto *cloned = rewriter.clone(*op);
call    0 never executed
    #####:  510:      rewriter.replaceOp(op, cloned->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  511:    }
    #####:  512:    return success();
branch  0 never executed
branch  1 never executed
        -:  513:  }
        -:  514:};
        -:  515:
function _ZN4mlir6memref13AllocaScopeOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446:  516:void AllocaScopeOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  517:                                                MLIRContext *context) {
     1446:  518:  results.add<AllocaScopeInliner, AllocaScopeHoister>(context);
call    0 returned 100%
     1446:  519:}
        -:  520:
        -:  521://===----------------------------------------------------------------------===//
        -:  522:// AssumeAlignmentOp
        -:  523://===----------------------------------------------------------------------===//
        -:  524:
function _ZN4mlir6memref17AssumeAlignmentOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  525:LogicalResult AssumeAlignmentOp::verify() {
    #####:  526:  if (!llvm::isPowerOf2_32(getAlignment()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  527:    return emitOpError("alignment must be power of 2");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  528:  return success();
        -:  529:}
        -:  530:
        -:  531://===----------------------------------------------------------------------===//
        -:  532:// CastOp
        -:  533://===----------------------------------------------------------------------===//
        -:  534:
function _ZN4mlir6memref6CastOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  535:void CastOp::getAsmResultNames(function_ref<void(Value, StringRef)> setNameFn) {
    #####:  536:  setNameFn(getResult(), "cast");
call    0 never executed
    #####:  537:}
        -:  538:
        -:  539:/// Determines whether MemRef_CastOp casts to a more dynamic version of the
        -:  540:/// source memref. This is useful to to fold a memref.cast into a consuming op
        -:  541:/// and implement canonicalization patterns for ops in different dialects that
        -:  542:/// may consume the results of memref.cast operations. Such foldable memref.cast
        -:  543:/// operations are typically inserted as `view` and `subview` ops are
        -:  544:/// canonicalized, to preserve the type compatibility of their uses.
        -:  545:///
        -:  546:/// Returns true when all conditions are met:
        -:  547:/// 1. source and result are ranked memrefs with strided semantics and same
        -:  548:/// element type and rank.
        -:  549:/// 2. each of the source's size, offset or stride has more static information
        -:  550:/// than the corresponding result's size, offset or stride.
        -:  551:///
        -:  552:/// Example 1:
        -:  553:/// ```mlir
        -:  554:///   %1 = memref.cast %0 : memref<8x16xf32> to memref<?x?xf32>
        -:  555:///   %2 = consumer %1 ... : memref<?x?xf32> ...
        -:  556:/// ```
        -:  557:///
        -:  558:/// may fold into:
        -:  559:///
        -:  560:/// ```mlir
        -:  561:///   %2 = consumer %0 ... : memref<8x16xf32> ...
        -:  562:/// ```
        -:  563:///
        -:  564:/// Example 2:
        -:  565:/// ```
        -:  566:///   %1 = memref.cast %0 : memref<?x16xf32, affine_map<(i, j)->(16 * i + j)>>
        -:  567:///          to memref<?x?xf32>
        -:  568:///   consumer %1 : memref<?x?xf32> ...
        -:  569:/// ```
        -:  570:///
        -:  571:/// may fold into:
        -:  572:///
        -:  573:/// ```
        -:  574:///   consumer %0 ... : memref<?x16xf32, affine_map<(i, j)->(16 * i + j)>>
        -:  575:/// ```
function _ZN4mlir6memref6CastOp21canFoldIntoConsumerOpES1_ called 0 returned 0% blocks executed 0%
    #####:  576:bool CastOp::canFoldIntoConsumerOp(CastOp castOp) {
    #####:  577:  MemRefType sourceType = castOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  578:  MemRefType resultType = castOp.getType().dyn_cast<MemRefType>();
call    0 never executed
        -:  579:
        -:  580:  // Requires ranked MemRefType.
    #####:  581:  if (!sourceType || !resultType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  582:    return false;
        -:  583:
        -:  584:  // Requires same elemental type.
    #####:  585:  if (sourceType.getElementType() != resultType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  586:    return false;
        -:  587:
        -:  588:  // Requires same rank.
    #####:  589:  if (sourceType.getRank() != resultType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  590:    return false;
        -:  591:
        -:  592:  // Only fold casts between strided memref forms.
    #####:  593:  int64_t sourceOffset, resultOffset;
    #####:  594:  SmallVector<int64_t, 4> sourceStrides, resultStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  595:  if (failed(getStridesAndOffset(sourceType, sourceStrides, sourceOffset)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  596:      failed(getStridesAndOffset(resultType, resultStrides, resultOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  597:    return false;
        -:  598:
        -:  599:  // If cast is towards more static sizes along any dimension, don't fold.
    #####:  600:  for (auto it : llvm::zip(sourceType.getShape(), resultType.getShape())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  601:    auto ss = std::get<0>(it), st = std::get<1>(it);
branch  0 never executed
branch  1 never executed
    #####:  602:    if (ss != st)
branch  0 never executed
branch  1 never executed
    #####:  603:      if (ShapedType::isDynamic(ss) && !ShapedType::isDynamic(st))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:        return false;
        -:  605:  }
        -:  606:
        -:  607:  // If cast is towards more static offset along any dimension, don't fold.
    #####:  608:  if (sourceOffset != resultOffset)
branch  0 never executed
branch  1 never executed
    #####:  609:    if (ShapedType::isDynamicStrideOrOffset(sourceOffset) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  610:        !ShapedType::isDynamicStrideOrOffset(resultOffset))
branch  0 never executed
branch  1 never executed
        -:  611:      return false;
        -:  612:
        -:  613:  // If cast is towards more static strides along any dimension, don't fold.
    #####:  614:  for (auto it : llvm::zip(sourceStrides, resultStrides)) {
branch  0 never executed
branch  1 never executed
    #####:  615:    auto ss = std::get<0>(it), st = std::get<1>(it);
branch  0 never executed
branch  1 never executed
    #####:  616:    if (ss != st)
branch  0 never executed
branch  1 never executed
    #####:  617:      if (ShapedType::isDynamicStrideOrOffset(ss) &&
branch  0 never executed
branch  1 never executed
    #####:  618:          !ShapedType::isDynamicStrideOrOffset(st))
branch  0 never executed
branch  1 never executed
    #####:  619:        return false;
        -:  620:  }
        -:  621:
    #####:  622:  return true;
        -:  623:}
        -:  624:
function _ZN4mlir6memref6CastOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####:  625:bool CastOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####:  626:  if (inputs.size() != 1 || outputs.size() != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  627:    return false;
    #####:  628:  Type a = inputs.front(), b = outputs.front();
call    0 never executed
call    1 never executed
    #####:  629:  auto aT = a.dyn_cast<MemRefType>();
call    0 never executed
    #####:  630:  auto bT = b.dyn_cast<MemRefType>();
call    0 never executed
        -:  631:
    #####:  632:  auto uaT = a.dyn_cast<UnrankedMemRefType>();
call    0 never executed
    #####:  633:  auto ubT = b.dyn_cast<UnrankedMemRefType>();
call    0 never executed
        -:  634:
    #####:  635:  if (aT && bT) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:    if (aT.getElementType() != bT.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  637:      return false;
    #####:  638:    if (aT.getLayout() != bT.getLayout()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  639:      int64_t aOffset, bOffset;
    #####:  640:      SmallVector<int64_t, 4> aStrides, bStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  641:      if (failed(getStridesAndOffset(aT, aStrides, aOffset)) ||
call    0 never executed
    #####:  642:          failed(getStridesAndOffset(bT, bStrides, bOffset)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  643:          aStrides.size() != bStrides.size())
branch  0 never executed
branch  1 never executed
    #####:  644:        return false;
branch  0 never executed
branch  1 never executed
        -:  645:
        -:  646:      // Strides along a dimension/offset are compatible if the value in the
        -:  647:      // source memref is static and the value in the target memref is the
        -:  648:      // same. They are also compatible if either one is dynamic (see
        -:  649:      // description of MemRefCastOp for details).
    #####:  650:      auto checkCompatible = [](int64_t a, int64_t b) {
    #####:  651:        return (a == MemRefType::getDynamicStrideOrOffset() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  652:                b == MemRefType::getDynamicStrideOrOffset() || a == b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  653:      };
    #####:  654:      if (!checkCompatible(aOffset, bOffset))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  655:        return false;
    #####:  656:      for (const auto &aStride : enumerate(aStrides))
branch  0 never executed
branch  1 never executed
    #####:  657:        if (!checkCompatible(aStride.value(), bStrides[aStride.index()]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  658:          return false;
        -:  659:    }
    #####:  660:    if (aT.getMemorySpace() != bT.getMemorySpace())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  661:      return false;
        -:  662:
        -:  663:    // They must have the same rank, and any specified dimensions must match.
    #####:  664:    if (aT.getRank() != bT.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  665:      return false;
        -:  666:
    #####:  667:    for (unsigned i = 0, e = aT.getRank(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  668:      int64_t aDim = aT.getDimSize(i), bDim = bT.getDimSize(i);
call    0 never executed
call    1 never executed
    #####:  669:      if (!ShapedType::isDynamic(aDim) && !ShapedType::isDynamic(bDim) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  670:          aDim != bDim)
        -:  671:        return false;
        -:  672:    }
        -:  673:    return true;
        -:  674:  } else {
    #####:  675:    if (!aT && !uaT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  676:      return false;
    #####:  677:    if (!bT && !ubT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  678:      return false;
        -:  679:    // Unranked to unranked casting is unsupported
    #####:  680:    if (uaT && ubT)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  681:      return false;
        -:  682:
    #####:  683:    auto aEltType = (aT) ? aT.getElementType() : uaT.getElementType();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  684:    auto bEltType = (bT) ? bT.getElementType() : ubT.getElementType();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  685:    if (aEltType != bEltType)
branch  0 never executed
branch  1 never executed
        -:  686:      return false;
        -:  687:
    #####:  688:    auto aMemSpace = (aT) ? aT.getMemorySpace() : uaT.getMemorySpace();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  689:    auto bMemSpace = (bT) ? bT.getMemorySpace() : ubT.getMemorySpace();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  690:    return aMemSpace == bMemSpace;
        -:  691:  }
        -:  692:
        -:  693:  return false;
        -:  694:}
        -:  695:
function _ZN4mlir6memref6CastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  696:OpFoldResult CastOp::fold(ArrayRef<Attribute> operands) {
    #####:  697:  return succeeded(foldMemRefCast(*this)) ? getResult() : Value();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  698:}
        -:  699:
        -:  700://===----------------------------------------------------------------------===//
        -:  701:// CopyOp
        -:  702://===----------------------------------------------------------------------===//
        -:  703:
        -:  704:namespace {
        -:  705:/// If the source/target of a CopyOp is a CastOp that does not modify the shape
        -:  706:/// and element type, the cast can be skipped. Such CastOps only cast the layout
        -:  707:/// of the type.
        -:  708:struct FoldCopyOfCast : public OpRewritePattern<CopyOp> {
        -:  709:  using OpRewritePattern<CopyOp>::OpRewritePattern;
        -:  710:
function _ZNK12_GLOBAL__N_114FoldCopyOfCast15matchAndRewriteEN4mlir6memref6CopyOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  711:  LogicalResult matchAndRewrite(CopyOp copyOp,
        -:  712:                                PatternRewriter &rewriter) const override {
    #####:  713:    bool modified = false;
        -:  714:
        -:  715:    // Check source.
    #####:  716:    if (auto castOp = copyOp.getSource().getDefiningOp<CastOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  717:      auto fromType = castOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  718:      auto toType = castOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
        -:  719:
    #####:  720:      if (fromType && toType) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  721:        if (fromType.getShape() == toType.getShape() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  722:            fromType.getElementType() == toType.getElementType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
function _ZZNK12_GLOBAL__N_114FoldCopyOfCast15matchAndRewriteEN4mlir6memref6CopyOpERNS1_15PatternRewriterEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  723:          rewriter.updateRootInPlace(copyOp, [&] {
call    0 never executed
    #####:  724:            copyOp.getSourceMutable().assign(castOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  725:          });
    #####:  726:          modified = true;
        -:  727:        }
        -:  728:      }
        -:  729:    }
        -:  730:
        -:  731:    // Check target.
    #####:  732:    if (auto castOp = copyOp.getTarget().getDefiningOp<CastOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  733:      auto fromType = castOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  734:      auto toType = castOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
        -:  735:
    #####:  736:      if (fromType && toType) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  737:        if (fromType.getShape() == toType.getShape() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  738:            fromType.getElementType() == toType.getElementType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
function _ZZNK12_GLOBAL__N_114FoldCopyOfCast15matchAndRewriteEN4mlir6memref6CopyOpERNS1_15PatternRewriterEENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  739:          rewriter.updateRootInPlace(copyOp, [&] {
call    0 never executed
    #####:  740:            copyOp.getTargetMutable().assign(castOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  741:          });
    #####:  742:          modified = true;
        -:  743:        }
        -:  744:      }
        -:  745:    }
        -:  746:
    #####:  747:    return success(modified);
        -:  748:  }
        -:  749:};
        -:  750:
        -:  751:/// Fold memref.copy(%x, %x).
        -:  752:struct FoldSelfCopy : public OpRewritePattern<CopyOp> {
        -:  753:  using OpRewritePattern<CopyOp>::OpRewritePattern;
        -:  754:
function _ZNK12_GLOBAL__N_112FoldSelfCopy15matchAndRewriteEN4mlir6memref6CopyOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  755:  LogicalResult matchAndRewrite(CopyOp copyOp,
        -:  756:                                PatternRewriter &rewriter) const override {
    #####:  757:    if (copyOp.getSource() != copyOp.getTarget())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  758:      return failure();
        -:  759:
    #####:  760:    rewriter.eraseOp(copyOp);
call    0 never executed
    #####:  761:    return success();
        -:  762:  }
        -:  763:};
        -:  764:} // namespace
        -:  765:
function _ZN4mlir6memref6CopyOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446:  766:void CopyOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  767:                                         MLIRContext *context) {
     1446:  768:  results.add<FoldCopyOfCast, FoldSelfCopy>(context);
call    0 returned 100%
     1446:  769:}
        -:  770:
function _ZN4mlir6memref6CopyOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:  771:LogicalResult CopyOp::fold(ArrayRef<Attribute> cstOperands,
        -:  772:                           SmallVectorImpl<OpFoldResult> &results) {
        -:  773:  /// copy(memrefcast) -> copy
    #####:  774:  bool folded = false;
    #####:  775:  Operation *op = *this;
call    0 never executed
    #####:  776:  for (OpOperand &operand : op->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  777:    auto castOp = operand.get().getDefiningOp<memref::CastOp>();
call    0 never executed
    #####:  778:    if (castOp && memref::CastOp::canFoldIntoConsumerOp(castOp)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  779:      operand.set(castOp.getOperand());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  780:      folded = true;
        -:  781:    }
        -:  782:  }
    #####:  783:  return success(folded);
        -:  784:}
        -:  785:
        -:  786://===----------------------------------------------------------------------===//
        -:  787:// DeallocOp
        -:  788://===----------------------------------------------------------------------===//
        -:  789:
function _ZN4mlir6memref9DeallocOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:  790:LogicalResult DeallocOp::fold(ArrayRef<Attribute> cstOperands,
        -:  791:                              SmallVectorImpl<OpFoldResult> &results) {
        -:  792:  /// dealloc(memrefcast) -> dealloc
    #####:  793:  return foldMemRefCast(*this);
call    0 never executed
        -:  794:}
        -:  795:
        -:  796://===----------------------------------------------------------------------===//
        -:  797:// DimOp
        -:  798://===----------------------------------------------------------------------===//
        -:  799:
function _ZN4mlir6memref5DimOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  800:void DimOp::getAsmResultNames(function_ref<void(Value, StringRef)> setNameFn) {
    #####:  801:  setNameFn(getResult(), "dim");
call    0 never executed
call    1 never executed
    #####:  802:}
        -:  803:
function _ZN4mlir6memref5DimOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####:  804:void DimOp::build(OpBuilder &builder, OperationState &result, Value source,
        -:  805:                  int64_t index) {
    #####:  806:  auto loc = result.location;
    #####:  807:  Value indexValue = builder.create<arith::ConstantIndexOp>(loc, index);
call    0 never executed
call    1 never executed
    #####:  808:  build(builder, result, source, indexValue);
call    0 never executed
    #####:  809:}
        -:  810:
function _ZN4mlir6memref5DimOp16getConstantIndexEv called 0 returned 0% blocks executed 0%
    #####:  811:Optional<int64_t> DimOp::getConstantIndex() {
    #####:  812:  if (auto constantOp = getIndex().getDefiningOp<arith::ConstantOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  813:    return constantOp.getValue().cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  814:  return {};
        -:  815:}
        -:  816:
function _ZN4mlir6memref5DimOp18getSpeculatabilityEv called 0 returned 0% blocks executed 0%
    #####:  817:Speculation::Speculatability DimOp::getSpeculatability() {
    #####:  818:  auto constantIndex = getConstantIndex();
call    0 never executed
    #####:  819:  if (!constantIndex)
branch  0 never executed
branch  1 never executed
        -:  820:    return Speculation::NotSpeculatable;
        -:  821:
    #####:  822:  auto rankedSourceType = dyn_cast<MemRefType>(getSource().getType());
call    0 never executed
call    1 never executed
    #####:  823:  if (!rankedSourceType)
branch  0 never executed
branch  1 never executed
        -:  824:    return Speculation::NotSpeculatable;
        -:  825:
        -:  826:  // The verifier rejects operations that violate this assertion.
    #####:  827:  assert(constantIndex < rankedSourceType.getRank());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  828:  return Speculation::Speculatable;
        -:  829:}
        -:  830:
function _ZN4mlir6memref5DimOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  831:LogicalResult DimOp::verify() {
        -:  832:  // Assume unknown index to be in range.
    #####:  833:  Optional<int64_t> index = getConstantIndex();
call    0 never executed
    #####:  834:  if (!index)
branch  0 never executed
branch  1 never executed
    #####:  835:    return success();
        -:  836:
        -:  837:  // Check that constant index is not knowingly out of range.
    #####:  838:  auto type = getSource().getType();
call    0 never executed
call    1 never executed
    #####:  839:  if (auto memrefType = type.dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  840:    if (*index >= memrefType.getRank())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  841:      return emitOpError("index is out of range");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  842:  } else if (type.isa<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  843:    // Assume index to be in range.
        -:  844:  } else {
    #####:  845:    llvm_unreachable("expected operand with memref type");
call    0 never executed
        -:  846:  }
    #####:  847:  return success();
        -:  848:}
        -:  849:
        -:  850:/// Return a map with key being elements in `vals` and data being number of
        -:  851:/// occurences of it. Use std::map, since the `vals` here are strides and the
        -:  852:/// dynamic stride value is the same as the tombstone value for
        -:  853:/// `DenseMap<int64_t>`.
function _ZL16getNumOccurencesN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:  854:static std::map<int64_t, unsigned> getNumOccurences(ArrayRef<int64_t> vals) {
    #####:  855:  std::map<int64_t, unsigned> numOccurences;
    #####:  856:  for (auto val : vals)
branch  0 never executed
branch  1 never executed
    #####:  857:    numOccurences[val]++;
call    0 never executed
    #####:  858:  return numOccurences;
        -:  859:}
        -:  860:
        -:  861:/// Given the `originalType` and a `candidateReducedType` whose shape is assumed
        -:  862:/// to be a subset of `originalType` with some `1` entries erased, return the
        -:  863:/// set of indices that specifies which of the entries of `originalShape` are
        -:  864:/// dropped to obtain `reducedShape`.
        -:  865:/// This accounts for cases where there are multiple unit-dims, but only a
        -:  866:/// subset of those are dropped. For MemRefTypes these can be disambiguated
        -:  867:/// using the strides. If a dimension is dropped the stride must be dropped too.
        -:  868:static llvm::Optional<llvm::SmallBitVector>
function _ZL30computeMemRefRankReductionMaskN4mlir10MemRefTypeES0_N4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:  869:computeMemRefRankReductionMask(MemRefType originalType, MemRefType reducedType,
        -:  870:                               ArrayRef<OpFoldResult> sizes) {
    #####:  871:  llvm::SmallBitVector unusedDims(originalType.getRank());
call    0 never executed
call    1 never executed
    #####:  872:  if (originalType.getRank() == reducedType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  873:    return unusedDims;
        -:  874:
    #####:  875:  for (const auto &dim : llvm::enumerate(sizes))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  876:    if (auto attr = dim.value().dyn_cast<Attribute>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  877:      if (attr.cast<IntegerAttr>().getInt() == 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  878:        unusedDims.set(dim.index());
call    0 never executed
        -:  879:
        -:  880:  // Early exit for the case where the number of unused dims matches the number
        -:  881:  // of ranks reduced.
    #####:  882:  if (static_cast<int64_t>(unusedDims.count()) + reducedType.getRank() ==
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  883:      originalType.getRank())
call    0 never executed
    #####:  884:    return unusedDims;
        -:  885:
    #####:  886:  SmallVector<int64_t> originalStrides, candidateStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  887:  int64_t originalOffset, candidateOffset;
    #####:  888:  if (failed(
call    0 never executed
    #####:  889:          getStridesAndOffset(originalType, originalStrides, originalOffset)) ||
branch  0 never executed
branch  1 never executed
    #####:  890:      failed(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  891:          getStridesAndOffset(reducedType, candidateStrides, candidateOffset)))
    #####:  892:    return llvm::None;
        -:  893:
        -:  894:  // For memrefs, a dimension is truly dropped if its corresponding stride is
        -:  895:  // also dropped. This is particularly important when more than one of the dims
        -:  896:  // is 1. Track the number of occurences of the strides in the original type
        -:  897:  // and the candidate type. For each unused dim that stride should not be
        -:  898:  // present in the candidate type. Note that there could be multiple dimensions
        -:  899:  // that have the same size. We dont need to exactly figure out which dim
        -:  900:  // corresponds to which stride, we just need to verify that the number of
        -:  901:  // reptitions of a stride in the original + number of unused dims with that
        -:  902:  // stride == number of repititions of a stride in the candidate.
    #####:  903:  std::map<int64_t, unsigned> currUnaccountedStrides =
call    0 never executed
    #####:  904:      getNumOccurences(originalStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  905:  std::map<int64_t, unsigned> candidateStridesNumOccurences =
call    0 never executed
    #####:  906:      getNumOccurences(candidateStrides);
call    0 never executed
call    1 never executed
    #####:  907:  for (size_t dim = 0, e = unusedDims.size(); dim != e; ++dim) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  908:    if (!unusedDims.test(dim))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  909:      continue;
    #####:  910:    int64_t originalStride = originalStrides[dim];
branch  0 never executed
branch  1 never executed
    #####:  911:    if (currUnaccountedStrides[originalStride] >
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  912:        candidateStridesNumOccurences[originalStride]) {
call    0 never executed
        -:  913:      // This dim can be treated as dropped.
    #####:  914:      currUnaccountedStrides[originalStride]--;
call    0 never executed
    #####:  915:      continue;
        -:  916:    }
    #####:  917:    if (currUnaccountedStrides[originalStride] ==
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  918:        candidateStridesNumOccurences[originalStride]) {
call    0 never executed
        -:  919:      // The stride for this is not dropped. Keep as is.
    #####:  920:      unusedDims.reset(dim);
call    0 never executed
    #####:  921:      continue;
        -:  922:    }
    #####:  923:    if (currUnaccountedStrides[originalStride] <
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  924:        candidateStridesNumOccurences[originalStride]) {
call    0 never executed
        -:  925:      // This should never happen. Cant have a stride in the reduced rank type
        -:  926:      // that wasnt in the original one.
    #####:  927:      return llvm::None;
        -:  928:    }
        -:  929:  }
        -:  930:
    #####:  931:  if ((int64_t)unusedDims.count() + reducedType.getRank() !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  932:      originalType.getRank())
call    0 never executed
    #####:  933:    return llvm::None;
    #####:  934:  return unusedDims;
call    0 never executed
        -:  935:}
        -:  936:
function _ZN4mlir6memref9SubViewOp14getDroppedDimsEv called 0 returned 0% blocks executed 0%
    #####:  937:llvm::SmallBitVector SubViewOp::getDroppedDims() {
    #####:  938:  MemRefType sourceType = getSourceType();
call    0 never executed
    #####:  939:  MemRefType resultType = getType();
call    0 never executed
    #####:  940:  llvm::Optional<llvm::SmallBitVector> unusedDims =
    #####:  941:      computeMemRefRankReductionMask(sourceType, resultType, getMixedSizes());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  942:  assert(unusedDims && "unable to find unused dims of subview");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  943:  return *unusedDims;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  944:}
        -:  945:
function _ZN4mlir6memref5DimOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  946:OpFoldResult DimOp::fold(ArrayRef<Attribute> operands) {
        -:  947:  // All forms of folding require a known index.
    #####:  948:  auto index = operands[1].dyn_cast_or_null<IntegerAttr>();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  949:  if (!index)
branch  0 never executed
branch  1 never executed
    #####:  950:    return {};
        -:  951:
        -:  952:  // Folding for unranked types (UnrankedMemRefType) is not supported.
    #####:  953:  auto memrefType = getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  954:  if (!memrefType)
branch  0 never executed
branch  1 never executed
    #####:  955:    return {};
        -:  956:
        -:  957:  // Fold if the shape extent along the given index is known.
    #####:  958:  if (!memrefType.isDynamicDim(index.getInt())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  959:    Builder builder(getContext());
call    0 never executed
call    1 never executed
    #####:  960:    return builder.getIndexAttr(memrefType.getShape()[index.getInt()]);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  961:  }
        -:  962:
        -:  963:  // The size at the given index is now known to be a dynamic size.
    #####:  964:  unsigned unsignedIndex = index.getValue().getZExtValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  965:
        -:  966:  // Fold dim to the size argument for an `AllocOp`, `ViewOp`, or `SubViewOp`.
    #####:  967:  Operation *definingOp = getSource().getDefiningOp();
call    0 never executed
call    1 never executed
        -:  968:
    #####:  969:  if (auto alloc = dyn_cast_or_null<AllocOp>(definingOp))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  970:    return *(alloc.getDynamicSizes().begin() +
call    0 never executed
    #####:  971:             memrefType.getDynamicDimIndex(unsignedIndex));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  972:
    #####:  973:  if (auto alloca = dyn_cast_or_null<AllocaOp>(definingOp))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  974:    return *(alloca.getDynamicSizes().begin() +
call    0 never executed
    #####:  975:             memrefType.getDynamicDimIndex(unsignedIndex));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  976:
    #####:  977:  if (auto view = dyn_cast_or_null<ViewOp>(definingOp))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  978:    return *(view.getDynamicSizes().begin() +
call    0 never executed
    #####:  979:             memrefType.getDynamicDimIndex(unsignedIndex));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  980:
    #####:  981:  if (auto subview = dyn_cast_or_null<SubViewOp>(definingOp)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  982:    llvm::SmallBitVector unusedDims = subview.getDroppedDims();
call    0 never executed
    #####:  983:    unsigned resultIndex = 0;
    #####:  984:    unsigned sourceRank = subview.getSourceType().getRank();
call    0 never executed
call    1 never executed
    #####:  985:    unsigned sourceIndex = 0;
    #####:  986:    for (auto i : llvm::seq<unsigned>(0, sourceRank)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  987:      if (unusedDims.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  988:        continue;
    #####:  989:      if (resultIndex == unsignedIndex) {
branch  0 never executed
branch  1 never executed
        -:  990:        sourceIndex = i;
        -:  991:        break;
        -:  992:      }
    #####:  993:      resultIndex++;
        -:  994:    }
    #####:  995:    assert(subview.isDynamicSize(sourceIndex) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  996:           "expected dynamic subview size");
    #####:  997:    return subview.getDynamicSize(sourceIndex);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  998:  }
        -:  999:
    #####: 1000:  if (auto sizeInterface =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1001:          dyn_cast_or_null<OffsetSizeAndStrideOpInterface>(definingOp)) {
branch  0 never executed
branch  1 never executed
    #####: 1002:    assert(sizeInterface.isDynamicSize(unsignedIndex) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1003:           "Expected dynamic subview size");
    #####: 1004:    return sizeInterface.getDynamicSize(unsignedIndex);
call    0 never executed
call    1 never executed
        -: 1005:  }
        -: 1006:
        -: 1007:  // dim(memrefcast) -> dim
    #####: 1008:  if (succeeded(foldMemRefCast(*this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1009:    return getResult();
call    0 never executed
call    1 never executed
        -: 1010:
    #####: 1011:  return {};
        -: 1012:}
        -: 1013:
        -: 1014:namespace {
        -: 1015:/// Fold dim of a memref reshape operation to a load into the reshape's shape
        -: 1016:/// operand.
        -: 1017:struct DimOfMemRefReshape : public OpRewritePattern<DimOp> {
        -: 1018:  using OpRewritePattern<DimOp>::OpRewritePattern;
        -: 1019:
function _ZNK12_GLOBAL__N_118DimOfMemRefReshape15matchAndRewriteEN4mlir6memref5DimOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1020:  LogicalResult matchAndRewrite(DimOp dim,
        -: 1021:                                PatternRewriter &rewriter) const override {
    #####: 1022:    auto reshape = dim.getSource().getDefiningOp<ReshapeOp>();
call    0 never executed
call    1 never executed
        -: 1023:
    #####: 1024:    if (!reshape)
branch  0 never executed
branch  1 never executed
    #####: 1025:      return failure();
        -: 1026:
        -: 1027:    // Place the load directly after the reshape to ensure that the shape memref
        -: 1028:    // was not mutated.
    #####: 1029:    rewriter.setInsertionPointAfter(reshape);
call    0 never executed
    #####: 1030:    Location loc = dim.getLoc();
call    0 never executed
    #####: 1031:    Value load =
    #####: 1032:        rewriter.create<LoadOp>(loc, reshape.getShape(), dim.getIndex());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1033:    if (load.getType() != dim.getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1034:      load = rewriter.create<arith::IndexCastOp>(loc, dim.getType(), load);
call    0 never executed
call    1 never executed
    #####: 1035:    rewriter.replaceOp(dim, load);
call    0 never executed
call    1 never executed
    #####: 1036:    return success();
        -: 1037:  }
        -: 1038:};
        -: 1039:
        -: 1040:} // namespace
        -: 1041:
function _ZN4mlir6memref5DimOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 1042:void DimOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1043:                                        MLIRContext *context) {
     1446: 1044:  results.add<DimOfMemRefReshape>(context);
call    0 returned 100%
     1446: 1045:}
        -: 1046:
        -: 1047:// ---------------------------------------------------------------------------
        -: 1048:// DmaStartOp
        -: 1049:// ---------------------------------------------------------------------------
        -: 1050:
function _ZN4mlir6memref10DmaStartOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeES6_S7_S6_S6_S7_S6_S6_ called 0 returned 0% blocks executed 0%
    #####: 1051:void DmaStartOp::build(OpBuilder &builder, OperationState &result,
        -: 1052:                       Value srcMemRef, ValueRange srcIndices, Value destMemRef,
        -: 1053:                       ValueRange destIndices, Value numElements,
        -: 1054:                       Value tagMemRef, ValueRange tagIndices, Value stride,
        -: 1055:                       Value elementsPerStride) {
    #####: 1056:  result.addOperands(srcMemRef);
call    0 never executed
call    1 never executed
    #####: 1057:  result.addOperands(srcIndices);
call    0 never executed
    #####: 1058:  result.addOperands(destMemRef);
call    0 never executed
call    1 never executed
    #####: 1059:  result.addOperands(destIndices);
call    0 never executed
    #####: 1060:  result.addOperands({numElements, tagMemRef});
call    0 never executed
call    1 never executed
    #####: 1061:  result.addOperands(tagIndices);
call    0 never executed
    #####: 1062:  if (stride)
branch  0 never executed
branch  1 never executed
    #####: 1063:    result.addOperands({stride, elementsPerStride});
call    0 never executed
call    1 never executed
    #####: 1064:}
        -: 1065:
function _ZN4mlir6memref10DmaStartOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1066:void DmaStartOp::print(OpAsmPrinter &p) {
    #####: 1067:  p << " " << getSrcMemRef() << '[' << getSrcIndices() << "], "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1068:    << getDstMemRef() << '[' << getDstIndices() << "], " << getNumElements()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1069:    << ", " << getTagMemRef() << '[' << getTagIndices() << ']';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 1070:  if (isStrided())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1071:    p << ", " << getStride() << ", " << getNumElementsPerStride();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 1072:
    #####: 1073:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 1074:  p << " : " << getSrcMemRef().getType() << ", " << getDstMemRef().getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1075:    << ", " << getTagMemRef().getType();
call    0 never executed
call    1 never executed
    #####: 1076:}
        -: 1077:
        -: 1078:// Parse DmaStartOp.
        -: 1079:// Ex:
        -: 1080://   %dma_id = dma_start %src[%i, %j], %dst[%k, %l], %size,
        -: 1081://                       %tag[%index], %stride, %num_elt_per_stride :
        -: 1082://                     : memref<3076 x f32, 0>,
        -: 1083://                       memref<1024 x f32, 2>,
        -: 1084://                       memref<1 x i32>
        -: 1085://
function _ZN4mlir6memref10DmaStartOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1086:ParseResult DmaStartOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 1087:  OpAsmParser::UnresolvedOperand srcMemRefInfo;
call    0 never executed
    #####: 1088:  SmallVector<OpAsmParser::UnresolvedOperand, 4> srcIndexInfos;
call    0 never executed
    #####: 1089:  OpAsmParser::UnresolvedOperand dstMemRefInfo;
    #####: 1090:  SmallVector<OpAsmParser::UnresolvedOperand, 4> dstIndexInfos;
branch  0 never executed
branch  1 never executed
    #####: 1091:  OpAsmParser::UnresolvedOperand numElementsInfo;
    #####: 1092:  OpAsmParser::UnresolvedOperand tagMemrefInfo;
    #####: 1093:  SmallVector<OpAsmParser::UnresolvedOperand, 4> tagIndexInfos;
branch  0 never executed
branch  1 never executed
    #####: 1094:  SmallVector<OpAsmParser::UnresolvedOperand, 2> strideInfo;
branch  0 never executed
branch  1 never executed
        -: 1095:
    #####: 1096:  SmallVector<Type, 3> types;
branch  0 never executed
branch  1 never executed
    #####: 1097:  auto indexType = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
        -: 1098:
        -: 1099:  // Parse and resolve the following list of operands:
        -: 1100:  // *) source memref followed by its indices (in square brackets).
        -: 1101:  // *) destination memref followed by its indices (in square brackets).
        -: 1102:  // *) dma size in KiB.
    #####: 1103:  if (parser.parseOperand(srcMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1104:      parser.parseOperandList(srcIndexInfos, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1105:      parser.parseComma() || parser.parseOperand(dstMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1106:      parser.parseOperandList(dstIndexInfos, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1107:      parser.parseComma() || parser.parseOperand(numElementsInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1108:      parser.parseComma() || parser.parseOperand(tagMemrefInfo) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1109:      parser.parseOperandList(tagIndexInfos, OpAsmParser::Delimiter::Square))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1110:    return failure();
        -: 1111:
        -: 1112:  // Parse optional stride and elements per stride.
    #####: 1113:  if (parser.parseTrailingOperandList(strideInfo))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1114:    return failure();
        -: 1115:
    #####: 1116:  bool isStrided = strideInfo.size() == 2;
branch  0 never executed
branch  1 never executed
    #####: 1117:  if (!strideInfo.empty() && !isStrided) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1118:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1119:                            "expected two stride related operands");
call    0 never executed
call    1 never executed
        -: 1120:  }
        -: 1121:
    #####: 1122:  if (parser.parseColonTypeList(types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1123:    return failure();
    #####: 1124:  if (types.size() != 3)
branch  0 never executed
branch  1 never executed
    #####: 1125:    return parser.emitError(parser.getNameLoc(), "fewer/more types expected");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1126:
    #####: 1127:  if (parser.resolveOperand(srcMemRefInfo, types[0], result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1128:      parser.resolveOperands(srcIndexInfos, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1129:      parser.resolveOperand(dstMemRefInfo, types[1], result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1130:      parser.resolveOperands(dstIndexInfos, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1131:      // size should be an index.
    #####: 1132:      parser.resolveOperand(numElementsInfo, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1133:      parser.resolveOperand(tagMemrefInfo, types[2], result.operands) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 1134:      // tag indices should be index.
    #####: 1135:      parser.resolveOperands(tagIndexInfos, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1136:    return failure();
        -: 1137:
    #####: 1138:  if (isStrided) {
branch  0 never executed
branch  1 never executed
    #####: 1139:    if (parser.resolveOperands(strideInfo, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1140:      return failure();
        -: 1141:  }
        -: 1142:
    #####: 1143:  return success();
        -: 1144:}
        -: 1145:
function _ZN4mlir6memref10DmaStartOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1146:LogicalResult DmaStartOp::verify() {
    #####: 1147:  unsigned numOperands = getNumOperands();
call    0 never executed
        -: 1148:
        -: 1149:  // Mandatory non-variadic operands are: src memref, dst memref, tag memref and
        -: 1150:  // the number of elements.
    #####: 1151:  if (numOperands < 4)
branch  0 never executed
branch  1 never executed
    #####: 1152:    return emitOpError("expected at least 4 operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1153:
        -: 1154:  // Check types of operands. The order of these calls is important: the later
        -: 1155:  // calls rely on some type properties to compute the operand position.
        -: 1156:  // 1. Source memref.
    #####: 1157:  if (!getSrcMemRef().getType().isa<MemRefType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1158:    return emitOpError("expected source to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1159:  if (numOperands < getSrcMemRefRank() + 4)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1160:    return emitOpError() << "expected at least " << getSrcMemRefRank() + 4
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1161:                         << " operands";
call    0 never executed
    #####: 1162:  if (!getSrcIndices().empty() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1163:      !llvm::all_of(getSrcIndices().getTypes(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1164:                    [](Type t) { return t.isIndex(); }))
    #####: 1165:    return emitOpError("expected source indices to be of index type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1166:
        -: 1167:  // 2. Destination memref.
    #####: 1168:  if (!getDstMemRef().getType().isa<MemRefType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1169:    return emitOpError("expected destination to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1170:  unsigned numExpectedOperands = getSrcMemRefRank() + getDstMemRefRank() + 4;
call    0 never executed
call    1 never executed
    #####: 1171:  if (numOperands < numExpectedOperands)
branch  0 never executed
branch  1 never executed
    #####: 1172:    return emitOpError() << "expected at least " << numExpectedOperands
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1173:                         << " operands";
call    0 never executed
    #####: 1174:  if (!getDstIndices().empty() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1175:      !llvm::all_of(getDstIndices().getTypes(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1176:                    [](Type t) { return t.isIndex(); }))
    #####: 1177:    return emitOpError("expected destination indices to be of index type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1178:
        -: 1179:  // 3. Number of elements.
    #####: 1180:  if (!getNumElements().getType().isIndex())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1181:    return emitOpError("expected num elements to be of index type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1182:
        -: 1183:  // 4. Tag memref.
    #####: 1184:  if (!getTagMemRef().getType().isa<MemRefType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1185:    return emitOpError("expected tag to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1186:  numExpectedOperands += getTagMemRefRank();
call    0 never executed
    #####: 1187:  if (numOperands < numExpectedOperands)
branch  0 never executed
branch  1 never executed
    #####: 1188:    return emitOpError() << "expected at least " << numExpectedOperands
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1189:                         << " operands";
call    0 never executed
    #####: 1190:  if (!getTagIndices().empty() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1191:      !llvm::all_of(getTagIndices().getTypes(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1192:                    [](Type t) { return t.isIndex(); }))
    #####: 1193:    return emitOpError("expected tag indices to be of index type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1194:
        -: 1195:  // Optional stride-related operands must be either both present or both
        -: 1196:  // absent.
    #####: 1197:  if (numOperands != numExpectedOperands &&
branch  0 never executed
branch  1 never executed
    #####: 1198:      numOperands != numExpectedOperands + 2)
branch  0 never executed
branch  1 never executed
    #####: 1199:    return emitOpError("incorrect number of operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1200:
        -: 1201:  // 5. Strides.
    #####: 1202:  if (isStrided()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1203:    if (!getStride().getType().isIndex() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1204:        !getNumElementsPerStride().getType().isIndex())
call    0 never executed
call    1 never executed
    #####: 1205:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1206:          "expected stride and num elements per stride to be of type index");
call    0 never executed
        -: 1207:  }
        -: 1208:
    #####: 1209:  return success();
        -: 1210:}
        -: 1211:
function _ZN4mlir6memref10DmaStartOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1212:LogicalResult DmaStartOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1213:                               SmallVectorImpl<OpFoldResult> &results) {
        -: 1214:  /// dma_start(memrefcast) -> dma_start
    #####: 1215:  return foldMemRefCast(*this);
call    0 never executed
        -: 1216:}
        -: 1217:
        -: 1218:// ---------------------------------------------------------------------------
        -: 1219:// DmaWaitOp
        -: 1220:// ---------------------------------------------------------------------------
        -: 1221:
function _ZN4mlir6memref9DmaWaitOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1222:LogicalResult DmaWaitOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1223:                              SmallVectorImpl<OpFoldResult> &results) {
        -: 1224:  /// dma_wait(memrefcast) -> dma_wait
    #####: 1225:  return foldMemRefCast(*this);
call    0 never executed
        -: 1226:}
        -: 1227:
function _ZN4mlir6memref9DmaWaitOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1228:LogicalResult DmaWaitOp::verify() {
        -: 1229:  // Check that the number of tag indices matches the tagMemRef rank.
    #####: 1230:  unsigned numTagIndices = getTagIndices().size();
call    0 never executed
call    1 never executed
    #####: 1231:  unsigned tagMemRefRank = getTagMemRefRank();
call    0 never executed
    #####: 1232:  if (numTagIndices != tagMemRefRank)
branch  0 never executed
branch  1 never executed
    #####: 1233:    return emitOpError() << "expected tagIndices to have the same number of "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1234:                            "elements as the tagMemRef rank, expected "
call    0 never executed
    #####: 1235:                         << tagMemRefRank << ", but got " << numTagIndices;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1236:  return success();
        -: 1237:}
        -: 1238:
        -: 1239://===----------------------------------------------------------------------===//
        -: 1240:// ExtractAlignedPointerAsIndexOp
        -: 1241://===----------------------------------------------------------------------===//
        -: 1242:
function _ZN4mlir6memref30ExtractAlignedPointerAsIndexOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1243:void ExtractAlignedPointerAsIndexOp::getAsmResultNames(
        -: 1244:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1245:  setNameFn(getResult(), "intptr");
call    0 never executed
    #####: 1246:}
        -: 1247:
        -: 1248://===----------------------------------------------------------------------===//
        -: 1249:// ExtractStridedMetadataOp
        -: 1250://===----------------------------------------------------------------------===//
        -: 1251:
        -: 1252:/// The number and type of the results are inferred from the
        -: 1253:/// shape of the source.
function _ZN4mlir6memref24ExtractStridedMetadataOp16inferReturnTypesEPNS_11MLIRContextEN4llvm8OptionalINS_8LocationEEENS_10ValueRangeENS_14DictionaryAttrENS_11RegionRangeERNS4_15SmallVectorImplINS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 1254:LogicalResult ExtractStridedMetadataOp::inferReturnTypes(
        -: 1255:    MLIRContext *context, Optional<Location> location, ValueRange operands,
        -: 1256:    DictionaryAttr attributes, RegionRange regions,
        -: 1257:    SmallVectorImpl<Type> &inferredReturnTypes) {
    #####: 1258:  ExtractStridedMetadataOpAdaptor extractAdaptor(operands, attributes, regions);
call    0 never executed
    #####: 1259:  auto sourceType = extractAdaptor.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 1260:  if (!sourceType)
branch  0 never executed
branch  1 never executed
    #####: 1261:    return failure();
        -: 1262:
    #####: 1263:  unsigned sourceRank = sourceType.getRank();
call    0 never executed
    #####: 1264:  IndexType indexType = IndexType::get(context);
call    0 never executed
    #####: 1265:  auto memrefType =
        -: 1266:      MemRefType::get({}, sourceType.getElementType(),
    #####: 1267:                      MemRefLayoutAttrInterface{}, sourceType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1268:  // Base.
    #####: 1269:  inferredReturnTypes.push_back(memrefType);
call    0 never executed
        -: 1270:  // Offset.
    #####: 1271:  inferredReturnTypes.push_back(indexType);
        -: 1272:  // Sizes and strides.
    #####: 1273:  for (unsigned i = 0; i < sourceRank * 2; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1274:    inferredReturnTypes.push_back(indexType);
call    0 never executed
    #####: 1275:  return success();
        -: 1276:}
        -: 1277:
function _ZN4mlir6memref24ExtractStridedMetadataOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1278:void ExtractStridedMetadataOp::getAsmResultNames(
        -: 1279:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1280:  setNameFn(getBaseBuffer(), "base_buffer");
call    0 never executed
call    1 never executed
    #####: 1281:  setNameFn(getOffset(), "offset");
call    0 never executed
call    1 never executed
        -: 1282:  // For multi-result to work properly with pretty names and packed syntax `x:3`
        -: 1283:  // we can only give a pretty name to the first value in the pack.
    #####: 1284:  if (!getSizes().empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1285:    setNameFn(getSizes().front(), "sizes");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1286:    setNameFn(getStrides().front(), "strides");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1287:  }
    #####: 1288:}
        -: 1289:
        -: 1290:/// Helper function to perform the replacement of all constant uses of `values`
        -: 1291:/// by a materialized constant extracted from `maybeConstants`.
        -: 1292:/// `values` and `maybeConstants` are expected to have the same size.
        -: 1293:template <typename Container>
    #####: 1294:static bool replaceConstantUsesOf(OpBuilder &rewriter, Location loc,
        -: 1295:                                  Container values,
        -: 1296:                                  ArrayRef<int64_t> maybeConstants,
        -: 1297:                                  llvm::function_ref<bool(int64_t)> isDynamic) {
    #####: 1298:  assert(values.size() == maybeConstants.size() &&
        -: 1299:         " expected values and maybeConstants of the same size");
    #####: 1300:  bool atLeastOneReplacement = false;
    #####: 1301:  for (auto [maybeConstant, result] : llvm::zip(maybeConstants, values)) {
        -: 1302:    // Don't materialize a constant if there are no uses: this would indice
        -: 1303:    // infinite loops in the driver.
    #####: 1304:    if (isDynamic(maybeConstant) || result.use_empty())
    #####: 1305:      continue;
    #####: 1306:    Value constantVal =
        -: 1307:        rewriter.create<arith::ConstantIndexOp>(loc, maybeConstant);
    #####: 1308:    for (Operation *op : llvm::make_early_inc_range(result.getUsers())) {
        -: 1309:      // updateRootInplace: lambda cannot capture structured bindings in C++17
        -: 1310:      // yet.
    #####: 1311:      op->replaceUsesOfWith(result, constantVal);
    #####: 1312:      atLeastOneReplacement = true;
        -: 1313:    }
        -: 1314:  }
    #####: 1315:  return atLeastOneReplacement;
        -: 1316:}
------------------
_Z21replaceConstantUsesOfIN4mlir11ResultRangeEEbRNS0_9OpBuilderENS0_8LocationET_N4llvm8ArrayRefIlEENS6_12function_refIFblEEE:
function _Z21replaceConstantUsesOfIN4mlir11ResultRangeEEbRNS0_9OpBuilderENS0_8LocationET_N4llvm8ArrayRefIlEENS6_12function_refIFblEEE called 0 returned 0% blocks executed 0%
    #####: 1294:static bool replaceConstantUsesOf(OpBuilder &rewriter, Location loc,
        -: 1295:                                  Container values,
        -: 1296:                                  ArrayRef<int64_t> maybeConstants,
        -: 1297:                                  llvm::function_ref<bool(int64_t)> isDynamic) {
    #####: 1298:  assert(values.size() == maybeConstants.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1299:         " expected values and maybeConstants of the same size");
    #####: 1300:  bool atLeastOneReplacement = false;
    #####: 1301:  for (auto [maybeConstant, result] : llvm::zip(maybeConstants, values)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1302:    // Don't materialize a constant if there are no uses: this would indice
        -: 1303:    // infinite loops in the driver.
    #####: 1304:    if (isDynamic(maybeConstant) || result.use_empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1305:      continue;
    #####: 1306:    Value constantVal =
call    0 never executed
        -: 1307:        rewriter.create<arith::ConstantIndexOp>(loc, maybeConstant);
    #####: 1308:    for (Operation *op : llvm::make_early_inc_range(result.getUsers())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1309:      // updateRootInplace: lambda cannot capture structured bindings in C++17
        -: 1310:      // yet.
    #####: 1311:      op->replaceUsesOfWith(result, constantVal);
call    0 never executed
    #####: 1312:      atLeastOneReplacement = true;
branch  0 never executed
branch  1 never executed
        -: 1313:    }
        -: 1314:  }
    #####: 1315:  return atLeastOneReplacement;
        -: 1316:}
------------------
_Z21replaceConstantUsesOfIN4llvm8ArrayRefIN4mlir6detail10TypedValueINS2_9IndexTypeEEEEEEbRNS2_9OpBuilderENS2_8LocationET_NS1_IlEENS0_12function_refIFblEEE:
function _Z21replaceConstantUsesOfIN4llvm8ArrayRefIN4mlir6detail10TypedValueINS2_9IndexTypeEEEEEEbRNS2_9OpBuilderENS2_8LocationET_NS1_IlEENS0_12function_refIFblEEE called 0 returned 0% blocks executed 0%
    #####: 1294:static bool replaceConstantUsesOf(OpBuilder &rewriter, Location loc,
        -: 1295:                                  Container values,
        -: 1296:                                  ArrayRef<int64_t> maybeConstants,
        -: 1297:                                  llvm::function_ref<bool(int64_t)> isDynamic) {
    #####: 1298:  assert(values.size() == maybeConstants.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1299:         " expected values and maybeConstants of the same size");
    #####: 1300:  bool atLeastOneReplacement = false;
    #####: 1301:  for (auto [maybeConstant, result] : llvm::zip(maybeConstants, values)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1302:    // Don't materialize a constant if there are no uses: this would indice
        -: 1303:    // infinite loops in the driver.
    #####: 1304:    if (isDynamic(maybeConstant) || result.use_empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1305:      continue;
    #####: 1306:    Value constantVal =
call    0 never executed
        -: 1307:        rewriter.create<arith::ConstantIndexOp>(loc, maybeConstant);
    #####: 1308:    for (Operation *op : llvm::make_early_inc_range(result.getUsers())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1309:      // updateRootInplace: lambda cannot capture structured bindings in C++17
        -: 1310:      // yet.
    #####: 1311:      op->replaceUsesOfWith(result, constantVal);
call    0 never executed
    #####: 1312:      atLeastOneReplacement = true;
branch  0 never executed
branch  1 never executed
        -: 1313:    }
        -: 1314:  }
    #####: 1315:  return atLeastOneReplacement;
        -: 1316:}
------------------
        -: 1317:
        -: 1318:LogicalResult
function _ZN4mlir6memref24ExtractStridedMetadataOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1319:ExtractStridedMetadataOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1320:                               SmallVectorImpl<OpFoldResult> &results) {
    #####: 1321:  OpBuilder builder(*this);
call    0 never executed
    #####: 1322:  auto memrefType = getSource().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1323:  SmallVector<int64_t> strides;
call    0 never executed
    #####: 1324:  int64_t offset;
    #####: 1325:  LogicalResult res = getStridesAndOffset(memrefType, strides, offset);
call    0 never executed
    #####: 1326:  (void)res;
    #####: 1327:  assert(succeeded(res) && "must be a strided memref type");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1328:
    #####: 1329:  bool atLeastOneReplacement = replaceConstantUsesOf(
call    0 never executed
call    1 never executed
    #####: 1330:      builder, getLoc(), ArrayRef<TypedValue<IndexType>>(getOffset()),
call    0 never executed
call    1 never executed
        -: 1331:      ArrayRef<int64_t>(offset), ShapedType::isDynamicStrideOrOffset);
    #####: 1332:  atLeastOneReplacement |=
call    0 never executed
    #####: 1333:      replaceConstantUsesOf(builder, getLoc(), getSizes(),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1334:                            memrefType.getShape(), ShapedType::isDynamic);
    #####: 1335:  atLeastOneReplacement |=
call    0 never executed
    #####: 1336:      replaceConstantUsesOf(builder, getLoc(), getStrides(), strides,
call    0 never executed
call    1 never executed
        -: 1337:                            ShapedType::isDynamicStrideOrOffset);
        -: 1338:
    #####: 1339:  return success(atLeastOneReplacement);
branch  0 never executed
branch  1 never executed
        -: 1340:}
        -: 1341:
        -: 1342://===----------------------------------------------------------------------===//
        -: 1343:// GenericAtomicRMWOp
        -: 1344://===----------------------------------------------------------------------===//
        -: 1345:
function _ZN4mlir6memref18GenericAtomicRMWOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1346:void GenericAtomicRMWOp::build(OpBuilder &builder, OperationState &result,
        -: 1347:                               Value memref, ValueRange ivs) {
    #####: 1348:  result.addOperands(memref);
call    0 never executed
call    1 never executed
    #####: 1349:  result.addOperands(ivs);
call    0 never executed
        -: 1350:
    #####: 1351:  if (auto memrefType = memref.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1352:    Type elementType = memrefType.getElementType();
call    0 never executed
    #####: 1353:    result.addTypes(elementType);
call    0 never executed
        -: 1354:
    #####: 1355:    Region *bodyRegion = result.addRegion();
call    0 never executed
    #####: 1356:    bodyRegion->push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1357:    bodyRegion->addArgument(elementType, memref.getLoc());
call    0 never executed
call    1 never executed
        -: 1358:  }
    #####: 1359:}
        -: 1360:
function _ZN4mlir6memref18GenericAtomicRMWOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1361:LogicalResult GenericAtomicRMWOp::verify() {
    #####: 1362:  auto &body = getRegion();
call    0 never executed
    #####: 1363:  if (body.getNumArguments() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1364:    return emitOpError("expected single number of entry block arguments");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1365:
    #####: 1366:  if (getResult().getType() != body.getArgument(0).getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1367:    return emitOpError("expected block argument of the same type result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1368:
    #####: 1369:  bool hasSideEffects =
function _ZZN4mlir6memref18GenericAtomicRMWOp6verifyEvENKUlPNS_9OperationEE_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1370:      body.walk([&](Operation *nestedOp) {
    #####: 1371:            if (MemoryEffectOpInterface::hasNoEffect(nestedOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1372:              return WalkResult::advance();
    #####: 1373:            nestedOp->emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1374:                "body of 'memref.generic_atomic_rmw' should contain "
        -: 1375:                "only operations with no side effects");
    #####: 1376:            return WalkResult::interrupt();
    #####: 1377:          })
call    0 never executed
    #####: 1378:          .wasInterrupted();
branch  0 never executed
branch  1 never executed
    #####: 1379:  return hasSideEffects ? failure() : success();
branch  0 never executed
branch  1 never executed
        -: 1380:}
        -: 1381:
function _ZN4mlir6memref18GenericAtomicRMWOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1382:ParseResult GenericAtomicRMWOp::parse(OpAsmParser &parser,
        -: 1383:                                      OperationState &result) {
    #####: 1384:  OpAsmParser::UnresolvedOperand memref;
call    0 never executed
    #####: 1385:  Type memrefType;
    #####: 1386:  SmallVector<OpAsmParser::UnresolvedOperand, 4> ivs;
call    0 never executed
        -: 1387:
    #####: 1388:  Type indexType = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 1389:  if (parser.parseOperand(memref) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1390:      parser.parseOperandList(ivs, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1391:      parser.parseColonType(memrefType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1392:      parser.resolveOperand(memref, memrefType, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1393:      parser.resolveOperands(ivs, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1394:    return failure();
        -: 1395:
    #####: 1396:  Region *body = result.addRegion();
call    0 never executed
    #####: 1397:  if (parser.parseRegion(*body, {}) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1398:      parser.parseOptionalAttrDict(result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1399:    return failure();
    #####: 1400:  result.types.push_back(memrefType.cast<MemRefType>().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1401:  return success();
        -: 1402:}
        -: 1403:
function _ZN4mlir6memref18GenericAtomicRMWOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1404:void GenericAtomicRMWOp::print(OpAsmPrinter &p) {
    #####: 1405:  p << ' ' << getMemref() << "[" << getIndices()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1406:    << "] : " << getMemref().getType() << ' ';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1407:  p.printRegion(getRegion());
call    0 never executed
call    1 never executed
    #####: 1408:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 1409:}
        -: 1410:
        -: 1411://===----------------------------------------------------------------------===//
        -: 1412:// AtomicYieldOp
        -: 1413://===----------------------------------------------------------------------===//
        -: 1414:
function _ZN4mlir6memref13AtomicYieldOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1415:LogicalResult AtomicYieldOp::verify() {
    #####: 1416:  Type parentType = (*this)->getParentOp()->getResultTypes().front();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1417:  Type resultType = getResult().getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1418:  if (parentType != resultType)
branch  0 never executed
branch  1 never executed
    #####: 1419:    return emitOpError() << "types mismatch between yield op: " << resultType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1420:                         << " and its parent: " << parentType;
call    0 never executed
call    1 never executed
    #####: 1421:  return success();
        -: 1422:}
        -: 1423:
        -: 1424://===----------------------------------------------------------------------===//
        -: 1425:// GlobalOp
        -: 1426://===----------------------------------------------------------------------===//
        -: 1427:
function _ZL38printGlobalMemrefOpTypeAndInitialValueRN4mlir12OpAsmPrinterENS_6memref8GlobalOpENS_8TypeAttrENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1428:static void printGlobalMemrefOpTypeAndInitialValue(OpAsmPrinter &p, GlobalOp op,
        -: 1429:                                                   TypeAttr type,
        -: 1430:                                                   Attribute initialValue) {
    #####: 1431:  p << type;
call    0 never executed
    #####: 1432:  if (!op.isExternal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1433:    p << " = ";
call    0 never executed
    #####: 1434:    if (op.isUninitialized())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1435:      p << "uninitialized";
call    0 never executed
        -: 1436:    else
    #####: 1437:      p.printAttributeWithoutType(initialValue);
call    0 never executed
        -: 1438:  }
    #####: 1439:}
        -: 1440:
        -: 1441:static ParseResult
function _ZL38parseGlobalMemrefOpTypeAndInitialValueRN4mlir11OpAsmParserERNS_8TypeAttrERNS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1442:parseGlobalMemrefOpTypeAndInitialValue(OpAsmParser &parser, TypeAttr &typeAttr,
        -: 1443:                                       Attribute &initialValue) {
    #####: 1444:  Type type;
    #####: 1445:  if (parser.parseType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1446:    return failure();
        -: 1447:
    #####: 1448:  auto memrefType = type.dyn_cast<MemRefType>();
call    0 never executed
    #####: 1449:  if (!memrefType || !memrefType.hasStaticShape())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1450:    return parser.emitError(parser.getNameLoc())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1451:           << "type should be static shaped memref, but got " << type;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1452:  typeAttr = TypeAttr::get(type);
call    0 never executed
        -: 1453:
    #####: 1454:  if (parser.parseOptionalEqual())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1455:    return success();
        -: 1456:
    #####: 1457:  if (succeeded(parser.parseOptionalKeyword("uninitialized"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1458:    initialValue = UnitAttr::get(parser.getContext());
call    0 never executed
call    1 never executed
    #####: 1459:    return success();
        -: 1460:  }
        -: 1461:
    #####: 1462:  Type tensorType = getTensorTypeFromMemRefType(memrefType);
call    0 never executed
    #####: 1463:  if (parser.parseAttribute(initialValue, tensorType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1464:    return failure();
    #####: 1465:  if (!initialValue.isa<ElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1466:    return parser.emitError(parser.getNameLoc())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1467:           << "initial value should be a unit or elements attribute";
call    0 never executed
call    1 never executed
    #####: 1468:  return success();
        -: 1469:}
        -: 1470:
function _ZN4mlir6memref8GlobalOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1471:LogicalResult GlobalOp::verify() {
    #####: 1472:  auto memrefType = getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 1473:  if (!memrefType || !memrefType.hasStaticShape())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1474:    return emitOpError("type should be static shaped memref, but got ")
call    0 never executed
call    1 never executed
    #####: 1475:           << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1476:
        -: 1477:  // Verify that the initial value, if present, is either a unit attribute or
        -: 1478:  // an elements attribute.
    #####: 1479:  if (getInitialValue().has_value()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1480:    Attribute initValue = getInitialValue().value();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1481:    if (!initValue.isa<UnitAttr>() && !initValue.isa<ElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1482:      return emitOpError("initial value should be a unit or elements "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1483:                         "attribute, but got ")
    #####: 1484:             << initValue;
call    0 never executed
        -: 1485:
        -: 1486:    // Check that the type of the initial value is compatible with the type of
        -: 1487:    // the global variable.
    #####: 1488:    if (auto elementsAttr = initValue.dyn_cast<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1489:      Type initType = elementsAttr.getType();
call    0 never executed
    #####: 1490:      Type tensorType = getTensorTypeFromMemRefType(memrefType);
call    0 never executed
    #####: 1491:      if (initType != tensorType)
branch  0 never executed
branch  1 never executed
    #####: 1492:        return emitOpError("initial value expected to be of type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1493:               << tensorType << ", but was of type " << initType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1494:    }
        -: 1495:  }
        -: 1496:
    #####: 1497:  if (Optional<uint64_t> alignAttr = getAlignment()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1498:    uint64_t alignment = *alignAttr;
branch  0 never executed
branch  1 never executed
        -: 1499:
    #####: 1500:    if (!llvm::isPowerOf2_64(alignment))
branch  0 never executed
branch  1 never executed
    #####: 1501:      return emitError() << "alignment attribute value " << alignment
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1502:                         << " is not a power of 2";
call    0 never executed
        -: 1503:  }
        -: 1504:
        -: 1505:  // TODO: verify visibility for declarations.
    #####: 1506:  return success();
        -: 1507:}
        -: 1508:
function _ZN4mlir6memref8GlobalOp20getConstantInitValueEv called 0 returned 0% blocks executed 0%
    #####: 1509:ElementsAttr GlobalOp::getConstantInitValue() {
    #####: 1510:  auto initVal = getInitialValue();
call    0 never executed
    #####: 1511:  if (getConstant() && initVal.has_value())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1512:    return initVal.value().cast<ElementsAttr>();
call    0 never executed
    #####: 1513:  return {};
call    0 never executed
        -: 1514:}
        -: 1515:
        -: 1516://===----------------------------------------------------------------------===//
        -: 1517:// GetGlobalOp
        -: 1518://===----------------------------------------------------------------------===//
        -: 1519:
        -: 1520:LogicalResult
function _ZN4mlir6memref11GetGlobalOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####: 1521:GetGlobalOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
        -: 1522:  // Verify that the result type is same as the type of the referenced
        -: 1523:  // memref.global op.
    #####: 1524:  auto global =
    #####: 1525:      symbolTable.lookupNearestSymbolFrom<GlobalOp>(*this, getNameAttr());
call    0 never executed
call    1 never executed
    #####: 1526:  if (!global)
branch  0 never executed
branch  1 never executed
    #####: 1527:    return emitOpError("'")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1528:           << getName() << "' does not reference a valid global memref";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1529:
    #####: 1530:  Type resultType = getResult().getType();
call    0 never executed
call    1 never executed
    #####: 1531:  if (global.getType() != resultType)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1532:    return emitOpError("result type ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1533:           << resultType << " does not match type " << global.getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1534:           << " of the global memref @" << getName();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1535:  return success();
        -: 1536:}
        -: 1537:
        -: 1538://===----------------------------------------------------------------------===//
        -: 1539:// LoadOp
        -: 1540://===----------------------------------------------------------------------===//
        -: 1541:
function _ZN4mlir6memref6LoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1542:LogicalResult LoadOp::verify() {
    #####: 1543:  if (getNumOperands() != 1 + getMemRefType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1544:    return emitOpError("incorrect number of indices for load");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1545:  return success();
        -: 1546:}
        -: 1547:
function _ZN4mlir6memref6LoadOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1548:OpFoldResult LoadOp::fold(ArrayRef<Attribute> cstOperands) {
        -: 1549:  /// load(memrefcast) -> load
    #####: 1550:  if (succeeded(foldMemRefCast(*this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1551:    return getResult();
call    0 never executed
call    1 never executed
    #####: 1552:  return OpFoldResult();
        -: 1553:}
        -: 1554:
        -: 1555://===----------------------------------------------------------------------===//
        -: 1556:// PrefetchOp
        -: 1557://===----------------------------------------------------------------------===//
        -: 1558:
function _ZN4mlir6memref10PrefetchOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1559:void PrefetchOp::print(OpAsmPrinter &p) {
    #####: 1560:  p << " " << getMemref() << '[';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1561:  p.printOperands(getIndices());
call    0 never executed
call    1 never executed
    #####: 1562:  p << ']' << ", " << (getIsWrite() ? "write" : "read");
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1563:  p << ", locality<" << getLocalityHint();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1564:  p << ">, " << (getIsDataCache() ? "data" : "instr");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1565:  p.printOptionalAttrDict(
call    0 never executed
        -: 1566:      (*this)->getAttrs(),
    #####: 1567:      /*elidedAttrs=*/{"localityHint", "isWrite", "isDataCache"});
call    0 never executed
    #####: 1568:  p << " : " << getMemRefType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1569:}
        -: 1570:
function _ZN4mlir6memref10PrefetchOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1571:ParseResult PrefetchOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 1572:  OpAsmParser::UnresolvedOperand memrefInfo;
call    0 never executed
    #####: 1573:  SmallVector<OpAsmParser::UnresolvedOperand, 4> indexInfo;
call    0 never executed
    #####: 1574:  IntegerAttr localityHint;
    #####: 1575:  MemRefType type;
    #####: 1576:  StringRef readOrWrite, cacheType;
        -: 1577:
    #####: 1578:  auto indexTy = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 1579:  auto i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####: 1580:  if (parser.parseOperand(memrefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1581:      parser.parseOperandList(indexInfo, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1582:      parser.parseComma() || parser.parseKeyword(&readOrWrite) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1583:      parser.parseComma() || parser.parseKeyword("locality") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1584:      parser.parseLess() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1585:      parser.parseAttribute(localityHint, i32Type, "localityHint",
    #####: 1586:                            result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1587:      parser.parseGreater() || parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1588:      parser.parseKeyword(&cacheType) || parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1589:      parser.resolveOperand(memrefInfo, type, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1590:      parser.resolveOperands(indexInfo, indexTy, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1591:    return failure();
        -: 1592:
    #####: 1593:  if (!readOrWrite.equals("read") && !readOrWrite.equals("write"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1594:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1595:                            "rw specifier has to be 'read' or 'write'");
call    0 never executed
call    1 never executed
    #####: 1596:  result.addAttribute(
call    0 never executed
        -: 1597:      PrefetchOp::getIsWriteAttrStrName(),
    #####: 1598:      parser.getBuilder().getBoolAttr(readOrWrite.equals("write")));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1599:
    #####: 1600:  if (!cacheType.equals("data") && !cacheType.equals("instr"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1601:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1602:                            "cache type has to be 'data' or 'instr'");
call    0 never executed
call    1 never executed
        -: 1603:
    #####: 1604:  result.addAttribute(
call    0 never executed
        -: 1605:      PrefetchOp::getIsDataCacheAttrStrName(),
    #####: 1606:      parser.getBuilder().getBoolAttr(cacheType.equals("data")));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1607:
    #####: 1608:  return success();
        -: 1609:}
        -: 1610:
function _ZN4mlir6memref10PrefetchOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1611:LogicalResult PrefetchOp::verify() {
    #####: 1612:  if (getNumOperands() != 1 + getMemRefType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1613:    return emitOpError("too few indices");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1614:
    #####: 1615:  return success();
        -: 1616:}
        -: 1617:
function _ZN4mlir6memref10PrefetchOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1618:LogicalResult PrefetchOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1619:                               SmallVectorImpl<OpFoldResult> &results) {
        -: 1620:  // prefetch(memrefcast) -> prefetch
    #####: 1621:  return foldMemRefCast(*this);
call    0 never executed
        -: 1622:}
        -: 1623:
        -: 1624://===----------------------------------------------------------------------===//
        -: 1625:// RankOp
        -: 1626://===----------------------------------------------------------------------===//
        -: 1627:
function _ZN4mlir6memref6RankOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1628:OpFoldResult RankOp::fold(ArrayRef<Attribute> operands) {
        -: 1629:  // Constant fold rank when the rank of the operand is known.
    #####: 1630:  auto type = getOperand().getType();
call    0 never executed
call    1 never executed
    #####: 1631:  auto shapedType = type.dyn_cast<ShapedType>();
call    0 never executed
    #####: 1632:  if (shapedType && shapedType.hasRank())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1633:    return IntegerAttr::get(IndexType::get(getContext()), shapedType.getRank());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1634:  return IntegerAttr();
call    0 never executed
        -: 1635:}
        -: 1636:
        -: 1637://===----------------------------------------------------------------------===//
        -: 1638:// ReinterpretCastOp
        -: 1639://===----------------------------------------------------------------------===//
        -: 1640:
function _ZN4mlir6memref17ReinterpretCastOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1641:void ReinterpretCastOp::getAsmResultNames(
        -: 1642:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1643:  setNameFn(getResult(), "reinterpret_cast");
call    0 never executed
call    1 never executed
    #####: 1644:}
        -: 1645:
        -: 1646:/// Build a ReinterpretCastOp with all dynamic entries: `staticOffsets`,
        -: 1647:/// `staticSizes` and `staticStrides` are automatically filled with
        -: 1648:/// source-memref-rank sentinel values that encode dynamic entries.
function _ZN4mlir6memref17ReinterpretCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueENS_12OpFoldResultEN4llvm8ArrayRefIS8_EESB_NSA_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1649:void ReinterpretCastOp::build(OpBuilder &b, OperationState &result,
        -: 1650:                              MemRefType resultType, Value source,
        -: 1651:                              OpFoldResult offset, ArrayRef<OpFoldResult> sizes,
        -: 1652:                              ArrayRef<OpFoldResult> strides,
        -: 1653:                              ArrayRef<NamedAttribute> attrs) {
    #####: 1654:  SmallVector<int64_t> staticOffsets, staticSizes, staticStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1655:  SmallVector<Value> dynamicOffsets, dynamicSizes, dynamicStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1656:  dispatchIndexOpFoldResults(offset, dynamicOffsets, staticOffsets,
call    0 never executed
        -: 1657:                             ShapedType::kDynamicStrideOrOffset);
    #####: 1658:  dispatchIndexOpFoldResults(sizes, dynamicSizes, staticSizes,
call    0 never executed
        -: 1659:                             ShapedType::kDynamicSize);
    #####: 1660:  dispatchIndexOpFoldResults(strides, dynamicStrides, staticStrides,
call    0 never executed
        -: 1661:                             ShapedType::kDynamicStrideOrOffset);
    #####: 1662:  build(b, result, resultType, source, dynamicOffsets, dynamicSizes,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 1663:        dynamicStrides, b.getI64ArrayAttr(staticOffsets),
        -: 1664:        b.getI64ArrayAttr(staticSizes), b.getI64ArrayAttr(staticStrides));
    #####: 1665:  result.addAttributes(attrs);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1666:}
        -: 1667:
function _ZN4mlir6memref17ReinterpretCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueElN4llvm8ArrayRefIlEESA_NS9_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1668:void ReinterpretCastOp::build(OpBuilder &b, OperationState &result,
        -: 1669:                              MemRefType resultType, Value source,
        -: 1670:                              int64_t offset, ArrayRef<int64_t> sizes,
        -: 1671:                              ArrayRef<int64_t> strides,
        -: 1672:                              ArrayRef<NamedAttribute> attrs) {
    #####: 1673:  SmallVector<OpFoldResult> sizeValues =
function _ZZN4mlir6memref17ReinterpretCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueElN4llvm8ArrayRefIlEESA_NS9_INS_14NamedAttributeEEEENKUllE_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1674:      llvm::to_vector<4>(llvm::map_range(sizes, [&](int64_t v) -> OpFoldResult {
branch  0 never executed
branch  1 never executed
    #####: 1675:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 1676:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1677:  SmallVector<OpFoldResult> strideValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir6memref17ReinterpretCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueElN4llvm8ArrayRefIlEESA_NS9_INS_14NamedAttributeEEEENKUllE0_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1678:      llvm::map_range(strides, [&](int64_t v) -> OpFoldResult {
    #####: 1679:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 1680:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1681:  build(b, result, resultType, source, b.getI64IntegerAttr(offset), sizeValues,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1682:        strideValues, attrs);
    #####: 1683:}
        -: 1684:
function _ZN4mlir6memref17ReinterpretCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueES7_NS_10ValueRangeES8_N4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1685:void ReinterpretCastOp::build(OpBuilder &b, OperationState &result,
        -: 1686:                              MemRefType resultType, Value source, Value offset,
        -: 1687:                              ValueRange sizes, ValueRange strides,
        -: 1688:                              ArrayRef<NamedAttribute> attrs) {
    #####: 1689:  SmallVector<OpFoldResult> sizeValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
    #####: 1690:      llvm::map_range(sizes, [](Value v) -> OpFoldResult { return v; }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1691:  SmallVector<OpFoldResult> strideValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
    #####: 1692:      llvm::map_range(strides, [](Value v) -> OpFoldResult { return v; }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1693:  build(b, result, resultType, source, offset, sizeValues, strideValues, attrs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1694:}
        -: 1695:
        -: 1696:// TODO: ponder whether we want to allow missing trailing sizes/strides that are
        -: 1697:// completed automatically, like we have for subview and extract_slice.
function _ZN4mlir6memref17ReinterpretCastOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1698:LogicalResult ReinterpretCastOp::verify() {
        -: 1699:  // The source and result memrefs should be in the same memory space.
    #####: 1700:  auto srcType = getSource().getType().cast<BaseMemRefType>();
call    0 never executed
call    1 never executed
    #####: 1701:  auto resultType = getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 1702:  if (srcType.getMemorySpace() != resultType.getMemorySpace())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1703:    return emitError("different memory spaces specified for source type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1704:           << srcType << " and result memref type " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1705:  if (srcType.getElementType() != resultType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1706:    return emitError("different element types specified for source type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1707:           << srcType << " and result memref type " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1708:
        -: 1709:  // Match sizes in result memref type and in static_sizes attribute.
    #####: 1710:  for (auto &en : llvm::enumerate(llvm::zip(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1711:           resultType.getShape(), extractFromI64ArrayAttr(getStaticSizes())))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
    #####: 1712:    int64_t resultSize = std::get<0>(en.value());
branch  0 never executed
branch  1 never executed
    #####: 1713:    int64_t expectedSize = std::get<1>(en.value());
branch  0 never executed
branch  1 never executed
    #####: 1714:    if (!ShapedType::isDynamic(resultSize) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1715:        !ShapedType::isDynamic(expectedSize) && resultSize != expectedSize)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1716:      return emitError("expected result type with size = ")
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1717:             << expectedSize << " instead of " << resultSize
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1718:             << " in dim = " << en.index();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1719:  }
        -: 1720:
        -: 1721:  // Match offset and strides in static_offset and static_strides attributes. If
        -: 1722:  // result memref type has no affine map specified, this will assume an
        -: 1723:  // identity layout.
    #####: 1724:  int64_t resultOffset;
    #####: 1725:  SmallVector<int64_t, 4> resultStrides;
call    0 never executed
    #####: 1726:  if (failed(getStridesAndOffset(resultType, resultStrides, resultOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1727:    return emitError("expected result type to have strided layout but found ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1728:           << resultType;
call    0 never executed
        -: 1729:
        -: 1730:  // Match offset in result memref type and in static_offsets attribute.
    #####: 1731:  int64_t expectedOffset = extractFromI64ArrayAttr(getStaticOffsets()).front();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1732:  if (!ShapedType::isDynamicStrideOrOffset(resultOffset) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1733:      !ShapedType::isDynamicStrideOrOffset(expectedOffset) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1734:      resultOffset != expectedOffset)
    #####: 1735:    return emitError("expected result type with offset = ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1736:           << resultOffset << " instead of " << expectedOffset;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1737:
        -: 1738:  // Match strides in result memref type and in static_strides attribute.
    #####: 1739:  for (auto &en : llvm::enumerate(llvm::zip(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1740:           resultStrides, extractFromI64ArrayAttr(getStaticStrides())))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####: 1741:    int64_t resultStride = std::get<0>(en.value());
branch  0 never executed
branch  1 never executed
    #####: 1742:    int64_t expectedStride = std::get<1>(en.value());
branch  0 never executed
branch  1 never executed
    #####: 1743:    if (!ShapedType::isDynamicStrideOrOffset(resultStride) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1744:        !ShapedType::isDynamicStrideOrOffset(expectedStride) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1745:        resultStride != expectedStride)
    #####: 1746:      return emitError("expected result type with stride = ")
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1747:             << expectedStride << " instead of " << resultStride
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1748:             << " in dim = " << en.index();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1749:  }
        -: 1750:
    #####: 1751:  return success();
branch  0 never executed
branch  1 never executed
        -: 1752:}
        -: 1753:
function _ZN4mlir6memref17ReinterpretCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1754:OpFoldResult ReinterpretCastOp::fold(ArrayRef<Attribute> /*operands*/) {
    #####: 1755:  Value src = getSource();
call    0 never executed
function _ZZN4mlir6memref17ReinterpretCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1756:  auto getPrevSrc = [&]() -> Value {
        -: 1757:    // reinterpret_cast(reinterpret_cast(x)) -> reinterpret_cast(x).
    #####: 1758:    if (auto prev = src.getDefiningOp<ReinterpretCastOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1759:      return prev.getSource();
call    0 never executed
        -: 1760:
        -: 1761:    // reinterpret_cast(cast(x)) -> reinterpret_cast(x).
    #####: 1762:    if (auto prev = src.getDefiningOp<CastOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1763:      return prev.getSource();
call    0 never executed
        -: 1764:
        -: 1765:    // reinterpret_cast(subview(x)) -> reinterpret_cast(x) if subview offsets
        -: 1766:    // are 0.
    #####: 1767:    if (auto prev = src.getDefiningOp<SubViewOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1768:      if (llvm::all_of(prev.getMixedOffsets(), [](OpFoldResult val) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1769:            return isConstantIntValue(val, 0);
        -: 1770:          }))
    #####: 1771:        return prev.getSource();
call    0 never executed
        -: 1772:
    #####: 1773:    return nullptr;
    #####: 1774:  };
        -: 1775:
    #####: 1776:  if (auto prevSrc = getPrevSrc()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1777:    getSourceMutable().assign(prevSrc);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1778:    return getResult();
call    0 never executed
call    1 never executed
        -: 1779:  }
        -: 1780:
    #####: 1781:  return nullptr;
        -: 1782:}
        -: 1783:
        -: 1784:namespace {
        -: 1785:/// Replace reinterpret_cast(extract_strided_metadata memref) -> memref.
        -: 1786:struct ReinterpretCastOpExtractStridedMetadataFolder
        -: 1787:    : public OpRewritePattern<ReinterpretCastOp> {
        -: 1788:public:
        -: 1789:  using OpRewritePattern<ReinterpretCastOp>::OpRewritePattern;
        -: 1790:
function _ZNK12_GLOBAL__N_145ReinterpretCastOpExtractStridedMetadataFolder15matchAndRewriteEN4mlir6memref17ReinterpretCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1791:  LogicalResult matchAndRewrite(ReinterpretCastOp op,
        -: 1792:                                PatternRewriter &rewriter) const override {
    #####: 1793:    auto extractStridedMetadata =
call    0 never executed
    #####: 1794:        op.getSource().getDefiningOp<ExtractStridedMetadataOp>();
call    0 never executed
    #####: 1795:    if (!extractStridedMetadata)
branch  0 never executed
branch  1 never executed
    #####: 1796:      return failure();
        -: 1797:    // Check if the reinterpret cast reconstructs a memref with the exact same
        -: 1798:    // properties as the extract strided metadata.
        -: 1799:
        -: 1800:    // First, check that the strides are the same.
    #####: 1801:    if (extractStridedMetadata.getStrides().size() != op.getStrides().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1802:      return failure();
    #####: 1803:    for (auto [extractStride, reinterpretStride] :
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1804:         llvm::zip(extractStridedMetadata.getStrides(), op.getStrides()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1805:      if (extractStride != reinterpretStride)
branch  0 never executed
branch  1 never executed
    #####: 1806:        return failure();
        -: 1807:
        -: 1808:    // Second, check the sizes.
    #####: 1809:    if (extractStridedMetadata.getSizes().size() != op.getSizes().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1810:      return failure();
    #####: 1811:    for (auto [extractSize, reinterpretSize] :
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1812:         llvm::zip(extractStridedMetadata.getSizes(), op.getSizes()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1813:      if (extractSize != reinterpretSize)
branch  0 never executed
branch  1 never executed
    #####: 1814:        return failure();
        -: 1815:
        -: 1816:    // Finally, check the offset.
    #####: 1817:    if (op.getOffsets().size() != 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1818:        extractStridedMetadata.getOffset() != *op.getOffsets().begin())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1819:      return failure();
        -: 1820:
        -: 1821:    // At this point, we know that the back and forth between extract strided
        -: 1822:    // metadata and reinterpret cast is a noop. However, the final type of the
        -: 1823:    // reinterpret cast may not be exactly the same as the original memref.
        -: 1824:    // E.g., it could be changing a dimension from static to dynamic. Check that
        -: 1825:    // here and add a cast if necessary.
    #####: 1826:    Type srcTy = extractStridedMetadata.getSource().getType();
call    0 never executed
call    1 never executed
    #####: 1827:    if (srcTy == op.getResult().getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1828:      rewriter.replaceOp(op, extractStridedMetadata.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1829:    else
    #####: 1830:      rewriter.replaceOpWithNewOp<CastOp>(op, op.getType(),
call    0 never executed
    #####: 1831:                                          extractStridedMetadata.getSource());
call    0 never executed
call    1 never executed
        -: 1832:
    #####: 1833:    return success();
        -: 1834:  }
        -: 1835:};
        -: 1836:} // namespace
        -: 1837:
function _ZN4mlir6memref17ReinterpretCastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 1838:void ReinterpretCastOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1839:                                                    MLIRContext *context) {
     1446: 1840:  results.add<ReinterpretCastOpExtractStridedMetadataFolder>(context);
call    0 returned 100%
     1446: 1841:}
        -: 1842:
        -: 1843://===----------------------------------------------------------------------===//
        -: 1844:// Reassociative reshape ops
        -: 1845://===----------------------------------------------------------------------===//
        -: 1846:
function _ZN4mlir6memref15CollapseShapeOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1847:void CollapseShapeOp::getAsmResultNames(
        -: 1848:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1849:  setNameFn(getResult(), "collapse_shape");
call    0 never executed
call    1 never executed
    #####: 1850:}
        -: 1851:
function _ZN4mlir6memref13ExpandShapeOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1852:void ExpandShapeOp::getAsmResultNames(
        -: 1853:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1854:  setNameFn(getResult(), "expand_shape");
call    0 never executed
call    1 never executed
    #####: 1855:}
        -: 1856:
        -: 1857:/// Helper function for verifying the shape of ExpandShapeOp and ResultShapeOp
        -: 1858:/// result and operand. Layout maps are verified separately.
        -: 1859:///
        -: 1860:/// If `allowMultipleDynamicDimsPerGroup`, multiple dynamic dimensions are
        -: 1861:/// allowed in a reassocation group.
        -: 1862:static LogicalResult
function _ZL20verifyCollapsedShapePN4mlir9OperationEN4llvm8ArrayRefIlEES4_NS3_INS2_11SmallVectorIlLj2EEEEEb called 0 returned 0% blocks executed 0%
    #####: 1863:verifyCollapsedShape(Operation *op, ArrayRef<int64_t> collapsedShape,
        -: 1864:                     ArrayRef<int64_t> expandedShape,
        -: 1865:                     ArrayRef<ReassociationIndices> reassociation,
        -: 1866:                     bool allowMultipleDynamicDimsPerGroup) {
        -: 1867:  // There must be one reassociation group per collapsed dimension.
    #####: 1868:  if (collapsedShape.size() != reassociation.size())
branch  0 never executed
branch  1 never executed
    #####: 1869:    return op->emitOpError("invalid number of reassociation groups: found ")
call    0 never executed
call    1 never executed
    #####: 1870:           << reassociation.size() << ", expected " << collapsedShape.size();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1871:
        -: 1872:  // The next expected expanded dimension index (while iterating over
        -: 1873:  // reassociation indices).
    #####: 1874:  int64_t nextDim = 0;
    #####: 1875:  for (const auto &it : llvm::enumerate(reassociation)) {
branch  0 never executed
branch  1 never executed
    #####: 1876:    ReassociationIndices group = it.value();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1877:    int64_t collapsedDim = it.index();
        -: 1878:
    #####: 1879:    bool foundDynamic = false;
    #####: 1880:    for (int64_t expandedDim : group) {
branch  0 never executed
branch  1 never executed
    #####: 1881:      if (expandedDim != nextDim++)
branch  0 never executed
branch  1 never executed
    #####: 1882:        return op->emitOpError("reassociation indices must be contiguous");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1883:
    #####: 1884:      if (expandedDim >= static_cast<int64_t>(expandedShape.size()))
branch  0 never executed
branch  1 never executed
    #####: 1885:        return op->emitOpError("reassociation index ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1886:               << expandedDim << " is out of bounds";
call    0 never executed
call    1 never executed
        -: 1887:
        -: 1888:      // Check if there are multiple dynamic dims in a reassociation group.
    #####: 1889:      if (ShapedType::isDynamic(expandedShape[expandedDim])) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1890:        if (foundDynamic && !allowMultipleDynamicDimsPerGroup)
branch  0 never executed
branch  1 never executed
    #####: 1891:          return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1892:              "at most one dimension in a reassociation group may be dynamic");
call    0 never executed
        -: 1893:        foundDynamic = true;
        -: 1894:      }
        -: 1895:    }
        -: 1896:
        -: 1897:    // ExpandShapeOp/CollapseShapeOp may not be used to cast dynamicity.
    #####: 1898:    if (ShapedType::isDynamic(collapsedShape[collapsedDim]) != foundDynamic)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1899:      return op->emitOpError("collapsed dim (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1900:             << collapsedDim
call    0 never executed
        -: 1901:             << ") must be dynamic if and only if reassociation group is "
    #####: 1902:                "dynamic";
call    0 never executed
        -: 1903:
        -: 1904:    // If all dims in the reassociation group are static, the size of the
        -: 1905:    // collapsed dim can be verified.
    #####: 1906:    if (!foundDynamic) {
branch  0 never executed
branch  1 never executed
    #####: 1907:      int64_t groupSize = 1;
    #####: 1908:      for (int64_t expandedDim : group)
branch  0 never executed
branch  1 never executed
    #####: 1909:        groupSize *= expandedShape[expandedDim];
branch  0 never executed
branch  1 never executed
    #####: 1910:      if (groupSize != collapsedShape[collapsedDim])
branch  0 never executed
branch  1 never executed
    #####: 1911:        return op->emitOpError("collapsed dim size (")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1912:               << collapsedShape[collapsedDim]
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1913:               << ") must equal reassociation group size (" << groupSize << ")";
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1914:    }
        -: 1915:  }
        -: 1916:
    #####: 1917:  if (collapsedShape.empty()) {
branch  0 never executed
branch  1 never executed
        -: 1918:    // Rank 0: All expanded dimensions must be 1.
    #####: 1919:    for (int64_t d : expandedShape)
branch  0 never executed
branch  1 never executed
    #####: 1920:      if (d != 1)
branch  0 never executed
branch  1 never executed
    #####: 1921:        return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1922:            "rank 0 memrefs can only be extended/collapsed with/from ones");
call    0 never executed
    #####: 1923:  } else if (nextDim != static_cast<int64_t>(expandedShape.size())) {
branch  0 never executed
branch  1 never executed
        -: 1924:    // Rank >= 1: Number of dimensions among all reassociation groups must match
        -: 1925:    // the result memref rank.
    #####: 1926:    return op->emitOpError("expanded rank (")
call    0 never executed
call    1 never executed
    #####: 1927:           << expandedShape.size()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1928:           << ") inconsistent with number of reassociation indices (" << nextDim
call    0 never executed
call    1 never executed
    #####: 1929:           << ")";
call    0 never executed
        -: 1930:  }
        -: 1931:
    #####: 1932:  return success();
        -: 1933:}
        -: 1934:
function _ZN4mlir6memref15CollapseShapeOp20getReassociationMapsEv called 0 returned 0% blocks executed 0%
    #####: 1935:SmallVector<AffineMap, 4> CollapseShapeOp::getReassociationMaps() {
    #####: 1936:  return getSymbolLessAffineMaps(getReassociationExprs());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1937:}
        -: 1938:
function _ZN4mlir6memref15CollapseShapeOp21getReassociationExprsEv called 0 returned 0% blocks executed 0%
    #####: 1939:SmallVector<ReassociationExprs, 4> CollapseShapeOp::getReassociationExprs() {
    #####: 1940:  return convertReassociationIndicesToExprs(getContext(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1941:                                            getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1942:}
        -: 1943:
function _ZN4mlir6memref13ExpandShapeOp20getReassociationMapsEv called 0 returned 0% blocks executed 0%
    #####: 1944:SmallVector<AffineMap, 4> ExpandShapeOp::getReassociationMaps() {
    #####: 1945:  return getSymbolLessAffineMaps(getReassociationExprs());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1946:}
        -: 1947:
function _ZN4mlir6memref13ExpandShapeOp21getReassociationExprsEv called 0 returned 0% blocks executed 0%
    #####: 1948:SmallVector<ReassociationExprs, 4> ExpandShapeOp::getReassociationExprs() {
    #####: 1949:  return convertReassociationIndicesToExprs(getContext(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1950:                                            getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1951:}
        -: 1952:
        -: 1953:/// Compute the layout map after expanding a given source MemRef type with the
        -: 1954:/// specified reassociation indices.
        -: 1955:static FailureOr<StridedLayoutAttr>
function _ZL24computeExpandedLayoutMapN4mlir10MemRefTypeEN4llvm8ArrayRefIlEENS2_INS1_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1956:computeExpandedLayoutMap(MemRefType srcType, ArrayRef<int64_t> resultShape,
        -: 1957:                         ArrayRef<ReassociationIndices> reassociation) {
    #####: 1958:  int64_t srcOffset;
    #####: 1959:  SmallVector<int64_t> srcStrides;
call    0 never executed
    #####: 1960:  if (failed(getStridesAndOffset(srcType, srcStrides, srcOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1961:    return failure();
    #####: 1962:  assert(srcStrides.size() == reassociation.size() && "invalid reassociation");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1963:
        -: 1964:  // 1-1 mapping between srcStrides and reassociation packs.
        -: 1965:  // Each srcStride starts with the given value and gets expanded according to
        -: 1966:  // the proper entries in resultShape.
        -: 1967:  // Example:
        -: 1968:  //   srcStrides     =                   [10000,  1 ,    100   ],
        -: 1969:  //   reassociations =                   [  [0], [1], [2, 3, 4]],
        -: 1970:  //   resultSizes    = [2, 5, 4, 3, 2] = [  [2], [5], [4, 3, 2]]
        -: 1971:  //     -> For the purpose of stride calculation, the useful sizes are:
        -: 1972:  //                    [x, x, x, 3, 2] = [  [x], [x], [x, 3, 2]].
        -: 1973:  //   resultStrides = [10000, 1, 600, 200, 100]
        -: 1974:  // Note that a stride does not get expanded along the first entry of each
        -: 1975:  // shape pack.
    #####: 1976:  SmallVector<int64_t> reverseResultStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1977:  reverseResultStrides.reserve(resultShape.size());
branch  0 never executed
branch  1 never executed
    #####: 1978:  unsigned shapeIndex = resultShape.size() - 1;
    #####: 1979:  for (auto it : llvm::reverse(llvm::zip(reassociation, srcStrides))) {
branch  0 never executed
branch  1 never executed
    #####: 1980:    ReassociationIndices reassoc = std::get<0>(it);
branch  0 never executed
branch  1 never executed
    #####: 1981:    int64_t currentStrideToExpand = std::get<1>(it);
    #####: 1982:    for (unsigned idx = 0, e = reassoc.size(); idx < e; ++idx) {
branch  0 never executed
branch  1 never executed
    #####: 1983:      using saturated_arith::Wrapper;
    #####: 1984:      reverseResultStrides.push_back(currentStrideToExpand);
call    0 never executed
    #####: 1985:      currentStrideToExpand = (Wrapper::stride(currentStrideToExpand) *
    #####: 1986:                               Wrapper::size(resultShape[shapeIndex--]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1987:                                  .asStride();
        -: 1988:    }
        -: 1989:  }
    #####: 1990:  auto resultStrides = llvm::to_vector<8>(llvm::reverse(reverseResultStrides));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1991:  resultStrides.resize(resultShape.size(), 1);
call    0 never executed
    #####: 1992:  return StridedLayoutAttr::get(srcType.getContext(), srcOffset, resultStrides);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1993:}
        -: 1994:
function _ZN4mlir6memref13ExpandShapeOp19computeExpandedTypeENS_10MemRefTypeEN4llvm8ArrayRefIlEENS4_INS3_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1995:FailureOr<MemRefType> ExpandShapeOp::computeExpandedType(
        -: 1996:    MemRefType srcType, ArrayRef<int64_t> resultShape,
        -: 1997:    ArrayRef<ReassociationIndices> reassociation) {
    #####: 1998:  if (srcType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1999:    // If the source is contiguous (i.e., no layout map specified), so is the
        -: 2000:    // result.
    #####: 2001:    MemRefLayoutAttrInterface layout;
call    0 never executed
    #####: 2002:    return MemRefType::get(resultShape, srcType.getElementType(), layout,
    #####: 2003:                           srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2004:  }
        -: 2005:
        -: 2006:  // Source may not be contiguous. Compute the layout map.
    #####: 2007:  FailureOr<StridedLayoutAttr> computedLayout =
    #####: 2008:      computeExpandedLayoutMap(srcType, resultShape, reassociation);
call    0 never executed
    #####: 2009:  if (failed(computedLayout))
branch  0 never executed
branch  1 never executed
    #####: 2010:    return failure();
    #####: 2011:  return MemRefType::get(resultShape, srcType.getElementType(), *computedLayout,
call    0 never executed
    #####: 2012:                         srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2013:}
        -: 2014:
function _ZN4mlir6memref13ExpandShapeOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm8ArrayRefIlEENS_5ValueENS7_INS6_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 2015:void ExpandShapeOp::build(OpBuilder &builder, OperationState &result,
        -: 2016:                          ArrayRef<int64_t> resultShape, Value src,
        -: 2017:                          ArrayRef<ReassociationIndices> reassociation) {
        -: 2018:  // Only ranked memref source values are supported.
    #####: 2019:  auto srcType = src.getType().cast<MemRefType>();
call    0 never executed
    #####: 2020:  FailureOr<MemRefType> resultType =
    #####: 2021:      ExpandShapeOp::computeExpandedType(srcType, resultShape, reassociation);
call    0 never executed
        -: 2022:  // Failure of this assertion usually indicates a problem with the source
        -: 2023:  // type, e.g., could not get strides/offset.
    #####: 2024:  assert(succeeded(resultType) && "could not compute layout");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2025:  build(builder, result, *resultType, src, reassociation);
call    0 never executed
    #####: 2026:}
        -: 2027:
function _ZN4mlir6memref13ExpandShapeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2028:LogicalResult ExpandShapeOp::verify() {
    #####: 2029:  MemRefType srcType = getSrcType();
call    0 never executed
    #####: 2030:  MemRefType resultType = getResultType();
call    0 never executed
        -: 2031:
        -: 2032:  // Verify result shape.
    #####: 2033:  if (failed(verifyCollapsedShape(getOperation(), srcType.getShape(),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2034:                                  resultType.getShape(),
    #####: 2035:                                  getReassociationIndices(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2036:                                  /*allowMultipleDynamicDimsPerGroup=*/false)))
    #####: 2037:    return failure();
        -: 2038:
        -: 2039:  // Compute expected result type (including layout map).
    #####: 2040:  FailureOr<MemRefType> expectedResultType = ExpandShapeOp::computeExpandedType(
    #####: 2041:      srcType, resultType.getShape(), getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2042:  if (failed(expectedResultType))
branch  0 never executed
branch  1 never executed
    #####: 2043:    return emitOpError("invalid source layout map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2044:
        -: 2045:  // Check actual result type.
    #####: 2046:  if (*expectedResultType != resultType)
branch  0 never executed
branch  1 never executed
    #####: 2047:    return emitOpError("expected expanded type to be ")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 2048:           << *expectedResultType << " but found " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2049:
    #####: 2050:  return success();
        -: 2051:}
        -: 2052:
function _ZN4mlir6memref13ExpandShapeOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 2053:void ExpandShapeOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2054:                                                MLIRContext *context) {
     1446: 2055:  results.add<ComposeReassociativeReshapeOps<ExpandShapeOp>,
        -: 2056:              ComposeExpandOfCollapseOp<ExpandShapeOp, CollapseShapeOp>>(
     1446: 2057:      context);
call    0 returned 100%
     1446: 2058:}
        -: 2059:
        -: 2060:/// Compute the layout map after collapsing a given source MemRef type with the
        -: 2061:/// specified reassociation indices.
        -: 2062:///
        -: 2063:/// Note: All collapsed dims in a reassociation group must be contiguous. It is
        -: 2064:/// not possible to check this by inspecting a MemRefType in the general case.
        -: 2065:/// If non-contiguity cannot be checked statically, the collapse is assumed to
        -: 2066:/// be valid (and thus accepted by this function) unless `strict = true`.
        -: 2067:static FailureOr<StridedLayoutAttr>
function _ZL25computeCollapsedLayoutMapN4mlir10MemRefTypeEN4llvm8ArrayRefINS1_11SmallVectorIlLj2EEEEEb called 0 returned 0% blocks executed 0%
    #####: 2068:computeCollapsedLayoutMap(MemRefType srcType,
        -: 2069:                          ArrayRef<ReassociationIndices> reassociation,
        -: 2070:                          bool strict = false) {
    #####: 2071:  int64_t srcOffset;
    #####: 2072:  SmallVector<int64_t> srcStrides;
call    0 never executed
    #####: 2073:  auto srcShape = srcType.getShape();
call    0 never executed
    #####: 2074:  if (failed(getStridesAndOffset(srcType, srcStrides, srcOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2075:    return failure();
        -: 2076:
        -: 2077:  // The result stride of a reassociation group is the stride of the last entry
        -: 2078:  // of the reassociation. (TODO: Should be the minimum stride in the
        -: 2079:  // reassociation because strides are not necessarily sorted. E.g., when using
        -: 2080:  // memref.transpose.) Dimensions of size 1 should be skipped, because their
        -: 2081:  // strides are meaningless and could have any arbitrary value.
    #####: 2082:  SmallVector<int64_t> resultStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2083:  resultStrides.reserve(reassociation.size());
branch  0 never executed
branch  1 never executed
    #####: 2084:  for (const ReassociationIndices &reassoc : reassociation) {
branch  0 never executed
branch  1 never executed
    #####: 2085:    ArrayRef<int64_t> ref = llvm::makeArrayRef(reassoc);
    #####: 2086:    while (srcShape[ref.back()] == 1 && ref.size() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2087:      ref = ref.drop_back();
call    0 never executed
    #####: 2088:    if (!ShapedType::isDynamic(srcShape[ref.back()]) || ref.size() == 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2089:      resultStrides.push_back(srcStrides[ref.back()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2090:    } else {
        -: 2091:      // Dynamically-sized dims may turn out to be dims of size 1 at runtime, so
        -: 2092:      // the corresponding stride may have to be skipped. (See above comment.)
        -: 2093:      // Therefore, the result stride cannot be statically determined and must
        -: 2094:      // be dynamic.
    #####: 2095:      resultStrides.push_back(ShapedType::kDynamicStrideOrOffset);
call    0 never executed
        -: 2096:    }
        -: 2097:  }
        -: 2098:
        -: 2099:  // Validate that each reassociation group is contiguous.
    #####: 2100:  unsigned resultStrideIndex = resultStrides.size() - 1;
    #####: 2101:  for (const ReassociationIndices &reassoc : llvm::reverse(reassociation)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2102:    auto trailingReassocs = ArrayRef<int64_t>(reassoc).drop_front();
call    0 never executed
    #####: 2103:    using saturated_arith::Wrapper;
    #####: 2104:    auto stride = Wrapper::stride(resultStrides[resultStrideIndex--]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2105:    for (int64_t idx : llvm::reverse(trailingReassocs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2106:      stride = stride * Wrapper::size(srcShape[idx]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2107:
        -: 2108:      // Both source and result stride must have the same static value. In that
        -: 2109:      // case, we can be sure, that the dimensions are collapsible (because they
        -: 2110:      // are contiguous).
        -: 2111:      // If `strict = false` (default during op verification), we accept cases
        -: 2112:      // where one or both strides are dynamic. This is best effort: We reject
        -: 2113:      // ops where obviously non-contiguous dims are collapsed, but accept ops
        -: 2114:      // where we cannot be sure statically. Such ops may fail at runtime. See
        -: 2115:      // the op documentation for details.
    #####: 2116:      auto srcStride = Wrapper::stride(srcStrides[idx - 1]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2117:      if (strict && (stride.saturated || srcStride.saturated))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2118:        return failure();
        -: 2119:
    #####: 2120:      if (!stride.saturated && !srcStride.saturated && stride != srcStride)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2121:        return failure();
        -: 2122:    }
        -: 2123:  }
    #####: 2124:  return StridedLayoutAttr::get(srcType.getContext(), srcOffset, resultStrides);
call    0 never executed
call    1 never executed
        -: 2125:}
        -: 2126:
function _ZN4mlir6memref15CollapseShapeOp23isGuaranteedCollapsibleENS_10MemRefTypeEN4llvm8ArrayRefINS3_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 2127:bool CollapseShapeOp::isGuaranteedCollapsible(
        -: 2128:    MemRefType srcType, ArrayRef<ReassociationIndices> reassociation) {
        -: 2129:  // MemRefs with identity layout are always collapsible.
    #####: 2130:  if (srcType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2131:    return true;
        -: 2132:
    #####: 2133:  return succeeded(computeCollapsedLayoutMap(srcType, reassociation,
    #####: 2134:                                             /*strict=*/true));
call    0 never executed
        -: 2135:}
        -: 2136:
function _ZN4mlir6memref15CollapseShapeOp20computeCollapsedTypeENS_10MemRefTypeEN4llvm8ArrayRefINS3_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 2137:MemRefType CollapseShapeOp::computeCollapsedType(
        -: 2138:    MemRefType srcType, ArrayRef<ReassociationIndices> reassociation) {
    #####: 2139:  SmallVector<int64_t> resultShape;
branch  0 never executed
branch  1 never executed
    #####: 2140:  resultShape.reserve(reassociation.size());
branch  0 never executed
branch  1 never executed
    #####: 2141:  for (const ReassociationIndices &group : reassociation) {
branch  0 never executed
branch  1 never executed
    #####: 2142:    using saturated_arith::Wrapper;
    #####: 2143:    auto groupSize = Wrapper::size(1);
    #####: 2144:    for (int64_t srcDim : group)
branch  0 never executed
branch  1 never executed
    #####: 2145:      groupSize = groupSize * Wrapper::size(srcType.getDimSize(srcDim));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2146:    resultShape.push_back(groupSize.asSize());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2147:  }
        -: 2148:
    #####: 2149:  if (srcType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2150:    // If the source is contiguous (i.e., no layout map specified), so is the
        -: 2151:    // result.
    #####: 2152:    MemRefLayoutAttrInterface layout;
call    0 never executed
    #####: 2153:    return MemRefType::get(resultShape, srcType.getElementType(), layout,
    #####: 2154:                           srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2155:  }
        -: 2156:
        -: 2157:  // Source may not be fully contiguous. Compute the layout map.
        -: 2158:  // Note: Dimensions that are collapsed into a single dim are assumed to be
        -: 2159:  // contiguous.
    #####: 2160:  FailureOr<StridedLayoutAttr> computedLayout =
    #####: 2161:      computeCollapsedLayoutMap(srcType, reassociation);
call    0 never executed
    #####: 2162:  assert(succeeded(computedLayout) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2163:         "invalid source layout map or collapsing non-contiguous dims");
    #####: 2164:  return MemRefType::get(resultShape, srcType.getElementType(), *computedLayout,
call    0 never executed
    #####: 2165:                         srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2166:}
        -: 2167:
function _ZN4mlir6memref15CollapseShapeOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefINS7_11SmallVectorIlLj2EEEEENS8_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2168:void CollapseShapeOp::build(OpBuilder &b, OperationState &result, Value src,
        -: 2169:                            ArrayRef<ReassociationIndices> reassociation,
        -: 2170:                            ArrayRef<NamedAttribute> attrs) {
    #####: 2171:  auto srcType = src.getType().cast<MemRefType>();
call    0 never executed
    #####: 2172:  MemRefType resultType =
    #####: 2173:      CollapseShapeOp::computeCollapsedType(srcType, reassociation);
call    0 never executed
    #####: 2174:  build(b, result, resultType, src, attrs);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2175:  result.addAttribute(::mlir::getReassociationAttrName(),
call    0 never executed
    #####: 2176:                      getReassociationIndicesAttribute(b, reassociation));
call    0 never executed
    #####: 2177:}
        -: 2178:
function _ZN4mlir6memref15CollapseShapeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2179:LogicalResult CollapseShapeOp::verify() {
    #####: 2180:  MemRefType srcType = getSrcType();
call    0 never executed
    #####: 2181:  MemRefType resultType = getResultType();
call    0 never executed
        -: 2182:
        -: 2183:  // Verify result shape.
    #####: 2184:  if (failed(verifyCollapsedShape(getOperation(), resultType.getShape(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2185:                                  srcType.getShape(), getReassociationIndices(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2186:                                  /*allowMultipleDynamicDimsPerGroup=*/true)))
    #####: 2187:    return failure();
        -: 2188:
        -: 2189:  // Compute expected result type (including layout map).
    #####: 2190:  MemRefType expectedResultType;
    #####: 2191:  if (srcType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2192:    // If the source is contiguous (i.e., no layout map specified), so is the
        -: 2193:    // result.
    #####: 2194:    MemRefLayoutAttrInterface layout;
call    0 never executed
    #####: 2195:    expectedResultType =
        -: 2196:        MemRefType::get(resultType.getShape(), srcType.getElementType(), layout,
    #####: 2197:                        srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2198:  } else {
        -: 2199:    // Source may not be fully contiguous. Compute the layout map.
        -: 2200:    // Note: Dimensions that are collapsed into a single dim are assumed to be
        -: 2201:    // contiguous.
    #####: 2202:    FailureOr<StridedLayoutAttr> computedLayout =
    #####: 2203:        computeCollapsedLayoutMap(srcType, getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2204:    if (failed(computedLayout))
branch  0 never executed
branch  1 never executed
    #####: 2205:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2206:          "invalid source layout map or collapsing non-contiguous dims");
call    0 never executed
    #####: 2207:    expectedResultType =
        -: 2208:        MemRefType::get(resultType.getShape(), srcType.getElementType(),
    #####: 2209:                        *computedLayout, srcType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2210:  }
        -: 2211:
    #####: 2212:  if (expectedResultType != resultType)
branch  0 never executed
branch  1 never executed
    #####: 2213:    return emitOpError("expected collapsed type to be ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2214:           << expectedResultType << " but found " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2215:
    #####: 2216:  return success();
        -: 2217:}
        -: 2218:
        -: 2219:struct CollapseShapeOpMemRefCastFolder
        -: 2220:    : public OpRewritePattern<CollapseShapeOp> {
        -: 2221:public:
        -: 2222:  using OpRewritePattern<CollapseShapeOp>::OpRewritePattern;
        -: 2223:
function _ZNK31CollapseShapeOpMemRefCastFolder15matchAndRewriteEN4mlir6memref15CollapseShapeOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2224:  LogicalResult matchAndRewrite(CollapseShapeOp op,
        -: 2225:                                PatternRewriter &rewriter) const override {
    #####: 2226:    auto cast = op.getOperand().getDefiningOp<CastOp>();
call    0 never executed
call    1 never executed
    #####: 2227:    if (!cast)
branch  0 never executed
branch  1 never executed
    #####: 2228:      return failure();
        -: 2229:
    #####: 2230:    if (!CastOp::canFoldIntoConsumerOp(cast))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2231:      return failure();
        -: 2232:
    #####: 2233:    Type newResultType = CollapseShapeOp::computeCollapsedType(
    #####: 2234:        cast.getOperand().getType().cast<MemRefType>(),
call    0 never executed
    #####: 2235:        op.getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2236:
    #####: 2237:    if (newResultType == op.getResultType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2238:      rewriter.updateRootInPlace(
call    0 never executed
function _ZZNK31CollapseShapeOpMemRefCastFolder15matchAndRewriteEN4mlir6memref15CollapseShapeOpERNS0_15PatternRewriterEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2239:          op, [&]() { op.getSrcMutable().assign(cast.getSource()); });
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2240:    } else {
    #####: 2241:      Value newOp = rewriter.create<CollapseShapeOp>(
call    0 never executed
    #####: 2242:          op->getLoc(), cast.getSource(), op.getReassociationIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2243:      rewriter.replaceOpWithNewOp<CastOp>(op, op.getType(), newOp);
call    0 never executed
call    1 never executed
        -: 2244:    }
    #####: 2245:    return success();
        -: 2246:  }
        -: 2247:};
        -: 2248:
function _ZN4mlir6memref15CollapseShapeOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 2249:void CollapseShapeOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2250:                                                  MLIRContext *context) {
     1446: 2251:  results.add<ComposeReassociativeReshapeOps<CollapseShapeOp>,
        -: 2252:              ComposeCollapseOfExpandOp<CollapseShapeOp, ExpandShapeOp>,
     1446: 2253:              CollapseShapeOpMemRefCastFolder>(context);
call    0 returned 100%
     1446: 2254:}
        -: 2255:
function _ZN4mlir6memref13ExpandShapeOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2256:OpFoldResult ExpandShapeOp::fold(ArrayRef<Attribute> operands) {
    #####: 2257:  return foldReshapeOp<ExpandShapeOp, CollapseShapeOp>(*this, operands);
call    0 never executed
        -: 2258:}
        -: 2259:
function _ZN4mlir6memref15CollapseShapeOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2260:OpFoldResult CollapseShapeOp::fold(ArrayRef<Attribute> operands) {
    #####: 2261:  return foldReshapeOp<CollapseShapeOp, ExpandShapeOp>(*this, operands);
call    0 never executed
        -: 2262:}
        -: 2263:
        -: 2264://===----------------------------------------------------------------------===//
        -: 2265:// ReshapeOp
        -: 2266://===----------------------------------------------------------------------===//
        -: 2267:
function _ZN4mlir6memref9ReshapeOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 2268:void ReshapeOp::getAsmResultNames(
        -: 2269:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 2270:  setNameFn(getResult(), "reshape");
call    0 never executed
call    1 never executed
    #####: 2271:}
        -: 2272:
function _ZN4mlir6memref9ReshapeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2273:LogicalResult ReshapeOp::verify() {
    #####: 2274:  Type operandType = getSource().getType();
call    0 never executed
call    1 never executed
    #####: 2275:  Type resultType = getResult().getType();
call    0 never executed
call    1 never executed
        -: 2276:
    #####: 2277:  Type operandElementType = operandType.cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 2278:  Type resultElementType = resultType.cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 2279:  if (operandElementType != resultElementType)
branch  0 never executed
branch  1 never executed
    #####: 2280:    return emitOpError("element types of source and destination memref "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2281:                       "types should be the same");
call    0 never executed
        -: 2282:
    #####: 2283:  if (auto operandMemRefType = operandType.dyn_cast<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2284:    if (!operandMemRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2285:      return emitOpError("source memref type should have identity affine map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2286:
    #####: 2287:  int64_t shapeSize = getShape().getType().cast<MemRefType>().getDimSize(0);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2288:  auto resultMemRefType = resultType.dyn_cast<MemRefType>();
call    0 never executed
    #####: 2289:  if (resultMemRefType) {
branch  0 never executed
branch  1 never executed
    #####: 2290:    if (!resultMemRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2291:      return emitOpError("result memref type should have identity affine map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2292:    if (shapeSize == ShapedType::kDynamicSize)
branch  0 never executed
branch  1 never executed
    #####: 2293:      return emitOpError("cannot use shape operand with dynamic length to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2294:                         "reshape to statically-ranked memref type");
call    0 never executed
    #####: 2295:    if (shapeSize != resultMemRefType.getRank())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2296:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2297:          "length of shape operand differs from the result's memref rank");
call    0 never executed
        -: 2298:  }
    #####: 2299:  return success();
        -: 2300:}
        -: 2301:
        -: 2302://===----------------------------------------------------------------------===//
        -: 2303:// StoreOp
        -: 2304://===----------------------------------------------------------------------===//
        -: 2305:
function _ZN4mlir6memref7StoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2306:LogicalResult StoreOp::verify() {
    #####: 2307:  if (getNumOperands() != 2 + getMemRefType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2308:    return emitOpError("store index operand count not equal to memref rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2309:
    #####: 2310:  return success();
        -: 2311:}
        -: 2312:
function _ZN4mlir6memref7StoreOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 2313:LogicalResult StoreOp::fold(ArrayRef<Attribute> cstOperands,
        -: 2314:                            SmallVectorImpl<OpFoldResult> &results) {
        -: 2315:  /// store(memrefcast) -> store
    #####: 2316:  return foldMemRefCast(*this, getValueToStore());
call    0 never executed
call    1 never executed
        -: 2317:}
        -: 2318:
        -: 2319://===----------------------------------------------------------------------===//
        -: 2320:// SubViewOp
        -: 2321://===----------------------------------------------------------------------===//
        -: 2322:
function _ZN4mlir6memref9SubViewOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 2323:void SubViewOp::getAsmResultNames(
        -: 2324:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 2325:  setNameFn(getResult(), "subview");
call    0 never executed
call    1 never executed
    #####: 2326:}
        -: 2327:
        -: 2328:/// A subview result type can be fully inferred from the source type and the
        -: 2329:/// static representation of offsets, sizes and strides. Special sentinels
        -: 2330:/// encode the dynamic case.
function _ZN4mlir6memref9SubViewOp15inferResultTypeENS_10MemRefTypeEN4llvm8ArrayRefIlEES5_S5_ called 0 returned 0% blocks executed 0%
    #####: 2331:Type SubViewOp::inferResultType(MemRefType sourceMemRefType,
        -: 2332:                                ArrayRef<int64_t> staticOffsets,
        -: 2333:                                ArrayRef<int64_t> staticSizes,
        -: 2334:                                ArrayRef<int64_t> staticStrides) {
    #####: 2335:  unsigned rank = sourceMemRefType.getRank();
call    0 never executed
    #####: 2336:  (void)rank;
    #####: 2337:  assert(staticOffsets.size() == rank && "staticOffsets length mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2338:  assert(staticSizes.size() == rank && "staticSizes length mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2339:  assert(staticStrides.size() == rank && "staticStrides length mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2340:
        -: 2341:  // Extract source offset and strides.
    #####: 2342:  int64_t sourceOffset;
    #####: 2343:  SmallVector<int64_t, 4> sourceStrides;
call    0 never executed
    #####: 2344:  auto res = getStridesAndOffset(sourceMemRefType, sourceStrides, sourceOffset);
call    0 never executed
    #####: 2345:  assert(succeeded(res) && "SubViewOp expected strided memref type");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2346:  (void)res;
        -: 2347:
        -: 2348:  // Compute target offset whose value is:
        -: 2349:  //   `sourceOffset + sum_i(staticOffset_i * sourceStrides_i)`.
    #####: 2350:  int64_t targetOffset = sourceOffset;
    #####: 2351:  for (auto it : llvm::zip(staticOffsets, sourceStrides)) {
branch  0 never executed
branch  1 never executed
    #####: 2352:    auto staticOffset = std::get<0>(it), targetStride = std::get<1>(it);
branch  0 never executed
branch  1 never executed
    #####: 2353:    using saturated_arith::Wrapper;
    #####: 2354:    targetOffset =
branch  0 never executed
branch  1 never executed
    #####: 2355:        (Wrapper::offset(targetOffset) +
    #####: 2356:         Wrapper::offset(staticOffset) * Wrapper::stride(targetStride))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 2357:            .asOffset();
        -: 2358:  }
        -: 2359:
        -: 2360:  // Compute target stride whose value is:
        -: 2361:  //   `sourceStrides_i * staticStrides_i`.
    #####: 2362:  SmallVector<int64_t, 4> targetStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2363:  targetStrides.reserve(staticOffsets.size());
branch  0 never executed
branch  1 never executed
    #####: 2364:  for (auto it : llvm::zip(sourceStrides, staticStrides)) {
branch  0 never executed
branch  1 never executed
    #####: 2365:    auto sourceStride = std::get<0>(it), staticStride = std::get<1>(it);
branch  0 never executed
branch  1 never executed
    #####: 2366:    using saturated_arith::Wrapper;
    #####: 2367:    targetStrides.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2368:        (Wrapper::stride(sourceStride) * Wrapper::stride(staticStride))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2369:            .asStride());
        -: 2370:  }
        -: 2371:
        -: 2372:  // The type is now known.
    #####: 2373:  return MemRefType::get(staticSizes, sourceMemRefType.getElementType(),
        -: 2374:                         StridedLayoutAttr::get(sourceMemRefType.getContext(),
        -: 2375:                                                targetOffset, targetStrides),
    #####: 2376:                         sourceMemRefType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
        -: 2377:}
        -: 2378:
function _ZN4mlir6memref9SubViewOp15inferResultTypeENS_10MemRefTypeEN4llvm8ArrayRefINS_12OpFoldResultEEES6_S6_ called 0 returned 0% blocks executed 0%
    #####: 2379:Type SubViewOp::inferResultType(MemRefType sourceMemRefType,
        -: 2380:                                ArrayRef<OpFoldResult> offsets,
        -: 2381:                                ArrayRef<OpFoldResult> sizes,
        -: 2382:                                ArrayRef<OpFoldResult> strides) {
    #####: 2383:  SmallVector<int64_t> staticOffsets, staticSizes, staticStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2384:  SmallVector<Value> dynamicOffsets, dynamicSizes, dynamicStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2385:  dispatchIndexOpFoldResults(offsets, dynamicOffsets, staticOffsets,
call    0 never executed
        -: 2386:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2387:  dispatchIndexOpFoldResults(sizes, dynamicSizes, staticSizes,
call    0 never executed
        -: 2388:                             ShapedType::kDynamicSize);
    #####: 2389:  dispatchIndexOpFoldResults(strides, dynamicStrides, staticStrides,
call    0 never executed
        -: 2390:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2391:  return SubViewOp::inferResultType(sourceMemRefType, staticOffsets,
call    0 never executed
    #####: 2392:                                    staticSizes, staticStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2393:}
        -: 2394:
function _ZN4mlir6memref9SubViewOp26inferRankReducedResultTypeEN4llvm8ArrayRefIlEENS_10MemRefTypeES4_S4_S4_ called 0 returned 0% blocks executed 0%
    #####: 2395:Type SubViewOp::inferRankReducedResultType(ArrayRef<int64_t> resultShape,
        -: 2396:                                           MemRefType sourceRankedTensorType,
        -: 2397:                                           ArrayRef<int64_t> offsets,
        -: 2398:                                           ArrayRef<int64_t> sizes,
        -: 2399:                                           ArrayRef<int64_t> strides) {
    #####: 2400:  auto inferredType =
    #####: 2401:      inferResultType(sourceRankedTensorType, offsets, sizes, strides)
call    0 never executed
call    1 never executed
    #####: 2402:          .cast<MemRefType>();
    #####: 2403:  assert(inferredType.getRank() >= static_cast<int64_t>(resultShape.size()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2404:         "expected ");
    #####: 2405:  if (inferredType.getRank() == static_cast<int64_t>(resultShape.size()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2406:    return inferredType;
        -: 2407:
        -: 2408:  // Compute which dimensions are dropped.
    #####: 2409:  Optional<llvm::SmallDenseSet<unsigned>> dimsToProject =
    #####: 2410:      computeRankReductionMask(inferredType.getShape(), resultShape);
call    0 never executed
call    1 never executed
    #####: 2411:  assert(dimsToProject.has_value() && "invalid rank reduction");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2412:
        -: 2413:  // Compute the layout and result type.
    #####: 2414:  auto inferredLayout = inferredType.getLayout().cast<StridedLayoutAttr>();
call    0 never executed
call    1 never executed
    #####: 2415:  SmallVector<int64_t> rankReducedStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2416:  rankReducedStrides.reserve(resultShape.size());
branch  0 never executed
branch  1 never executed
    #####: 2417:  for (auto [idx, value] : llvm::enumerate(inferredLayout.getStrides())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 2418:    if (!dimsToProject->contains(idx))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2419:      rankReducedStrides.push_back(value);
call    0 never executed
        -: 2420:  }
    #####: 2421:  return MemRefType::get(resultShape, inferredType.getElementType(),
        -: 2422:                         StridedLayoutAttr::get(inferredLayout.getContext(),
        -: 2423:                                                inferredLayout.getOffset(),
        -: 2424:                                                rankReducedStrides),
    #####: 2425:                         inferredType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -: 2426:}
        -: 2427:
function _ZN4mlir6memref9SubViewOp26inferRankReducedResultTypeEN4llvm8ArrayRefIlEENS_10MemRefTypeENS3_INS_12OpFoldResultEEES7_S7_ called 0 returned 0% blocks executed 0%
    #####: 2428:Type SubViewOp::inferRankReducedResultType(ArrayRef<int64_t> resultShape,
        -: 2429:                                           MemRefType sourceRankedTensorType,
        -: 2430:                                           ArrayRef<OpFoldResult> offsets,
        -: 2431:                                           ArrayRef<OpFoldResult> sizes,
        -: 2432:                                           ArrayRef<OpFoldResult> strides) {
    #####: 2433:  SmallVector<int64_t> staticOffsets, staticSizes, staticStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2434:  SmallVector<Value> dynamicOffsets, dynamicSizes, dynamicStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2435:  dispatchIndexOpFoldResults(offsets, dynamicOffsets, staticOffsets,
call    0 never executed
        -: 2436:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2437:  dispatchIndexOpFoldResults(sizes, dynamicSizes, staticSizes,
call    0 never executed
        -: 2438:                             ShapedType::kDynamicSize);
    #####: 2439:  dispatchIndexOpFoldResults(strides, dynamicStrides, staticStrides,
call    0 never executed
        -: 2440:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2441:  return SubViewOp::inferRankReducedResultType(
call    0 never executed
        -: 2442:      resultShape, sourceRankedTensorType, staticOffsets, staticSizes,
    #####: 2443:      staticStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2444:}
        -: 2445:
        -: 2446:// Build a SubViewOp with mixed static and dynamic entries and custom result
        -: 2447:// type. If the type passed is nullptr, it is inferred.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEESB_SB_NS9_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2448:void SubViewOp::build(OpBuilder &b, OperationState &result,
        -: 2449:                      MemRefType resultType, Value source,
        -: 2450:                      ArrayRef<OpFoldResult> offsets,
        -: 2451:                      ArrayRef<OpFoldResult> sizes,
        -: 2452:                      ArrayRef<OpFoldResult> strides,
        -: 2453:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2454:  SmallVector<int64_t> staticOffsets, staticSizes, staticStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2455:  SmallVector<Value> dynamicOffsets, dynamicSizes, dynamicStrides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2456:  dispatchIndexOpFoldResults(offsets, dynamicOffsets, staticOffsets,
call    0 never executed
        -: 2457:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2458:  dispatchIndexOpFoldResults(sizes, dynamicSizes, staticSizes,
call    0 never executed
        -: 2459:                             ShapedType::kDynamicSize);
    #####: 2460:  dispatchIndexOpFoldResults(strides, dynamicStrides, staticStrides,
call    0 never executed
        -: 2461:                             ShapedType::kDynamicStrideOrOffset);
    #####: 2462:  auto sourceMemRefType = source.getType().cast<MemRefType>();
call    0 never executed
        -: 2463:  // Structuring implementation this way avoids duplication between builders.
    #####: 2464:  if (!resultType) {
branch  0 never executed
branch  1 never executed
    #####: 2465:    resultType = SubViewOp::inferResultType(sourceMemRefType, staticOffsets,
call    0 never executed
    #####: 2466:                                            staticSizes, staticStrides)
call    0 never executed
call    1 never executed
    #####: 2467:                     .cast<MemRefType>();
        -: 2468:  }
    #####: 2469:  build(b, result, resultType, source, dynamicOffsets, dynamicSizes,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 2470:        dynamicStrides, b.getI64ArrayAttr(staticOffsets),
        -: 2471:        b.getI64ArrayAttr(staticSizes), b.getI64ArrayAttr(staticStrides));
    #####: 2472:  result.addAttributes(attrs);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2473:}
        -: 2474:
        -: 2475:// Build a SubViewOp with mixed static and dynamic entries and inferred result
        -: 2476:// type.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEESA_SA_NS8_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2477:void SubViewOp::build(OpBuilder &b, OperationState &result, Value source,
        -: 2478:                      ArrayRef<OpFoldResult> offsets,
        -: 2479:                      ArrayRef<OpFoldResult> sizes,
        -: 2480:                      ArrayRef<OpFoldResult> strides,
        -: 2481:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2482:  build(b, result, MemRefType(), source, offsets, sizes, strides, attrs);
call    0 never executed
call    1 never executed
    #####: 2483:}
        -: 2484:
        -: 2485:// Build a SubViewOp with static entries and inferred result type.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEES9_S9_NS8_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2486:void SubViewOp::build(OpBuilder &b, OperationState &result, Value source,
        -: 2487:                      ArrayRef<int64_t> offsets, ArrayRef<int64_t> sizes,
        -: 2488:                      ArrayRef<int64_t> strides,
        -: 2489:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2490:  SmallVector<OpFoldResult> offsetValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEES9_S9_NS8_INS_14NamedAttributeEEEENKUllE_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2491:      llvm::map_range(offsets, [&](int64_t v) -> OpFoldResult {
    #####: 2492:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2493:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2494:  SmallVector<OpFoldResult> sizeValues =
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEES9_S9_NS8_INS_14NamedAttributeEEEENKUllE0_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2495:      llvm::to_vector<4>(llvm::map_range(sizes, [&](int64_t v) -> OpFoldResult {
branch  0 never executed
branch  1 never executed
    #####: 2496:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2497:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2498:  SmallVector<OpFoldResult> strideValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEES9_S9_NS8_INS_14NamedAttributeEEEENKUllE1_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2499:      llvm::map_range(strides, [&](int64_t v) -> OpFoldResult {
    #####: 2500:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2501:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2502:  build(b, result, source, offsetValues, sizeValues, strideValues, attrs);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2503:}
        -: 2504:
        -: 2505:// Build a SubViewOp with dynamic entries and custom result type. If the
        -: 2506:// type passed is nullptr, it is inferred.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueEN4llvm8ArrayRefIlEESA_SA_NS9_INS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2507:void SubViewOp::build(OpBuilder &b, OperationState &result,
        -: 2508:                      MemRefType resultType, Value source,
        -: 2509:                      ArrayRef<int64_t> offsets, ArrayRef<int64_t> sizes,
        -: 2510:                      ArrayRef<int64_t> strides,
        -: 2511:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2512:  SmallVector<OpFoldResult> offsetValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueEN4llvm8ArrayRefIlEESA_SA_NS9_INS_14NamedAttributeEEEENKUllE_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2513:      llvm::map_range(offsets, [&](int64_t v) -> OpFoldResult {
    #####: 2514:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2515:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2516:  SmallVector<OpFoldResult> sizeValues =
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueEN4llvm8ArrayRefIlEESA_SA_NS9_INS_14NamedAttributeEEEENKUllE0_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2517:      llvm::to_vector<4>(llvm::map_range(sizes, [&](int64_t v) -> OpFoldResult {
branch  0 never executed
branch  1 never executed
    #####: 2518:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2519:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2520:  SmallVector<OpFoldResult> strideValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueEN4llvm8ArrayRefIlEESA_SA_NS9_INS_14NamedAttributeEEEENKUllE1_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2521:      llvm::map_range(strides, [&](int64_t v) -> OpFoldResult {
    #####: 2522:        return b.getI64IntegerAttr(v);
call    0 never executed
call    1 never executed
    #####: 2523:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2524:  build(b, result, resultType, source, offsetValues, sizeValues, strideValues,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2525:        attrs);
    #####: 2526:}
        -: 2527:
        -: 2528:// Build a SubViewOp with dynamic entries and custom result type. If the type
        -: 2529:// passed is nullptr, it is inferred.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10MemRefTypeENS_5ValueENS_10ValueRangeES8_S8_N4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2530:void SubViewOp::build(OpBuilder &b, OperationState &result,
        -: 2531:                      MemRefType resultType, Value source, ValueRange offsets,
        -: 2532:                      ValueRange sizes, ValueRange strides,
        -: 2533:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2534:  SmallVector<OpFoldResult> offsetValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
    #####: 2535:      llvm::map_range(offsets, [](Value v) -> OpFoldResult { return v; }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2536:  SmallVector<OpFoldResult> sizeValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
    #####: 2537:      llvm::map_range(sizes, [](Value v) -> OpFoldResult { return v; }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2538:  SmallVector<OpFoldResult> strideValues = llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
    #####: 2539:      llvm::map_range(strides, [](Value v) -> OpFoldResult { return v; }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2540:  build(b, result, resultType, source, offsetValues, sizeValues, strideValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2541:}
        -: 2542:
        -: 2543:// Build a SubViewOp with dynamic entries and inferred result type.
function _ZN4mlir6memref9SubViewOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeES7_S7_N4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2544:void SubViewOp::build(OpBuilder &b, OperationState &result, Value source,
        -: 2545:                      ValueRange offsets, ValueRange sizes, ValueRange strides,
        -: 2546:                      ArrayRef<NamedAttribute> attrs) {
    #####: 2547:  build(b, result, MemRefType(), source, offsets, sizes, strides, attrs);
call    0 never executed
    #####: 2548:}
        -: 2549:
        -: 2550:/// For ViewLikeOpInterface.
function _ZN4mlir6memref9SubViewOp13getViewSourceEv called 0 returned 0% blocks executed 0%
    #####: 2551:Value SubViewOp::getViewSource() { return getSource(); }
call    0 never executed
        -: 2552:
        -: 2553:/// Return true if t1 and t2 have equal offsets (both dynamic or of same
        -: 2554:/// static value).
function _ZL21haveCompatibleOffsetsN4mlir10MemRefTypeES0_ called 0 returned 0% blocks executed 0%
    #####: 2555:static bool haveCompatibleOffsets(MemRefType t1, MemRefType t2) {
    #####: 2556:  int64_t t1Offset, t2Offset;
    #####: 2557:  SmallVector<int64_t> t1Strides, t2Strides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2558:  auto res1 = getStridesAndOffset(t1, t1Strides, t1Offset);
call    0 never executed
    #####: 2559:  auto res2 = getStridesAndOffset(t2, t2Strides, t2Offset);
call    0 never executed
    #####: 2560:  return succeeded(res1) && succeeded(res2) && t1Offset == t2Offset;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 2561:}
        -: 2562:
        -: 2563:/// Checks if `original` Type type can be rank reduced to `reduced` type.
        -: 2564:/// This function is slight variant of `is subsequence` algorithm where
        -: 2565:/// not matching dimension must be 1.
        -: 2566:static SliceVerificationResult
function _ZL23isRankReducedMemRefTypeN4mlir10MemRefTypeES0_N4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 2567:isRankReducedMemRefType(MemRefType originalType,
        -: 2568:                        MemRefType candidateRankReducedType,
        -: 2569:                        ArrayRef<OpFoldResult> sizes) {
    #####: 2570:  auto partialRes = isRankReducedType(originalType, candidateRankReducedType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2571:  if (partialRes != SliceVerificationResult::Success)
branch  0 never executed
branch  1 never executed
        -: 2572:    return partialRes;
        -: 2573:
    #####: 2574:  auto optionalUnusedDimsMask = computeMemRefRankReductionMask(
    #####: 2575:      originalType, candidateRankReducedType, sizes);
call    0 never executed
        -: 2576:
        -: 2577:  // Sizes cannot be matched in case empty vector is returned.
    #####: 2578:  if (!optionalUnusedDimsMask)
branch  0 never executed
branch  1 never executed
        -: 2579:    return SliceVerificationResult::LayoutMismatch;
        -: 2580:
    #####: 2581:  if (originalType.getMemorySpace() !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2582:      candidateRankReducedType.getMemorySpace())
        -: 2583:    return SliceVerificationResult::MemSpaceMismatch;
        -: 2584:
        -: 2585:  // No amount of stride dropping can reconcile incompatible offsets.
    #####: 2586:  if (!haveCompatibleOffsets(originalType, candidateRankReducedType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2587:    return SliceVerificationResult::LayoutMismatch;
        -: 2588:
        -: 2589:  return SliceVerificationResult::Success;
        -: 2590:}
        -: 2591:
        -: 2592:template <typename OpTy>
function _Z22produceSubViewErrorMsgIN4mlir6memref9SubViewOpEENS0_13LogicalResultENS0_23SliceVerificationResultET_NS0_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2593:static LogicalResult produceSubViewErrorMsg(SliceVerificationResult result,
call    0 never executed
        -: 2594:                                            OpTy op, Type expectedType) {
    #####: 2595:  auto memrefType = expectedType.cast<ShapedType>();
    #####: 2596:  switch (result) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2597:  case SliceVerificationResult::Success:
    #####: 2598:    return success();
    #####: 2599:  case SliceVerificationResult::RankTooLarge:
        -: 2600:    return op.emitError("expected result rank to be smaller or equal to ")
    #####: 2601:           << "the source rank. ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2602:  case SliceVerificationResult::SizeMismatch:
        -: 2603:    return op.emitError("expected result type to be ")
    #####: 2604:           << expectedType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2605:           << " or a rank-reduced version. (mismatch of result sizes) ";
call    0 never executed
    #####: 2606:  case SliceVerificationResult::ElemTypeMismatch:
        -: 2607:    return op.emitError("expected result element type to be ")
    #####: 2608:           << memrefType.getElementType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2609:  case SliceVerificationResult::MemSpaceMismatch:
    #####: 2610:    return op.emitError("expected result and source memory spaces to match.");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2611:  case SliceVerificationResult::LayoutMismatch:
        -: 2612:    return op.emitError("expected result type to be ")
    #####: 2613:           << expectedType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2614:           << " or a rank-reduced version. (mismatch of result layout) ";
call    0 never executed
        -: 2615:  }
    #####: 2616:  llvm_unreachable("unexpected subview verification result");
call    0 never executed
        -: 2617:}
        -: 2618:
        -: 2619:/// Verifier for SubViewOp.
function _ZN4mlir6memref9SubViewOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2620:LogicalResult SubViewOp::verify() {
    #####: 2621:  MemRefType baseType = getSourceType();
call    0 never executed
    #####: 2622:  MemRefType subViewType = getType();
call    0 never executed
        -: 2623:
        -: 2624:  // The base memref and the view memref should be in the same memory space.
    #####: 2625:  if (baseType.getMemorySpace() != subViewType.getMemorySpace())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2626:    return emitError("different memory spaces specified for base memref "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2627:                     "type ")
    #####: 2628:           << baseType << " and subview memref type " << subViewType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2629:
        -: 2630:  // Verify that the base memref type has a strided layout map.
    #####: 2631:  if (!isStrided(baseType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2632:    return emitError("base type ") << baseType << " is not strided";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 2633:
        -: 2634:  // Verify result type against inferred type.
    #####: 2635:  auto expectedType = SubViewOp::inferResultType(
call    0 never executed
    #####: 2636:      baseType, extractFromI64ArrayAttr(getStaticOffsets()),
call    0 never executed
call    1 never executed
    #####: 2637:      extractFromI64ArrayAttr(getStaticSizes()),
call    0 never executed
call    1 never executed
    #####: 2638:      extractFromI64ArrayAttr(getStaticStrides()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 2639:
    #####: 2640:  auto result = isRankReducedMemRefType(expectedType.cast<MemRefType>(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2641:                                        subViewType, getMixedSizes());
call    0 never executed
call    1 never executed
    #####: 2642:  return produceSubViewErrorMsg(result, *this, expectedType);
call    0 never executed
        -: 2643:}
        -: 2644:
function _ZN4mlirlsERN4llvm11raw_ostreamERKNS_5RangeE called 0 returned 0% blocks executed 0%
    #####: 2645:raw_ostream &mlir::operator<<(raw_ostream &os, const Range &range) {
    #####: 2646:  return os << "range " << range.offset << ":" << range.size << ":"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2647:            << range.stride;
call    0 never executed
call    1 never executed
        -: 2648:}
        -: 2649:
        -: 2650:/// Return the list of Range (i.e. offset, size, stride). Each Range
        -: 2651:/// entry contains either the dynamic value or a ConstantIndexOp constructed
        -: 2652:/// with `b` at location `loc`.
function _ZN4mlir17getOrCreateRangesENS_30OffsetSizeAndStrideOpInterfaceERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 2653:SmallVector<Range, 8> mlir::getOrCreateRanges(OffsetSizeAndStrideOpInterface op,
        -: 2654:                                              OpBuilder &b, Location loc) {
    #####: 2655:  std::array<unsigned, 3> ranks = op.getArrayAttrMaxRanks();
call    0 never executed
    #####: 2656:  assert(ranks[0] == ranks[1] && "expected offset and sizes of equal ranks");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2657:  assert(ranks[1] == ranks[2] && "expected sizes and strides of equal ranks");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2658:  SmallVector<Range, 8> res;
branch  0 never executed
branch  1 never executed
    #####: 2659:  unsigned rank = ranks[0];
branch  0 never executed
branch  1 never executed
    #####: 2660:  res.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####: 2661:  for (unsigned idx = 0; idx < rank; ++idx) {
branch  0 never executed
branch  1 never executed
    #####: 2662:    Value offset =
    #####: 2663:        op.isDynamicOffset(idx)
call    0 never executed
    #####: 2664:            ? op.getDynamicOffset(idx)
call    0 never executed
    #####: 2665:            : b.create<arith::ConstantIndexOp>(loc, op.getStaticOffset(idx));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2666:    Value size =
    #####: 2667:        op.isDynamicSize(idx)
call    0 never executed
    #####: 2668:            ? op.getDynamicSize(idx)
call    0 never executed
    #####: 2669:            : b.create<arith::ConstantIndexOp>(loc, op.getStaticSize(idx));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2670:    Value stride =
    #####: 2671:        op.isDynamicStride(idx)
call    0 never executed
    #####: 2672:            ? op.getDynamicStride(idx)
call    0 never executed
    #####: 2673:            : b.create<arith::ConstantIndexOp>(loc, op.getStaticStride(idx));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2674:    res.emplace_back(Range{offset, size, stride});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2675:  }
    #####: 2676:  return res;
        -: 2677:}
        -: 2678:
        -: 2679:/// Compute the canonical result type of a SubViewOp. Call `inferResultType`
        -: 2680:/// to deduce the result type for the given `sourceType`. Additionally, reduce
        -: 2681:/// the rank of the inferred result type if `currentResultType` is lower rank
        -: 2682:/// than `currentSourceType`. Use this signature if `sourceType` is updated
        -: 2683:/// together with the result type. In this case, it is important to compute
        -: 2684:/// the dropped dimensions using `currentSourceType` whose strides align with
        -: 2685:/// `currentResultType`.
function _ZL29getCanonicalSubViewResultTypeN4mlir10MemRefTypeES0_S0_N4llvm8ArrayRefINS_12OpFoldResultEEES4_S4_ called 0 returned 0% blocks executed 0%
    #####: 2686:static MemRefType getCanonicalSubViewResultType(
        -: 2687:    MemRefType currentResultType, MemRefType currentSourceType,
        -: 2688:    MemRefType sourceType, ArrayRef<OpFoldResult> mixedOffsets,
        -: 2689:    ArrayRef<OpFoldResult> mixedSizes, ArrayRef<OpFoldResult> mixedStrides) {
    #####: 2690:  auto nonRankReducedType = SubViewOp::inferResultType(sourceType, mixedOffsets,
    #####: 2691:                                                       mixedSizes, mixedStrides)
call    0 never executed
call    1 never executed
    #####: 2692:                                .cast<MemRefType>();
    #####: 2693:  llvm::Optional<llvm::SmallBitVector> unusedDims =
        -: 2694:      computeMemRefRankReductionMask(currentSourceType, currentResultType,
    #####: 2695:                                     mixedSizes);
call    0 never executed
        -: 2696:  // Return nullptr as failure mode.
    #####: 2697:  if (!unusedDims)
branch  0 never executed
branch  1 never executed
    #####: 2698:    return nullptr;
        -: 2699:
    #####: 2700:  auto layout = nonRankReducedType.getLayout().cast<StridedLayoutAttr>();
call    0 never executed
call    1 never executed
    #####: 2701:  SmallVector<int64_t> shape, strides;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2702:  unsigned numDimsAfterReduction =
    #####: 2703:      nonRankReducedType.getRank() - unusedDims->count();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2704:  shape.reserve(numDimsAfterReduction);
branch  0 never executed
branch  1 never executed
    #####: 2705:  strides.reserve(numDimsAfterReduction);
branch  0 never executed
branch  1 never executed
    #####: 2706:  for (const auto &[idx, size, stride] :
branch  0 never executed
branch  1 never executed
    #####: 2707:       llvm::zip(llvm::seq<unsigned>(0, nonRankReducedType.getRank()),
call    0 never executed
call    1 never executed
    #####: 2708:                 nonRankReducedType.getShape(), layout.getStrides())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 2709:    if (unusedDims->test(idx))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2710:      continue;
    #####: 2711:    shape.push_back(size);
call    0 never executed
    #####: 2712:    strides.push_back(stride);
call    0 never executed
        -: 2713:  }
        -: 2714:
    #####: 2715:  return MemRefType::get(shape, nonRankReducedType.getElementType(),
        -: 2716:                         StridedLayoutAttr::get(sourceType.getContext(),
        -: 2717:                                                layout.getOffset(), strides),
    #####: 2718:                         nonRankReducedType.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -: 2719:}
        -: 2720:
        -: 2721:/// Compute the canonical result type of a SubViewOp. Call `inferResultType`
        -: 2722:/// to deduce the result type. Additionally, reduce the rank of the inferred
        -: 2723:/// result type if `currentResultType` is lower rank than `sourceType`.
        -: 2724:static MemRefType getCanonicalSubViewResultType(
        -: 2725:    MemRefType currentResultType, MemRefType sourceType,
        -: 2726:    ArrayRef<OpFoldResult> mixedOffsets, ArrayRef<OpFoldResult> mixedSizes,
        -: 2727:    ArrayRef<OpFoldResult> mixedStrides) {
        -: 2728:  return getCanonicalSubViewResultType(currentResultType, sourceType,
        -: 2729:                                       sourceType, mixedOffsets, mixedSizes,
        -: 2730:                                       mixedStrides);
        -: 2731:}
        -: 2732:
        -: 2733:/// Helper method to check if a `subview` operation is trivially a no-op. This
        -: 2734:/// is the case if the all offsets are zero, all strides are 1, and the source
        -: 2735:/// shape is same as the size of the subview. In such cases, the subview can
        -: 2736:/// be folded into its source.
function _ZL18isTrivialSubViewOpN4mlir6memref9SubViewOpE called 0 returned 0% blocks executed 0%
    #####: 2737:static bool isTrivialSubViewOp(SubViewOp subViewOp) {
    #####: 2738:  if (subViewOp.getSourceType().getRank() != subViewOp.getType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2739:    return false;
        -: 2740:
    #####: 2741:  auto mixedOffsets = subViewOp.getMixedOffsets();
call    0 never executed
    #####: 2742:  auto mixedSizes = subViewOp.getMixedSizes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2743:  auto mixedStrides = subViewOp.getMixedStrides();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2744:
        -: 2745:  // Check offsets are zero.
    #####: 2746:  if (llvm::any_of(mixedOffsets, [](OpFoldResult ofr) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2747:        Optional<int64_t> intValue = getConstantIntValue(ofr);
        -: 2748:        return !intValue || intValue.value() != 0;
        -: 2749:      }))
        -: 2750:    return false;
        -: 2751:
        -: 2752:  // Check strides are one.
    #####: 2753:  if (llvm::any_of(mixedStrides, [](OpFoldResult ofr) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2754:        Optional<int64_t> intValue = getConstantIntValue(ofr);
        -: 2755:        return !intValue || intValue.value() != 1;
        -: 2756:      }))
        -: 2757:    return false;
        -: 2758:
        -: 2759:  // Check all size values are static and matches the (static) source shape.
    #####: 2760:  ArrayRef<int64_t> sourceShape = subViewOp.getSourceType().getShape();
call    0 never executed
call    1 never executed
    #####: 2761:  for (const auto &size : llvm::enumerate(mixedSizes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2762:    Optional<int64_t> intValue = getConstantIntValue(size.value());
call    0 never executed
    #####: 2763:    if (!intValue || *intValue != sourceShape[size.index()])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2764:      return false;
        -: 2765:  }
        -: 2766:  // All conditions met. The `SubViewOp` is foldable as a no-op.
    #####: 2767:  return true;
        -: 2768:}
        -: 2769:
        -: 2770:namespace {
        -: 2771:/// Pattern to rewrite a subview op with MemRefCast arguments.
        -: 2772:/// This essentially pushes memref.cast past its consuming subview when
        -: 2773:/// `canFoldIntoConsumerOp` is true.
        -: 2774:///
        -: 2775:/// Example:
        -: 2776:/// ```
        -: 2777:///   %0 = memref.cast %V : memref<16x16xf32> to memref<?x?xf32>
        -: 2778:///   %1 = memref.subview %0[0, 0][3, 4][1, 1] :
        -: 2779:///     memref<?x?xf32> to memref<3x4xf32, strided<[?, 1], offset: ?>>
        -: 2780:/// ```
        -: 2781:/// is rewritten into:
        -: 2782:/// ```
        -: 2783:///   %0 = memref.subview %V: memref<16x16xf32> to memref<3x4xf32, #[[map0]]>
        -: 2784:///   %1 = memref.cast %0: memref<3x4xf32, strided<[16, 1], offset: 0>> to
        -: 2785:///     memref<3x4xf32, strided<[?, 1], offset: ?>>
        -: 2786:/// ```
        -: 2787:class SubViewOpMemRefCastFolder final : public OpRewritePattern<SubViewOp> {
        -: 2788:public:
        -: 2789:  using OpRewritePattern<SubViewOp>::OpRewritePattern;
        -: 2790:
function _ZNK12_GLOBAL__N_125SubViewOpMemRefCastFolder15matchAndRewriteEN4mlir6memref9SubViewOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2791:  LogicalResult matchAndRewrite(SubViewOp subViewOp,
        -: 2792:                                PatternRewriter &rewriter) const override {
        -: 2793:    // Any constant operand, just return to let SubViewOpConstantFolder kick
        -: 2794:    // in.
    #####: 2795:    if (llvm::any_of(subViewOp.getOperands(), [](Value operand) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2796:          return matchPattern(operand, matchConstantIndex());
        -: 2797:        }))
    #####: 2798:      return failure();
        -: 2799:
    #####: 2800:    auto castOp = subViewOp.getSource().getDefiningOp<CastOp>();
call    0 never executed
call    1 never executed
    #####: 2801:    if (!castOp)
branch  0 never executed
branch  1 never executed
    #####: 2802:      return failure();
        -: 2803:
    #####: 2804:    if (!CastOp::canFoldIntoConsumerOp(castOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2805:      return failure();
        -: 2806:
        -: 2807:    // Compute the SubViewOp result type after folding the MemRefCastOp. Use
        -: 2808:    // the MemRefCastOp source operand type to infer the result type and the
        -: 2809:    // current SubViewOp source operand type to compute the dropped dimensions
        -: 2810:    // if the operation is rank-reducing.
    #####: 2811:    auto resultType = getCanonicalSubViewResultType(
        -: 2812:        subViewOp.getType(), subViewOp.getSourceType(),
    #####: 2813:        castOp.getSource().getType().cast<MemRefType>(),
call    0 never executed
    #####: 2814:        subViewOp.getMixedOffsets(), subViewOp.getMixedSizes(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2815:        subViewOp.getMixedStrides());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 2816:    if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 2817:      return failure();
        -: 2818:
    #####: 2819:    Value newSubView = rewriter.create<SubViewOp>(
    #####: 2820:        subViewOp.getLoc(), resultType, castOp.getSource(),
    #####: 2821:        subViewOp.getOffsets(), subViewOp.getSizes(), subViewOp.getStrides(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2822:        subViewOp.getStaticOffsets(), subViewOp.getStaticSizes(),
call    0 never executed
call    1 never executed
    #####: 2823:        subViewOp.getStaticStrides());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2824:    rewriter.replaceOpWithNewOp<CastOp>(subViewOp, subViewOp.getType(),
    #####: 2825:                                        newSubView);
call    0 never executed
call    1 never executed
    #####: 2826:    return success();
        -: 2827:  }
        -: 2828:};
        -: 2829:
        -: 2830:/// Canonicalize subview ops that are no-ops. When the source shape is not
        -: 2831:/// same as a result shape due to use of `affine_map`.
        -: 2832:class TrivialSubViewOpFolder final : public OpRewritePattern<SubViewOp> {
        -: 2833:public:
        -: 2834:  using OpRewritePattern<SubViewOp>::OpRewritePattern;
        -: 2835:
function _ZNK12_GLOBAL__N_122TrivialSubViewOpFolder15matchAndRewriteEN4mlir6memref9SubViewOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2836:  LogicalResult matchAndRewrite(SubViewOp subViewOp,
        -: 2837:                                PatternRewriter &rewriter) const override {
    #####: 2838:    if (!isTrivialSubViewOp(subViewOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2839:      return failure();
    #####: 2840:    if (subViewOp.getSourceType() == subViewOp.getType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2841:      rewriter.replaceOp(subViewOp, subViewOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2842:      return success();
        -: 2843:    }
    #####: 2844:    rewriter.replaceOpWithNewOp<CastOp>(subViewOp, subViewOp.getType(),
call    0 never executed
    #####: 2845:                                        subViewOp.getSource());
call    0 never executed
call    1 never executed
    #####: 2846:    return success();
        -: 2847:  }
        -: 2848:};
        -: 2849:} // namespace
        -: 2850:
        -: 2851:/// Return the canonical type of the result of a subview.
        -: 2852:struct SubViewReturnTypeCanonicalizer {
        -: 2853:  MemRefType operator()(SubViewOp op, ArrayRef<OpFoldResult> mixedOffsets,
        -: 2854:                        ArrayRef<OpFoldResult> mixedSizes,
        -: 2855:                        ArrayRef<OpFoldResult> mixedStrides) {
        -: 2856:    return getCanonicalSubViewResultType(op.getType(), op.getSourceType(),
        -: 2857:                                         mixedOffsets, mixedSizes,
        -: 2858:                                         mixedStrides);
        -: 2859:  }
        -: 2860:};
        -: 2861:
        -: 2862:/// A canonicalizer wrapper to replace SubViewOps.
        -: 2863:struct SubViewCanonicalizer {
        -: 2864:  void operator()(PatternRewriter &rewriter, SubViewOp op, SubViewOp newOp) {
        -: 2865:    rewriter.replaceOpWithNewOp<CastOp>(op, op.getType(), newOp);
        -: 2866:  }
        -: 2867:};
        -: 2868:
function _ZN4mlir6memref9SubViewOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 2869:void SubViewOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2870:                                            MLIRContext *context) {
     1446: 2871:  results
        -: 2872:      .add<OpWithOffsetSizesAndStridesConstantArgumentFolder<
        -: 2873:               SubViewOp, SubViewReturnTypeCanonicalizer, SubViewCanonicalizer>,
     1446: 2874:           SubViewOpMemRefCastFolder, TrivialSubViewOpFolder>(context);
call    0 returned 100%
     1446: 2875:}
        -: 2876:
function _ZN4mlir6memref9SubViewOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2877:OpFoldResult SubViewOp::fold(ArrayRef<Attribute> operands) {
    #####: 2878:  auto resultShapedType = getResult().getType().cast<ShapedType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2879:  auto sourceShapedType = getSource().getType().cast<ShapedType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2880:
    #####: 2881:  if (resultShapedType.hasStaticShape() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2882:      resultShapedType == sourceShapedType) {
branch  0 never executed
branch  1 never executed
    #####: 2883:    return getViewSource();
call    0 never executed
call    1 never executed
        -: 2884:  }
        -: 2885:
    #####: 2886:  return {};
        -: 2887:}
        -: 2888:
        -: 2889://===----------------------------------------------------------------------===//
        -: 2890:// TransposeOp
        -: 2891://===----------------------------------------------------------------------===//
        -: 2892:
function _ZN4mlir6memref11TransposeOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 2893:void TransposeOp::getAsmResultNames(
        -: 2894:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 2895:  setNameFn(getResult(), "transpose");
call    0 never executed
    #####: 2896:}
        -: 2897:
        -: 2898:/// Build a strided memref type by applying `permutationMap` tp `memRefType`.
function _ZL24inferTransposeResultTypeN4mlir10MemRefTypeENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 2899:static MemRefType inferTransposeResultType(MemRefType memRefType,
        -: 2900:                                           AffineMap permutationMap) {
    #####: 2901:  auto rank = memRefType.getRank();
call    0 never executed
    #####: 2902:  auto originalSizes = memRefType.getShape();
call    0 never executed
    #####: 2903:  int64_t offset;
    #####: 2904:  SmallVector<int64_t, 4> originalStrides;
call    0 never executed
    #####: 2905:  auto res = getStridesAndOffset(memRefType, originalStrides, offset);
call    0 never executed
    #####: 2906:  assert(succeeded(res) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2907:         originalStrides.size() == static_cast<unsigned>(rank));
    #####: 2908:  (void)res;
        -: 2909:
        -: 2910:  // Compute permuted sizes and strides.
    #####: 2911:  SmallVector<int64_t> sizes(rank, 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2912:  SmallVector<int64_t> strides(rank, 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2913:  for (const auto &en : llvm::enumerate(permutationMap.getResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2914:    unsigned position = en.value().cast<AffineDimExpr>().getPosition();
call    0 never executed
call    1 never executed
    #####: 2915:    sizes[en.index()] = originalSizes[position];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2916:    strides[en.index()] = originalStrides[position];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2917:  }
        -: 2918:
    #####: 2919:  return MemRefType::Builder(memRefType)
call    0 never executed
call    1 never executed
    #####: 2920:      .setShape(sizes)
call    0 never executed
        -: 2921:      .setLayout(
    #####: 2922:          StridedLayoutAttr::get(memRefType.getContext(), offset, strides));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2923:}
        -: 2924:
function _ZN4mlir6memref11TransposeOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_13AffineMapAttrEN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2925:void TransposeOp::build(OpBuilder &b, OperationState &result, Value in,
        -: 2926:                        AffineMapAttr permutation,
        -: 2927:                        ArrayRef<NamedAttribute> attrs) {
    #####: 2928:  auto permutationMap = permutation.getValue();
call    0 never executed
    #####: 2929:  assert(permutationMap);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2930:
    #####: 2931:  auto memRefType = in.getType().cast<MemRefType>();
call    0 never executed
        -: 2932:  // Compute result type.
    #####: 2933:  MemRefType resultType = inferTransposeResultType(memRefType, permutationMap);
call    0 never executed
        -: 2934:
    #####: 2935:  build(b, result, resultType, in, attrs);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2936:  result.addAttribute(TransposeOp::getPermutationAttrStrName(), permutation);
call    0 never executed
    #####: 2937:}
        -: 2938:
        -: 2939:// transpose $in $permutation attr-dict : type($in) `to` type(results)
function _ZN4mlir6memref11TransposeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2940:void TransposeOp::print(OpAsmPrinter &p) {
    #####: 2941:  p << " " << getIn() << " " << getPermutation();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2942:  p.printOptionalAttrDict((*this)->getAttrs(), {getPermutationAttrStrName()});
call    0 never executed
call    1 never executed
    #####: 2943:  p << " : " << getIn().getType() << " to " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 2944:}
        -: 2945:
function _ZN4mlir6memref11TransposeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2946:ParseResult TransposeOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2947:  OpAsmParser::UnresolvedOperand in;
call    0 never executed
    #####: 2948:  AffineMap permutation;
    #####: 2949:  MemRefType srcType, dstType;
    #####: 2950:  if (parser.parseOperand(in) || parser.parseAffineMap(permutation) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2951:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2952:      parser.parseColonType(srcType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2953:      parser.resolveOperand(in, srcType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2954:      parser.parseKeywordType("to", dstType) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2955:      parser.addTypeToList(dstType, result.types))
call    0 never executed
call    1 never executed
    #####: 2956:    return failure();
        -: 2957:
    #####: 2958:  result.addAttribute(TransposeOp::getPermutationAttrStrName(),
call    0 never executed
    #####: 2959:                      AffineMapAttr::get(permutation));
call    0 never executed
    #####: 2960:  return success();
        -: 2961:}
        -: 2962:
function _ZN4mlir6memref11TransposeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2963:LogicalResult TransposeOp::verify() {
    #####: 2964:  if (!getPermutation().isPermutation())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2965:    return emitOpError("expected a permutation map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2966:  if (getPermutation().getNumDims() != getShapedType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2967:    return emitOpError("expected a permutation map of same rank as the input");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2968:
    #####: 2969:  auto srcType = getIn().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2970:  auto dstType = getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 2971:  auto transposedType = inferTransposeResultType(srcType, getPermutation());
call    0 never executed
call    1 never executed
    #####: 2972:  if (dstType != transposedType)
branch  0 never executed
branch  1 never executed
    #####: 2973:    return emitOpError("output type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2974:           << dstType << " does not match transposed input type " << srcType
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2975:           << ", " << transposedType;
call    0 never executed
call    1 never executed
    #####: 2976:  return success();
        -: 2977:}
        -: 2978:
function _ZN4mlir6memref11TransposeOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2979:OpFoldResult TransposeOp::fold(ArrayRef<Attribute>) {
    #####: 2980:  if (succeeded(foldMemRefCast(*this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2981:    return getResult();
call    0 never executed
    #####: 2982:  return {};
        -: 2983:}
        -: 2984:
        -: 2985://===----------------------------------------------------------------------===//
        -: 2986:// ViewOp
        -: 2987://===----------------------------------------------------------------------===//
        -: 2988:
function _ZN4mlir6memref6ViewOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 2989:void ViewOp::getAsmResultNames(function_ref<void(Value, StringRef)> setNameFn) {
    #####: 2990:  setNameFn(getResult(), "view");
call    0 never executed
    #####: 2991:}
        -: 2992:
function _ZN4mlir6memref6ViewOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2993:LogicalResult ViewOp::verify() {
    #####: 2994:  auto baseType = getOperand(0).getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 2995:  auto viewType = getType();
call    0 never executed
        -: 2996:
        -: 2997:  // The base memref should have identity layout map (or none).
    #####: 2998:  if (!baseType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2999:    return emitError("unsupported map for base memref type ") << baseType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3000:
        -: 3001:  // The result memref should have identity layout map (or none).
    #####: 3002:  if (!viewType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3003:    return emitError("unsupported map for result memref type ") << viewType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3004:
        -: 3005:  // The base memref and the view memref should be in the same memory space.
    #####: 3006:  if (baseType.getMemorySpace() != viewType.getMemorySpace())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3007:    return emitError("different memory spaces specified for base memref "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3008:                     "type ")
    #####: 3009:           << baseType << " and view memref type " << viewType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3010:
        -: 3011:  // Verify that we have the correct number of sizes for the result type.
    #####: 3012:  unsigned numDynamicDims = viewType.getNumDynamicDims();
call    0 never executed
    #####: 3013:  if (getSizes().size() != numDynamicDims)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3014:    return emitError("incorrect number of size operands for type ") << viewType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3015:
    #####: 3016:  return success();
        -: 3017:}
        -: 3018:
function _ZN4mlir6memref6ViewOp13getViewSourceEv called 0 returned 0% blocks executed 0%
    #####: 3019:Value ViewOp::getViewSource() { return getSource(); }
call    0 never executed
        -: 3020:
        -: 3021:namespace {
        -: 3022:
        -: 3023:struct ViewOpShapeFolder : public OpRewritePattern<ViewOp> {
        -: 3024:  using OpRewritePattern<ViewOp>::OpRewritePattern;
        -: 3025:
function _ZNK12_GLOBAL__N_117ViewOpShapeFolder15matchAndRewriteEN4mlir6memref6ViewOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3026:  LogicalResult matchAndRewrite(ViewOp viewOp,
        -: 3027:                                PatternRewriter &rewriter) const override {
        -: 3028:    // Return if none of the operands are constants.
    #####: 3029:    if (llvm::none_of(viewOp.getOperands(), [](Value operand) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 3030:          return matchPattern(operand, matchConstantIndex());
        -: 3031:        }))
    #####: 3032:      return failure();
        -: 3033:
        -: 3034:    // Get result memref type.
    #####: 3035:    auto memrefType = viewOp.getType();
call    0 never executed
        -: 3036:
        -: 3037:    // Get offset from old memref view type 'memRefType'.
    #####: 3038:    int64_t oldOffset;
    #####: 3039:    SmallVector<int64_t, 4> oldStrides;
call    0 never executed
    #####: 3040:    if (failed(getStridesAndOffset(memrefType, oldStrides, oldOffset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3041:      return failure();
    #####: 3042:    assert(oldOffset == 0 && "Expected 0 offset");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3043:
    #####: 3044:    SmallVector<Value, 4> newOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3045:
        -: 3046:    // Offset cannot be folded into result type.
        -: 3047:
        -: 3048:    // Fold any dynamic dim operands which are produced by a constant.
    #####: 3049:    SmallVector<int64_t, 4> newShapeConstants;
branch  0 never executed
branch  1 never executed
    #####: 3050:    newShapeConstants.reserve(memrefType.getRank());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3051:
    #####: 3052:    unsigned dynamicDimPos = 0;
    #####: 3053:    unsigned rank = memrefType.getRank();
call    0 never executed
    #####: 3054:    for (unsigned dim = 0, e = rank; dim < e; ++dim) {
branch  0 never executed
branch  1 never executed
    #####: 3055:      int64_t dimSize = memrefType.getDimSize(dim);
call    0 never executed
        -: 3056:      // If this is already static dimension, keep it.
    #####: 3057:      if (!ShapedType::isDynamic(dimSize)) {
branch  0 never executed
branch  1 never executed
    #####: 3058:        newShapeConstants.push_back(dimSize);
call    0 never executed
    #####: 3059:        continue;
        -: 3060:      }
    #####: 3061:      auto *defOp = viewOp.getSizes()[dynamicDimPos].getDefiningOp();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3062:      if (auto constantIndexOp =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3063:              dyn_cast_or_null<arith::ConstantIndexOp>(defOp)) {
branch  0 never executed
branch  1 never executed
        -: 3064:        // Dynamic shape dimension will be folded.
    #####: 3065:        newShapeConstants.push_back(constantIndexOp.value());
call    0 never executed
call    1 never executed
        -: 3066:      } else {
        -: 3067:        // Dynamic shape dimension not folded; copy operand from old memref.
    #####: 3068:        newShapeConstants.push_back(dimSize);
call    0 never executed
    #####: 3069:        newOperands.push_back(viewOp.getSizes()[dynamicDimPos]);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3070:      }
    #####: 3071:      dynamicDimPos++;
        -: 3072:    }
        -: 3073:
        -: 3074:    // Create new memref type with constant folded dims.
    #####: 3075:    MemRefType newMemRefType =
    #####: 3076:        MemRefType::Builder(memrefType).setShape(newShapeConstants);
call    0 never executed
call    1 never executed
        -: 3077:    // Nothing new, don't fold.
    #####: 3078:    if (newMemRefType == memrefType)
branch  0 never executed
branch  1 never executed
    #####: 3079:      return failure();
        -: 3080:
        -: 3081:    // Create new ViewOp.
    #####: 3082:    auto newViewOp = rewriter.create<ViewOp>(
    #####: 3083:        viewOp.getLoc(), newMemRefType, viewOp.getOperand(0),
    #####: 3084:        viewOp.getByteShift(), newOperands);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3085:    // Insert a cast so we have the same type as the old memref type.
    #####: 3086:    rewriter.replaceOpWithNewOp<CastOp>(viewOp, viewOp.getType(), newViewOp);
call    0 never executed
call    1 never executed
    #####: 3087:    return success();
branch  0 never executed
branch  1 never executed
        -: 3088:  }
        -: 3089:};
        -: 3090:
        -: 3091:struct ViewOpMemrefCastFolder : public OpRewritePattern<ViewOp> {
        -: 3092:  using OpRewritePattern<ViewOp>::OpRewritePattern;
        -: 3093:
function _ZNK12_GLOBAL__N_122ViewOpMemrefCastFolder15matchAndRewriteEN4mlir6memref6ViewOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3094:  LogicalResult matchAndRewrite(ViewOp viewOp,
        -: 3095:                                PatternRewriter &rewriter) const override {
    #####: 3096:    Value memrefOperand = viewOp.getOperand(0);
call    0 never executed
    #####: 3097:    CastOp memrefCastOp = memrefOperand.getDefiningOp<CastOp>();
call    0 never executed
    #####: 3098:    if (!memrefCastOp)
branch  0 never executed
branch  1 never executed
    #####: 3099:      return failure();
    #####: 3100:    Value allocOperand = memrefCastOp.getOperand();
call    0 never executed
    #####: 3101:    AllocOp allocOp = allocOperand.getDefiningOp<AllocOp>();
call    0 never executed
    #####: 3102:    if (!allocOp)
branch  0 never executed
branch  1 never executed
    #####: 3103:      return failure();
    #####: 3104:    rewriter.replaceOpWithNewOp<ViewOp>(viewOp, viewOp.getType(), allocOperand,
    #####: 3105:                                        viewOp.getByteShift(),
call    0 never executed
    #####: 3106:                                        viewOp.getSizes());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3107:    return success();
        -: 3108:  }
        -: 3109:};
        -: 3110:
        -: 3111:} // namespace
        -: 3112:
function _ZN4mlir6memref6ViewOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1446 returned 100% blocks executed 100%
     1446: 3113:void ViewOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 3114:                                         MLIRContext *context) {
     1446: 3115:  results.add<ViewOpShapeFolder, ViewOpMemrefCastFolder>(context);
call    0 returned 100%
     1446: 3116:}
        -: 3117:
        -: 3118://===----------------------------------------------------------------------===//
        -: 3119:// AtomicRMWOp
        -: 3120://===----------------------------------------------------------------------===//
        -: 3121:
function _ZN4mlir6memref11AtomicRMWOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3122:LogicalResult AtomicRMWOp::verify() {
    #####: 3123:  if (getMemRefType().getRank() != getNumOperands() - 2)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3124:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3125:        "expects the number of subscripts to be equal to memref rank");
call    0 never executed
    #####: 3126:  switch (getKind()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3127:  case arith::AtomicRMWKind::addf:
    #####: 3128:  case arith::AtomicRMWKind::maxf:
    #####: 3129:  case arith::AtomicRMWKind::minf:
    #####: 3130:  case arith::AtomicRMWKind::mulf:
    #####: 3131:    if (!getValue().getType().isa<FloatType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3132:      return emitOpError() << "with kind '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3133:                           << arith::stringifyAtomicRMWKind(getKind())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3134:                           << "' expects a floating-point type";
call    0 never executed
        -: 3135:    break;
    #####: 3136:  case arith::AtomicRMWKind::addi:
    #####: 3137:  case arith::AtomicRMWKind::maxs:
    #####: 3138:  case arith::AtomicRMWKind::maxu:
    #####: 3139:  case arith::AtomicRMWKind::mins:
    #####: 3140:  case arith::AtomicRMWKind::minu:
    #####: 3141:  case arith::AtomicRMWKind::muli:
    #####: 3142:  case arith::AtomicRMWKind::ori:
    #####: 3143:  case arith::AtomicRMWKind::andi:
    #####: 3144:    if (!getValue().getType().isa<IntegerType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3145:      return emitOpError() << "with kind '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3146:                           << arith::stringifyAtomicRMWKind(getKind())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3147:                           << "' expects an integer type";
call    0 never executed
        -: 3148:    break;
        -: 3149:  default:
        -: 3150:    break;
        -: 3151:  }
    #####: 3152:  return success();
        -: 3153:}
        -: 3154:
function _ZN4mlir6memref11AtomicRMWOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 3155:OpFoldResult AtomicRMWOp::fold(ArrayRef<Attribute> operands) {
        -: 3156:  /// atomicrmw(memrefcast) -> atomicrmw
    #####: 3157:  if (succeeded(foldMemRefCast(*this, getValue())))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3158:    return getResult();
call    0 never executed
call    1 never executed
    #####: 3159:  return OpFoldResult();
        -: 3160:}
        -: 3161:
        -: 3162://===----------------------------------------------------------------------===//
        -: 3163:// TableGen'd op method definitions
        -: 3164://===----------------------------------------------------------------------===//
        -: 3165:
        -: 3166:#define GET_OP_CLASSES
        -: 3167:#include "mlir/Dialect/MemRef/IR/MemRefOps.cpp.inc"
