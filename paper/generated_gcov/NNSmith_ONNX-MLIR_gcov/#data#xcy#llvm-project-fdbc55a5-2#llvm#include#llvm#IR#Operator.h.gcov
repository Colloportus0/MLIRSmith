        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/Operator.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===-- llvm/Operator.h - Operator utility subclass -------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines various classes for working with Instructions and
        -:   10:// ConstantExprs.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_IR_OPERATOR_H
        -:   15:#define LLVM_IR_OPERATOR_H
        -:   16:
        -:   17:#include "llvm/ADT/MapVector.h"
        -:   18:#include "llvm/ADT/None.h"
        -:   19:#include "llvm/ADT/Optional.h"
        -:   20:#include "llvm/IR/Constants.h"
        -:   21:#include "llvm/IR/FMF.h"
        -:   22:#include "llvm/IR/Instruction.h"
        -:   23:#include "llvm/IR/Type.h"
        -:   24:#include "llvm/IR/Value.h"
        -:   25:#include "llvm/Support/Casting.h"
        -:   26:#include <cstddef>
        -:   27:
        -:   28:namespace llvm {
        -:   29:
        -:   30:/// This is a utility class that provides an abstraction for the common
        -:   31:/// functionality between Instructions and ConstantExprs.
        -:   32:class Operator : public User {
        -:   33:public:
        -:   34:  // The Operator class is intended to be used as a utility, and is never itself
        -:   35:  // instantiated.
        -:   36:  Operator() = delete;
        -:   37:  ~Operator() = delete;
        -:   38:
        -:   39:  void *operator new(size_t s) = delete;
        -:   40:
        -:   41:  /// Return the opcode for this Instruction or ConstantExpr.
        -:   42:  unsigned getOpcode() const {
        -:   43:    if (const Instruction *I = dyn_cast<Instruction>(this))
        -:   44:      return I->getOpcode();
        -:   45:    return cast<ConstantExpr>(this)->getOpcode();
        -:   46:  }
        -:   47:
        -:   48:  /// If V is an Instruction or ConstantExpr, return its opcode.
        -:   49:  /// Otherwise return UserOp1.
        -:   50:  static unsigned getOpcode(const Value *V) {
        -:   51:    if (const Instruction *I = dyn_cast<Instruction>(V))
        -:   52:      return I->getOpcode();
        -:   53:    if (const ConstantExpr *CE = dyn_cast<ConstantExpr>(V))
        -:   54:      return CE->getOpcode();
        -:   55:    return Instruction::UserOp1;
        -:   56:  }
        -:   57:
        -:   58:  static bool classof(const Instruction *) { return true; }
        -:   59:  static bool classof(const ConstantExpr *) { return true; }
        -:   60:  static bool classof(const Value *V) {
        -:   61:    return isa<Instruction>(V) || isa<ConstantExpr>(V);
        -:   62:  }
        -:   63:
        -:   64:  /// Return true if this operator has flags which may cause this operator
        -:   65:  /// to evaluate to poison despite having non-poison inputs.
        -:   66:  bool hasPoisonGeneratingFlags() const;
        -:   67:};
        -:   68:
        -:   69:/// Utility class for integer operators which may exhibit overflow - Add, Sub,
        -:   70:/// Mul, and Shl. It does not include SDiv, despite that operator having the
        -:   71:/// potential for overflow.
        -:   72:class OverflowingBinaryOperator : public Operator {
        -:   73:public:
        -:   74:  enum {
        -:   75:    AnyWrap        = 0,
        -:   76:    NoUnsignedWrap = (1 << 0),
        -:   77:    NoSignedWrap   = (1 << 1)
        -:   78:  };
        -:   79:
        -:   80:private:
        -:   81:  friend class Instruction;
        -:   82:  friend class ConstantExpr;
        -:   83:
        -:   84:  void setHasNoUnsignedWrap(bool B) {
        -:   85:    SubclassOptionalData =
        -:   86:      (SubclassOptionalData & ~NoUnsignedWrap) | (B * NoUnsignedWrap);
        -:   87:  }
        -:   88:  void setHasNoSignedWrap(bool B) {
        -:   89:    SubclassOptionalData =
        -:   90:      (SubclassOptionalData & ~NoSignedWrap) | (B * NoSignedWrap);
        -:   91:  }
        -:   92:
        -:   93:public:
        -:   94:  /// Test whether this operation is known to never
        -:   95:  /// undergo unsigned overflow, aka the nuw property.
        -:   96:  bool hasNoUnsignedWrap() const {
        -:   97:    return SubclassOptionalData & NoUnsignedWrap;
        -:   98:  }
        -:   99:
        -:  100:  /// Test whether this operation is known to never
        -:  101:  /// undergo signed overflow, aka the nsw property.
        -:  102:  bool hasNoSignedWrap() const {
        -:  103:    return (SubclassOptionalData & NoSignedWrap) != 0;
        -:  104:  }
        -:  105:
        -:  106:  static bool classof(const Instruction *I) {
        -:  107:    return I->getOpcode() == Instruction::Add ||
        -:  108:           I->getOpcode() == Instruction::Sub ||
        -:  109:           I->getOpcode() == Instruction::Mul ||
        -:  110:           I->getOpcode() == Instruction::Shl;
        -:  111:  }
        -:  112:  static bool classof(const ConstantExpr *CE) {
        -:  113:    return CE->getOpcode() == Instruction::Add ||
        -:  114:           CE->getOpcode() == Instruction::Sub ||
        -:  115:           CE->getOpcode() == Instruction::Mul ||
        -:  116:           CE->getOpcode() == Instruction::Shl;
        -:  117:  }
        -:  118:  static bool classof(const Value *V) {
        -:  119:    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
        -:  120:           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
        -:  121:  }
        -:  122:};
        -:  123:
        -:  124:/// A udiv or sdiv instruction, which can be marked as "exact",
        -:  125:/// indicating that no bits are destroyed.
        -:  126:class PossiblyExactOperator : public Operator {
        -:  127:public:
        -:  128:  enum {
        -:  129:    IsExact = (1 << 0)
        -:  130:  };
        -:  131:
        -:  132:private:
        -:  133:  friend class Instruction;
        -:  134:  friend class ConstantExpr;
        -:  135:
        -:  136:  void setIsExact(bool B) {
        -:  137:    SubclassOptionalData = (SubclassOptionalData & ~IsExact) | (B * IsExact);
        -:  138:  }
        -:  139:
        -:  140:public:
        -:  141:  /// Test whether this division is known to be exact, with zero remainder.
        -:  142:  bool isExact() const {
        -:  143:    return SubclassOptionalData & IsExact;
        -:  144:  }
        -:  145:
        -:  146:  static bool isPossiblyExactOpcode(unsigned OpC) {
        -:  147:    return OpC == Instruction::SDiv ||
        -:  148:           OpC == Instruction::UDiv ||
        -:  149:           OpC == Instruction::AShr ||
        -:  150:           OpC == Instruction::LShr;
        -:  151:  }
        -:  152:
        -:  153:  static bool classof(const ConstantExpr *CE) {
        -:  154:    return isPossiblyExactOpcode(CE->getOpcode());
        -:  155:  }
        -:  156:  static bool classof(const Instruction *I) {
        -:  157:    return isPossiblyExactOpcode(I->getOpcode());
        -:  158:  }
        -:  159:  static bool classof(const Value *V) {
        -:  160:    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
        -:  161:           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
        -:  162:  }
        -:  163:};
        -:  164:
        -:  165:/// Utility class for floating point operations which can have
        -:  166:/// information about relaxed accuracy requirements attached to them.
        -:  167:class FPMathOperator : public Operator {
        -:  168:private:
        -:  169:  friend class Instruction;
        -:  170:
        -:  171:  /// 'Fast' means all bits are set.
        -:  172:  void setFast(bool B) {
        -:  173:    setHasAllowReassoc(B);
        -:  174:    setHasNoNaNs(B);
        -:  175:    setHasNoInfs(B);
        -:  176:    setHasNoSignedZeros(B);
        -:  177:    setHasAllowReciprocal(B);
        -:  178:    setHasAllowContract(B);
        -:  179:    setHasApproxFunc(B);
        -:  180:  }
        -:  181:
        -:  182:  void setHasAllowReassoc(bool B) {
        -:  183:    SubclassOptionalData =
        -:  184:    (SubclassOptionalData & ~FastMathFlags::AllowReassoc) |
        -:  185:    (B * FastMathFlags::AllowReassoc);
        -:  186:  }
        -:  187:
        -:  188:  void setHasNoNaNs(bool B) {
        -:  189:    SubclassOptionalData =
        -:  190:      (SubclassOptionalData & ~FastMathFlags::NoNaNs) |
        -:  191:      (B * FastMathFlags::NoNaNs);
        -:  192:  }
        -:  193:
        -:  194:  void setHasNoInfs(bool B) {
        -:  195:    SubclassOptionalData =
        -:  196:      (SubclassOptionalData & ~FastMathFlags::NoInfs) |
        -:  197:      (B * FastMathFlags::NoInfs);
        -:  198:  }
        -:  199:
        -:  200:  void setHasNoSignedZeros(bool B) {
        -:  201:    SubclassOptionalData =
        -:  202:      (SubclassOptionalData & ~FastMathFlags::NoSignedZeros) |
        -:  203:      (B * FastMathFlags::NoSignedZeros);
        -:  204:  }
        -:  205:
        -:  206:  void setHasAllowReciprocal(bool B) {
        -:  207:    SubclassOptionalData =
        -:  208:      (SubclassOptionalData & ~FastMathFlags::AllowReciprocal) |
        -:  209:      (B * FastMathFlags::AllowReciprocal);
        -:  210:  }
        -:  211:
        -:  212:  void setHasAllowContract(bool B) {
        -:  213:    SubclassOptionalData =
        -:  214:        (SubclassOptionalData & ~FastMathFlags::AllowContract) |
        -:  215:        (B * FastMathFlags::AllowContract);
        -:  216:  }
        -:  217:
        -:  218:  void setHasApproxFunc(bool B) {
        -:  219:    SubclassOptionalData =
        -:  220:        (SubclassOptionalData & ~FastMathFlags::ApproxFunc) |
        -:  221:        (B * FastMathFlags::ApproxFunc);
        -:  222:  }
        -:  223:
        -:  224:  /// Convenience function for setting multiple fast-math flags.
        -:  225:  /// FMF is a mask of the bits to set.
        -:  226:  void setFastMathFlags(FastMathFlags FMF) {
        -:  227:    SubclassOptionalData |= FMF.Flags;
        -:  228:  }
        -:  229:
        -:  230:  /// Convenience function for copying all fast-math flags.
        -:  231:  /// All values in FMF are transferred to this operator.
        -:  232:  void copyFastMathFlags(FastMathFlags FMF) {
        -:  233:    SubclassOptionalData = FMF.Flags;
        -:  234:  }
        -:  235:
        -:  236:public:
        -:  237:  /// Test if this operation allows all non-strict floating-point transforms.
        -:  238:  bool isFast() const {
        -:  239:    return ((SubclassOptionalData & FastMathFlags::AllowReassoc) != 0 &&
        -:  240:            (SubclassOptionalData & FastMathFlags::NoNaNs) != 0 &&
        -:  241:            (SubclassOptionalData & FastMathFlags::NoInfs) != 0 &&
        -:  242:            (SubclassOptionalData & FastMathFlags::NoSignedZeros) != 0 &&
        -:  243:            (SubclassOptionalData & FastMathFlags::AllowReciprocal) != 0 &&
        -:  244:            (SubclassOptionalData & FastMathFlags::AllowContract) != 0 &&
        -:  245:            (SubclassOptionalData & FastMathFlags::ApproxFunc) != 0);
        -:  246:  }
        -:  247:
        -:  248:  /// Test if this operation may be simplified with reassociative transforms.
        -:  249:  bool hasAllowReassoc() const {
        -:  250:    return (SubclassOptionalData & FastMathFlags::AllowReassoc) != 0;
        -:  251:  }
        -:  252:
        -:  253:  /// Test if this operation's arguments and results are assumed not-NaN.
        -:  254:  bool hasNoNaNs() const {
        -:  255:    return (SubclassOptionalData & FastMathFlags::NoNaNs) != 0;
        -:  256:  }
        -:  257:
        -:  258:  /// Test if this operation's arguments and results are assumed not-infinite.
        -:  259:  bool hasNoInfs() const {
        -:  260:    return (SubclassOptionalData & FastMathFlags::NoInfs) != 0;
        -:  261:  }
        -:  262:
        -:  263:  /// Test if this operation can ignore the sign of zero.
        -:  264:  bool hasNoSignedZeros() const {
        -:  265:    return (SubclassOptionalData & FastMathFlags::NoSignedZeros) != 0;
        -:  266:  }
        -:  267:
        -:  268:  /// Test if this operation can use reciprocal multiply instead of division.
        -:  269:  bool hasAllowReciprocal() const {
        -:  270:    return (SubclassOptionalData & FastMathFlags::AllowReciprocal) != 0;
        -:  271:  }
        -:  272:
        -:  273:  /// Test if this operation can be floating-point contracted (FMA).
        -:  274:  bool hasAllowContract() const {
        -:  275:    return (SubclassOptionalData & FastMathFlags::AllowContract) != 0;
        -:  276:  }
        -:  277:
        -:  278:  /// Test if this operation allows approximations of math library functions or
        -:  279:  /// intrinsics.
        -:  280:  bool hasApproxFunc() const {
        -:  281:    return (SubclassOptionalData & FastMathFlags::ApproxFunc) != 0;
        -:  282:  }
        -:  283:
        -:  284:  /// Convenience function for getting all the fast-math flags
        -:  285:  FastMathFlags getFastMathFlags() const {
        -:  286:    return FastMathFlags(SubclassOptionalData);
        -:  287:  }
        -:  288:
        -:  289:  /// Get the maximum error permitted by this operation in ULPs. An accuracy of
        -:  290:  /// 0.0 means that the operation should be performed with the default
        -:  291:  /// precision.
        -:  292:  float getFPAccuracy() const;
        -:  293:
function _ZN4llvm14FPMathOperator7classofEPKNS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  294:  static bool classof(const Value *V) {
    #####:  295:    unsigned Opcode;
    #####:  296:    if (auto *I = dyn_cast<Instruction>(V))
branch  0 never executed
branch  1 never executed
    #####:  297:      Opcode = I->getOpcode();
    #####:  298:    else if (auto *CE = dyn_cast<ConstantExpr>(V))
branch  0 never executed
branch  1 never executed
    #####:  299:      Opcode = CE->getOpcode();
        -:  300:    else
        -:  301:      return false;
        -:  302:
    #####:  303:    switch (Opcode) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  304:    case Instruction::FNeg:
        -:  305:    case Instruction::FAdd:
        -:  306:    case Instruction::FSub:
        -:  307:    case Instruction::FMul:
        -:  308:    case Instruction::FDiv:
        -:  309:    case Instruction::FRem:
        -:  310:    // FIXME: To clean up and correct the semantics of fast-math-flags, FCmp
        -:  311:    //        should not be treated as a math op, but the other opcodes should.
        -:  312:    //        This would make things consistent with Select/PHI (FP value type
        -:  313:    //        determines whether they are math ops and, therefore, capable of
        -:  314:    //        having fast-math-flags).
        -:  315:    case Instruction::FCmp:
        -:  316:      return true;
    #####:  317:    case Instruction::PHI:
    #####:  318:    case Instruction::Select:
    #####:  319:    case Instruction::Call: {
    #####:  320:      Type *Ty = V->getType();
    #####:  321:      while (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty))
branch  0 never executed
branch  1 never executed
    #####:  322:        Ty = ArrTy->getElementType();
    #####:  323:      return Ty->isFPOrFPVectorTy();
call    0 never executed
        -:  324:    }
    #####:  325:    default:
    #####:  326:      return false;
        -:  327:    }
        -:  328:  }
        -:  329:};
        -:  330:
        -:  331:/// A helper template for defining operators for individual opcodes.
        -:  332:template<typename SuperClass, unsigned Opc>
        -:  333:class ConcreteOperator : public SuperClass {
        -:  334:public:
        -:  335:  static bool classof(const Instruction *I) {
        -:  336:    return I->getOpcode() == Opc;
        -:  337:  }
        -:  338:  static bool classof(const ConstantExpr *CE) {
        -:  339:    return CE->getOpcode() == Opc;
        -:  340:  }
        -:  341:  static bool classof(const Value *V) {
        -:  342:    return (isa<Instruction>(V) && classof(cast<Instruction>(V))) ||
        -:  343:           (isa<ConstantExpr>(V) && classof(cast<ConstantExpr>(V)));
        -:  344:  }
        -:  345:};
        -:  346:
        -:  347:class AddOperator
        -:  348:  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Add> {
        -:  349:};
        -:  350:class SubOperator
        -:  351:  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Sub> {
        -:  352:};
        -:  353:class MulOperator
        -:  354:  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Mul> {
        -:  355:};
        -:  356:class ShlOperator
        -:  357:  : public ConcreteOperator<OverflowingBinaryOperator, Instruction::Shl> {
        -:  358:};
        -:  359:
        -:  360:class SDivOperator
        -:  361:  : public ConcreteOperator<PossiblyExactOperator, Instruction::SDiv> {
        -:  362:};
        -:  363:class UDivOperator
        -:  364:  : public ConcreteOperator<PossiblyExactOperator, Instruction::UDiv> {
        -:  365:};
        -:  366:class AShrOperator
        -:  367:  : public ConcreteOperator<PossiblyExactOperator, Instruction::AShr> {
        -:  368:};
        -:  369:class LShrOperator
        -:  370:  : public ConcreteOperator<PossiblyExactOperator, Instruction::LShr> {
        -:  371:};
        -:  372:
        -:  373:class ZExtOperator : public ConcreteOperator<Operator, Instruction::ZExt> {};
        -:  374:
        -:  375:class GEPOperator
        -:  376:  : public ConcreteOperator<Operator, Instruction::GetElementPtr> {
        -:  377:  friend class GetElementPtrInst;
        -:  378:  friend class ConstantExpr;
        -:  379:
        -:  380:  enum {
        -:  381:    IsInBounds = (1 << 0),
        -:  382:    // InRangeIndex: bits 1-6
        -:  383:  };
        -:  384:
        -:  385:  void setIsInBounds(bool B) {
        -:  386:    SubclassOptionalData =
        -:  387:      (SubclassOptionalData & ~IsInBounds) | (B * IsInBounds);
        -:  388:  }
        -:  389:
        -:  390:public:
        -:  391:  /// Test whether this is an inbounds GEP, as defined by LangRef.html.
        -:  392:  bool isInBounds() const {
        -:  393:    return SubclassOptionalData & IsInBounds;
        -:  394:  }
        -:  395:
        -:  396:  /// Returns the offset of the index with an inrange attachment, or None if
        -:  397:  /// none.
        -:  398:  Optional<unsigned> getInRangeIndex() const {
        -:  399:    if (SubclassOptionalData >> 1 == 0) return None;
        -:  400:    return (SubclassOptionalData >> 1) - 1;
        -:  401:  }
        -:  402:
        -:  403:  inline op_iterator       idx_begin()       { return op_begin()+1; }
        -:  404:  inline const_op_iterator idx_begin() const { return op_begin()+1; }
        -:  405:  inline op_iterator       idx_end()         { return op_end(); }
        -:  406:  inline const_op_iterator idx_end()   const { return op_end(); }
        -:  407:
        -:  408:  inline iterator_range<op_iterator> indices() {
        -:  409:    return make_range(idx_begin(), idx_end());
        -:  410:  }
        -:  411:
        -:  412:  inline iterator_range<const_op_iterator> indices() const {
        -:  413:    return make_range(idx_begin(), idx_end());
        -:  414:  }
        -:  415:
        -:  416:  Value *getPointerOperand() {
        -:  417:    return getOperand(0);
        -:  418:  }
        -:  419:  const Value *getPointerOperand() const {
        -:  420:    return getOperand(0);
        -:  421:  }
        -:  422:  static unsigned getPointerOperandIndex() {
        -:  423:    return 0U;                      // get index for modifying correct operand
        -:  424:  }
        -:  425:
        -:  426:  /// Method to return the pointer operand as a PointerType.
        -:  427:  Type *getPointerOperandType() const {
        -:  428:    return getPointerOperand()->getType();
        -:  429:  }
        -:  430:
        -:  431:  Type *getSourceElementType() const;
        -:  432:  Type *getResultElementType() const;
        -:  433:
        -:  434:  /// Method to return the address space of the pointer operand.
        -:  435:  unsigned getPointerAddressSpace() const {
        -:  436:    return getPointerOperandType()->getPointerAddressSpace();
        -:  437:  }
        -:  438:
        -:  439:  unsigned getNumIndices() const {  // Note: always non-negative
        -:  440:    return getNumOperands() - 1;
        -:  441:  }
        -:  442:
        -:  443:  bool hasIndices() const {
        -:  444:    return getNumOperands() > 1;
        -:  445:  }
        -:  446:
        -:  447:  /// Return true if all of the indices of this GEP are zeros.
        -:  448:  /// If so, the result pointer and the first operand have the same
        -:  449:  /// value, just potentially different types.
        -:  450:  bool hasAllZeroIndices() const {
        -:  451:    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {
        -:  452:      if (ConstantInt *C = dyn_cast<ConstantInt>(I))
        -:  453:        if (C->isZero())
        -:  454:          continue;
        -:  455:      return false;
        -:  456:    }
        -:  457:    return true;
        -:  458:  }
        -:  459:
        -:  460:  /// Return true if all of the indices of this GEP are constant integers.
        -:  461:  /// If so, the result pointer and the first operand have
        -:  462:  /// a constant offset between them.
        -:  463:  bool hasAllConstantIndices() const {
        -:  464:    for (const_op_iterator I = idx_begin(), E = idx_end(); I != E; ++I) {
        -:  465:      if (!isa<ConstantInt>(I))
        -:  466:        return false;
        -:  467:    }
        -:  468:    return true;
        -:  469:  }
        -:  470:
        -:  471:  unsigned countNonConstantIndices() const {
        -:  472:    return count_if(indices(), [](const Use& use) {
        -:  473:        return !isa<ConstantInt>(*use);
        -:  474:      });
        -:  475:  }
        -:  476:
        -:  477:  /// Compute the maximum alignment that this GEP is garranteed to preserve.
        -:  478:  Align getMaxPreservedAlignment(const DataLayout &DL) const;
        -:  479:
        -:  480:  /// Accumulate the constant address offset of this GEP if possible.
        -:  481:  ///
        -:  482:  /// This routine accepts an APInt into which it will try to accumulate the
        -:  483:  /// constant offset of this GEP.
        -:  484:  ///
        -:  485:  /// If \p ExternalAnalysis is provided it will be used to calculate a offset
        -:  486:  /// when a operand of GEP is not constant.
        -:  487:  /// For example, for a value \p ExternalAnalysis might try to calculate a
        -:  488:  /// lower bound. If \p ExternalAnalysis is successful, it should return true.
        -:  489:  ///
        -:  490:  /// If the \p ExternalAnalysis returns false or the value returned by \p
        -:  491:  /// ExternalAnalysis results in a overflow/underflow, this routine returns
        -:  492:  /// false and the value of the offset APInt is undefined (it is *not*
        -:  493:  /// preserved!).
        -:  494:  ///
        -:  495:  /// The APInt passed into this routine must be at exactly as wide as the
        -:  496:  /// IntPtr type for the address space of the base GEP pointer.
        -:  497:  bool accumulateConstantOffset(
        -:  498:      const DataLayout &DL, APInt &Offset,
        -:  499:      function_ref<bool(Value &, APInt &)> ExternalAnalysis = nullptr) const;
        -:  500:
        -:  501:  static bool accumulateConstantOffset(
        -:  502:      Type *SourceType, ArrayRef<const Value *> Index, const DataLayout &DL,
        -:  503:      APInt &Offset,
        -:  504:      function_ref<bool(Value &, APInt &)> ExternalAnalysis = nullptr);
        -:  505:
        -:  506:  /// Collect the offset of this GEP as a map of Values to their associated
        -:  507:  /// APInt multipliers, as well as a total Constant Offset.
        -:  508:  bool collectOffset(const DataLayout &DL, unsigned BitWidth,
        -:  509:                     MapVector<Value *, APInt> &VariableOffsets,
        -:  510:                     APInt &ConstantOffset) const;
        -:  511:};
        -:  512:
        -:  513:class PtrToIntOperator
        -:  514:    : public ConcreteOperator<Operator, Instruction::PtrToInt> {
        -:  515:  friend class PtrToInt;
        -:  516:  friend class ConstantExpr;
        -:  517:
        -:  518:public:
        -:  519:  Value *getPointerOperand() {
        -:  520:    return getOperand(0);
        -:  521:  }
        -:  522:  const Value *getPointerOperand() const {
        -:  523:    return getOperand(0);
        -:  524:  }
        -:  525:
        -:  526:  static unsigned getPointerOperandIndex() {
        -:  527:    return 0U;                      // get index for modifying correct operand
        -:  528:  }
        -:  529:
        -:  530:  /// Method to return the pointer operand as a PointerType.
        -:  531:  Type *getPointerOperandType() const {
        -:  532:    return getPointerOperand()->getType();
        -:  533:  }
        -:  534:
        -:  535:  /// Method to return the address space of the pointer operand.
        -:  536:  unsigned getPointerAddressSpace() const {
        -:  537:    return cast<PointerType>(getPointerOperandType())->getAddressSpace();
        -:  538:  }
        -:  539:};
        -:  540:
        -:  541:class BitCastOperator
        -:  542:    : public ConcreteOperator<Operator, Instruction::BitCast> {
        -:  543:  friend class BitCastInst;
        -:  544:  friend class ConstantExpr;
        -:  545:
        -:  546:public:
        -:  547:  Type *getSrcTy() const {
        -:  548:    return getOperand(0)->getType();
        -:  549:  }
        -:  550:
        -:  551:  Type *getDestTy() const {
        -:  552:    return getType();
        -:  553:  }
        -:  554:};
        -:  555:
        -:  556:class AddrSpaceCastOperator
        -:  557:    : public ConcreteOperator<Operator, Instruction::AddrSpaceCast> {
        -:  558:  friend class AddrSpaceCastInst;
        -:  559:  friend class ConstantExpr;
        -:  560:
        -:  561:public:
        -:  562:  Value *getPointerOperand() { return getOperand(0); }
        -:  563:
        -:  564:  const Value *getPointerOperand() const { return getOperand(0); }
        -:  565:
        -:  566:  unsigned getSrcAddressSpace() const {
        -:  567:    return getPointerOperand()->getType()->getPointerAddressSpace();
        -:  568:  }
        -:  569:
        -:  570:  unsigned getDestAddressSpace() const {
        -:  571:    return getType()->getPointerAddressSpace();
        -:  572:  }
        -:  573:};
        -:  574:
        -:  575:} // end namespace llvm
        -:  576:
        -:  577:#endif // LLVM_IR_OPERATOR_H
