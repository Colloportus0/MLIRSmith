        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===- ModuleTranslation.cpp - MLIR to LLVM conversion --------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the translation between an MLIR LLVM dialect module and
        -:   10:// the corresponding LLVMIR module. It only handles core LLVM IR operations.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Target/LLVMIR/ModuleTranslation.h"
        -:   15:
        -:   16:#include "DebugTranslation.h"
        -:   17:#include "mlir/Dialect/DLTI/DLTI.h"
        -:   18:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   19:#include "mlir/Dialect/LLVMIR/Transforms/LegalizeForExport.h"
        -:   20:#include "mlir/Dialect/OpenMP/OpenMPDialect.h"
        -:   21:#include "mlir/IR/Attributes.h"
        -:   22:#include "mlir/IR/BuiltinOps.h"
        -:   23:#include "mlir/IR/BuiltinTypes.h"
        -:   24:#include "mlir/IR/RegionGraphTraits.h"
        -:   25:#include "mlir/Support/LLVM.h"
        -:   26:#include "mlir/Target/LLVMIR/LLVMTranslationInterface.h"
        -:   27:#include "mlir/Target/LLVMIR/TypeToLLVM.h"
        -:   28:#include "llvm/ADT/TypeSwitch.h"
        -:   29:
        -:   30:#include "llvm/ADT/PostOrderIterator.h"
        -:   31:#include "llvm/ADT/SetVector.h"
        -:   32:#include "llvm/Frontend/OpenMP/OMPIRBuilder.h"
        -:   33:#include "llvm/IR/BasicBlock.h"
        -:   34:#include "llvm/IR/CFG.h"
        -:   35:#include "llvm/IR/Constants.h"
        -:   36:#include "llvm/IR/DerivedTypes.h"
        -:   37:#include "llvm/IR/IRBuilder.h"
        -:   38:#include "llvm/IR/InlineAsm.h"
        -:   39:#include "llvm/IR/IntrinsicsNVPTX.h"
        -:   40:#include "llvm/IR/LLVMContext.h"
        -:   41:#include "llvm/IR/MDBuilder.h"
        -:   42:#include "llvm/IR/Module.h"
        -:   43:#include "llvm/IR/Verifier.h"
        -:   44:#include "llvm/Transforms/Utils/BasicBlockUtils.h"
        -:   45:#include "llvm/Transforms/Utils/Cloning.h"
        -:   46:#include "llvm/Transforms/Utils/ModuleUtils.h"
        -:   47:
        -:   48:using namespace mlir;
        -:   49:using namespace mlir::LLVM;
        -:   50:using namespace mlir::LLVM::detail;
        -:   51:
        -:   52:#include "mlir/Dialect/LLVMIR/LLVMConversionEnumsToLLVM.inc"
        -:   53:
        -:   54:/// Translates the given data layout spec attribute to the LLVM IR data layout.
        -:   55:/// Only integer, float, pointer and endianness entries are currently supported.
        -:   56:static FailureOr<llvm::DataLayout>
function _ZL19translateDataLayoutN4mlir23DataLayoutSpecInterfaceERKNS_10DataLayoutEN4llvm8OptionalINS_8LocationEEE called 0 returned 0% blocks executed 0%
    #####:   57:translateDataLayout(DataLayoutSpecInterface attribute,
        -:   58:                    const DataLayout &dataLayout,
        -:   59:                    Optional<Location> loc = llvm::None) {
    #####:   60:  if (!loc)
branch  0 never executed
branch  1 never executed
    #####:   61:    loc = UnknownLoc::get(attribute.getContext());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   62:
        -:   63:  // Translate the endianness attribute.
    #####:   64:  std::string llvmDataLayout;
call    0 never executed
    #####:   65:  llvm::raw_string_ostream layoutStream(llvmDataLayout);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:  for (DataLayoutEntryInterface entry : attribute.getEntries()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:    auto key = entry.getKey().dyn_cast<StringAttr>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   68:    if (!key)
branch  0 never executed
branch  1 never executed
    #####:   69:      continue;
    #####:   70:    if (key.getValue() == DLTIDialect::kDataLayoutEndiannessKey) {
call    0 never executed
    #####:   71:      auto value = entry.getValue().cast<StringAttr>();
call    0 never executed
call    1 never executed
    #####:   72:      bool isLittleEndian =
    #####:   73:          value.getValue() == DLTIDialect::kDataLayoutEndiannessLittle;
call    0 never executed
    #####:   74:      layoutStream << (isLittleEndian ? "e" : "E");
call    0 never executed
    #####:   75:      layoutStream.flush();
branch  0 never executed
branch  1 never executed
    #####:   76:      continue;
        -:   77:    }
    #####:   78:    emitError(*loc) << "unsupported data layout key " << key;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:   79:    return failure();
        -:   80:  }
        -:   81:
        -:   82:  // Go through the list of entries to check which types are explicitly
        -:   83:  // specified in entries. Where possible, data layout queries are used instead
        -:   84:  // of directly inspecting the entries.
    #####:   85:  for (DataLayoutEntryInterface entry : attribute.getEntries()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   86:    auto type = entry.getKey().dyn_cast<Type>();
call    0 never executed
call    1 never executed
    #####:   87:    if (!type)
branch  0 never executed
branch  1 never executed
    #####:   88:      continue;
        -:   89:    // Data layout for the index type is irrelevant at this point.
    #####:   90:    if (type.isa<IndexType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   91:      continue;
    #####:   92:    layoutStream << "-";
call    0 never executed
    #####:   93:    LogicalResult result =
call    0 never executed
    #####:   94:        llvm::TypeSwitch<Type, LogicalResult>(type)
        -:   95:            .Case<IntegerType, Float16Type, Float32Type, Float64Type,
function _ZZL19translateDataLayoutN4mlir23DataLayoutSpecInterfaceERKNS_10DataLayoutEN4llvm8OptionalINS_8LocationEEEENKUlNS_4TypeEE_clES8_ called 0 returned 0% blocks executed 0%
    #####:   96:                  Float80Type, Float128Type>([&](Type type) -> LogicalResult {
    #####:   97:              if (auto intType = type.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   98:                if (intType.getSignedness() != IntegerType::Signless)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:                  return emitError(*loc)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  100:                         << "unsupported data layout for non-signless integer "
call    0 never executed
    #####:  101:                         << intType;
call    0 never executed
    #####:  102:                layoutStream << "i";
call    0 never executed
        -:  103:              } else {
    #####:  104:                layoutStream << "f";
call    0 never executed
        -:  105:              }
    #####:  106:              unsigned size = dataLayout.getTypeSizeInBits(type);
call    0 never executed
    #####:  107:              unsigned abi = dataLayout.getTypeABIAlignment(type) * 8u;
call    0 never executed
    #####:  108:              unsigned preferred =
    #####:  109:                  dataLayout.getTypePreferredAlignment(type) * 8u;
call    0 never executed
    #####:  110:              layoutStream << size << ":" << abi;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  111:              if (abi != preferred)
branch  0 never executed
branch  1 never executed
    #####:  112:                layoutStream << ":" << preferred;
call    0 never executed
call    1 never executed
    #####:  113:              return success();
    #####:  114:            })
call    0 never executed
function _ZZL19translateDataLayoutN4mlir23DataLayoutSpecInterfaceERKNS_10DataLayoutEN4llvm8OptionalINS_8LocationEEEENKUlNS_4LLVM15LLVMPointerTypeEE0_clES9_ called 0 returned 0% blocks executed 0%
    #####:  115:            .Case([&](LLVMPointerType ptrType) {
    #####:  116:              layoutStream << "p" << ptrType.getAddressSpace() << ":";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  117:              unsigned size = dataLayout.getTypeSizeInBits(type);
call    0 never executed
    #####:  118:              unsigned abi = dataLayout.getTypeABIAlignment(type) * 8u;
call    0 never executed
    #####:  119:              unsigned preferred =
    #####:  120:                  dataLayout.getTypePreferredAlignment(type) * 8u;
call    0 never executed
    #####:  121:              layoutStream << size << ":" << abi << ":" << preferred;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  122:              if (Optional<unsigned> index = extractPointerSpecValue(
branch  0 never executed
branch  1 never executed
    #####:  123:                      entry.getValue(), PtrDLEntryPos::Index))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:                layoutStream << ":" << *index;
call    0 never executed
call    1 never executed
    #####:  125:              return success();
    #####:  126:            })
call    0 never executed
function _ZZL19translateDataLayoutN4mlir23DataLayoutSpecInterfaceERKNS_10DataLayoutEN4llvm8OptionalINS_8LocationEEEENKUlNS_4TypeEE1_clES8_ called 0 returned 0% blocks executed 0%
    #####:  127:            .Default([loc](Type type) {
    #####:  128:              return emitError(*loc)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  129:                     << "unsupported type in data layout: " << type;
call    0 never executed
call    1 never executed
    #####:  130:            });
call    0 never executed
    #####:  131:    if (failed(result))
branch  0 never executed
branch  1 never executed
    #####:  132:      return failure();
        -:  133:  }
    #####:  134:  layoutStream.flush();
branch  0 never executed
branch  1 never executed
    #####:  135:  StringRef layoutSpec(llvmDataLayout);
branch  0 never executed
branch  1 never executed
    #####:  136:  if (layoutSpec.startswith("-"))
branch  0 never executed
branch  1 never executed
    #####:  137:    layoutSpec = layoutSpec.drop_front();
call    0 never executed
        -:  138:
    #####:  139:  return llvm::DataLayout(layoutSpec);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  140:}
        -:  141:
        -:  142:/// Builds a constant of a sequential LLVM type `type`, potentially containing
        -:  143:/// other sequential types recursively, from the individual constant values
        -:  144:/// provided in `constants`. `shape` contains the number of elements in nested
        -:  145:/// sequential types. Reports errors at `loc` and returns nullptr on error.
        -:  146:static llvm::Constant *
function _ZL23buildSequentialConstantRN4llvm8ArrayRefIPNS_8ConstantEEENS0_IlEEPNS_4TypeEN4mlir8LocationE called 0 returned 0% blocks executed 0%
    #####:  147:buildSequentialConstant(ArrayRef<llvm::Constant *> &constants,
        -:  148:                        ArrayRef<int64_t> shape, llvm::Type *type,
        -:  149:                        Location loc) {
    #####:  150:  if (shape.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  151:    llvm::Constant *result = constants.front();
branch  0 never executed
branch  1 never executed
    #####:  152:    constants = constants.drop_front();
    #####:  153:    return result;
call    0 never executed
        -:  154:  }
        -:  155:
    #####:  156:  llvm::Type *elementType;
    #####:  157:  if (auto *arrayTy = dyn_cast<llvm::ArrayType>(type)) {
branch  0 never executed
branch  1 never executed
    #####:  158:    elementType = arrayTy->getElementType();
    #####:  159:  } else if (auto *vectorTy = dyn_cast<llvm::VectorType>(type)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:    elementType = vectorTy->getElementType();
        -:  161:  } else {
    #####:  162:    emitError(loc) << "expected sequential LLVM types wrapping a scalar";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  163:    return nullptr;
        -:  164:  }
        -:  165:
    #####:  166:  SmallVector<llvm::Constant *, 8> nested;
branch  0 never executed
branch  1 never executed
    #####:  167:  nested.reserve(shape.front());
branch  0 never executed
branch  1 never executed
    #####:  168:  for (int64_t i = 0; i < shape.front(); ++i) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  169:    nested.push_back(buildSequentialConstant(constants, shape.drop_front(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  170:                                             elementType, loc));
    #####:  171:    if (!nested.back())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  172:      return nullptr;
        -:  173:  }
        -:  174:
    #####:  175:  if (shape.size() == 1 && type->isVectorTy())
branch  0 never executed
branch  1 never executed
    #####:  176:    return llvm::ConstantVector::get(nested);
call    0 never executed
    #####:  177:  return llvm::ConstantArray::get(
call    0 never executed
call    1 never executed
    #####:  178:      llvm::ArrayType::get(elementType, shape.front()), nested);
call    0 never executed
        -:  179:}
        -:  180:
        -:  181:/// Returns the first non-sequential type nested in sequential types.
function _ZL23getInnermostElementTypePN4llvm4TypeE called 0 returned 0% blocks executed 0%
    #####:  182:static llvm::Type *getInnermostElementType(llvm::Type *type) {
    #####:  183:  do {
    #####:  184:    if (auto *arrayTy = dyn_cast<llvm::ArrayType>(type)) {
branch  0 never executed
branch  1 never executed
    #####:  185:      type = arrayTy->getElementType();
    #####:  186:    } else if (auto *vectorTy = dyn_cast<llvm::VectorType>(type)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  187:      type = vectorTy->getElementType();
        -:  188:    } else {
    #####:  189:      return type;
        -:  190:    }
        -:  191:  } while (true);
        -:  192:}
        -:  193:
        -:  194:/// Convert a dense elements attribute to an LLVM IR constant using its raw data
        -:  195:/// storage if possible. This supports elements attributes of tensor or vector
        -:  196:/// type and avoids constructing separate objects for individual values of the
        -:  197:/// innermost dimension. Constants for other dimensions are still constructed
        -:  198:/// recursively. Returns null if constructing from raw data is not supported for
        -:  199:/// this type, e.g., element type is not a power-of-two-sized primitive. Reports
        -:  200:/// other errors at `loc`.
        -:  201:static llvm::Constant *
function _ZL24convertDenseElementsAttrN4mlir8LocationENS_17DenseElementsAttrEPN4llvm4TypeERKNS_4LLVM17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  202:convertDenseElementsAttr(Location loc, DenseElementsAttr denseElementsAttr,
        -:  203:                         llvm::Type *llvmType,
        -:  204:                         const ModuleTranslation &moduleTranslation) {
    #####:  205:  if (!denseElementsAttr)
branch  0 never executed
branch  1 never executed
        -:  206:    return nullptr;
        -:  207:
    #####:  208:  llvm::Type *innermostLLVMType = getInnermostElementType(llvmType);
call    0 never executed
    #####:  209:  if (!llvm::ConstantDataSequential::isElementTypeCompatible(innermostLLVMType))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  210:    return nullptr;
        -:  211:
    #####:  212:  ShapedType type = denseElementsAttr.getType();
call    0 never executed
    #####:  213:  if (type.getNumElements() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  214:    return nullptr;
        -:  215:
        -:  216:  // Compute the shape of all dimensions but the innermost. Note that the
        -:  217:  // innermost dimension may be that of the vector element type.
    #####:  218:  bool hasVectorElementType = type.getElementType().isa<VectorType>();
call    0 never executed
call    1 never executed
    #####:  219:  unsigned numAggregates =
    #####:  220:      denseElementsAttr.getNumElements() /
call    0 never executed
    #####:  221:      (hasVectorElementType ? 1
branch  0 never executed
branch  1 never executed
    #####:  222:                            : denseElementsAttr.getType().getShape().back());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  223:  ArrayRef<int64_t> outerShape = type.getShape();
call    0 never executed
    #####:  224:  if (!hasVectorElementType)
branch  0 never executed
branch  1 never executed
    #####:  225:    outerShape = outerShape.drop_back();
call    0 never executed
        -:  226:
        -:  227:  // Handle the case of vector splat, LLVM has special support for it.
    #####:  228:  if (denseElementsAttr.isSplat() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  229:      (type.isa<VectorType>() || hasVectorElementType)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  230:    llvm::Constant *splatValue = LLVM::detail::getLLVMConstant(
call    0 never executed
call    1 never executed
        -:  231:        innermostLLVMType, denseElementsAttr.getSplatValue<Attribute>(), loc,
        -:  232:        moduleTranslation);
    #####:  233:    llvm::Constant *splatVector =
    #####:  234:        llvm::ConstantDataVector::getSplat(0, splatValue);
call    0 never executed
    #####:  235:    SmallVector<llvm::Constant *> constants(numAggregates, splatVector);
call    0 never executed
    #####:  236:    ArrayRef<llvm::Constant *> constantsRef = constants;
call    0 never executed
    #####:  237:    return buildSequentialConstant(constantsRef, outerShape, llvmType, loc);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  238:  }
    #####:  239:  if (denseElementsAttr.isSplat())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  240:    return nullptr;
        -:  241:
        -:  242:  // In case of non-splat, create a constructor for the innermost constant from
        -:  243:  // a piece of raw data.
    #####:  244:  std::function<llvm::Constant *(StringRef)> buildCstData;
call    0 never executed
    #####:  245:  if (type.isa<TensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  246:    auto vectorElementType = type.getElementType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####:  247:    if (vectorElementType && vectorElementType.getRank() == 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
function _ZZL24convertDenseElementsAttrN4mlir8LocationENS_17DenseElementsAttrEPN4llvm4TypeERKNS_4LLVM17ModuleTranslationEENKUlNS2_9StringRefEE_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  248:      buildCstData = [&](StringRef data) {
    #####:  249:        return llvm::ConstantDataVector::getRaw(
    #####:  250:            data, vectorElementType.getShape().back(), innermostLLVMType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  251:      };
call    0 never executed
    #####:  252:    } else if (!vectorElementType) {
branch  0 never executed
branch  1 never executed
function _ZZL24convertDenseElementsAttrN4mlir8LocationENS_17DenseElementsAttrEPN4llvm4TypeERKNS_4LLVM17ModuleTranslationEENKUlNS2_9StringRefEE0_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  253:      buildCstData = [&](StringRef data) {
    #####:  254:        return llvm::ConstantDataArray::getRaw(data, type.getShape().back(),
call    0 never executed
call    1 never executed
    #####:  255:                                               innermostLLVMType);
call    0 never executed
    #####:  256:      };
call    0 never executed
        -:  257:    }
    #####:  258:  } else if (type.isa<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZL24convertDenseElementsAttrN4mlir8LocationENS_17DenseElementsAttrEPN4llvm4TypeERKNS_4LLVM17ModuleTranslationEENKUlNS2_9StringRefEE1_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  259:    buildCstData = [&](StringRef data) {
    #####:  260:      return llvm::ConstantDataVector::getRaw(data, type.getShape().back(),
call    0 never executed
call    1 never executed
    #####:  261:                                              innermostLLVMType);
call    0 never executed
    #####:  262:    };
call    0 never executed
        -:  263:  }
    #####:  264:  if (!buildCstData)
branch  0 never executed
branch  1 never executed
        -:  265:    return nullptr;
        -:  266:
        -:  267:  // Create innermost constants and defer to the default constant creation
        -:  268:  // mechanism for other dimensions.
    #####:  269:  SmallVector<llvm::Constant *> constants;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  270:  unsigned aggregateSize = denseElementsAttr.getType().getShape().back() *
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  271:                           (innermostLLVMType->getScalarSizeInBits() / 8);
    #####:  272:  constants.reserve(numAggregates);
branch  0 never executed
branch  1 never executed
    #####:  273:  for (unsigned i = 0; i < numAggregates; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  274:    StringRef data(denseElementsAttr.getRawData().data() + i * aggregateSize,
branch  0 never executed
branch  1 never executed
    #####:  275:                   aggregateSize);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  276:    constants.push_back(buildCstData(data));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  277:  }
        -:  278:
    #####:  279:  ArrayRef<llvm::Constant *> constantsRef = constants;
call    0 never executed
    #####:  280:  return buildSequentialConstant(constantsRef, outerShape, llvmType, loc);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  281:}
        -:  282:
        -:  283:/// Create an LLVM IR constant of `llvmType` from the MLIR attribute `attr`.
        -:  284:/// This currently supports integer, floating point, splat and dense element
        -:  285:/// attributes and combinations thereof. Also, an array attribute with two
        -:  286:/// elements is supported to represent a complex constant.  In case of error,
        -:  287:/// report it to `loc` and return nullptr.
function _ZN4mlir4LLVM6detail15getLLVMConstantEPN4llvm4TypeENS_9AttributeENS_8LocationERKNS0_17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  288:llvm::Constant *mlir::LLVM::detail::getLLVMConstant(
        -:  289:    llvm::Type *llvmType, Attribute attr, Location loc,
        -:  290:    const ModuleTranslation &moduleTranslation) {
    #####:  291:  if (!attr)
branch  0 never executed
branch  1 never executed
    #####:  292:    return llvm::UndefValue::get(llvmType);
call    0 never executed
    #####:  293:  if (auto *structType = dyn_cast<::llvm::StructType>(llvmType)) {
branch  0 never executed
branch  1 never executed
    #####:  294:    auto arrayAttr = attr.dyn_cast<ArrayAttr>();
call    0 never executed
    #####:  295:    if (!arrayAttr || arrayAttr.size() != 2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  296:      emitError(loc, "expected struct type to be a complex number");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  297:      return nullptr;
        -:  298:    }
    #####:  299:    llvm::Type *elementType = structType->getElementType(0);
branch  0 never executed
branch  1 never executed
    #####:  300:    llvm::Constant *real =
    #####:  301:        getLLVMConstant(elementType, arrayAttr[0], loc, moduleTranslation);
call    0 never executed
call    1 never executed
    #####:  302:    if (!real)
branch  0 never executed
branch  1 never executed
        -:  303:      return nullptr;
    #####:  304:    llvm::Constant *imag =
    #####:  305:        getLLVMConstant(elementType, arrayAttr[1], loc, moduleTranslation);
call    0 never executed
call    1 never executed
    #####:  306:    if (!imag)
branch  0 never executed
branch  1 never executed
        -:  307:      return nullptr;
    #####:  308:    return llvm::ConstantStruct::get(structType, {real, imag});
call    0 never executed
        -:  309:  }
        -:  310:  // For integer types, we allow a mismatch in sizes as the index type in
        -:  311:  // MLIR might have a different size than the index type in the LLVM module.
    #####:  312:  if (auto intAttr = attr.dyn_cast<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  313:    return llvm::ConstantInt::get(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  314:        llvmType,
    #####:  315:        intAttr.getValue().sextOrTrunc(llvmType->getIntegerBitWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  316:  if (auto floatAttr = attr.dyn_cast<FloatAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  317:    if (llvmType !=
call    0 never executed
    #####:  318:        llvm::Type::getFloatingPointTy(llvmType->getContext(),
call    0 never executed
    #####:  319:                                       floatAttr.getValue().getSemantics())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  320:      emitError(loc, "FloatAttr does not match expected type of the constant");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  321:      return nullptr;
        -:  322:    }
    #####:  323:    return llvm::ConstantFP::get(llvmType, floatAttr.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  324:  }
    #####:  325:  if (auto funcAttr = attr.dyn_cast<FlatSymbolRefAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  326:    return llvm::ConstantExpr::getBitCast(
    #####:  327:        moduleTranslation.lookupFunction(funcAttr.getValue()), llvmType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  328:  if (auto splatAttr = attr.dyn_cast<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  329:    llvm::Type *elementType;
    #####:  330:    uint64_t numElements;
    #####:  331:    bool isScalable = false;
    #####:  332:    if (auto *arrayTy = dyn_cast<llvm::ArrayType>(llvmType)) {
branch  0 never executed
branch  1 never executed
    #####:  333:      elementType = arrayTy->getElementType();
    #####:  334:      numElements = arrayTy->getNumElements();
    #####:  335:    } else if (auto *fVectorTy = dyn_cast<llvm::FixedVectorType>(llvmType)) {
branch  0 never executed
branch  1 never executed
    #####:  336:      elementType = fVectorTy->getElementType();
    #####:  337:      numElements = fVectorTy->getNumElements();
    #####:  338:    } else if (auto *sVectorTy = dyn_cast<llvm::ScalableVectorType>(llvmType)) {
branch  0 never executed
branch  1 never executed
    #####:  339:      elementType = sVectorTy->getElementType();
    #####:  340:      numElements = sVectorTy->getMinNumElements();
    #####:  341:      isScalable = true;
        -:  342:    } else {
    #####:  343:      llvm_unreachable("unrecognized constant vector type");
call    0 never executed
        -:  344:    }
        -:  345:    // Splat value is a scalar. Extract it only if the element type is not
        -:  346:    // another sequence type. The recursion terminates because each step removes
        -:  347:    // one outer sequential type.
    #####:  348:    bool elementTypeSequential =
    #####:  349:        isa<llvm::ArrayType, llvm::VectorType>(elementType);
call    0 never executed
    #####:  350:    llvm::Constant *child = getLLVMConstant(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  351:        elementType,
        -:  352:        elementTypeSequential ? splatAttr
    #####:  353:                              : splatAttr.getSplatValue<Attribute>(),
call    0 never executed
    #####:  354:        loc, moduleTranslation);
    #####:  355:    if (!child)
branch  0 never executed
branch  1 never executed
    #####:  356:      return nullptr;
    #####:  357:    if (llvmType->isVectorTy())
branch  0 never executed
branch  1 never executed
    #####:  358:      return llvm::ConstantVector::getSplat(
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  359:          llvm::ElementCount::get(numElements, /*Scalable=*/isScalable), child);
    #####:  360:    if (llvmType->isArrayTy()) {
branch  0 never executed
branch  1 never executed
    #####:  361:      auto *arrayType = llvm::ArrayType::get(elementType, numElements);
call    0 never executed
    #####:  362:      SmallVector<llvm::Constant *, 8> constants(numElements, child);
call    0 never executed
    #####:  363:      return llvm::ConstantArray::get(arrayType, constants);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  364:    }
        -:  365:  }
        -:  366:
        -:  367:  // Try using raw elements data if possible.
    #####:  368:  if (llvm::Constant *result =
call    0 never executed
    #####:  369:          convertDenseElementsAttr(loc, attr.dyn_cast<DenseElementsAttr>(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  370:                                   llvmType, moduleTranslation)) {
        -:  371:    return result;
        -:  372:  }
        -:  373:
        -:  374:  // Fall back to element-by-element construction otherwise.
    #####:  375:  if (auto elementsAttr = attr.dyn_cast<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  376:    assert(elementsAttr.getType().hasStaticShape());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  377:    assert(!elementsAttr.getType().getShape().empty() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  378:           "unexpected empty elements attribute shape");
        -:  379:
    #####:  380:    SmallVector<llvm::Constant *, 8> constants;
call    0 never executed
    #####:  381:    constants.reserve(elementsAttr.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  382:    llvm::Type *innermostType = getInnermostElementType(llvmType);
call    0 never executed
    #####:  383:    for (auto n : elementsAttr.getValues<Attribute>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
    #####:  384:      constants.push_back(
call    0 never executed
call    1 never executed
        -:  385:          getLLVMConstant(innermostType, n, loc, moduleTranslation));
    #####:  386:      if (!constants.back())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:        return nullptr;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  388:    }
    #####:  389:    ArrayRef<llvm::Constant *> constantsRef = constants;
call    0 never executed
    #####:  390:    llvm::Constant *result = buildSequentialConstant(
call    0 never executed
call    1 never executed
    #####:  391:        constantsRef, elementsAttr.getType().getShape(), llvmType, loc);
call    0 never executed
    #####:  392:    assert(constantsRef.empty() && "did not consume all elemental constants");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  393:    return result;
        -:  394:  }
        -:  395:
    #####:  396:  if (auto stringAttr = attr.dyn_cast<StringAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  397:    return llvm::ConstantDataArray::get(
call    0 never executed
call    1 never executed
        -:  398:        moduleTranslation.getLLVMContext(),
    #####:  399:        ArrayRef<char>{stringAttr.getValue().data(),
call    0 never executed
    #####:  400:                       stringAttr.getValue().size()});
call    0 never executed
        -:  401:  }
    #####:  402:  emitError(loc, "unsupported constant value");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  403:  return nullptr;
        -:  404:}
        -:  405:
function _ZN4mlir4LLVM17ModuleTranslationC2EPNS_9OperationESt10unique_ptrIN4llvm6ModuleESt14default_deleteIS6_EE called 0 returned 0% blocks executed 0%
    #####:  406:ModuleTranslation::ModuleTranslation(Operation *module,
    #####:  407:                                     std::unique_ptr<llvm::Module> llvmModule)
    #####:  408:    : mlirModule(module), llvmModule(std::move(llvmModule)),
call    0 never executed
        -:  409:      debugTranslation(
    #####:  410:          std::make_unique<DebugTranslation>(module, *this->llvmModule)),
call    0 never executed
        -:  411:      typeTranslator(this->llvmModule->getContext()),
    #####:  412:      iface(module->getContext()) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
    #####:  413:  assert(satisfiesLLVMModule(mlirModule) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  414:         "mlirModule should honor LLVM's module semantics.");
    #####:  415:}
function _ZN4mlir4LLVM17ModuleTranslationD2Ev called 0 returned 0% blocks executed 0%
    #####:  416:ModuleTranslation::~ModuleTranslation() {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  417:  if (ompBuilder)
branch  0 never executed
branch  1 never executed
    #####:  418:    ompBuilder->finalize();
call    0 never executed
    #####:  419:}
        -:  420:
function _ZN4mlir4LLVM17ModuleTranslation13forgetMappingERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  421:void ModuleTranslation::forgetMapping(Region &region) {
    #####:  422:  SmallVector<Region *> toProcess;
call    0 never executed
    #####:  423:  toProcess.push_back(&region);
call    0 never executed
    #####:  424:  while (!toProcess.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  425:    Region *current = toProcess.pop_back_val();
call    0 never executed
    #####:  426:    for (Block &block : *current) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  427:      blockMapping.erase(&block);
call    0 never executed
    #####:  428:      for (Value arg : block.getArguments())
branch  0 never executed
branch  1 never executed
    #####:  429:        valueMapping.erase(arg);
call    0 never executed
    #####:  430:      for (Operation &op : block) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  431:        for (Value value : op.getResults())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  432:          valueMapping.erase(value);
call    0 never executed
    #####:  433:        if (op.hasSuccessors())
branch  0 never executed
branch  1 never executed
    #####:  434:          branchMapping.erase(&op);
call    0 never executed
    #####:  435:        if (isa<LLVM::GlobalOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  436:          globalsMapping.erase(&op);
call    0 never executed
    #####:  437:        accessGroupMetadataMapping.erase(&op);
call    0 never executed
    #####:  438:        llvm::append_range(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  439:            toProcess,
    #####:  440:            llvm::map_range(op.getRegions(), [](Region &r) { return &r; }));
call    0 never executed
        -:  441:      }
        -:  442:    }
        -:  443:  }
    #####:  444:}
        -:  445:
        -:  446:/// Get the SSA value passed to the current block from the terminator operation
        -:  447:/// of its predecessor.
        -:  448:static Value getPHISourceValue(Block *current, Block *pred,
        -:  449:                               unsigned numArguments, unsigned index) {
        -:  450:  Operation &terminator = *pred->getTerminator();
        -:  451:  if (isa<LLVM::BrOp>(terminator))
        -:  452:    return terminator.getOperand(index);
        -:  453:
        -:  454:#ifndef NDEBUG
        -:  455:  llvm::SmallPtrSet<Block *, 4> seenSuccessors;
        -:  456:  for (unsigned i = 0, e = terminator.getNumSuccessors(); i < e; ++i) {
        -:  457:    Block *successor = terminator.getSuccessor(i);
        -:  458:    auto branch = cast<BranchOpInterface>(terminator);
        -:  459:    SuccessorOperands successorOperands = branch.getSuccessorOperands(i);
        -:  460:    assert(
        -:  461:        (!seenSuccessors.contains(successor) || successorOperands.empty()) &&
        -:  462:        "successors with arguments in LLVM branches must be different blocks");
        -:  463:    seenSuccessors.insert(successor);
        -:  464:  }
        -:  465:#endif
        -:  466:
        -:  467:  // For instructions that branch based on a condition value, we need to take
        -:  468:  // the operands for the branch that was taken.
        -:  469:  if (auto condBranchOp = dyn_cast<LLVM::CondBrOp>(terminator)) {
        -:  470:    // For conditional branches, we take the operands from either the "true" or
        -:  471:    // the "false" branch.
        -:  472:    return condBranchOp.getSuccessor(0) == current
        -:  473:               ? condBranchOp.getTrueDestOperands()[index]
        -:  474:               : condBranchOp.getFalseDestOperands()[index];
        -:  475:  }
        -:  476:
        -:  477:  if (auto switchOp = dyn_cast<LLVM::SwitchOp>(terminator)) {
        -:  478:    // For switches, we take the operands from either the default case, or from
        -:  479:    // the case branch that was taken.
        -:  480:    if (switchOp.getDefaultDestination() == current)
        -:  481:      return switchOp.getDefaultOperands()[index];
        -:  482:    for (const auto &i : llvm::enumerate(switchOp.getCaseDestinations()))
        -:  483:      if (i.value() == current)
        -:  484:        return switchOp.getCaseOperands(i.index())[index];
        -:  485:  }
        -:  486:
        -:  487:  if (auto invokeOp = dyn_cast<LLVM::InvokeOp>(terminator)) {
        -:  488:    return invokeOp.getNormalDest() == current
        -:  489:               ? invokeOp.getNormalDestOperands()[index]
        -:  490:               : invokeOp.getUnwindDestOperands()[index];
        -:  491:  }
        -:  492:
        -:  493:  llvm_unreachable(
        -:  494:      "only branch, switch or invoke operations can be terminators "
        -:  495:      "of a block that has successors");
        -:  496:}
        -:  497:
        -:  498:/// Connect the PHI nodes to the results of preceding blocks.
function _ZN4mlir4LLVM6detail15connectPHINodesERNS_6RegionERKNS0_17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  499:void mlir::LLVM::detail::connectPHINodes(Region &region,
        -:  500:                                         const ModuleTranslation &state) {
        -:  501:  // Skip the first block, it cannot be branched to and its arguments correspond
        -:  502:  // to the arguments of the LLVM function.
    #####:  503:  for (Block &bb : llvm::drop_begin(region)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  504:    llvm::BasicBlock *llvmBB = state.lookupBlock(&bb);
call    0 never executed
    #####:  505:    auto phis = llvmBB->phis();
call    0 never executed
    #####:  506:    auto numArguments = bb.getNumArguments();
    #####:  507:    assert(numArguments == std::distance(phis.begin(), phis.end()));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  508:    for (auto &numberedPhiNode : llvm::enumerate(phis)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  509:      auto &phiNode = numberedPhiNode.value();
    #####:  510:      unsigned index = numberedPhiNode.index();
    #####:  511:      for (auto *pred : bb.getPredecessors()) {
branch  0 never executed
branch  1 never executed
        -:  512:        // Find the LLVM IR block that contains the converted terminator
        -:  513:        // instruction and use it in the PHI node. Note that this block is not
        -:  514:        // necessarily the same as state.lookupBlock(pred), some operations
        -:  515:        // (in particular, OpenMP operations using OpenMPIRBuilder) may have
        -:  516:        // split the blocks.
    #####:  517:        llvm::Instruction *terminator =
    #####:  518:            state.lookupBranch(pred->getTerminator());
call    0 never executed
call    1 never executed
    #####:  519:        assert(terminator && "missing the mapping for a terminator");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  520:        phiNode.addIncoming(state.lookupValue(getPHISourceValue(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  521:                                &bb, pred, numArguments, index)),
        -:  522:                            terminator->getParent());
        -:  523:      }
        -:  524:    }
        -:  525:  }
    #####:  526:}
        -:  527:
        -:  528:/// Sort function blocks topologically.
        -:  529:SetVector<Block *>
function _ZN4mlir4LLVM6detail28getTopologicallySortedBlocksERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  530:mlir::LLVM::detail::getTopologicallySortedBlocks(Region &region) {
        -:  531:  // For each block that has not been visited yet (i.e. that has no
        -:  532:  // predecessors), add it to the list as well as its successors.
    #####:  533:  SetVector<Block *> blocks;
call    0 never executed
    #####:  534:  for (Block &b : region) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  535:    if (blocks.count(&b) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  536:      llvm::ReversePostOrderTraversal<Block *> traversal(&b);
call    0 never executed
    #####:  537:      blocks.insert(traversal.begin(), traversal.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  538:    }
        -:  539:  }
    #####:  540:  assert(blocks.size() == region.getBlocks().size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  541:         "some blocks are not sorted");
        -:  542:
    #####:  543:  return blocks;
        -:  544:}
        -:  545:
function _ZN4mlir4LLVM6detail19createIntrinsicCallERN4llvm13IRBuilderBaseEjNS2_8ArrayRefIPNS2_5ValueEEENS5_IPNS2_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  546:llvm::Value *mlir::LLVM::detail::createIntrinsicCall(
        -:  547:    llvm::IRBuilderBase &builder, llvm::Intrinsic::ID intrinsic,
        -:  548:    ArrayRef<llvm::Value *> args, ArrayRef<llvm::Type *> tys) {
    #####:  549:  llvm::Module *module = builder.GetInsertBlock()->getModule();
call    0 never executed
    #####:  550:  llvm::Function *fn = llvm::Intrinsic::getDeclaration(module, intrinsic, tys);
call    0 never executed
    #####:  551:  return builder.CreateCall(fn, args);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  552:}
        -:  553:
        -:  554:/// Given a single MLIR operation, create the corresponding LLVM IR operation
        -:  555:/// using the `builder`.
        -:  556:LogicalResult
function _ZN4mlir4LLVM17ModuleTranslation16convertOperationERNS_9OperationERN4llvm13IRBuilderBaseE called 0 returned 0% blocks executed 0%
    #####:  557:ModuleTranslation::convertOperation(Operation &op,
        -:  558:                                    llvm::IRBuilderBase &builder) {
    #####:  559:  const LLVMTranslationDialectInterface *opIface = iface.getInterfaceFor(&op);
call    0 never executed
    #####:  560:  if (!opIface)
branch  0 never executed
branch  1 never executed
    #####:  561:    return op.emitError("cannot be converted to LLVM IR: missing "
call    0 never executed
call    1 never executed
        -:  562:                        "`LLVMTranslationDialectInterface` registration for "
        -:  563:                        "dialect for op: ")
    #####:  564:           << op.getName();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  565:
    #####:  566:  if (failed(opIface->convertOperation(&op, builder, *this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  567:    return op.emitError("LLVM Translation failed for operation: ")
call    0 never executed
call    1 never executed
    #####:  568:           << op.getName();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  569:
    #####:  570:  return convertDialectAttributes(&op);
call    0 never executed
        -:  571:}
        -:  572:
        -:  573:/// Convert block to LLVM IR.  Unless `ignoreArguments` is set, emit PHI nodes
        -:  574:/// to define values corresponding to the MLIR block arguments.  These nodes
        -:  575:/// are not connected to the source basic blocks, which may not exist yet.  Uses
        -:  576:/// `builder` to construct the LLVM IR. Expects the LLVM IR basic block to have
        -:  577:/// been created for `bb` and included in the block mapping.  Inserts new
        -:  578:/// instructions at the end of the block and leaves `builder` in a state
        -:  579:/// suitable for further insertion into the end of the block.
function _ZN4mlir4LLVM17ModuleTranslation12convertBlockERNS_5BlockEbRN4llvm13IRBuilderBaseE called 0 returned 0% blocks executed 0%
    #####:  580:LogicalResult ModuleTranslation::convertBlock(Block &bb, bool ignoreArguments,
        -:  581:                                              llvm::IRBuilderBase &builder) {
    #####:  582:  builder.SetInsertPoint(lookupBlock(&bb));
call    0 never executed
call    1 never executed
    #####:  583:  auto *subprogram = builder.GetInsertBlock()->getParent()->getSubprogram();
call    0 never executed
        -:  584:
        -:  585:  // Before traversing operations, make block arguments available through
        -:  586:  // value remapping and PHI nodes, but do not add incoming edges for the PHI
        -:  587:  // nodes just yet: those values may be defined by this or following blocks.
        -:  588:  // This step is omitted if "ignoreArguments" is set.  The arguments of the
        -:  589:  // first block have been already made available through the remapping of
        -:  590:  // LLVM function arguments.
    #####:  591:  if (!ignoreArguments) {
branch  0 never executed
branch  1 never executed
    #####:  592:    auto predecessors = bb.getPredecessors();
    #####:  593:    unsigned numPredecessors =
    #####:  594:        std::distance(predecessors.begin(), predecessors.end());
    #####:  595:    for (auto arg : bb.getArguments()) {
branch  0 never executed
branch  1 never executed
    #####:  596:      auto wrappedType = arg.getType();
call    0 never executed
    #####:  597:      if (!isCompatibleType(wrappedType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  598:        return emitError(bb.front().getLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  599:                         "block argument does not have an LLVM type");
call    0 never executed
    #####:  600:      llvm::Type *type = convertType(wrappedType);
    #####:  601:      llvm::PHINode *phi = builder.CreatePHI(type, numPredecessors);
call    0 never executed
call    1 never executed
    #####:  602:      mapValue(arg, phi);
call    0 never executed
        -:  603:    }
        -:  604:  }
        -:  605:
        -:  606:  // Traverse operations.
    #####:  607:  for (auto &op : bb) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  608:    // Set the current debug location within the builder.
    #####:  609:    builder.SetCurrentDebugLocation(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  610:        debugTranslation->translateLoc(op.getLoc(), subprogram));
        -:  611:
    #####:  612:    if (failed(convertOperation(op, builder)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  613:      return failure();
        -:  614:  }
        -:  615:
    #####:  616:  return success();
        -:  617:}
        -:  618:
        -:  619:/// A helper method to get the single Block in an operation honoring LLVM's
        -:  620:/// module requirements.
    #####:  621:static Block &getModuleBody(Operation *module) {
    #####:  622:  return module->getRegion(0).front();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  623:}
        -:  624:
        -:  625:/// A helper method to decide if a constant must not be set as a global variable
        -:  626:/// initializer. For an external linkage variable, the variable with an
        -:  627:/// initializer is considered externally visible and defined in this module, the
        -:  628:/// variable without an initializer is externally available and is defined
        -:  629:/// elsewhere.
    #####:  630:static bool shouldDropGlobalInitializer(llvm::GlobalValue::LinkageTypes linkage,
        -:  631:                                        llvm::Constant *cst) {
    #####:  632:  return (linkage == llvm::GlobalVariable::ExternalLinkage && !cst) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  633:         linkage == llvm::GlobalVariable::ExternalWeakLinkage;
        -:  634:}
        -:  635:
        -:  636:/// Sets the runtime preemption specifier of `gv` to dso_local if
        -:  637:/// `dsoLocalRequested` is true, otherwise it is left unchanged.
    #####:  638:static void addRuntimePreemptionSpecifier(bool dsoLocalRequested,
        -:  639:                                          llvm::GlobalValue *gv) {
    #####:  640:  if (dsoLocalRequested)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  641:    gv->setDSOLocal(true);
        -:  642:}
        -:  643:
        -:  644:/// Create named global variables that correspond to llvm.mlir.global
        -:  645:/// definitions. Convert llvm.global_ctors and global_dtors ops.
function _ZN4mlir4LLVM17ModuleTranslation14convertGlobalsEv called 0 returned 0% blocks executed 0%
    #####:  646:LogicalResult ModuleTranslation::convertGlobals() {
    #####:  647:  for (auto op : getModuleBody(mlirModule).getOps<LLVM::GlobalOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  648:    llvm::Type *type = convertType(op.getType());
call    0 never executed
    #####:  649:    llvm::Constant *cst = nullptr;
    #####:  650:    if (op.getValueOrNull()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  651:      // String attributes are treated separately because they cannot appear as
        -:  652:      // in-function constants and are thus not supported by getLLVMConstant.
    #####:  653:      if (auto strAttr = op.getValueOrNull().dyn_cast_or_null<StringAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  654:        cst = llvm::ConstantDataArray::getString(
call    0 never executed
call    1 never executed
        -:  655:            llvmModule->getContext(), strAttr.getValue(), /*AddNull=*/false);
    #####:  656:        type = cst->getType();
    #####:  657:      } else if (!(cst = getLLVMConstant(type, op.getValueOrNull(), op.getLoc(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  658:                                         *this))) {
    #####:  659:        return failure();
        -:  660:      }
        -:  661:    }
        -:  662:
    #####:  663:    auto linkage = convertLinkageToLLVM(op.getLinkage());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  664:    auto addrSpace = op.getAddrSpace();
call    0 never executed
        -:  665:
        -:  666:    // LLVM IR requires constant with linkage other than external or weak
        -:  667:    // external to have initializers. If MLIR does not provide an initializer,
        -:  668:    // default to undef.
    #####:  669:    bool dropInitializer = shouldDropGlobalInitializer(linkage, cst);
branch  0 never executed
branch  1 never executed
    #####:  670:    if (!dropInitializer && !cst)
branch  0 never executed
branch  1 never executed
    #####:  671:      cst = llvm::UndefValue::get(type);
call    0 never executed
    #####:  672:    else if (dropInitializer && cst)
branch  0 never executed
branch  1 never executed
    #####:  673:      cst = nullptr;
        -:  674:
    #####:  675:    auto *var = new llvm::GlobalVariable(
    #####:  676:        *llvmModule, type, op.getConstant(), linkage, cst, op.getSymName(),
call    0 never executed
call    1 never executed
        -:  677:        /*InsertBefore=*/nullptr,
    #####:  678:        op.getThreadLocal_() ? llvm::GlobalValue::GeneralDynamicTLSModel
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  679:                             : llvm::GlobalValue::NotThreadLocal,
    #####:  680:        addrSpace);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  681:
    #####:  682:    if (op.getUnnamedAddr().has_value())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  683:      var->setUnnamedAddr(convertUnnamedAddrToLLVM(*op.getUnnamedAddr()));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  684:
    #####:  685:    if (op.getSection().has_value())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  686:      var->setSection(*op.getSection());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  687:
    #####:  688:    addRuntimePreemptionSpecifier(op.getDsoLocal(), var);
call    0 never executed
        -:  689:
    #####:  690:    Optional<uint64_t> alignment = op.getAlignment();
call    0 never executed
    #####:  691:    if (alignment.has_value())
branch  0 never executed
branch  1 never executed
    #####:  692:      var->setAlignment(llvm::MaybeAlign(alignment.value()));
call    0 never executed
call    1 never executed
        -:  693:
    #####:  694:    globalsMapping.try_emplace(op, var);
call    0 never executed
call    1 never executed
        -:  695:  }
        -:  696:
        -:  697:  // Convert global variable bodies. This is done after all global variables
        -:  698:  // have been created in LLVM IR because a global body may refer to another
        -:  699:  // global or itself. So all global variables need to be mapped first.
    #####:  700:  for (auto op : getModuleBody(mlirModule).getOps<LLVM::GlobalOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  701:    if (Block *initializer = op.getInitializerBlock()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  702:      llvm::IRBuilder<> builder(llvmModule->getContext());
branch  0 never executed
branch  1 never executed
    #####:  703:      for (auto &op : initializer->without_terminator()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  704:        if (failed(convertOperation(op, builder)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  705:            !isa<llvm::Constant>(lookupValue(op.getResult(0))))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  706:          return emitError(op.getLoc(), "unemittable constant value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  707:      }
    #####:  708:      ReturnOp ret = cast<ReturnOp>(initializer->getTerminator());
call    0 never executed
call    1 never executed
    #####:  709:      llvm::Constant *cst =
call    0 never executed
    #####:  710:          cast<llvm::Constant>(lookupValue(ret.getOperand(0)));
call    0 never executed
call    1 never executed
    #####:  711:      auto *global = cast<llvm::GlobalVariable>(lookupGlobal(op));
call    0 never executed
call    1 never executed
    #####:  712:      if (!shouldDropGlobalInitializer(global->getLinkage(), cst))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  713:        global->setInitializer(cst);
call    0 never executed
        -:  714:    }
        -:  715:  }
        -:  716:
        -:  717:  // Convert llvm.mlir.global_ctors and dtors.
    #####:  718:  for (Operation &op : getModuleBody(mlirModule)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  719:    auto ctorOp = dyn_cast<GlobalCtorsOp>(op);
call    0 never executed
    #####:  720:    auto dtorOp = dyn_cast<GlobalDtorsOp>(op);
call    0 never executed
    #####:  721:    if (!ctorOp && !dtorOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  722:      continue;
    #####:  723:    auto range = ctorOp ? llvm::zip(ctorOp.getCtors(), ctorOp.getPriorities())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  724:                        : llvm::zip(dtorOp.getDtors(), dtorOp.getPriorities());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  725:    auto appendGlobalFn =
branch  0 never executed
branch  1 never executed
    #####:  726:        ctorOp ? llvm::appendToGlobalCtors : llvm::appendToGlobalDtors;
branch  0 never executed
branch  1 never executed
    #####:  727:    for (auto symbolAndPriority : range) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  728:      llvm::Function *f = lookupFunction(
call    0 never executed
call    1 never executed
    #####:  729:          std::get<0>(symbolAndPriority).cast<FlatSymbolRefAttr>().getValue());
call    0 never executed
call    1 never executed
    #####:  730:      appendGlobalFn(
call    0 never executed
    #####:  731:          *llvmModule, f,
call    0 never executed
    #####:  732:          std::get<1>(symbolAndPriority).cast<IntegerAttr>().getInt(),
call    0 never executed
call    1 never executed
        -:  733:          /*Data=*/nullptr);
        -:  734:    }
        -:  735:  }
        -:  736:
    #####:  737:  return success();
        -:  738:}
        -:  739:
        -:  740:/// Attempts to add an attribute identified by `key`, optionally with the given
        -:  741:/// `value` to LLVM function `llvmFunc`. Reports errors at `loc` if any. If the
        -:  742:/// attribute has a kind known to LLVM IR, create the attribute of this kind,
        -:  743:/// otherwise keep it as a string attribute. Performs additional checks for
        -:  744:/// attributes known to have or not have a value in order to avoid assertions
        -:  745:/// inside LLVM upon construction.
function _ZL25checkedAddLLVMFnAttributeN4mlir8LocationEPN4llvm8FunctionENS1_9StringRefES4_ called 0 returned 0% blocks executed 0%
    #####:  746:static LogicalResult checkedAddLLVMFnAttribute(Location loc,
        -:  747:                                               llvm::Function *llvmFunc,
        -:  748:                                               StringRef key,
        -:  749:                                               StringRef value = StringRef()) {
    #####:  750:  auto kind = llvm::Attribute::getAttrKindFromName(key);
call    0 never executed
    #####:  751:  if (kind == llvm::Attribute::None) {
branch  0 never executed
branch  1 never executed
    #####:  752:    llvmFunc->addFnAttr(key, value);
call    0 never executed
    #####:  753:    return success();
        -:  754:  }
        -:  755:
    #####:  756:  if (llvm::Attribute::isIntAttrKind(kind)) {
branch  0 never executed
branch  1 never executed
    #####:  757:    if (value.empty())
branch  0 never executed
branch  1 never executed
    #####:  758:      return emitError(loc) << "LLVM attribute '" << key << "' expects a value";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  759:
    #####:  760:    int result;
    #####:  761:    if (!value.getAsInteger(/*Radix=*/0, result))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  762:      llvmFunc->addFnAttr(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  763:          llvm::Attribute::get(llvmFunc->getContext(), kind, result));
        -:  764:    else
    #####:  765:      llvmFunc->addFnAttr(key, value);
call    0 never executed
    #####:  766:    return success();
        -:  767:  }
        -:  768:
    #####:  769:  if (!value.empty())
branch  0 never executed
branch  1 never executed
    #####:  770:    return emitError(loc) << "LLVM attribute '" << key
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  771:                          << "' does not expect a value, found '" << value
call    0 never executed
call    1 never executed
    #####:  772:                          << "'";
call    0 never executed
        -:  773:
    #####:  774:  llvmFunc->addFnAttr(kind);
call    0 never executed
    #####:  775:  return success();
        -:  776:}
        -:  777:
        -:  778:/// Attaches the attributes listed in the given array attribute to `llvmFunc`.
        -:  779:/// Reports error to `loc` if any and returns immediately. Expects `attributes`
        -:  780:/// to be an array attribute containing either string attributes, treated as
        -:  781:/// value-less LLVM attributes, or array attributes containing two string
        -:  782:/// attributes, with the first string being the name of the corresponding LLVM
        -:  783:/// attribute and the second string beings its value. Note that even integer
        -:  784:/// attributes are expected to have their values expressed as strings.
        -:  785:static LogicalResult
function _ZL28forwardPassthroughAttributesN4mlir8LocationEN4llvm8OptionalINS_9ArrayAttrEEEPNS1_8FunctionE called 0 returned 0% blocks executed 0%
    #####:  786:forwardPassthroughAttributes(Location loc, Optional<ArrayAttr> attributes,
        -:  787:                             llvm::Function *llvmFunc) {
    #####:  788:  if (!attributes)
branch  0 never executed
branch  1 never executed
    #####:  789:    return success();
        -:  790:
    #####:  791:  for (Attribute attr : *attributes) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  792:    if (auto stringAttr = attr.dyn_cast<StringAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:      if (failed(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  794:              checkedAddLLVMFnAttribute(loc, llvmFunc, stringAttr.getValue())))
    #####:  795:        return failure();
    #####:  796:      continue;
        -:  797:    }
        -:  798:
    #####:  799:    auto arrayAttr = attr.dyn_cast<ArrayAttr>();
call    0 never executed
    #####:  800:    if (!arrayAttr || arrayAttr.size() != 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  801:      return emitError(loc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  802:             << "expected 'passthrough' to contain string or array attributes";
call    0 never executed
        -:  803:
    #####:  804:    auto keyAttr = arrayAttr[0].dyn_cast<StringAttr>();
call    0 never executed
call    1 never executed
    #####:  805:    auto valueAttr = arrayAttr[1].dyn_cast<StringAttr>();
call    0 never executed
call    1 never executed
    #####:  806:    if (!keyAttr || !valueAttr)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  807:      return emitError(loc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  808:             << "expected arrays within 'passthrough' to contain two strings";
call    0 never executed
        -:  809:
    #####:  810:    if (failed(checkedAddLLVMFnAttribute(loc, llvmFunc, keyAttr.getValue(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  811:                                         valueAttr.getValue())))
    #####:  812:      return failure();
        -:  813:  }
    #####:  814:  return success();
        -:  815:}
        -:  816:
function _ZN4mlir4LLVM17ModuleTranslation18convertOneFunctionENS0_10LLVMFuncOpE called 0 returned 0% blocks executed 0%
    #####:  817:LogicalResult ModuleTranslation::convertOneFunction(LLVMFuncOp func) {
        -:  818:  // Clear the block, branch value mappings, they are only relevant within one
        -:  819:  // function.
    #####:  820:  blockMapping.clear();
call    0 never executed
    #####:  821:  valueMapping.clear();
call    0 never executed
    #####:  822:  branchMapping.clear();
call    0 never executed
    #####:  823:  llvm::Function *llvmFunc = lookupFunction(func.getName());
call    0 never executed
call    1 never executed
        -:  824:
        -:  825:  // Translate the debug information for this function.
    #####:  826:  debugTranslation->translate(func, *llvmFunc);
call    0 never executed
        -:  827:
        -:  828:  // Add function arguments to the value remapping table.
        -:  829:  // If there was noalias info then we decorate each argument accordingly.
    #####:  830:  unsigned int argIdx = 0;
    #####:  831:  for (auto kvp : llvm::zip(func.getArguments(), llvmFunc->args())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  832:    llvm::Argument &llvmArg = std::get<1>(kvp);
call    0 never executed
    #####:  833:    BlockArgument mlirArg = std::get<0>(kvp);
call    0 never executed
        -:  834:
    #####:  835:    if (auto attr = func.getArgAttrOfType<UnitAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  836:            argIdx, LLVMDialect::getNoAliasAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  837:      // NB: Attribute already verified to be boolean, so check if we can indeed
        -:  838:      // attach the attribute to this argument, based on its type.
    #####:  839:      auto argTy = mlirArg.getType();
call    0 never executed
    #####:  840:      if (!argTy.isa<LLVM::LLVMPointerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  841:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  842:            "llvm.noalias attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  843:      llvmArg.addAttr(llvm::Attribute::AttrKind::NoAlias);
call    0 never executed
        -:  844:    }
        -:  845:
    #####:  846:    if (auto attr = func.getArgAttrOfType<IntegerAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  847:            argIdx, LLVMDialect::getAlignAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  848:      // NB: Attribute already verified to be int, so check if we can indeed
        -:  849:      // attach the attribute to this argument, based on its type.
    #####:  850:      auto argTy = mlirArg.getType();
call    0 never executed
    #####:  851:      if (!argTy.isa<LLVM::LLVMPointerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  852:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  853:            "llvm.align attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  854:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  855:                           .addAlignmentAttr(llvm::Align(attr.getInt())));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  856:    }
        -:  857:
    #####:  858:    if (auto attr = func.getArgAttrOfType<TypeAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  859:            argIdx, LLVMDialect::getStructRetAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  860:      auto argTy = mlirArg.getType().dyn_cast<LLVM::LLVMPointerType>();
call    0 never executed
    #####:  861:      if (!argTy)
branch  0 never executed
branch  1 never executed
    #####:  862:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  863:            "llvm.sret attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  864:      if (!argTy.isOpaque() && argTy.getElementType() != attr.getValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  865:        return func.emitError("llvm.sret attribute attached to LLVM pointer "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  866:                              "argument of a different type");
call    0 never executed
    #####:  867:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  868:                           .addStructRetAttr(convertType(attr.getValue())));
        -:  869:    }
        -:  870:
    #####:  871:    if (auto attr = func.getArgAttrOfType<TypeAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  872:            argIdx, LLVMDialect::getByValAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  873:      auto argTy = mlirArg.getType().dyn_cast<LLVM::LLVMPointerType>();
call    0 never executed
    #####:  874:      if (!argTy)
branch  0 never executed
branch  1 never executed
    #####:  875:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  876:            "llvm.byval attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  877:      if (!argTy.isOpaque() && argTy.getElementType() != attr.getValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  878:        return func.emitError("llvm.byval attribute attached to LLVM pointer "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  879:                              "argument of a different type");
call    0 never executed
    #####:  880:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  881:                           .addByValAttr(convertType(attr.getValue())));
        -:  882:    }
        -:  883:
    #####:  884:    if (auto attr = func.getArgAttrOfType<TypeAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  885:            argIdx, LLVMDialect::getByRefAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  886:      auto argTy = mlirArg.getType().dyn_cast<LLVM::LLVMPointerType>();
call    0 never executed
    #####:  887:      if (!argTy)
branch  0 never executed
branch  1 never executed
    #####:  888:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  889:            "llvm.byref attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  890:      if (!argTy.isOpaque() && argTy.getElementType() != attr.getValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  891:        return func.emitError("llvm.byref attribute attached to LLVM pointer "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  892:                              "argument of a different type");
call    0 never executed
    #####:  893:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  894:                           .addByRefAttr(convertType(attr.getValue())));
        -:  895:    }
        -:  896:
    #####:  897:    if (auto attr = func.getArgAttrOfType<TypeAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:            argIdx, LLVMDialect::getInAllocaAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  899:      auto argTy = mlirArg.getType().dyn_cast<LLVM::LLVMPointerType>();
call    0 never executed
    #####:  900:      if (!argTy)
branch  0 never executed
branch  1 never executed
    #####:  901:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  902:            "llvm.inalloca attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  903:      if (!argTy.isOpaque() && argTy.getElementType() != attr.getValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  904:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  905:            "llvm.inalloca attribute attached to LLVM pointer "
    #####:  906:            "argument of a different type");
call    0 never executed
    #####:  907:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  908:                           .addInAllocaAttr(convertType(attr.getValue())));
        -:  909:    }
        -:  910:
    #####:  911:    if (auto attr = func.getArgAttrOfType<UnitAttr>(argIdx, "llvm.nest")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  912:      auto argTy = mlirArg.getType();
call    0 never executed
    #####:  913:      if (!argTy.isa<LLVM::LLVMPointerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  914:        return func.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  915:            "llvm.nest attribute attached to LLVM non-pointer argument");
call    0 never executed
    #####:  916:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  917:                           .addAttribute(llvm::Attribute::Nest));
        -:  918:    }
        -:  919:
    #####:  920:    if (auto attr = func.getArgAttrOfType<UnitAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  921:            argIdx, LLVMDialect::getNoUndefAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  922:      // llvm.noundef can be added to any argument type.
    #####:  923:      llvmArg.addAttrs(llvm::AttrBuilder(llvmArg.getContext())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  924:                           .addAttribute(llvm::Attribute::NoUndef));
        -:  925:    }
        -:  926:
    #####:  927:    mapValue(mlirArg, &llvmArg);
call    0 never executed
    #####:  928:    argIdx++;
        -:  929:  }
        -:  930:
        -:  931:  // Check the personality and set it.
    #####:  932:  if (func.getPersonality()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  933:    llvm::Type *ty = llvm::Type::getInt8PtrTy(llvmFunc->getContext());
call    0 never executed
call    1 never executed
    #####:  934:    if (llvm::Constant *pfunc = getLLVMConstant(ty, func.getPersonalityAttr(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  935:                                                func.getLoc(), *this))
    #####:  936:      llvmFunc->setPersonalityFn(pfunc);
call    0 never executed
        -:  937:  }
        -:  938:
    #####:  939:  if (auto gc = func.getGarbageCollector())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:    llvmFunc->setGC(gc->str());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  941:
        -:  942:  // First, create all blocks so we can jump to them.
    #####:  943:  llvm::LLVMContext &llvmContext = llvmFunc->getContext();
call    0 never executed
    #####:  944:  for (auto &bb : func) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  945:    auto *llvmBB = llvm::BasicBlock::Create(llvmContext);
call    0 never executed
call    1 never executed
    #####:  946:    llvmBB->insertInto(llvmFunc);
call    0 never executed
    #####:  947:    mapBlock(&bb, llvmBB);
call    0 never executed
        -:  948:  }
        -:  949:
        -:  950:  // Then, convert blocks one by one in topological order to ensure defs are
        -:  951:  // converted before uses.
    #####:  952:  auto blocks = detail::getTopologicallySortedBlocks(func.getBody());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  953:  for (Block *bb : blocks) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  954:    llvm::IRBuilder<> builder(llvmContext);
call    0 never executed
call    1 never executed
    #####:  955:    if (failed(convertBlock(*bb, bb->isEntryBlock(), builder)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  956:      return failure();
call    0 never executed
        -:  957:  }
        -:  958:
        -:  959:  // After all blocks have been traversed and values mapped, connect the PHI
        -:  960:  // nodes to the results of preceding blocks.
    #####:  961:  detail::connectPHINodes(func.getBody(), *this);
call    0 never executed
call    1 never executed
        -:  962:
        -:  963:  // Finally, convert dialect attributes attached to the function.
    #####:  964:  return convertDialectAttributes(func);
call    0 never executed
        -:  965:}
        -:  966:
function _ZN4mlir4LLVM17ModuleTranslation24convertDialectAttributesEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  967:LogicalResult ModuleTranslation::convertDialectAttributes(Operation *op) {
    #####:  968:  for (NamedAttribute attribute : op->getDialectAttrs())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  969:    if (failed(iface.amendOperation(op, attribute, *this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  970:      return failure();
    #####:  971:  return success();
        -:  972:}
        -:  973:
function _ZN4mlir4LLVM17ModuleTranslation25convertFunctionSignaturesEv called 0 returned 0% blocks executed 0%
    #####:  974:LogicalResult ModuleTranslation::convertFunctionSignatures() {
        -:  975:  // Declare all functions first because there may be function calls that form a
        -:  976:  // call graph with cycles, or global initializers that reference functions.
    #####:  977:  for (auto function : getModuleBody(mlirModule).getOps<LLVMFuncOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  978:    llvm::FunctionCallee llvmFuncCst = llvmModule->getOrInsertFunction(
        -:  979:        function.getName(),
    #####:  980:        cast<llvm::FunctionType>(convertType(function.getFunctionType())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  981:    llvm::Function *llvmFunc = cast<llvm::Function>(llvmFuncCst.getCallee());
call    0 never executed
    #####:  982:    llvmFunc->setLinkage(convertLinkageToLLVM(function.getLinkage()));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  983:    mapFunction(function.getName(), llvmFunc);
call    0 never executed
call    1 never executed
    #####:  984:    addRuntimePreemptionSpecifier(function.getDsoLocal(), llvmFunc);
call    0 never executed
        -:  985:
    #####:  986:    if (function->getAttrOfType<UnitAttr>(LLVMDialect::getReadnoneAttrName()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  987:      llvmFunc->setDoesNotAccessMemory();
call    0 never executed
        -:  988:
        -:  989:    // Forward the pass-through attributes to LLVM.
    #####:  990:    if (failed(forwardPassthroughAttributes(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  991:            function.getLoc(), function.getPassthrough(), llvmFunc)))
    #####:  992:      return failure();
        -:  993:  }
        -:  994:
    #####:  995:  return success();
        -:  996:}
        -:  997:
function _ZN4mlir4LLVM17ModuleTranslation16convertFunctionsEv called 0 returned 0% blocks executed 0%
    #####:  998:LogicalResult ModuleTranslation::convertFunctions() {
        -:  999:  // Convert functions.
    #####: 1000:  for (auto function : getModuleBody(mlirModule).getOps<LLVMFuncOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 1001:    // Ignore external functions.
    #####: 1002:    if (function.isExternal())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1003:      continue;
        -: 1004:
    #####: 1005:    if (failed(convertOneFunction(function)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1006:      return failure();
        -: 1007:  }
        -: 1008:
    #####: 1009:  return success();
        -: 1010:}
        -: 1011:
        -: 1012:llvm::MDNode *
function _ZNK4mlir4LLVM17ModuleTranslation14getAccessGroupERNS_9OperationENS_13SymbolRefAttrE called 0 returned 0% blocks executed 0%
    #####: 1013:ModuleTranslation::getAccessGroup(Operation &opInst,
        -: 1014:                                  SymbolRefAttr accessGroupRef) const {
    #####: 1015:  auto metadataName = accessGroupRef.getRootReference();
call    0 never executed
    #####: 1016:  auto accessGroupName = accessGroupRef.getLeafReference();
call    0 never executed
    #####: 1017:  auto metadataOp = SymbolTable::lookupNearestSymbolFrom<LLVM::MetadataOp>(
    #####: 1018:      opInst.getParentOp(), metadataName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1019:  auto *accessGroupOp =
    #####: 1020:      SymbolTable::lookupNearestSymbolFrom(metadataOp, accessGroupName);
call    0 never executed
    #####: 1021:  return accessGroupMetadataMapping.lookup(accessGroupOp);
call    0 never executed
        -: 1022:}
        -: 1023:
function _ZN4mlir4LLVM17ModuleTranslation25createAccessGroupMetadataEv called 0 returned 0% blocks executed 0%
    #####: 1024:LogicalResult ModuleTranslation::createAccessGroupMetadata() {
    #####: 1025:  mlirModule->walk([&](LLVM::MetadataOp metadatas) {
call    0 never executed
function _ZZZN4mlir4LLVM17ModuleTranslation25createAccessGroupMetadataEvENKUlNS0_10MetadataOpEE_clES2_ENKUlNS0_21AccessGroupMetadataOpEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1026:    metadatas.walk([&](LLVM::AccessGroupMetadataOp op) {
call    0 never executed
    #####: 1027:      llvm::LLVMContext &ctx = llvmModule->getContext();
call    0 never executed
    #####: 1028:      llvm::MDNode *accessGroup = llvm::MDNode::getDistinct(ctx, {});
call    0 never executed
    #####: 1029:      accessGroupMetadataMapping.insert({op, accessGroup});
call    0 never executed
    #####: 1030:    });
        -: 1031:  });
    #####: 1032:  return success();
call    0 never executed
        -: 1033:}
        -: 1034:
function _ZN4mlir4LLVM17ModuleTranslation23setAccessGroupsMetadataEPNS_9OperationEPN4llvm11InstructionE called 0 returned 0% blocks executed 0%
    #####: 1035:void ModuleTranslation::setAccessGroupsMetadata(Operation *op,
        -: 1036:                                                llvm::Instruction *inst) {
    #####: 1037:  auto accessGroups =
call    0 never executed
    #####: 1038:      op->getAttrOfType<ArrayAttr>(LLVMDialect::getAccessGroupsAttrName());
call    0 never executed
    #####: 1039:  if (accessGroups && !accessGroups.empty()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1040:    llvm::Module *module = inst->getModule();
call    0 never executed
    #####: 1041:    SmallVector<llvm::Metadata *> metadatas;
call    0 never executed
    #####: 1042:    for (SymbolRefAttr accessGroupRef :
    #####: 1043:         accessGroups.getAsRange<SymbolRefAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1044:      metadatas.push_back(getAccessGroup(*op, accessGroupRef));
call    0 never executed
call    1 never executed
        -: 1045:
    #####: 1046:    llvm::MDNode *unionMD = nullptr;
    #####: 1047:    if (metadatas.size() == 1)
branch  0 never executed
branch  1 never executed
    #####: 1048:      unionMD = llvm::cast<llvm::MDNode>(metadatas.front());
call    0 never executed
    #####: 1049:    else if (metadatas.size() >= 2)
branch  0 never executed
branch  1 never executed
    #####: 1050:      unionMD = llvm::MDNode::get(module->getContext(), metadatas);
call    0 never executed
        -: 1051:
    #####: 1052:    inst->setMetadata(module->getMDKindID("llvm.access.group"), unionMD);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1053:  }
    #####: 1054:}
        -: 1055:
function _ZN4mlir4LLVM17ModuleTranslation24createAliasScopeMetadataEv called 0 returned 0% blocks executed 0%
    #####: 1056:LogicalResult ModuleTranslation::createAliasScopeMetadata() {
function _ZZN4mlir4LLVM17ModuleTranslation24createAliasScopeMetadataEvENKUlNS0_10MetadataOpEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1057:  mlirModule->walk([&](LLVM::MetadataOp metadatas) {
call    0 never executed
        -: 1058:    // Create the domains first, so they can be reference below in the scopes.
    #####: 1059:    DenseMap<Operation *, llvm::MDNode *> aliasScopeDomainMetadataMapping;
call    0 never executed
function _ZZZN4mlir4LLVM17ModuleTranslation24createAliasScopeMetadataEvENKUlNS0_10MetadataOpEE_clES2_ENKUlNS0_26AliasScopeDomainMetadataOpEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1060:    metadatas.walk([&](LLVM::AliasScopeDomainMetadataOp op) {
    #####: 1061:      llvm::LLVMContext &ctx = llvmModule->getContext();
call    0 never executed
call    1 never executed
    #####: 1062:      llvm::SmallVector<llvm::Metadata *, 2> operands;
call    0 never executed
    #####: 1063:      operands.push_back({}); // Placeholder for self-reference
call    0 never executed
    #####: 1064:      if (Optional<StringRef> description = op.getDescription())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1065:        operands.push_back(llvm::MDString::get(ctx, *description));
call    0 never executed
call    1 never executed
    #####: 1066:      llvm::MDNode *domain = llvm::MDNode::get(ctx, operands);
call    0 never executed
    #####: 1067:      domain->replaceOperandWith(0, domain); // Self-reference for uniqueness
call    0 never executed
    #####: 1068:      aliasScopeDomainMetadataMapping.insert({op, domain});
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1069:    });
        -: 1070:
        -: 1071:    // Now create the scopes, referencing the domains created above.
function _ZZZN4mlir4LLVM17ModuleTranslation24createAliasScopeMetadataEvENKUlNS0_10MetadataOpEE_clES2_ENKUlNS0_20AliasScopeMetadataOpEE0_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1072:    metadatas.walk([&](LLVM::AliasScopeMetadataOp op) {
call    0 never executed
call    1 never executed
    #####: 1073:      llvm::LLVMContext &ctx = llvmModule->getContext();
branch  0 never executed
branch  1 never executed
    #####: 1074:      assert(isa<LLVM::MetadataOp>(op->getParentOp()));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1075:      auto metadataOp = dyn_cast<LLVM::MetadataOp>(op->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1076:      Operation *domainOp =
    #####: 1077:          SymbolTable::lookupNearestSymbolFrom(metadataOp, op.getDomainAttr());
call    0 never executed
call    1 never executed
    #####: 1078:      llvm::MDNode *domain = aliasScopeDomainMetadataMapping.lookup(domainOp);
call    0 never executed
    #####: 1079:      assert(domain && "Scope's domain should already be valid");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1080:      llvm::SmallVector<llvm::Metadata *, 3> operands;
call    0 never executed
    #####: 1081:      operands.push_back({}); // Placeholder for self-reference
call    0 never executed
    #####: 1082:      operands.push_back(domain);
call    0 never executed
    #####: 1083:      if (Optional<StringRef> description = op.getDescription())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1084:        operands.push_back(llvm::MDString::get(ctx, *description));
call    0 never executed
call    1 never executed
    #####: 1085:      llvm::MDNode *scope = llvm::MDNode::get(ctx, operands);
call    0 never executed
    #####: 1086:      scope->replaceOperandWith(0, scope); // Self-reference for uniqueness
call    0 never executed
    #####: 1087:      aliasScopeMetadataMapping.insert({op, scope});
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1088:    });
    #####: 1089:  });
    #####: 1090:  return success();
call    0 never executed
        -: 1091:}
        -: 1092:
        -: 1093:llvm::MDNode *
function _ZNK4mlir4LLVM17ModuleTranslation13getAliasScopeERNS_9OperationENS_13SymbolRefAttrE called 0 returned 0% blocks executed 0%
    #####: 1094:ModuleTranslation::getAliasScope(Operation &opInst,
        -: 1095:                                 SymbolRefAttr aliasScopeRef) const {
    #####: 1096:  StringAttr metadataName = aliasScopeRef.getRootReference();
call    0 never executed
    #####: 1097:  StringAttr scopeName = aliasScopeRef.getLeafReference();
call    0 never executed
    #####: 1098:  auto metadataOp = SymbolTable::lookupNearestSymbolFrom<LLVM::MetadataOp>(
    #####: 1099:      opInst.getParentOp(), metadataName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1100:  Operation *aliasScopeOp =
    #####: 1101:      SymbolTable::lookupNearestSymbolFrom(metadataOp, scopeName);
call    0 never executed
    #####: 1102:  return aliasScopeMetadataMapping.lookup(aliasScopeOp);
call    0 never executed
        -: 1103:}
        -: 1104:
function _ZN4mlir4LLVM17ModuleTranslation21setAliasScopeMetadataEPNS_9OperationEPN4llvm11InstructionE called 0 returned 0% blocks executed 0%
    #####: 1105:void ModuleTranslation::setAliasScopeMetadata(Operation *op,
        -: 1106:                                              llvm::Instruction *inst) {
function _ZZN4mlir4LLVM17ModuleTranslation21setAliasScopeMetadataEPNS_9OperationEPN4llvm11InstructionEENKUlNS4_9StringRefES7_E_clES7_S7_ called 0 returned 0% blocks executed 0%
    #####: 1107:  auto populateScopeMetadata = [this, op, inst](StringRef attrName,
    #####: 1108:                                                StringRef llvmMetadataName) {
    #####: 1109:    auto scopes = op->getAttrOfType<ArrayAttr>(attrName);
call    0 never executed
    #####: 1110:    if (!scopes || scopes.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1111:      return;
    #####: 1112:    llvm::Module *module = inst->getModule();
call    0 never executed
    #####: 1113:    SmallVector<llvm::Metadata *> scopeMDs;
call    0 never executed
    #####: 1114:    for (SymbolRefAttr scopeRef : scopes.getAsRange<SymbolRefAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1115:      scopeMDs.push_back(getAliasScope(*op, scopeRef));
call    0 never executed
call    1 never executed
    #####: 1116:    llvm::MDNode *unionMD = llvm::MDNode::get(module->getContext(), scopeMDs);
call    0 never executed
    #####: 1117:    inst->setMetadata(module->getMDKindID(llvmMetadataName), unionMD);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1118:  };
        -: 1119:
    #####: 1120:  populateScopeMetadata(LLVMDialect::getAliasScopesAttrName(), "alias.scope");
call    0 never executed
    #####: 1121:  populateScopeMetadata(LLVMDialect::getNoAliasScopesAttrName(), "noalias");
call    0 never executed
    #####: 1122:}
        -: 1123:
function _ZN4mlir4LLVM17ModuleTranslation11convertTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 1124:llvm::Type *ModuleTranslation::convertType(Type type) {
    #####: 1125:  return typeTranslator.translateType(type);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1126:}
        -: 1127:
        -: 1128:/// A helper to look up remapped operands in the value remapping table.
function _ZN4mlir4LLVM17ModuleTranslation12lookupValuesENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1129:SmallVector<llvm::Value *> ModuleTranslation::lookupValues(ValueRange values) {
    #####: 1130:  SmallVector<llvm::Value *> remapped;
branch  0 never executed
branch  1 never executed
    #####: 1131:  remapped.reserve(values.size());
branch  0 never executed
branch  1 never executed
    #####: 1132:  for (Value v : values)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1133:    remapped.push_back(lookupValue(v));
call    0 never executed
call    1 never executed
    #####: 1134:  return remapped;
        -: 1135:}
        -: 1136:
        -: 1137:const llvm::DILocation *
function _ZN4mlir4LLVM17ModuleTranslation12translateLocENS_8LocationEPN4llvm12DILocalScopeE called 0 returned 0% blocks executed 0%
    #####: 1138:ModuleTranslation::translateLoc(Location loc, llvm::DILocalScope *scope) {
    #####: 1139:  return debugTranslation->translateLoc(loc, scope);
call    0 never executed
        -: 1140:}
        -: 1141:
function _ZN4mlir4LLVM17ModuleTranslation18translateDebugInfoENS0_10DINodeAttrE called 0 returned 0% blocks executed 0%
    #####: 1142:llvm::Metadata *ModuleTranslation::translateDebugInfo(LLVM::DINodeAttr attr) {
    #####: 1143:  return debugTranslation->translate(attr);
call    0 never executed
        -: 1144:}
        -: 1145:
        -: 1146:llvm::NamedMDNode *
function _ZN4mlir4LLVM17ModuleTranslation30getOrInsertNamedModuleMetadataEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1147:ModuleTranslation::getOrInsertNamedModuleMetadata(StringRef name) {
    #####: 1148:  return llvmModule->getOrInsertNamedMetadata(name);
call    0 never executed
        -: 1149:}
        -: 1150:
function _ZN4mlir4LLVM17ModuleTranslation10StackFrame6anchorEv called 0 returned 0% blocks executed 0%
    #####: 1151:void ModuleTranslation::StackFrame::anchor() {}
        -: 1152:
        -: 1153:static std::unique_ptr<llvm::Module>
function _ZL17prepareLLVMModulePN4mlir9OperationERN4llvm11LLVMContextENS2_9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1154:prepareLLVMModule(Operation *m, llvm::LLVMContext &llvmContext,
        -: 1155:                  StringRef name) {
    #####: 1156:  m->getContext()->getOrLoadDialect<LLVM::LLVMDialect>();
call    0 never executed
call    1 never executed
    #####: 1157:  auto llvmModule = std::make_unique<llvm::Module>(name, llvmContext);
call    0 never executed
    #####: 1158:  if (auto dataLayoutAttr =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1159:          m->getAttr(LLVM::LLVMDialect::getDataLayoutAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1160:    llvmModule->setDataLayout(dataLayoutAttr.cast<StringAttr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1161:  } else {
    #####: 1162:    FailureOr<llvm::DataLayout> llvmDataLayout(llvm::DataLayout(""));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1163:    if (auto iface = dyn_cast<DataLayoutOpInterface>(m)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1164:      if (DataLayoutSpecInterface spec = iface.getDataLayoutSpec()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1165:        llvmDataLayout =
    #####: 1166:            translateDataLayout(spec, DataLayout(iface), m->getLoc());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1167:      }
    #####: 1168:    } else if (auto mod = dyn_cast<ModuleOp>(m)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1169:      if (DataLayoutSpecInterface spec = mod.getDataLayoutSpec()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1170:        llvmDataLayout =
    #####: 1171:            translateDataLayout(spec, DataLayout(mod), m->getLoc());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1172:      }
        -: 1173:    }
    #####: 1174:    if (failed(llvmDataLayout))
branch  0 never executed
branch  1 never executed
    #####: 1175:      return nullptr;
    #####: 1176:    llvmModule->setDataLayout(*llvmDataLayout);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1177:  }
    #####: 1178:  if (auto targetTripleAttr =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1179:          m->getAttr(LLVM::LLVMDialect::getTargetTripleAttrName()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1180:    llvmModule->setTargetTriple(targetTripleAttr.cast<StringAttr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1181:
        -: 1182:  // Inject declarations for `malloc` and `free` functions that can be used in
        -: 1183:  // memref allocation/deallocation coming from standard ops lowering.
    #####: 1184:  llvm::IRBuilder<> builder(llvmContext);
call    0 never executed
call    1 never executed
    #####: 1185:  llvmModule->getOrInsertFunction("malloc", builder.getInt8PtrTy(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1186:                                  builder.getInt64Ty());
call    0 never executed
call    1 never executed
    #####: 1187:  llvmModule->getOrInsertFunction("free", builder.getVoidTy(),
call    0 never executed
    #####: 1188:                                  builder.getInt8PtrTy());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1189:
    #####: 1190:  return llvmModule;
call    0 never executed
        -: 1191:}
        -: 1192:
        -: 1193:std::unique_ptr<llvm::Module>
function _ZN4mlir23translateModuleToLLVMIREPNS_9OperationERN4llvm11LLVMContextENS2_9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1194:mlir::translateModuleToLLVMIR(Operation *module, llvm::LLVMContext &llvmContext,
        -: 1195:                              StringRef name) {
    #####: 1196:  if (!satisfiesLLVMModule(module)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1197:    module->emitOpError("can not be translated to an LLVMIR module");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1198:    return nullptr;
        -: 1199:  }
        -: 1200:
    #####: 1201:  std::unique_ptr<llvm::Module> llvmModule =
    #####: 1202:      prepareLLVMModule(module, llvmContext, name);
call    0 never executed
    #####: 1203:  if (!llvmModule)
branch  0 never executed
branch  1 never executed
    #####: 1204:    return nullptr;
branch  0 never executed
branch  1 never executed
        -: 1205:
    #####: 1206:  LLVM::ensureDistinctSuccessors(module);
call    0 never executed
        -: 1207:
    #####: 1208:  ModuleTranslation translator(module, std::move(llvmModule));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1209:  if (failed(translator.convertFunctionSignatures()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1210:    return nullptr;
    #####: 1211:  if (failed(translator.convertGlobals()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1212:    return nullptr;
    #####: 1213:  if (failed(translator.createAccessGroupMetadata()))
call    0 never executed
call    1 never executed
    #####: 1214:    return nullptr;
    #####: 1215:  if (failed(translator.createAliasScopeMetadata()))
call    0 never executed
call    1 never executed
    #####: 1216:    return nullptr;
    #####: 1217:  if (failed(translator.convertFunctions()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1218:    return nullptr;
call    0 never executed
        -: 1219:
        -: 1220:  // Convert other top-level operations if possible.
    #####: 1221:  llvm::IRBuilder<> llvmBuilder(llvmContext);
call    0 never executed
    #####: 1222:  for (Operation &o : getModuleBody(module).getOperations()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1223:    if (!isa<LLVM::LLVMFuncOp, LLVM::GlobalOp, LLVM::GlobalCtorsOp,
    #####: 1224:             LLVM::GlobalDtorsOp, LLVM::MetadataOp>(&o) &&
call    0 never executed
    #####: 1225:        !o.hasTrait<OpTrait::IsTerminator>() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1226:        failed(translator.convertOperation(o, llvmBuilder))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1227:      return nullptr;
        -: 1228:    }
        -: 1229:  }
        -: 1230:
    #####: 1231:  if (llvm::verifyModule(*translator.llvmModule, &llvm::errs()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1232:    return nullptr;
        -: 1233:
    #####: 1234:  return std::move(translator.llvmModule);
call    0 never executed
        -: 1235:}
