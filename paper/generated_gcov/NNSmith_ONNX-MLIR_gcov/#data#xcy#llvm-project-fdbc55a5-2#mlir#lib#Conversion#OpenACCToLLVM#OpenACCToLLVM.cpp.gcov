        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/OpenACCToLLVM/OpenACCToLLVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/OpenACCToLLVM/CMakeFiles/obj.MLIROpenACCToLLVM.dir/OpenACCToLLVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/OpenACCToLLVM/CMakeFiles/obj.MLIROpenACCToLLVM.dir/OpenACCToLLVM.cpp.gcda
        -:    0:Runs:128636
        -:    1://===- OpenACCToLLVM.cpp - Prepare OpenACC data for LLVM translation ------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/OpenACCToLLVM/ConvertOpenACCToLLVM.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/Pattern.h"
        -:   12:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   13:#include "mlir/Dialect/OpenACC/OpenACC.h"
        -:   14:#include "mlir/IR/Builders.h"
        -:   15:#include "mlir/Pass/Pass.h"
        -:   16:
        -:   17:namespace mlir {
        -:   18:#define GEN_PASS_DEF_CONVERTOPENACCTOLLVM
        -:   19:#include "mlir/Conversion/Passes.h.inc"
        -:   20:} // namespace mlir
        -:   21:
        -:   22:using namespace mlir;
        -:   23:
        -:   24://===----------------------------------------------------------------------===//
        -:   25:// DataDescriptor implementation
        -:   26://===----------------------------------------------------------------------===//
        -:   27:
    #####:   28:constexpr StringRef getStructName() { return "openacc_data"; }
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   29:
        -:   30:/// Construct a helper for the given descriptor value.
function _ZN4mlir14DataDescriptorC2ENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   31:DataDescriptor::DataDescriptor(Value descriptor) : StructBuilder(descriptor) {
call    0 never executed
    #####:   32:  assert(value != nullptr && "value cannot be null");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:}
        -:   34:
        -:   35:/// Builds IR creating an `undef` value of the data descriptor.
function _ZN4mlir14DataDescriptor5undefERNS_9OpBuilderENS_8LocationENS_4TypeES4_ called 0 returned 0% blocks executed 0%
    #####:   36:DataDescriptor DataDescriptor::undef(OpBuilder &builder, Location loc,
        -:   37:                                     Type basePtrTy, Type ptrTy) {
    #####:   38:  Type descriptorType = LLVM::LLVMStructType::getNewIdentified(
        -:   39:      builder.getContext(), getStructName(),
    #####:   40:      {basePtrTy, ptrTy, builder.getI64Type()});
call    0 never executed
call    1 never executed
    #####:   41:  Value descriptor = builder.create<LLVM::UndefOp>(loc, descriptorType);
call    0 never executed
call    1 never executed
    #####:   42:  return DataDescriptor(descriptor);
call    0 never executed
        -:   43:}
        -:   44:
        -:   45:/// Check whether the type is a valid data descriptor.
function _ZN4mlir14DataDescriptor7isValidENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   46:bool DataDescriptor::isValid(Value descriptor) {
    #####:   47:  if (auto type = descriptor.getType().dyn_cast<LLVM::LLVMStructType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   48:    if (type.isIdentified() && type.getName().startswith(getStructName()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   49:        type.getBody().size() == 3 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   50:        (type.getBody()[kPtrBasePosInDataDescriptor]
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   51:             .isa<LLVM::LLVMPointerType>() ||
branch  0 never executed
branch  1 never executed
    #####:   52:         type.getBody()[kPtrBasePosInDataDescriptor]
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   53:             .isa<LLVM::LLVMStructType>()) &&
branch  0 never executed
branch  1 never executed
    #####:   54:        type.getBody()[kPtrPosInDataDescriptor].isa<LLVM::LLVMPointerType>() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:   55:        type.getBody()[kSizePosInDataDescriptor].isInteger(64))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   56:      return true;
        -:   57:  }
    #####:   58:  return false;
        -:   59:}
        -:   60:
        -:   61:/// Builds IR inserting the base pointer value into the descriptor.
function _ZN4mlir14DataDescriptor14setBasePointerERNS_9OpBuilderENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   62:void DataDescriptor::setBasePointer(OpBuilder &builder, Location loc,
        -:   63:                                    Value basePtr) {
    #####:   64:  setPtr(builder, loc, kPtrBasePosInDataDescriptor, basePtr);
call    0 never executed
    #####:   65:}
        -:   66:
        -:   67:/// Builds IR inserting the pointer value into the descriptor.
function _ZN4mlir14DataDescriptor10setPointerERNS_9OpBuilderENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   68:void DataDescriptor::setPointer(OpBuilder &builder, Location loc, Value ptr) {
    #####:   69:  setPtr(builder, loc, kPtrPosInDataDescriptor, ptr);
call    0 never executed
    #####:   70:}
        -:   71:
        -:   72:/// Builds IR inserting the size value into the descriptor.
function _ZN4mlir14DataDescriptor7setSizeERNS_9OpBuilderENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   73:void DataDescriptor::setSize(OpBuilder &builder, Location loc, Value size) {
    #####:   74:  setPtr(builder, loc, kSizePosInDataDescriptor, size);
call    0 never executed
    #####:   75:}
        -:   76:
        -:   77://===----------------------------------------------------------------------===//
        -:   78:// Conversion patterns
        -:   79://===----------------------------------------------------------------------===//
        -:   80:
        -:   81:namespace {
        -:   82:
        -:   83:template <typename Op>
        -:   84:class LegalizeDataOpForLLVMTranslation : public ConvertOpToLLVMPattern<Op> {
     2780:   85:  using ConvertOpToLLVMPattern<Op>::ConvertOpToLLVMPattern;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:   86:
        -:   87:  LogicalResult
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
    #####:   98:    SmallVector<Value> convertedOperands;
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
    #####:  108:        Type structType = converter->convertType(memRefType);
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
    #####:  129:        convertedOperands.push_back(descr);
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
    #####:  131:        convertedOperands.push_back(originalDataOperand);
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
        -:  142:  }
------------------
_ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc6DataOpEE15matchAndRewriteES3_NS2_13DataOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc6DataOpEE15matchAndRewriteES3_NS2_13DataOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
call    0 never executed
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
call    0 never executed
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
call    0 never executed
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
call    0 never executed
call    1 never executed
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    SmallVector<Value> convertedOperands;
call    0 never executed
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
call    0 never executed
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
call    0 never executed
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:        Type structType = converter->convertType(memRefType);
call    0 never executed
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
call    0 never executed
call    1 never executed
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
call    0 never executed
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
branch  0 never executed
branch  1 never executed
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
call    0 never executed
call    1 never executed
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
call    0 never executed
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
call    0 never executed
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
call    0 never executed
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
call    0 never executed
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
call    0 never executed
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
call    0 never executed
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
call    0 never executed
    #####:  129:        convertedOperands.push_back(descr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        convertedOperands.push_back(originalDataOperand);
call    0 never executed
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
call    0 never executed
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
branch  0 never executed
branch  1 never executed
        -:  142:  }
------------------
_ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc11EnterDataOpEE15matchAndRewriteES3_NS2_18EnterDataOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc11EnterDataOpEE15matchAndRewriteES3_NS2_18EnterDataOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
call    0 never executed
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
call    0 never executed
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
call    0 never executed
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
call    0 never executed
call    1 never executed
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    SmallVector<Value> convertedOperands;
call    0 never executed
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
call    0 never executed
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
call    0 never executed
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:        Type structType = converter->convertType(memRefType);
call    0 never executed
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
call    0 never executed
call    1 never executed
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
call    0 never executed
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
branch  0 never executed
branch  1 never executed
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
call    0 never executed
call    1 never executed
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
call    0 never executed
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
call    0 never executed
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
call    0 never executed
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
call    0 never executed
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
call    0 never executed
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
call    0 never executed
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
call    0 never executed
    #####:  129:        convertedOperands.push_back(descr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        convertedOperands.push_back(originalDataOperand);
call    0 never executed
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
call    0 never executed
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
branch  0 never executed
branch  1 never executed
        -:  142:  }
------------------
_ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc10ExitDataOpEE15matchAndRewriteES3_NS2_17ExitDataOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc10ExitDataOpEE15matchAndRewriteES3_NS2_17ExitDataOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
call    0 never executed
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
call    0 never executed
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
call    0 never executed
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
call    0 never executed
call    1 never executed
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    SmallVector<Value> convertedOperands;
call    0 never executed
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
call    0 never executed
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
call    0 never executed
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:        Type structType = converter->convertType(memRefType);
call    0 never executed
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
call    0 never executed
call    1 never executed
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
call    0 never executed
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
branch  0 never executed
branch  1 never executed
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
call    0 never executed
call    1 never executed
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
call    0 never executed
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
call    0 never executed
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
call    0 never executed
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
call    0 never executed
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
call    0 never executed
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
call    0 never executed
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
call    0 never executed
    #####:  129:        convertedOperands.push_back(descr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        convertedOperands.push_back(originalDataOperand);
call    0 never executed
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
call    0 never executed
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
branch  0 never executed
branch  1 never executed
        -:  142:  }
------------------
_ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc10ParallelOpEE15matchAndRewriteES3_NS2_17ParallelOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc10ParallelOpEE15matchAndRewriteES3_NS2_17ParallelOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
call    0 never executed
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
call    0 never executed
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
call    0 never executed
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
call    0 never executed
call    1 never executed
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    SmallVector<Value> convertedOperands;
call    0 never executed
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
call    0 never executed
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
call    0 never executed
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:        Type structType = converter->convertType(memRefType);
call    0 never executed
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
call    0 never executed
call    1 never executed
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
call    0 never executed
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
branch  0 never executed
branch  1 never executed
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
call    0 never executed
call    1 never executed
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
call    0 never executed
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
call    0 never executed
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
call    0 never executed
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
call    0 never executed
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
call    0 never executed
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
call    0 never executed
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
call    0 never executed
    #####:  129:        convertedOperands.push_back(descr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        convertedOperands.push_back(originalDataOperand);
call    0 never executed
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
call    0 never executed
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
branch  0 never executed
branch  1 never executed
        -:  142:  }
------------------
_ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc8UpdateOpEE15matchAndRewriteES3_NS2_15UpdateOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132LegalizeDataOpForLLVMTranslationIN4mlir3acc8UpdateOpEE15matchAndRewriteES3_NS2_15UpdateOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   88:  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
        -:   89:                  ConversionPatternRewriter &builder) const override {
    #####:   90:    Location loc = op.getLoc();
call    0 never executed
    #####:   91:    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
call    0 never executed
        -:   92:
    #####:   93:    unsigned numDataOperand = op.getNumDataOperands();
call    0 never executed
        -:   94:
        -:   95:    // Keep the non data operands without modification.
    #####:   96:    auto nonDataOperands = adaptor.getOperands().take_front(
call    0 never executed
call    1 never executed
    #####:   97:        adaptor.getOperands().size() - numDataOperand);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    SmallVector<Value> convertedOperands;
call    0 never executed
    #####:   99:    convertedOperands.append(nonDataOperands.begin(), nonDataOperands.end());
call    0 never executed
        -:  100:
        -:  101:    // Go over the data operand and legalize them for translation.
    #####:  102:    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  103:      Value originalDataOperand = op.getDataOperand(idx);
call    0 never executed
        -:  104:
        -:  105:      // Traverse operands that were converted to MemRefDescriptors.
    #####:  106:      if (auto memRefType =
    #####:  107:              originalDataOperand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:        Type structType = converter->convertType(memRefType);
call    0 never executed
        -:  109:        Value memRefDescriptor = builder
    #####:  110:                                     .create<UnrealizedConversionCastOp>(
call    0 never executed
call    1 never executed
        -:  111:                                         loc, structType, originalDataOperand)
    #####:  112:                                     .getResult(0);
call    0 never executed
        -:  113:
        -:  114:        // Calculate the size of the memref and get the pointer to the allocated
        -:  115:        // buffer.
    #####:  116:        SmallVector<Value> sizes;
    #####:  117:        SmallVector<Value> strides;
branch  0 never executed
branch  1 never executed
    #####:  118:        Value sizeBytes;
    #####:  119:        ConvertToLLVMPattern::getMemRefDescriptorSizes(
call    0 never executed
call    1 never executed
        -:  120:            loc, memRefType, {}, builder, sizes, strides, sizeBytes);
    #####:  121:        MemRefDescriptor descriptor(memRefDescriptor);
call    0 never executed
    #####:  122:        Value dataPtr = descriptor.alignedPtr(builder, loc);
call    0 never executed
    #####:  123:        auto ptrType = descriptor.getElementPtrType();
call    0 never executed
        -:  124:
    #####:  125:        auto descr = DataDescriptor::undef(builder, loc, structType, ptrType);
call    0 never executed
    #####:  126:        descr.setBasePointer(builder, loc, memRefDescriptor);
call    0 never executed
    #####:  127:        descr.setPointer(builder, loc, dataPtr);
call    0 never executed
    #####:  128:        descr.setSize(builder, loc, sizeBytes);
call    0 never executed
    #####:  129:        convertedOperands.push_back(descr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      } else if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        convertedOperands.push_back(originalDataOperand);
call    0 never executed
        -:  132:      } else {
        -:  133:        // Type not supported.
    #####:  134:        return builder.notifyMatchFailure(op, "unsupported type");
call    0 never executed
        -:  135:      }
        -:  136:    }
        -:  137:
    #####:  138:    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  139:                                   op.getOperation()->getAttrs());
        -:  140:
    #####:  141:    return success();
branch  0 never executed
branch  1 never executed
        -:  142:  }
------------------
        -:  143:};
        -:  144:} // namespace
        -:  145:
function _ZN4mlir39populateOpenACCToLLVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 556 returned 100% blocks executed 100%
      556:  146:void mlir::populateOpenACCToLLVMConversionPatterns(
        -:  147:    LLVMTypeConverter &converter, RewritePatternSet &patterns) {
      556:  148:  patterns.add<LegalizeDataOpForLLVMTranslation<acc::DataOp>>(converter);
call    0 returned 100%
      556:  149:  patterns.add<LegalizeDataOpForLLVMTranslation<acc::EnterDataOp>>(converter);
call    0 returned 100%
      556:  150:  patterns.add<LegalizeDataOpForLLVMTranslation<acc::ExitDataOp>>(converter);
call    0 returned 100%
      556:  151:  patterns.add<LegalizeDataOpForLLVMTranslation<acc::ParallelOp>>(converter);
call    0 returned 100%
      556:  152:  patterns.add<LegalizeDataOpForLLVMTranslation<acc::UpdateOp>>(converter);
call    0 returned 100%
      556:  153:}
        -:  154:
        -:  155:namespace {
  129280*:  156:struct ConvertOpenACCToLLVMPass
call    0 never executed
call    1 returned 100%
        -:  157:    : public impl::ConvertOpenACCToLLVMBase<ConvertOpenACCToLLVMPass> {
        -:  158:  void runOnOperation() override;
        -:  159:};
        -:  160:} // namespace
        -:  161:
function _ZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEv called 556 returned 100% blocks executed 96%
      556:  162:void ConvertOpenACCToLLVMPass::runOnOperation() {
      556:  163:  auto op = getOperation();
call    0 returned 100%
      556:  164:  auto *context = op.getContext();
call    0 returned 100%
        -:  165:
        -:  166:  // Convert to OpenACC operations with LLVM IR dialect
      556:  167:  RewritePatternSet patterns(context);
call    0 returned 100%
     1112:  168:  LLVMTypeConverter converter(context);
call    0 returned 100%
call    1 returned 100%
      556:  169:  populateOpenACCToLLVMConversionPatterns(converter, patterns);
call    0 returned 100%
        -:  170:
     1112:  171:  ConversionTarget target(*context);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      556:  172:  target.addLegalDialect<LLVM::LLVMDialect>();
call    0 returned 100%
      556:  173:  target.addLegalOp<UnrealizedConversionCastOp>();
call    0 returned 100%
        -:  174:
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir10ValueRangeEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     556*:  175:  auto allDataOperandsAreConverted = [](ValueRange operands) {
    #####:  176:    for (Value operand : operands) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  177:      if (!DataDescriptor::isValid(operand) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  178:          !operand.getType().isa<LLVM::LLVMPointerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  179:        return false;
        -:  180:    }
    #####:  181:    return true;
        -:  182:  };
        -:  183:
      556:  184:  target.addDynamicallyLegalOp<acc::DataOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir3acc6DataOpEE0_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  185:      [allDataOperandsAreConverted](acc::DataOp op) {
    #####:  186:        return allDataOperandsAreConverted(op.getCopyOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  187:               allDataOperandsAreConverted(op.getCopyinOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  188:               allDataOperandsAreConverted(op.getCopyinReadonlyOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  189:               allDataOperandsAreConverted(op.getCopyoutOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  190:               allDataOperandsAreConverted(op.getCopyoutZeroOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  191:               allDataOperandsAreConverted(op.getCreateOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  192:               allDataOperandsAreConverted(op.getCreateZeroOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  193:               allDataOperandsAreConverted(op.getNoCreateOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  194:               allDataOperandsAreConverted(op.getPresentOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  195:               allDataOperandsAreConverted(op.getDeviceptrOperands()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  196:               allDataOperandsAreConverted(op.getAttachOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  197:      });
        -:  198:
      556:  199:  target.addDynamicallyLegalOp<acc::EnterDataOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir3acc11EnterDataOpEE1_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  200:      [allDataOperandsAreConverted](acc::EnterDataOp op) {
    #####:  201:        return allDataOperandsAreConverted(op.getCopyinOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  202:               allDataOperandsAreConverted(op.getCreateOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  203:               allDataOperandsAreConverted(op.getCreateZeroOperands()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  204:               allDataOperandsAreConverted(op.getAttachOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  205:      });
        -:  206:
      556:  207:  target.addDynamicallyLegalOp<acc::ExitDataOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir3acc10ExitDataOpEE2_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  208:      [allDataOperandsAreConverted](acc::ExitDataOp op) {
    #####:  209:        return allDataOperandsAreConverted(op.getCopyoutOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  210:               allDataOperandsAreConverted(op.getDeleteOperands()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  211:               allDataOperandsAreConverted(op.getDetachOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  212:      });
        -:  213:
      556:  214:  target.addDynamicallyLegalOp<acc::ParallelOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir3acc10ParallelOpEE3_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  215:      [allDataOperandsAreConverted](acc::ParallelOp op) {
    #####:  216:        return allDataOperandsAreConverted(op.getReductionOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  217:               allDataOperandsAreConverted(op.getCopyOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  218:               allDataOperandsAreConverted(op.getCopyinOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  219:               allDataOperandsAreConverted(op.getCopyinReadonlyOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  220:               allDataOperandsAreConverted(op.getCopyoutOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  221:               allDataOperandsAreConverted(op.getCopyoutZeroOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  222:               allDataOperandsAreConverted(op.getCreateOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  223:               allDataOperandsAreConverted(op.getCreateZeroOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  224:               allDataOperandsAreConverted(op.getNoCreateOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  225:               allDataOperandsAreConverted(op.getPresentOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  226:               allDataOperandsAreConverted(op.getDevicePtrOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  227:               allDataOperandsAreConverted(op.getAttachOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  228:               allDataOperandsAreConverted(op.getGangPrivateOperands()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  229:               allDataOperandsAreConverted(op.getGangFirstPrivateOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  230:      });
        -:  231:
      556:  232:  target.addDynamicallyLegalOp<acc::UpdateOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124ConvertOpenACCToLLVMPass14runOnOperationEvENKUlN4mlir3acc8UpdateOpEE4_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  233:      [allDataOperandsAreConverted](acc::UpdateOp op) {
    #####:  234:        return allDataOperandsAreConverted(op.getHostOperands()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  235:               allDataOperandsAreConverted(op.getDeviceOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  236:      });
        -:  237:
      556:  238:  if (failed(applyPartialConversion(op, target, std::move(patterns))))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  239:    signalPassFailure();
call    0 never executed
      556:  240:}
        -:  241:
        -:  242:std::unique_ptr<OperationPass<ModuleOp>>
function _ZN4mlir30createConvertOpenACCToLLVMPassEv called 129280 returned 100% blocks executed 100%
   129280:  243:mlir::createConvertOpenACCToLLVMPass() {
   129280:  244:  return std::make_unique<ConvertOpenACCToLLVMPass>();
call    0 returned 100%
        -:  245:}
