        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/DebugInfoMetadata.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Declarations for metadata specific to debug info.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_IR_DEBUGINFOMETADATA_H
        -:   14:#define LLVM_IR_DEBUGINFOMETADATA_H
        -:   15:
        -:   16:#include "llvm/ADT/ArrayRef.h"
        -:   17:#include "llvm/ADT/BitmaskEnum.h"
        -:   18:#include "llvm/ADT/None.h"
        -:   19:#include "llvm/ADT/Optional.h"
        -:   20:#include "llvm/ADT/PointerUnion.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/SmallVector.h"
        -:   23:#include "llvm/ADT/StringRef.h"
        -:   24:#include "llvm/ADT/iterator_range.h"
        -:   25:#include "llvm/IR/Constants.h"
        -:   26:#include "llvm/IR/Metadata.h"
        -:   27:#include "llvm/Support/Casting.h"
        -:   28:#include "llvm/Support/CommandLine.h"
        -:   29:#include "llvm/Support/Discriminator.h"
        -:   30:#include <cassert>
        -:   31:#include <climits>
        -:   32:#include <cstddef>
        -:   33:#include <cstdint>
        -:   34:#include <iterator>
        -:   35:#include <vector>
        -:   36:
        -:   37:// Helper macros for defining get() overrides.
        -:   38:#define DEFINE_MDNODE_GET_UNPACK_IMPL(...) __VA_ARGS__
        -:   39:#define DEFINE_MDNODE_GET_UNPACK(ARGS) DEFINE_MDNODE_GET_UNPACK_IMPL ARGS
        -:   40:#define DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)              \
        -:   41:  static CLASS *getDistinct(LLVMContext &Context,                              \
        -:   42:                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \
        -:   43:    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \
        -:   44:  }                                                                            \
        -:   45:  static Temp##CLASS getTemporary(LLVMContext &Context,                        \
        -:   46:                                  DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \
        -:   47:    return Temp##CLASS(                                                        \
        -:   48:        getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \
        -:   49:  }
        -:   50:#define DEFINE_MDNODE_GET(CLASS, FORMAL, ARGS)                                 \
        -:   51:  static CLASS *get(LLVMContext &Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \
        -:   52:    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \
        -:   53:  }                                                                            \
        -:   54:  static CLASS *getIfExists(LLVMContext &Context,                              \
        -:   55:                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \
        -:   56:    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \
        -:   57:                   /* ShouldCreate */ false);                                  \
        -:   58:  }                                                                            \
        -:   59:  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)
        -:   60:
        -:   61:namespace llvm {
        -:   62:
        -:   63:namespace dwarf {
        -:   64:enum Tag : uint16_t;
        -:   65:}
        -:   66:
        -:   67:class DbgVariableIntrinsic;
        -:   68:
        -:   69:extern cl::opt<bool> EnableFSDiscriminator;
        -:   70:
        -:   71:class DITypeRefArray {
        -:   72:  const MDTuple *N = nullptr;
        -:   73:
        -:   74:public:
        -:   75:  DITypeRefArray() = default;
        -:   76:  DITypeRefArray(const MDTuple *N) : N(N) {}
        -:   77:
        -:   78:  explicit operator bool() const { return get(); }
        -:   79:  explicit operator MDTuple *() const { return get(); }
        -:   80:
        -:   81:  MDTuple *get() const { return const_cast<MDTuple *>(N); }
        -:   82:  MDTuple *operator->() const { return get(); }
        -:   83:  MDTuple &operator*() const { return *get(); }
        -:   84:
        -:   85:  // FIXME: Fix callers and remove condition on N.
        -:   86:  unsigned size() const { return N ? N->getNumOperands() : 0u; }
        -:   87:  DIType *operator[](unsigned I) const {
        -:   88:    return cast_or_null<DIType>(N->getOperand(I));
        -:   89:  }
        -:   90:
        -:   91:  class iterator {
        -:   92:    MDNode::op_iterator I = nullptr;
        -:   93:
        -:   94:  public:
        -:   95:    using iterator_category = std::input_iterator_tag;
        -:   96:    using value_type = DIType *;
        -:   97:    using difference_type = std::ptrdiff_t;
        -:   98:    using pointer = void;
        -:   99:    using reference = DIType *;
        -:  100:
        -:  101:    iterator() = default;
        -:  102:    explicit iterator(MDNode::op_iterator I) : I(I) {}
        -:  103:
        -:  104:    DIType *operator*() const { return cast_or_null<DIType>(*I); }
        -:  105:
        -:  106:    iterator &operator++() {
        -:  107:      ++I;
        -:  108:      return *this;
        -:  109:    }
        -:  110:
        -:  111:    iterator operator++(int) {
        -:  112:      iterator Temp(*this);
        -:  113:      ++I;
        -:  114:      return Temp;
        -:  115:    }
        -:  116:
        -:  117:    bool operator==(const iterator &X) const { return I == X.I; }
        -:  118:    bool operator!=(const iterator &X) const { return I != X.I; }
        -:  119:  };
        -:  120:
        -:  121:  // FIXME: Fix callers and remove condition on N.
        -:  122:  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }
        -:  123:  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }
        -:  124:};
        -:  125:
        -:  126:/// Tagged DWARF-like metadata node.
        -:  127:///
        -:  128:/// A metadata node with a DWARF tag (i.e., a constant named \c DW_TAG_*,
        -:  129:/// defined in llvm/BinaryFormat/Dwarf.h).  Called \a DINode because it's
        -:  130:/// potentially used for non-DWARF output.
        -:  131:class DINode : public MDNode {
        -:  132:  friend class LLVMContextImpl;
        -:  133:  friend class MDNode;
        -:  134:
        -:  135:protected:
        -:  136:  DINode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,
        -:  137:         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)
        -:  138:      : MDNode(C, ID, Storage, Ops1, Ops2) {
        -:  139:    assert(Tag < 1u << 16);
        -:  140:    SubclassData16 = Tag;
        -:  141:  }
        -:  142:  ~DINode() = default;
        -:  143:
        -:  144:  template <class Ty> Ty *getOperandAs(unsigned I) const {
        -:  145:    return cast_or_null<Ty>(getOperand(I));
        -:  146:  }
        -:  147:
        -:  148:  StringRef getStringOperand(unsigned I) const {
        -:  149:    if (auto *S = getOperandAs<MDString>(I))
        -:  150:      return S->getString();
        -:  151:    return StringRef();
        -:  152:  }
        -:  153:
        -:  154:  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {
        -:  155:    if (S.empty())
        -:  156:      return nullptr;
        -:  157:    return MDString::get(Context, S);
        -:  158:  }
        -:  159:
        -:  160:  /// Allow subclasses to mutate the tag.
        -:  161:  void setTag(unsigned Tag) { SubclassData16 = Tag; }
        -:  162:
        -:  163:public:
        -:  164:  dwarf::Tag getTag() const;
        -:  165:
        -:  166:  /// Debug info flags.
        -:  167:  ///
        -:  168:  /// The three accessibility flags are mutually exclusive and rolled together
        -:  169:  /// in the first two bits.
        -:  170:  enum DIFlags : uint32_t {
        -:  171:#define HANDLE_DI_FLAG(ID, NAME) Flag##NAME = ID,
        -:  172:#define DI_FLAG_LARGEST_NEEDED
        -:  173:#include "llvm/IR/DebugInfoFlags.def"
        -:  174:    FlagAccessibility = FlagPrivate | FlagProtected | FlagPublic,
        -:  175:    FlagPtrToMemberRep = FlagSingleInheritance | FlagMultipleInheritance |
        -:  176:                         FlagVirtualInheritance,
        -:  177:    LLVM_MARK_AS_BITMASK_ENUM(FlagLargest)
        -:  178:  };
        -:  179:
        -:  180:  static DIFlags getFlag(StringRef Flag);
        -:  181:  static StringRef getFlagString(DIFlags Flag);
        -:  182:
        -:  183:  /// Split up a flags bitfield.
        -:  184:  ///
        -:  185:  /// Split \c Flags into \c SplitFlags, a vector of its components.  Returns
        -:  186:  /// any remaining (unrecognized) bits.
        -:  187:  static DIFlags splitFlags(DIFlags Flags,
        -:  188:                            SmallVectorImpl<DIFlags> &SplitFlags);
        -:  189:
        -:  190:  static bool classof(const Metadata *MD) {
        -:  191:    switch (MD->getMetadataID()) {
        -:  192:    default:
        -:  193:      return false;
        -:  194:    case GenericDINodeKind:
        -:  195:    case DISubrangeKind:
        -:  196:    case DIEnumeratorKind:
        -:  197:    case DIBasicTypeKind:
        -:  198:    case DIStringTypeKind:
        -:  199:    case DIDerivedTypeKind:
        -:  200:    case DICompositeTypeKind:
        -:  201:    case DISubroutineTypeKind:
        -:  202:    case DIFileKind:
        -:  203:    case DICompileUnitKind:
        -:  204:    case DISubprogramKind:
        -:  205:    case DILexicalBlockKind:
        -:  206:    case DILexicalBlockFileKind:
        -:  207:    case DINamespaceKind:
        -:  208:    case DICommonBlockKind:
        -:  209:    case DITemplateTypeParameterKind:
        -:  210:    case DITemplateValueParameterKind:
        -:  211:    case DIGlobalVariableKind:
        -:  212:    case DILocalVariableKind:
        -:  213:    case DILabelKind:
        -:  214:    case DIObjCPropertyKind:
        -:  215:    case DIImportedEntityKind:
        -:  216:    case DIModuleKind:
        -:  217:    case DIGenericSubrangeKind:
        -:  218:      return true;
        -:  219:    }
        -:  220:  }
        -:  221:};
        -:  222:
        -:  223:/// Generic tagged DWARF-like metadata node.
        -:  224:///
        -:  225:/// An un-specialized DWARF-like metadata node.  The first operand is a
        -:  226:/// (possibly empty) null-separated \a MDString header that contains arbitrary
        -:  227:/// fields.  The remaining operands are \a dwarf_operands(), and are pointers
        -:  228:/// to other metadata.
        -:  229:class GenericDINode : public DINode {
        -:  230:  friend class LLVMContextImpl;
        -:  231:  friend class MDNode;
        -:  232:
        -:  233:  GenericDINode(LLVMContext &C, StorageType Storage, unsigned Hash,
        -:  234:                unsigned Tag, ArrayRef<Metadata *> Ops1,
        -:  235:                ArrayRef<Metadata *> Ops2)
        -:  236:      : DINode(C, GenericDINodeKind, Storage, Tag, Ops1, Ops2) {
        -:  237:    setHash(Hash);
        -:  238:  }
        -:  239:  ~GenericDINode() { dropAllReferences(); }
        -:  240:
        -:  241:  void setHash(unsigned Hash) { SubclassData32 = Hash; }
        -:  242:  void recalculateHash();
        -:  243:
        -:  244:  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,
        -:  245:                                StringRef Header, ArrayRef<Metadata *> DwarfOps,
        -:  246:                                StorageType Storage, bool ShouldCreate = true) {
        -:  247:    return getImpl(Context, Tag, getCanonicalMDString(Context, Header),
        -:  248:                   DwarfOps, Storage, ShouldCreate);
        -:  249:  }
        -:  250:
        -:  251:  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,
        -:  252:                                MDString *Header, ArrayRef<Metadata *> DwarfOps,
        -:  253:                                StorageType Storage, bool ShouldCreate = true);
        -:  254:
        -:  255:  TempGenericDINode cloneImpl() const {
        -:  256:    return getTemporary(getContext(), getTag(), getHeader(),
        -:  257:                        SmallVector<Metadata *, 4>(dwarf_operands()));
        -:  258:  }
        -:  259:
        -:  260:public:
        -:  261:  unsigned getHash() const { return SubclassData32; }
        -:  262:
        -:  263:  DEFINE_MDNODE_GET(GenericDINode,
        -:  264:                    (unsigned Tag, StringRef Header,
        -:  265:                     ArrayRef<Metadata *> DwarfOps),
        -:  266:                    (Tag, Header, DwarfOps))
        -:  267:  DEFINE_MDNODE_GET(GenericDINode,
        -:  268:                    (unsigned Tag, MDString *Header,
        -:  269:                     ArrayRef<Metadata *> DwarfOps),
        -:  270:                    (Tag, Header, DwarfOps))
        -:  271:
        -:  272:  /// Return a (temporary) clone of this.
        -:  273:  TempGenericDINode clone() const { return cloneImpl(); }
        -:  274:
        -:  275:  dwarf::Tag getTag() const;
        -:  276:  StringRef getHeader() const { return getStringOperand(0); }
        -:  277:  MDString *getRawHeader() const { return getOperandAs<MDString>(0); }
        -:  278:
        -:  279:  op_iterator dwarf_op_begin() const { return op_begin() + 1; }
        -:  280:  op_iterator dwarf_op_end() const { return op_end(); }
        -:  281:  op_range dwarf_operands() const {
        -:  282:    return op_range(dwarf_op_begin(), dwarf_op_end());
        -:  283:  }
        -:  284:
        -:  285:  unsigned getNumDwarfOperands() const { return getNumOperands() - 1; }
        -:  286:  const MDOperand &getDwarfOperand(unsigned I) const {
        -:  287:    return getOperand(I + 1);
        -:  288:  }
        -:  289:  void replaceDwarfOperandWith(unsigned I, Metadata *New) {
        -:  290:    replaceOperandWith(I + 1, New);
        -:  291:  }
        -:  292:
        -:  293:  static bool classof(const Metadata *MD) {
        -:  294:    return MD->getMetadataID() == GenericDINodeKind;
        -:  295:  }
        -:  296:};
        -:  297:
        -:  298:/// Array subrange.
        -:  299:///
        -:  300:/// TODO: Merge into node for DW_TAG_array_type, which should have a custom
        -:  301:/// type.
        -:  302:class DISubrange : public DINode {
        -:  303:  friend class LLVMContextImpl;
        -:  304:  friend class MDNode;
        -:  305:
        -:  306:  DISubrange(LLVMContext &C, StorageType Storage, ArrayRef<Metadata *> Ops);
        -:  307:
        -:  308:  ~DISubrange() = default;
        -:  309:
        -:  310:  static DISubrange *getImpl(LLVMContext &Context, int64_t Count,
        -:  311:                             int64_t LowerBound, StorageType Storage,
        -:  312:                             bool ShouldCreate = true);
        -:  313:
        -:  314:  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,
        -:  315:                             int64_t LowerBound, StorageType Storage,
        -:  316:                             bool ShouldCreate = true);
        -:  317:
        -:  318:  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,
        -:  319:                             Metadata *LowerBound, Metadata *UpperBound,
        -:  320:                             Metadata *Stride, StorageType Storage,
        -:  321:                             bool ShouldCreate = true);
        -:  322:
        -:  323:  TempDISubrange cloneImpl() const {
        -:  324:    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),
        -:  325:                        getRawUpperBound(), getRawStride());
        -:  326:  }
        -:  327:
        -:  328:public:
        -:  329:  DEFINE_MDNODE_GET(DISubrange, (int64_t Count, int64_t LowerBound = 0),
        -:  330:                    (Count, LowerBound))
        -:  331:
        -:  332:  DEFINE_MDNODE_GET(DISubrange, (Metadata * CountNode, int64_t LowerBound = 0),
        -:  333:                    (CountNode, LowerBound))
        -:  334:
        -:  335:  DEFINE_MDNODE_GET(DISubrange,
        -:  336:                    (Metadata * CountNode, Metadata *LowerBound,
        -:  337:                     Metadata *UpperBound, Metadata *Stride),
        -:  338:                    (CountNode, LowerBound, UpperBound, Stride))
        -:  339:
        -:  340:  TempDISubrange clone() const { return cloneImpl(); }
        -:  341:
        -:  342:  Metadata *getRawCountNode() const { return getOperand(0).get(); }
        -:  343:
        -:  344:  Metadata *getRawLowerBound() const { return getOperand(1).get(); }
        -:  345:
        -:  346:  Metadata *getRawUpperBound() const { return getOperand(2).get(); }
        -:  347:
        -:  348:  Metadata *getRawStride() const { return getOperand(3).get(); }
        -:  349:
        -:  350:  typedef PointerUnion<ConstantInt *, DIVariable *, DIExpression *> BoundType;
        -:  351:
        -:  352:  BoundType getCount() const;
        -:  353:
        -:  354:  BoundType getLowerBound() const;
        -:  355:
        -:  356:  BoundType getUpperBound() const;
        -:  357:
        -:  358:  BoundType getStride() const;
        -:  359:
        -:  360:  static bool classof(const Metadata *MD) {
        -:  361:    return MD->getMetadataID() == DISubrangeKind;
        -:  362:  }
        -:  363:};
        -:  364:
        -:  365:class DIGenericSubrange : public DINode {
        -:  366:  friend class LLVMContextImpl;
        -:  367:  friend class MDNode;
        -:  368:
        -:  369:  DIGenericSubrange(LLVMContext &C, StorageType Storage,
        -:  370:                    ArrayRef<Metadata *> Ops);
        -:  371:
        -:  372:  ~DIGenericSubrange() = default;
        -:  373:
        -:  374:  static DIGenericSubrange *getImpl(LLVMContext &Context, Metadata *CountNode,
        -:  375:                                    Metadata *LowerBound, Metadata *UpperBound,
        -:  376:                                    Metadata *Stride, StorageType Storage,
        -:  377:                                    bool ShouldCreate = true);
        -:  378:
        -:  379:  TempDIGenericSubrange cloneImpl() const {
        -:  380:    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),
        -:  381:                        getRawUpperBound(), getRawStride());
        -:  382:  }
        -:  383:
        -:  384:public:
        -:  385:  DEFINE_MDNODE_GET(DIGenericSubrange,
        -:  386:                    (Metadata * CountNode, Metadata *LowerBound,
        -:  387:                     Metadata *UpperBound, Metadata *Stride),
        -:  388:                    (CountNode, LowerBound, UpperBound, Stride))
        -:  389:
        -:  390:  TempDIGenericSubrange clone() const { return cloneImpl(); }
        -:  391:
        -:  392:  Metadata *getRawCountNode() const { return getOperand(0).get(); }
        -:  393:  Metadata *getRawLowerBound() const { return getOperand(1).get(); }
        -:  394:  Metadata *getRawUpperBound() const { return getOperand(2).get(); }
        -:  395:  Metadata *getRawStride() const { return getOperand(3).get(); }
        -:  396:
        -:  397:  using BoundType = PointerUnion<DIVariable *, DIExpression *>;
        -:  398:
        -:  399:  BoundType getCount() const;
        -:  400:  BoundType getLowerBound() const;
        -:  401:  BoundType getUpperBound() const;
        -:  402:  BoundType getStride() const;
        -:  403:
        -:  404:  static bool classof(const Metadata *MD) {
        -:  405:    return MD->getMetadataID() == DIGenericSubrangeKind;
        -:  406:  }
        -:  407:};
        -:  408:
        -:  409:/// Enumeration value.
        -:  410:///
        -:  411:/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no
        -:  412:/// longer creates a type cycle.
        -:  413:class DIEnumerator : public DINode {
        -:  414:  friend class LLVMContextImpl;
        -:  415:  friend class MDNode;
        -:  416:
        -:  417:  APInt Value;
        -:  418:  DIEnumerator(LLVMContext &C, StorageType Storage, const APInt &Value,
        -:  419:               bool IsUnsigned, ArrayRef<Metadata *> Ops);
        -:  420:  DIEnumerator(LLVMContext &C, StorageType Storage, int64_t Value,
        -:  421:               bool IsUnsigned, ArrayRef<Metadata *> Ops)
        -:  422:      : DIEnumerator(C, Storage, APInt(64, Value, !IsUnsigned), IsUnsigned,
        -:  423:                     Ops) {}
        -:  424:  ~DIEnumerator() = default;
        -:  425:
        -:  426:  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,
        -:  427:                               bool IsUnsigned, StringRef Name,
        -:  428:                               StorageType Storage, bool ShouldCreate = true) {
        -:  429:    return getImpl(Context, Value, IsUnsigned,
        -:  430:                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);
        -:  431:  }
        -:  432:  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,
        -:  433:                               bool IsUnsigned, MDString *Name,
        -:  434:                               StorageType Storage, bool ShouldCreate = true);
        -:  435:
        -:  436:  TempDIEnumerator cloneImpl() const {
        -:  437:    return getTemporary(getContext(), getValue(), isUnsigned(), getName());
        -:  438:  }
        -:  439:
        -:  440:public:
        -:  441:  DEFINE_MDNODE_GET(DIEnumerator,
        -:  442:                    (int64_t Value, bool IsUnsigned, StringRef Name),
        -:  443:                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))
        -:  444:  DEFINE_MDNODE_GET(DIEnumerator,
        -:  445:                    (int64_t Value, bool IsUnsigned, MDString *Name),
        -:  446:                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))
        -:  447:  DEFINE_MDNODE_GET(DIEnumerator,
        -:  448:                    (APInt Value, bool IsUnsigned, StringRef Name),
        -:  449:                    (Value, IsUnsigned, Name))
        -:  450:  DEFINE_MDNODE_GET(DIEnumerator,
        -:  451:                    (APInt Value, bool IsUnsigned, MDString *Name),
        -:  452:                    (Value, IsUnsigned, Name))
        -:  453:
        -:  454:  TempDIEnumerator clone() const { return cloneImpl(); }
        -:  455:
        -:  456:  const APInt &getValue() const { return Value; }
        -:  457:  bool isUnsigned() const { return SubclassData32; }
        -:  458:  StringRef getName() const { return getStringOperand(0); }
        -:  459:
        -:  460:  MDString *getRawName() const { return getOperandAs<MDString>(0); }
        -:  461:
        -:  462:  static bool classof(const Metadata *MD) {
        -:  463:    return MD->getMetadataID() == DIEnumeratorKind;
        -:  464:  }
        -:  465:};
        -:  466:
        -:  467:/// Base class for scope-like contexts.
        -:  468:///
        -:  469:/// Base class for lexical scopes and types (which are also declaration
        -:  470:/// contexts).
        -:  471:///
        -:  472:/// TODO: Separate the concepts of declaration contexts and lexical scopes.
        -:  473:class DIScope : public DINode {
        -:  474:protected:
        -:  475:  DIScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,
        -:  476:          ArrayRef<Metadata *> Ops)
        -:  477:      : DINode(C, ID, Storage, Tag, Ops) {}
        -:  478:  ~DIScope() = default;
        -:  479:
        -:  480:public:
        -:  481:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -:  482:
        -:  483:  inline StringRef getFilename() const;
        -:  484:  inline StringRef getDirectory() const;
        -:  485:  inline Optional<StringRef> getSource() const;
        -:  486:
        -:  487:  StringRef getName() const;
        -:  488:  DIScope *getScope() const;
        -:  489:
        -:  490:  /// Return the raw underlying file.
        -:  491:  ///
        -:  492:  /// A \a DIFile is a \a DIScope, but it doesn't point at a separate file (it
        -:  493:  /// \em is the file).  If \c this is an \a DIFile, we need to return \c this.
        -:  494:  /// Otherwise, return the first operand, which is where all other subclasses
        -:  495:  /// store their file pointer.
        -:  496:  Metadata *getRawFile() const {
        -:  497:    return isa<DIFile>(this) ? const_cast<DIScope *>(this)
        -:  498:                             : static_cast<Metadata *>(getOperand(0));
        -:  499:  }
        -:  500:
        -:  501:  static bool classof(const Metadata *MD) {
        -:  502:    switch (MD->getMetadataID()) {
        -:  503:    default:
        -:  504:      return false;
        -:  505:    case DIBasicTypeKind:
        -:  506:    case DIStringTypeKind:
        -:  507:    case DIDerivedTypeKind:
        -:  508:    case DICompositeTypeKind:
        -:  509:    case DISubroutineTypeKind:
        -:  510:    case DIFileKind:
        -:  511:    case DICompileUnitKind:
        -:  512:    case DISubprogramKind:
        -:  513:    case DILexicalBlockKind:
        -:  514:    case DILexicalBlockFileKind:
        -:  515:    case DINamespaceKind:
        -:  516:    case DICommonBlockKind:
        -:  517:    case DIModuleKind:
        -:  518:      return true;
        -:  519:    }
        -:  520:  }
        -:  521:};
        -:  522:
        -:  523:/// File.
        -:  524:///
        -:  525:/// TODO: Merge with directory/file node (including users).
        -:  526:/// TODO: Canonicalize paths on creation.
        -:  527:class DIFile : public DIScope {
        -:  528:  friend class LLVMContextImpl;
        -:  529:  friend class MDNode;
        -:  530:
        -:  531:public:
        -:  532:  /// Which algorithm (e.g. MD5) a checksum was generated with.
        -:  533:  ///
        -:  534:  /// The encoding is explicit because it is used directly in Bitcode. The
        -:  535:  /// value 0 is reserved to indicate the absence of a checksum in Bitcode.
        -:  536:  enum ChecksumKind {
        -:  537:    // The first variant was originally CSK_None, encoded as 0. The new
        -:  538:    // internal representation removes the need for this by wrapping the
        -:  539:    // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0
        -:  540:    // encoding is reserved.
        -:  541:    CSK_MD5 = 1,
        -:  542:    CSK_SHA1 = 2,
        -:  543:    CSK_SHA256 = 3,
        -:  544:    CSK_Last = CSK_SHA256 // Should be last enumeration.
        -:  545:  };
        -:  546:
        -:  547:  /// A single checksum, represented by a \a Kind and a \a Value (a string).
        -:  548:  template <typename T> struct ChecksumInfo {
        -:  549:    /// The kind of checksum which \a Value encodes.
        -:  550:    ChecksumKind Kind;
        -:  551:    /// The string value of the checksum.
        -:  552:    T Value;
        -:  553:
        -:  554:    ChecksumInfo(ChecksumKind Kind, T Value) : Kind(Kind), Value(Value) {}
        -:  555:    ~ChecksumInfo() = default;
        -:  556:    bool operator==(const ChecksumInfo<T> &X) const {
        -:  557:      return Kind == X.Kind && Value == X.Value;
        -:  558:    }
        -:  559:    bool operator!=(const ChecksumInfo<T> &X) const { return !(*this == X); }
        -:  560:    StringRef getKindAsString() const { return getChecksumKindAsString(Kind); }
        -:  561:  };
        -:  562:
        -:  563:private:
        -:  564:  Optional<ChecksumInfo<MDString *>> Checksum;
        -:  565:  Optional<MDString *> Source;
        -:  566:
        -:  567:  DIFile(LLVMContext &C, StorageType Storage,
        -:  568:         Optional<ChecksumInfo<MDString *>> CS, Optional<MDString *> Src,
        -:  569:         ArrayRef<Metadata *> Ops);
        -:  570:  ~DIFile() = default;
        -:  571:
        -:  572:  static DIFile *getImpl(LLVMContext &Context, StringRef Filename,
        -:  573:                         StringRef Directory,
        -:  574:                         Optional<ChecksumInfo<StringRef>> CS,
        -:  575:                         Optional<StringRef> Source, StorageType Storage,
        -:  576:                         bool ShouldCreate = true) {
        -:  577:    Optional<ChecksumInfo<MDString *>> MDChecksum;
        -:  578:    if (CS)
        -:  579:      MDChecksum.emplace(CS->Kind, getCanonicalMDString(Context, CS->Value));
        -:  580:    return getImpl(
        -:  581:        Context, getCanonicalMDString(Context, Filename),
        -:  582:        getCanonicalMDString(Context, Directory), MDChecksum,
        -:  583:        Source ? Optional<MDString *>(getCanonicalMDString(Context, *Source))
        -:  584:               : None,
        -:  585:        Storage, ShouldCreate);
        -:  586:  }
        -:  587:  static DIFile *getImpl(LLVMContext &Context, MDString *Filename,
        -:  588:                         MDString *Directory,
        -:  589:                         Optional<ChecksumInfo<MDString *>> CS,
        -:  590:                         Optional<MDString *> Source, StorageType Storage,
        -:  591:                         bool ShouldCreate = true);
        -:  592:
        -:  593:  TempDIFile cloneImpl() const {
        -:  594:    return getTemporary(getContext(), getFilename(), getDirectory(),
        -:  595:                        getChecksum(), getSource());
        -:  596:  }
        -:  597:
        -:  598:public:
        -:  599:  DEFINE_MDNODE_GET(DIFile,
        -:  600:                    (StringRef Filename, StringRef Directory,
        -:  601:                     Optional<ChecksumInfo<StringRef>> CS = None,
        -:  602:                     Optional<StringRef> Source = None),
        -:  603:                    (Filename, Directory, CS, Source))
        -:  604:  DEFINE_MDNODE_GET(DIFile,
        -:  605:                    (MDString * Filename, MDString *Directory,
        -:  606:                     Optional<ChecksumInfo<MDString *>> CS = None,
        -:  607:                     Optional<MDString *> Source = None),
        -:  608:                    (Filename, Directory, CS, Source))
        -:  609:
        -:  610:  TempDIFile clone() const { return cloneImpl(); }
        -:  611:
        -:  612:  StringRef getFilename() const { return getStringOperand(0); }
        -:  613:  StringRef getDirectory() const { return getStringOperand(1); }
        -:  614:  Optional<ChecksumInfo<StringRef>> getChecksum() const {
        -:  615:    Optional<ChecksumInfo<StringRef>> StringRefChecksum;
        -:  616:    if (Checksum)
        -:  617:      StringRefChecksum.emplace(Checksum->Kind, Checksum->Value->getString());
        -:  618:    return StringRefChecksum;
        -:  619:  }
        -:  620:  Optional<StringRef> getSource() const {
        -:  621:    return Source ? Optional<StringRef>((*Source)->getString()) : None;
        -:  622:  }
        -:  623:
        -:  624:  MDString *getRawFilename() const { return getOperandAs<MDString>(0); }
        -:  625:  MDString *getRawDirectory() const { return getOperandAs<MDString>(1); }
        -:  626:  Optional<ChecksumInfo<MDString *>> getRawChecksum() const { return Checksum; }
        -:  627:  Optional<MDString *> getRawSource() const { return Source; }
        -:  628:
        -:  629:  static StringRef getChecksumKindAsString(ChecksumKind CSKind);
        -:  630:  static Optional<ChecksumKind> getChecksumKind(StringRef CSKindStr);
        -:  631:
        -:  632:  static bool classof(const Metadata *MD) {
        -:  633:    return MD->getMetadataID() == DIFileKind;
        -:  634:  }
        -:  635:};
        -:  636:
        -:  637:StringRef DIScope::getFilename() const {
        -:  638:  if (auto *F = getFile())
        -:  639:    return F->getFilename();
        -:  640:  return "";
        -:  641:}
        -:  642:
        -:  643:StringRef DIScope::getDirectory() const {
        -:  644:  if (auto *F = getFile())
        -:  645:    return F->getDirectory();
        -:  646:  return "";
        -:  647:}
        -:  648:
        -:  649:Optional<StringRef> DIScope::getSource() const {
        -:  650:  if (auto *F = getFile())
        -:  651:    return F->getSource();
        -:  652:  return None;
        -:  653:}
        -:  654:
        -:  655:/// Base class for types.
        -:  656:///
        -:  657:/// TODO: Remove the hardcoded name and context, since many types don't use
        -:  658:/// them.
        -:  659:/// TODO: Split up flags.
        -:  660:class DIType : public DIScope {
        -:  661:  unsigned Line;
        -:  662:  DIFlags Flags;
        -:  663:  uint64_t SizeInBits;
        -:  664:  uint64_t OffsetInBits;
        -:  665:  uint32_t AlignInBits;
        -:  666:
        -:  667:protected:
        -:  668:  DIType(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,
        -:  669:         unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,
        -:  670:         uint64_t OffsetInBits, DIFlags Flags, ArrayRef<Metadata *> Ops)
        -:  671:      : DIScope(C, ID, Storage, Tag, Ops) {
        -:  672:    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);
        -:  673:  }
        -:  674:  ~DIType() = default;
        -:  675:
        -:  676:  void init(unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,
        -:  677:            uint64_t OffsetInBits, DIFlags Flags) {
        -:  678:    this->Line = Line;
        -:  679:    this->Flags = Flags;
        -:  680:    this->SizeInBits = SizeInBits;
        -:  681:    this->AlignInBits = AlignInBits;
        -:  682:    this->OffsetInBits = OffsetInBits;
        -:  683:  }
        -:  684:
        -:  685:  /// Change fields in place.
        -:  686:  void mutate(unsigned Tag, unsigned Line, uint64_t SizeInBits,
        -:  687:              uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags) {
        -:  688:    assert(isDistinct() && "Only distinct nodes can mutate");
        -:  689:    setTag(Tag);
        -:  690:    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);
        -:  691:  }
        -:  692:
        -:  693:public:
        -:  694:  TempDIType clone() const {
        -:  695:    return TempDIType(cast<DIType>(MDNode::clone().release()));
        -:  696:  }
        -:  697:
        -:  698:  unsigned getLine() const { return Line; }
        -:  699:  uint64_t getSizeInBits() const { return SizeInBits; }
        -:  700:  uint32_t getAlignInBits() const { return AlignInBits; }
        -:  701:  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }
        -:  702:  uint64_t getOffsetInBits() const { return OffsetInBits; }
        -:  703:  DIFlags getFlags() const { return Flags; }
        -:  704:
        -:  705:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -:  706:  StringRef getName() const { return getStringOperand(2); }
        -:  707:
        -:  708:  Metadata *getRawScope() const { return getOperand(1); }
        -:  709:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -:  710:
        -:  711:  /// Returns a new temporary DIType with updated Flags
        -:  712:  TempDIType cloneWithFlags(DIFlags NewFlags) const {
        -:  713:    auto NewTy = clone();
        -:  714:    NewTy->Flags = NewFlags;
        -:  715:    return NewTy;
        -:  716:  }
        -:  717:
        -:  718:  bool isPrivate() const {
        -:  719:    return (getFlags() & FlagAccessibility) == FlagPrivate;
        -:  720:  }
        -:  721:  bool isProtected() const {
        -:  722:    return (getFlags() & FlagAccessibility) == FlagProtected;
        -:  723:  }
        -:  724:  bool isPublic() const {
        -:  725:    return (getFlags() & FlagAccessibility) == FlagPublic;
        -:  726:  }
        -:  727:  bool isForwardDecl() const { return getFlags() & FlagFwdDecl; }
        -:  728:  bool isAppleBlockExtension() const { return getFlags() & FlagAppleBlock; }
        -:  729:  bool isVirtual() const { return getFlags() & FlagVirtual; }
        -:  730:  bool isArtificial() const { return getFlags() & FlagArtificial; }
        -:  731:  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }
        -:  732:  bool isObjcClassComplete() const {
        -:  733:    return getFlags() & FlagObjcClassComplete;
        -:  734:  }
        -:  735:  bool isVector() const { return getFlags() & FlagVector; }
        -:  736:  bool isBitField() const { return getFlags() & FlagBitField; }
        -:  737:  bool isStaticMember() const { return getFlags() & FlagStaticMember; }
        -:  738:  bool isLValueReference() const { return getFlags() & FlagLValueReference; }
        -:  739:  bool isRValueReference() const { return getFlags() & FlagRValueReference; }
        -:  740:  bool isTypePassByValue() const { return getFlags() & FlagTypePassByValue; }
        -:  741:  bool isTypePassByReference() const {
        -:  742:    return getFlags() & FlagTypePassByReference;
        -:  743:  }
        -:  744:  bool isBigEndian() const { return getFlags() & FlagBigEndian; }
        -:  745:  bool isLittleEndian() const { return getFlags() & FlagLittleEndian; }
        -:  746:  bool getExportSymbols() const { return getFlags() & FlagExportSymbols; }
        -:  747:
        -:  748:  static bool classof(const Metadata *MD) {
        -:  749:    switch (MD->getMetadataID()) {
        -:  750:    default:
        -:  751:      return false;
        -:  752:    case DIBasicTypeKind:
        -:  753:    case DIStringTypeKind:
        -:  754:    case DIDerivedTypeKind:
        -:  755:    case DICompositeTypeKind:
        -:  756:    case DISubroutineTypeKind:
        -:  757:      return true;
        -:  758:    }
        -:  759:  }
        -:  760:};
        -:  761:
        -:  762:/// Basic type, like 'int' or 'float'.
        -:  763:///
        -:  764:/// TODO: Split out DW_TAG_unspecified_type.
        -:  765:/// TODO: Drop unused accessors.
        -:  766:class DIBasicType : public DIType {
        -:  767:  friend class LLVMContextImpl;
        -:  768:  friend class MDNode;
        -:  769:
        -:  770:  unsigned Encoding;
        -:  771:
        -:  772:  DIBasicType(LLVMContext &C, StorageType Storage, unsigned Tag,
        -:  773:              uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,
        -:  774:              DIFlags Flags, ArrayRef<Metadata *> Ops)
        -:  775:      : DIType(C, DIBasicTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,
        -:  776:               Flags, Ops),
        -:  777:        Encoding(Encoding) {}
        -:  778:  ~DIBasicType() = default;
        -:  779:
        -:  780:  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,
        -:  781:                              StringRef Name, uint64_t SizeInBits,
        -:  782:                              uint32_t AlignInBits, unsigned Encoding,
        -:  783:                              DIFlags Flags, StorageType Storage,
        -:  784:                              bool ShouldCreate = true) {
        -:  785:    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),
        -:  786:                   SizeInBits, AlignInBits, Encoding, Flags, Storage,
        -:  787:                   ShouldCreate);
        -:  788:  }
        -:  789:  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,
        -:  790:                              MDString *Name, uint64_t SizeInBits,
        -:  791:                              uint32_t AlignInBits, unsigned Encoding,
        -:  792:                              DIFlags Flags, StorageType Storage,
        -:  793:                              bool ShouldCreate = true);
        -:  794:
        -:  795:  TempDIBasicType cloneImpl() const {
        -:  796:    return getTemporary(getContext(), getTag(), getName(), getSizeInBits(),
        -:  797:                        getAlignInBits(), getEncoding(), getFlags());
        -:  798:  }
        -:  799:
        -:  800:public:
        -:  801:  DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),
        -:  802:                    (Tag, Name, 0, 0, 0, FlagZero))
        -:  803:  DEFINE_MDNODE_GET(DIBasicType,
        -:  804:                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),
        -:  805:                    (Tag, Name, SizeInBits, 0, 0, FlagZero))
        -:  806:  DEFINE_MDNODE_GET(DIBasicType,
        -:  807:                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),
        -:  808:                    (Tag, Name, SizeInBits, 0, 0, FlagZero))
        -:  809:  DEFINE_MDNODE_GET(DIBasicType,
        -:  810:                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,
        -:  811:                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),
        -:  812:                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))
        -:  813:  DEFINE_MDNODE_GET(DIBasicType,
        -:  814:                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,
        -:  815:                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),
        -:  816:                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))
        -:  817:
        -:  818:  TempDIBasicType clone() const { return cloneImpl(); }
        -:  819:
        -:  820:  unsigned getEncoding() const { return Encoding; }
        -:  821:
        -:  822:  enum class Signedness { Signed, Unsigned };
        -:  823:
        -:  824:  /// Return the signedness of this type, or None if this type is neither
        -:  825:  /// signed nor unsigned.
        -:  826:  Optional<Signedness> getSignedness() const;
        -:  827:
        -:  828:  static bool classof(const Metadata *MD) {
        -:  829:    return MD->getMetadataID() == DIBasicTypeKind;
        -:  830:  }
        -:  831:};
        -:  832:
        -:  833:/// String type, Fortran CHARACTER(n)
        -:  834:class DIStringType : public DIType {
        -:  835:  friend class LLVMContextImpl;
        -:  836:  friend class MDNode;
        -:  837:
        -:  838:  unsigned Encoding;
        -:  839:
        -:  840:  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,
        -:  841:               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,
        -:  842:               ArrayRef<Metadata *> Ops)
        -:  843:      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,
        -:  844:               FlagZero, Ops),
        -:  845:        Encoding(Encoding) {}
        -:  846:  ~DIStringType() = default;
        -:  847:
        -:  848:  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,
        -:  849:                               StringRef Name, Metadata *StringLength,
        -:  850:                               Metadata *StrLenExp, Metadata *StrLocationExp,
        -:  851:                               uint64_t SizeInBits, uint32_t AlignInBits,
        -:  852:                               unsigned Encoding, StorageType Storage,
        -:  853:                               bool ShouldCreate = true) {
        -:  854:    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),
        -:  855:                   StringLength, StrLenExp, StrLocationExp, SizeInBits,
        -:  856:                   AlignInBits, Encoding, Storage, ShouldCreate);
        -:  857:  }
        -:  858:  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,
        -:  859:                               MDString *Name, Metadata *StringLength,
        -:  860:                               Metadata *StrLenExp, Metadata *StrLocationExp,
        -:  861:                               uint64_t SizeInBits, uint32_t AlignInBits,
        -:  862:                               unsigned Encoding, StorageType Storage,
        -:  863:                               bool ShouldCreate = true);
        -:  864:
        -:  865:  TempDIStringType cloneImpl() const {
        -:  866:    return getTemporary(getContext(), getTag(), getRawName(),
        -:  867:                        getRawStringLength(), getRawStringLengthExp(),
        -:  868:                        getRawStringLocationExp(), getSizeInBits(),
        -:  869:                        getAlignInBits(), getEncoding());
        -:  870:  }
        -:  871:
        -:  872:public:
        -:  873:  DEFINE_MDNODE_GET(DIStringType,
        -:  874:                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,
        -:  875:                     uint32_t AlignInBits),
        -:  876:                    (Tag, Name, nullptr, nullptr, nullptr, SizeInBits,
        -:  877:                     AlignInBits, 0))
        -:  878:  DEFINE_MDNODE_GET(DIStringType,
        -:  879:                    (unsigned Tag, MDString *Name, Metadata *StringLength,
        -:  880:                     Metadata *StringLengthExp, Metadata *StringLocationExp,
        -:  881:                     uint64_t SizeInBits, uint32_t AlignInBits,
        -:  882:                     unsigned Encoding),
        -:  883:                    (Tag, Name, StringLength, StringLengthExp,
        -:  884:                     StringLocationExp, SizeInBits, AlignInBits, Encoding))
        -:  885:  DEFINE_MDNODE_GET(DIStringType,
        -:  886:                    (unsigned Tag, StringRef Name, Metadata *StringLength,
        -:  887:                     Metadata *StringLengthExp, Metadata *StringLocationExp,
        -:  888:                     uint64_t SizeInBits, uint32_t AlignInBits,
        -:  889:                     unsigned Encoding),
        -:  890:                    (Tag, Name, StringLength, StringLengthExp,
        -:  891:                     StringLocationExp, SizeInBits, AlignInBits, Encoding))
        -:  892:
        -:  893:  TempDIStringType clone() const { return cloneImpl(); }
        -:  894:
        -:  895:  static bool classof(const Metadata *MD) {
        -:  896:    return MD->getMetadataID() == DIStringTypeKind;
        -:  897:  }
        -:  898:
        -:  899:  DIVariable *getStringLength() const {
        -:  900:    return cast_or_null<DIVariable>(getRawStringLength());
        -:  901:  }
        -:  902:
        -:  903:  DIExpression *getStringLengthExp() const {
        -:  904:    return cast_or_null<DIExpression>(getRawStringLengthExp());
        -:  905:  }
        -:  906:
        -:  907:  DIExpression *getStringLocationExp() const {
        -:  908:    return cast_or_null<DIExpression>(getRawStringLocationExp());
        -:  909:  }
        -:  910:
        -:  911:  unsigned getEncoding() const { return Encoding; }
        -:  912:
        -:  913:  Metadata *getRawStringLength() const { return getOperand(3); }
        -:  914:
        -:  915:  Metadata *getRawStringLengthExp() const { return getOperand(4); }
        -:  916:
        -:  917:  Metadata *getRawStringLocationExp() const { return getOperand(5); }
        -:  918:};
        -:  919:
        -:  920:/// Derived types.
        -:  921:///
        -:  922:/// This includes qualified types, pointers, references, friends, typedefs, and
        -:  923:/// class members.
        -:  924:///
        -:  925:/// TODO: Split out members (inheritance, fields, methods, etc.).
        -:  926:class DIDerivedType : public DIType {
        -:  927:  friend class LLVMContextImpl;
        -:  928:  friend class MDNode;
        -:  929:
        -:  930:  /// The DWARF address space of the memory pointed to or referenced by a
        -:  931:  /// pointer or reference type respectively.
        -:  932:  Optional<unsigned> DWARFAddressSpace;
        -:  933:
        -:  934:  DIDerivedType(LLVMContext &C, StorageType Storage, unsigned Tag,
        -:  935:                unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,
        -:  936:                uint64_t OffsetInBits, Optional<unsigned> DWARFAddressSpace,
        -:  937:                DIFlags Flags, ArrayRef<Metadata *> Ops)
        -:  938:      : DIType(C, DIDerivedTypeKind, Storage, Tag, Line, SizeInBits,
        -:  939:               AlignInBits, OffsetInBits, Flags, Ops),
        -:  940:        DWARFAddressSpace(DWARFAddressSpace) {}
        -:  941:  ~DIDerivedType() = default;
        -:  942:
        -:  943:  static DIDerivedType *
        -:  944:  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, DIFile *File,
        -:  945:          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,
        -:  946:          uint32_t AlignInBits, uint64_t OffsetInBits,
        -:  947:          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,
        -:  948:          Metadata *ExtraData, DINodeArray Annotations, StorageType Storage,
        -:  949:          bool ShouldCreate = true) {
        -:  950:    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), File,
        -:  951:                   Line, Scope, BaseType, SizeInBits, AlignInBits, OffsetInBits,
        -:  952:                   DWARFAddressSpace, Flags, ExtraData, Annotations.get(),
        -:  953:                   Storage, ShouldCreate);
        -:  954:  }
        -:  955:  static DIDerivedType *
        -:  956:  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,
        -:  957:          unsigned Line, Metadata *Scope, Metadata *BaseType,
        -:  958:          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,
        -:  959:          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,
        -:  960:          Metadata *ExtraData, Metadata *Annotations, StorageType Storage,
        -:  961:          bool ShouldCreate = true);
        -:  962:
        -:  963:  TempDIDerivedType cloneImpl() const {
        -:  964:    return getTemporary(
        -:  965:        getContext(), getTag(), getName(), getFile(), getLine(), getScope(),
        -:  966:        getBaseType(), getSizeInBits(), getAlignInBits(), getOffsetInBits(),
        -:  967:        getDWARFAddressSpace(), getFlags(), getExtraData(), getAnnotations());
        -:  968:  }
        -:  969:
        -:  970:public:
        -:  971:  DEFINE_MDNODE_GET(
        -:  972:      DIDerivedType,
        -:  973:      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,
        -:  974:       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,
        -:  975:       uint32_t AlignInBits, uint64_t OffsetInBits,
        -:  976:       Optional<unsigned> DWARFAddressSpace, DIFlags Flags,
        -:  977:       Metadata *ExtraData = nullptr, Metadata *Annotations = nullptr),
        -:  978:      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,
        -:  979:       OffsetInBits, DWARFAddressSpace, Flags, ExtraData, Annotations))
        -:  980:  DEFINE_MDNODE_GET(DIDerivedType,
        -:  981:                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,
        -:  982:                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,
        -:  983:                     uint32_t AlignInBits, uint64_t OffsetInBits,
        -:  984:                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,
        -:  985:                     Metadata *ExtraData = nullptr,
        -:  986:                     DINodeArray Annotations = nullptr),
        -:  987:                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,
        -:  988:                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,
        -:  989:                     ExtraData, Annotations))
        -:  990:
        -:  991:  TempDIDerivedType clone() const { return cloneImpl(); }
        -:  992:
        -:  993:  /// Get the base type this is derived from.
        -:  994:  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }
        -:  995:  Metadata *getRawBaseType() const { return getOperand(3); }
        -:  996:
        -:  997:  /// \returns The DWARF address space of the memory pointed to or referenced by
        -:  998:  /// a pointer or reference type respectively.
        -:  999:  Optional<unsigned> getDWARFAddressSpace() const { return DWARFAddressSpace; }
        -: 1000:
        -: 1001:  /// Get extra data associated with this derived type.
        -: 1002:  ///
        -: 1003:  /// Class type for pointer-to-members, objective-c property node for ivars,
        -: 1004:  /// global constant wrapper for static members, or virtual base pointer offset
        -: 1005:  /// for inheritance.
        -: 1006:  ///
        -: 1007:  /// TODO: Separate out types that need this extra operand: pointer-to-member
        -: 1008:  /// types and member fields (static members and ivars).
        -: 1009:  Metadata *getExtraData() const { return getRawExtraData(); }
        -: 1010:  Metadata *getRawExtraData() const { return getOperand(4); }
        -: 1011:
        -: 1012:  /// Get annotations associated with this derived type.
        -: 1013:  DINodeArray getAnnotations() const {
        -: 1014:    return cast_or_null<MDTuple>(getRawAnnotations());
        -: 1015:  }
        -: 1016:  Metadata *getRawAnnotations() const { return getOperand(5); }
        -: 1017:
        -: 1018:  /// Get casted version of extra data.
        -: 1019:  /// @{
        -: 1020:  DIType *getClassType() const;
        -: 1021:
        -: 1022:  DIObjCProperty *getObjCProperty() const {
        -: 1023:    return dyn_cast_or_null<DIObjCProperty>(getExtraData());
        -: 1024:  }
        -: 1025:
        -: 1026:  uint32_t getVBPtrOffset() const;
        -: 1027:
        -: 1028:  Constant *getStorageOffsetInBits() const;
        -: 1029:
        -: 1030:  Constant *getConstant() const;
        -: 1031:
        -: 1032:  Constant *getDiscriminantValue() const;
        -: 1033:  /// @}
        -: 1034:
        -: 1035:  static bool classof(const Metadata *MD) {
        -: 1036:    return MD->getMetadataID() == DIDerivedTypeKind;
        -: 1037:  }
        -: 1038:};
        -: 1039:
        -: 1040:/// Composite types.
        -: 1041:///
        -: 1042:/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).
        -: 1043:/// TODO: Create a custom, unrelated node for DW_TAG_array_type.
        -: 1044:class DICompositeType : public DIType {
        -: 1045:  friend class LLVMContextImpl;
        -: 1046:  friend class MDNode;
        -: 1047:
        -: 1048:  unsigned RuntimeLang;
        -: 1049:
        -: 1050:  DICompositeType(LLVMContext &C, StorageType Storage, unsigned Tag,
        -: 1051:                  unsigned Line, unsigned RuntimeLang, uint64_t SizeInBits,
        -: 1052:                  uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,
        -: 1053:                  ArrayRef<Metadata *> Ops)
        -: 1054:      : DIType(C, DICompositeTypeKind, Storage, Tag, Line, SizeInBits,
        -: 1055:               AlignInBits, OffsetInBits, Flags, Ops),
        -: 1056:        RuntimeLang(RuntimeLang) {}
        -: 1057:  ~DICompositeType() = default;
        -: 1058:
        -: 1059:  /// Change fields in place.
        -: 1060:  void mutate(unsigned Tag, unsigned Line, unsigned RuntimeLang,
        -: 1061:              uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,
        -: 1062:              DIFlags Flags) {
        -: 1063:    assert(isDistinct() && "Only distinct nodes can mutate");
        -: 1064:    assert(getRawIdentifier() && "Only ODR-uniqued nodes should mutate");
        -: 1065:    this->RuntimeLang = RuntimeLang;
        -: 1066:    DIType::mutate(Tag, Line, SizeInBits, AlignInBits, OffsetInBits, Flags);
        -: 1067:  }
        -: 1068:
        -: 1069:  static DICompositeType *
        -: 1070:  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,
        -: 1071:          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,
        -: 1072:          uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,
        -: 1073:          DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,
        -: 1074:          DITemplateParameterArray TemplateParams, StringRef Identifier,
        -: 1075:          DIDerivedType *Discriminator, Metadata *DataLocation,
        -: 1076:          Metadata *Associated, Metadata *Allocated, Metadata *Rank,
        -: 1077:          DINodeArray Annotations, StorageType Storage,
        -: 1078:          bool ShouldCreate = true) {
        -: 1079:    return getImpl(
        -: 1080:        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,
        -: 1081:        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),
        -: 1082:        RuntimeLang, VTableHolder, TemplateParams.get(),
        -: 1083:        getCanonicalMDString(Context, Identifier), Discriminator, DataLocation,
        -: 1084:        Associated, Allocated, Rank, Annotations.get(), Storage, ShouldCreate);
        -: 1085:  }
        -: 1086:  static DICompositeType *
        -: 1087:  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,
        -: 1088:          unsigned Line, Metadata *Scope, Metadata *BaseType,
        -: 1089:          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,
        -: 1090:          DIFlags Flags, Metadata *Elements, unsigned RuntimeLang,
        -: 1091:          Metadata *VTableHolder, Metadata *TemplateParams,
        -: 1092:          MDString *Identifier, Metadata *Discriminator, Metadata *DataLocation,
        -: 1093:          Metadata *Associated, Metadata *Allocated, Metadata *Rank,
        -: 1094:          Metadata *Annotations, StorageType Storage, bool ShouldCreate = true);
        -: 1095:
        -: 1096:  TempDICompositeType cloneImpl() const {
        -: 1097:    return getTemporary(
        -: 1098:        getContext(), getTag(), getName(), getFile(), getLine(), getScope(),
        -: 1099:        getBaseType(), getSizeInBits(), getAlignInBits(), getOffsetInBits(),
        -: 1100:        getFlags(), getElements(), getRuntimeLang(), getVTableHolder(),
        -: 1101:        getTemplateParams(), getIdentifier(), getDiscriminator(),
        -: 1102:        getRawDataLocation(), getRawAssociated(), getRawAllocated(),
        -: 1103:        getRawRank(), getAnnotations());
        -: 1104:  }
        -: 1105:
        -: 1106:public:
        -: 1107:  DEFINE_MDNODE_GET(
        -: 1108:      DICompositeType,
        -: 1109:      (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,
        -: 1110:       DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,
        -: 1111:       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,
        -: 1112:       DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,
        -: 1113:       DITemplateParameterArray TemplateParams = nullptr,
        -: 1114:       StringRef Identifier = "", DIDerivedType *Discriminator = nullptr,
        -: 1115:       Metadata *DataLocation = nullptr, Metadata *Associated = nullptr,
        -: 1116:       Metadata *Allocated = nullptr, Metadata *Rank = nullptr,
        -: 1117:       DINodeArray Annotations = nullptr),
        -: 1118:      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,
        -: 1119:       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,
        -: 1120:       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank,
        -: 1121:       Annotations))
        -: 1122:  DEFINE_MDNODE_GET(
        -: 1123:      DICompositeType,
        -: 1124:      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,
        -: 1125:       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,
        -: 1126:       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,
        -: 1127:       Metadata *Elements, unsigned RuntimeLang, Metadata *VTableHolder,
        -: 1128:       Metadata *TemplateParams = nullptr, MDString *Identifier = nullptr,
        -: 1129:       Metadata *Discriminator = nullptr, Metadata *DataLocation = nullptr,
        -: 1130:       Metadata *Associated = nullptr, Metadata *Allocated = nullptr,
        -: 1131:       Metadata *Rank = nullptr, Metadata *Annotations = nullptr),
        -: 1132:      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,
        -: 1133:       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,
        -: 1134:       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank,
        -: 1135:       Annotations))
        -: 1136:
        -: 1137:  TempDICompositeType clone() const { return cloneImpl(); }
        -: 1138:
        -: 1139:  /// Get a DICompositeType with the given ODR identifier.
        -: 1140:  ///
        -: 1141:  /// If \a LLVMContext::isODRUniquingDebugTypes(), gets the mapped
        -: 1142:  /// DICompositeType for the given ODR \c Identifier.  If none exists, creates
        -: 1143:  /// a new node.
        -: 1144:  ///
        -: 1145:  /// Else, returns \c nullptr.
        -: 1146:  static DICompositeType *
        -: 1147:  getODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,
        -: 1148:             MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,
        -: 1149:             Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,
        -: 1150:             uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,
        -: 1151:             unsigned RuntimeLang, Metadata *VTableHolder,
        -: 1152:             Metadata *TemplateParams, Metadata *Discriminator,
        -: 1153:             Metadata *DataLocation, Metadata *Associated, Metadata *Allocated,
        -: 1154:             Metadata *Rank, Metadata *Annotations);
        -: 1155:  static DICompositeType *getODRTypeIfExists(LLVMContext &Context,
        -: 1156:                                             MDString &Identifier);
        -: 1157:
        -: 1158:  /// Build a DICompositeType with the given ODR identifier.
        -: 1159:  ///
        -: 1160:  /// Looks up the mapped DICompositeType for the given ODR \c Identifier.  If
        -: 1161:  /// it doesn't exist, creates a new one.  If it does exist and \a
        -: 1162:  /// isForwardDecl(), and the new arguments would be a definition, mutates the
        -: 1163:  /// the type in place.  In either case, returns the type.
        -: 1164:  ///
        -: 1165:  /// If not \a LLVMContext::isODRUniquingDebugTypes(), this function returns
        -: 1166:  /// nullptr.
        -: 1167:  static DICompositeType *
        -: 1168:  buildODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,
        -: 1169:               MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,
        -: 1170:               Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,
        -: 1171:               uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,
        -: 1172:               unsigned RuntimeLang, Metadata *VTableHolder,
        -: 1173:               Metadata *TemplateParams, Metadata *Discriminator,
        -: 1174:               Metadata *DataLocation, Metadata *Associated,
        -: 1175:               Metadata *Allocated, Metadata *Rank, Metadata *Annotations);
        -: 1176:
        -: 1177:  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }
        -: 1178:  DINodeArray getElements() const {
        -: 1179:    return cast_or_null<MDTuple>(getRawElements());
        -: 1180:  }
        -: 1181:  DIType *getVTableHolder() const {
        -: 1182:    return cast_or_null<DIType>(getRawVTableHolder());
        -: 1183:  }
        -: 1184:  DITemplateParameterArray getTemplateParams() const {
        -: 1185:    return cast_or_null<MDTuple>(getRawTemplateParams());
        -: 1186:  }
        -: 1187:  StringRef getIdentifier() const { return getStringOperand(7); }
        -: 1188:  unsigned getRuntimeLang() const { return RuntimeLang; }
        -: 1189:
        -: 1190:  Metadata *getRawBaseType() const { return getOperand(3); }
        -: 1191:  Metadata *getRawElements() const { return getOperand(4); }
        -: 1192:  Metadata *getRawVTableHolder() const { return getOperand(5); }
        -: 1193:  Metadata *getRawTemplateParams() const { return getOperand(6); }
        -: 1194:  MDString *getRawIdentifier() const { return getOperandAs<MDString>(7); }
        -: 1195:  Metadata *getRawDiscriminator() const { return getOperand(8); }
        -: 1196:  DIDerivedType *getDiscriminator() const {
        -: 1197:    return getOperandAs<DIDerivedType>(8);
        -: 1198:  }
        -: 1199:  Metadata *getRawDataLocation() const { return getOperand(9); }
        -: 1200:  DIVariable *getDataLocation() const {
        -: 1201:    return dyn_cast_or_null<DIVariable>(getRawDataLocation());
        -: 1202:  }
        -: 1203:  DIExpression *getDataLocationExp() const {
        -: 1204:    return dyn_cast_or_null<DIExpression>(getRawDataLocation());
        -: 1205:  }
        -: 1206:  Metadata *getRawAssociated() const { return getOperand(10); }
        -: 1207:  DIVariable *getAssociated() const {
        -: 1208:    return dyn_cast_or_null<DIVariable>(getRawAssociated());
        -: 1209:  }
        -: 1210:  DIExpression *getAssociatedExp() const {
        -: 1211:    return dyn_cast_or_null<DIExpression>(getRawAssociated());
        -: 1212:  }
        -: 1213:  Metadata *getRawAllocated() const { return getOperand(11); }
        -: 1214:  DIVariable *getAllocated() const {
        -: 1215:    return dyn_cast_or_null<DIVariable>(getRawAllocated());
        -: 1216:  }
        -: 1217:  DIExpression *getAllocatedExp() const {
        -: 1218:    return dyn_cast_or_null<DIExpression>(getRawAllocated());
        -: 1219:  }
        -: 1220:  Metadata *getRawRank() const { return getOperand(12); }
        -: 1221:  ConstantInt *getRankConst() const {
        -: 1222:    if (auto *MD = dyn_cast_or_null<ConstantAsMetadata>(getRawRank()))
        -: 1223:      return dyn_cast_or_null<ConstantInt>(MD->getValue());
        -: 1224:    return nullptr;
        -: 1225:  }
        -: 1226:  DIExpression *getRankExp() const {
        -: 1227:    return dyn_cast_or_null<DIExpression>(getRawRank());
        -: 1228:  }
        -: 1229:
        -: 1230:  Metadata *getRawAnnotations() const { return getOperand(13); }
        -: 1231:  DINodeArray getAnnotations() const {
        -: 1232:    return cast_or_null<MDTuple>(getRawAnnotations());
        -: 1233:  }
        -: 1234:
        -: 1235:  /// Replace operands.
        -: 1236:  ///
        -: 1237:  /// If this \a isUniqued() and not \a isResolved(), on a uniquing collision
        -: 1238:  /// this will be RAUW'ed and deleted.  Use a \a TrackingMDRef to keep track
        -: 1239:  /// of its movement if necessary.
        -: 1240:  /// @{
        -: 1241:  void replaceElements(DINodeArray Elements) {
        -: 1242:#ifndef NDEBUG
        -: 1243:    for (DINode *Op : getElements())
        -: 1244:      assert(is_contained(Elements->operands(), Op) &&
        -: 1245:             "Lost a member during member list replacement");
        -: 1246:#endif
        -: 1247:    replaceOperandWith(4, Elements.get());
        -: 1248:  }
        -: 1249:
        -: 1250:  void replaceVTableHolder(DIType *VTableHolder) {
        -: 1251:    replaceOperandWith(5, VTableHolder);
        -: 1252:  }
        -: 1253:
        -: 1254:  void replaceTemplateParams(DITemplateParameterArray TemplateParams) {
        -: 1255:    replaceOperandWith(6, TemplateParams.get());
        -: 1256:  }
        -: 1257:  /// @}
        -: 1258:
        -: 1259:  static bool classof(const Metadata *MD) {
        -: 1260:    return MD->getMetadataID() == DICompositeTypeKind;
        -: 1261:  }
        -: 1262:};
        -: 1263:
        -: 1264:/// Type array for a subprogram.
        -: 1265:///
        -: 1266:/// TODO: Fold the array of types in directly as operands.
        -: 1267:class DISubroutineType : public DIType {
        -: 1268:  friend class LLVMContextImpl;
        -: 1269:  friend class MDNode;
        -: 1270:
        -: 1271:  /// The calling convention used with DW_AT_calling_convention. Actually of
        -: 1272:  /// type dwarf::CallingConvention.
        -: 1273:  uint8_t CC;
        -: 1274:
        -: 1275:  DISubroutineType(LLVMContext &C, StorageType Storage, DIFlags Flags,
        -: 1276:                   uint8_t CC, ArrayRef<Metadata *> Ops);
        -: 1277:  ~DISubroutineType() = default;
        -: 1278:
        -: 1279:  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,
        -: 1280:                                   uint8_t CC, DITypeRefArray TypeArray,
        -: 1281:                                   StorageType Storage,
        -: 1282:                                   bool ShouldCreate = true) {
        -: 1283:    return getImpl(Context, Flags, CC, TypeArray.get(), Storage, ShouldCreate);
        -: 1284:  }
        -: 1285:  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,
        -: 1286:                                   uint8_t CC, Metadata *TypeArray,
        -: 1287:                                   StorageType Storage,
        -: 1288:                                   bool ShouldCreate = true);
        -: 1289:
        -: 1290:  TempDISubroutineType cloneImpl() const {
        -: 1291:    return getTemporary(getContext(), getFlags(), getCC(), getTypeArray());
        -: 1292:  }
        -: 1293:
        -: 1294:public:
        -: 1295:  DEFINE_MDNODE_GET(DISubroutineType,
        -: 1296:                    (DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray),
        -: 1297:                    (Flags, CC, TypeArray))
        -: 1298:  DEFINE_MDNODE_GET(DISubroutineType,
        -: 1299:                    (DIFlags Flags, uint8_t CC, Metadata *TypeArray),
        -: 1300:                    (Flags, CC, TypeArray))
        -: 1301:
        -: 1302:  TempDISubroutineType clone() const { return cloneImpl(); }
        -: 1303:  // Returns a new temporary DISubroutineType with updated CC
        -: 1304:  TempDISubroutineType cloneWithCC(uint8_t CC) const {
        -: 1305:    auto NewTy = clone();
        -: 1306:    NewTy->CC = CC;
        -: 1307:    return NewTy;
        -: 1308:  }
        -: 1309:
        -: 1310:  uint8_t getCC() const { return CC; }
        -: 1311:
        -: 1312:  DITypeRefArray getTypeArray() const {
        -: 1313:    return cast_or_null<MDTuple>(getRawTypeArray());
        -: 1314:  }
        -: 1315:
        -: 1316:  Metadata *getRawTypeArray() const { return getOperand(3); }
        -: 1317:
        -: 1318:  static bool classof(const Metadata *MD) {
        -: 1319:    return MD->getMetadataID() == DISubroutineTypeKind;
        -: 1320:  }
        -: 1321:};
        -: 1322:
        -: 1323:/// Compile unit.
        -: 1324:class DICompileUnit : public DIScope {
        -: 1325:  friend class LLVMContextImpl;
        -: 1326:  friend class MDNode;
        -: 1327:
        -: 1328:public:
        -: 1329:  enum DebugEmissionKind : unsigned {
        -: 1330:    NoDebug = 0,
        -: 1331:    FullDebug,
        -: 1332:    LineTablesOnly,
        -: 1333:    DebugDirectivesOnly,
        -: 1334:    LastEmissionKind = DebugDirectivesOnly
        -: 1335:  };
        -: 1336:
        -: 1337:  enum class DebugNameTableKind : unsigned {
        -: 1338:    Default = 0,
        -: 1339:    GNU = 1,
        -: 1340:    None = 2,
        -: 1341:    LastDebugNameTableKind = None
        -: 1342:  };
        -: 1343:
        -: 1344:  static Optional<DebugEmissionKind> getEmissionKind(StringRef Str);
        -: 1345:  static const char *emissionKindString(DebugEmissionKind EK);
        -: 1346:  static Optional<DebugNameTableKind> getNameTableKind(StringRef Str);
        -: 1347:  static const char *nameTableKindString(DebugNameTableKind PK);
        -: 1348:
        -: 1349:private:
        -: 1350:  unsigned SourceLanguage;
        -: 1351:  bool IsOptimized;
        -: 1352:  unsigned RuntimeVersion;
        -: 1353:  unsigned EmissionKind;
        -: 1354:  uint64_t DWOId;
        -: 1355:  bool SplitDebugInlining;
        -: 1356:  bool DebugInfoForProfiling;
        -: 1357:  unsigned NameTableKind;
        -: 1358:  bool RangesBaseAddress;
        -: 1359:
        -: 1360:  DICompileUnit(LLVMContext &C, StorageType Storage, unsigned SourceLanguage,
        -: 1361:                bool IsOptimized, unsigned RuntimeVersion,
        -: 1362:                unsigned EmissionKind, uint64_t DWOId, bool SplitDebugInlining,
        -: 1363:                bool DebugInfoForProfiling, unsigned NameTableKind,
        -: 1364:                bool RangesBaseAddress, ArrayRef<Metadata *> Ops);
        -: 1365:  ~DICompileUnit() = default;
        -: 1366:
        -: 1367:  static DICompileUnit *
        -: 1368:  getImpl(LLVMContext &Context, unsigned SourceLanguage, DIFile *File,
        -: 1369:          StringRef Producer, bool IsOptimized, StringRef Flags,
        -: 1370:          unsigned RuntimeVersion, StringRef SplitDebugFilename,
        -: 1371:          unsigned EmissionKind, DICompositeTypeArray EnumTypes,
        -: 1372:          DIScopeArray RetainedTypes,
        -: 1373:          DIGlobalVariableExpressionArray GlobalVariables,
        -: 1374:          DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,
        -: 1375:          uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,
        -: 1376:          unsigned NameTableKind, bool RangesBaseAddress, StringRef SysRoot,
        -: 1377:          StringRef SDK, StorageType Storage, bool ShouldCreate = true) {
        -: 1378:    return getImpl(
        -: 1379:        Context, SourceLanguage, File, getCanonicalMDString(Context, Producer),
        -: 1380:        IsOptimized, getCanonicalMDString(Context, Flags), RuntimeVersion,
        -: 1381:        getCanonicalMDString(Context, SplitDebugFilename), EmissionKind,
        -: 1382:        EnumTypes.get(), RetainedTypes.get(), GlobalVariables.get(),
        -: 1383:        ImportedEntities.get(), Macros.get(), DWOId, SplitDebugInlining,
        -: 1384:        DebugInfoForProfiling, NameTableKind, RangesBaseAddress,
        -: 1385:        getCanonicalMDString(Context, SysRoot),
        -: 1386:        getCanonicalMDString(Context, SDK), Storage, ShouldCreate);
        -: 1387:  }
        -: 1388:  static DICompileUnit *
        -: 1389:  getImpl(LLVMContext &Context, unsigned SourceLanguage, Metadata *File,
        -: 1390:          MDString *Producer, bool IsOptimized, MDString *Flags,
        -: 1391:          unsigned RuntimeVersion, MDString *SplitDebugFilename,
        -: 1392:          unsigned EmissionKind, Metadata *EnumTypes, Metadata *RetainedTypes,
        -: 1393:          Metadata *GlobalVariables, Metadata *ImportedEntities,
        -: 1394:          Metadata *Macros, uint64_t DWOId, bool SplitDebugInlining,
        -: 1395:          bool DebugInfoForProfiling, unsigned NameTableKind,
        -: 1396:          bool RangesBaseAddress, MDString *SysRoot, MDString *SDK,
        -: 1397:          StorageType Storage, bool ShouldCreate = true);
        -: 1398:
        -: 1399:  TempDICompileUnit cloneImpl() const {
        -: 1400:    return getTemporary(
        -: 1401:        getContext(), getSourceLanguage(), getFile(), getProducer(),
        -: 1402:        isOptimized(), getFlags(), getRuntimeVersion(), getSplitDebugFilename(),
        -: 1403:        getEmissionKind(), getEnumTypes(), getRetainedTypes(),
        -: 1404:        getGlobalVariables(), getImportedEntities(), getMacros(), DWOId,
        -: 1405:        getSplitDebugInlining(), getDebugInfoForProfiling(), getNameTableKind(),
        -: 1406:        getRangesBaseAddress(), getSysRoot(), getSDK());
        -: 1407:  }
        -: 1408:
        -: 1409:public:
        -: 1410:  static void get() = delete;
        -: 1411:  static void getIfExists() = delete;
        -: 1412:
        -: 1413:  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(
        -: 1414:      DICompileUnit,
        -: 1415:      (unsigned SourceLanguage, DIFile *File, StringRef Producer,
        -: 1416:       bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,
        -: 1417:       StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,
        -: 1418:       DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,
        -: 1419:       DIGlobalVariableExpressionArray GlobalVariables,
        -: 1420:       DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,
        -: 1421:       uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,
        -: 1422:       DebugNameTableKind NameTableKind, bool RangesBaseAddress,
        -: 1423:       StringRef SysRoot, StringRef SDK),
        -: 1424:      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,
        -: 1425:       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,
        -: 1426:       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,
        -: 1427:       DebugInfoForProfiling, (unsigned)NameTableKind, RangesBaseAddress,
        -: 1428:       SysRoot, SDK))
        -: 1429:  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(
        -: 1430:      DICompileUnit,
        -: 1431:      (unsigned SourceLanguage, Metadata *File, MDString *Producer,
        -: 1432:       bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,
        -: 1433:       MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,
        -: 1434:       Metadata *RetainedTypes, Metadata *GlobalVariables,
        -: 1435:       Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,
        -: 1436:       bool SplitDebugInlining, bool DebugInfoForProfiling,
        -: 1437:       unsigned NameTableKind, bool RangesBaseAddress, MDString *SysRoot,
        -: 1438:       MDString *SDK),
        -: 1439:      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,
        -: 1440:       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,
        -: 1441:       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,
        -: 1442:       DebugInfoForProfiling, NameTableKind, RangesBaseAddress, SysRoot, SDK))
        -: 1443:
        -: 1444:  TempDICompileUnit clone() const { return cloneImpl(); }
        -: 1445:
        -: 1446:  unsigned getSourceLanguage() const { return SourceLanguage; }
        -: 1447:  bool isOptimized() const { return IsOptimized; }
        -: 1448:  unsigned getRuntimeVersion() const { return RuntimeVersion; }
        -: 1449:  DebugEmissionKind getEmissionKind() const {
        -: 1450:    return (DebugEmissionKind)EmissionKind;
        -: 1451:  }
        -: 1452:  bool isDebugDirectivesOnly() const {
        -: 1453:    return EmissionKind == DebugDirectivesOnly;
        -: 1454:  }
        -: 1455:  bool getDebugInfoForProfiling() const { return DebugInfoForProfiling; }
        -: 1456:  DebugNameTableKind getNameTableKind() const {
        -: 1457:    return (DebugNameTableKind)NameTableKind;
        -: 1458:  }
        -: 1459:  bool getRangesBaseAddress() const { return RangesBaseAddress; }
        -: 1460:  StringRef getProducer() const { return getStringOperand(1); }
        -: 1461:  StringRef getFlags() const { return getStringOperand(2); }
        -: 1462:  StringRef getSplitDebugFilename() const { return getStringOperand(3); }
        -: 1463:  DICompositeTypeArray getEnumTypes() const {
        -: 1464:    return cast_or_null<MDTuple>(getRawEnumTypes());
        -: 1465:  }
        -: 1466:  DIScopeArray getRetainedTypes() const {
        -: 1467:    return cast_or_null<MDTuple>(getRawRetainedTypes());
        -: 1468:  }
        -: 1469:  DIGlobalVariableExpressionArray getGlobalVariables() const {
        -: 1470:    return cast_or_null<MDTuple>(getRawGlobalVariables());
        -: 1471:  }
        -: 1472:  DIImportedEntityArray getImportedEntities() const {
        -: 1473:    return cast_or_null<MDTuple>(getRawImportedEntities());
        -: 1474:  }
        -: 1475:  DIMacroNodeArray getMacros() const {
        -: 1476:    return cast_or_null<MDTuple>(getRawMacros());
        -: 1477:  }
        -: 1478:  uint64_t getDWOId() const { return DWOId; }
        -: 1479:  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }
        -: 1480:  bool getSplitDebugInlining() const { return SplitDebugInlining; }
        -: 1481:  void setSplitDebugInlining(bool SplitDebugInlining) {
        -: 1482:    this->SplitDebugInlining = SplitDebugInlining;
        -: 1483:  }
        -: 1484:  StringRef getSysRoot() const { return getStringOperand(9); }
        -: 1485:  StringRef getSDK() const { return getStringOperand(10); }
        -: 1486:
        -: 1487:  MDString *getRawProducer() const { return getOperandAs<MDString>(1); }
        -: 1488:  MDString *getRawFlags() const { return getOperandAs<MDString>(2); }
        -: 1489:  MDString *getRawSplitDebugFilename() const {
        -: 1490:    return getOperandAs<MDString>(3);
        -: 1491:  }
        -: 1492:  Metadata *getRawEnumTypes() const { return getOperand(4); }
        -: 1493:  Metadata *getRawRetainedTypes() const { return getOperand(5); }
        -: 1494:  Metadata *getRawGlobalVariables() const { return getOperand(6); }
        -: 1495:  Metadata *getRawImportedEntities() const { return getOperand(7); }
        -: 1496:  Metadata *getRawMacros() const { return getOperand(8); }
        -: 1497:  MDString *getRawSysRoot() const { return getOperandAs<MDString>(9); }
        -: 1498:  MDString *getRawSDK() const { return getOperandAs<MDString>(10); }
        -: 1499:
        -: 1500:  /// Replace arrays.
        -: 1501:  ///
        -: 1502:  /// If this \a isUniqued() and not \a isResolved(), it will be RAUW'ed and
        -: 1503:  /// deleted on a uniquing collision.  In practice, uniquing collisions on \a
        -: 1504:  /// DICompileUnit should be fairly rare.
        -: 1505:  /// @{
        -: 1506:  void replaceEnumTypes(DICompositeTypeArray N) {
        -: 1507:    replaceOperandWith(4, N.get());
        -: 1508:  }
        -: 1509:  void replaceRetainedTypes(DITypeArray N) { replaceOperandWith(5, N.get()); }
        -: 1510:  void replaceGlobalVariables(DIGlobalVariableExpressionArray N) {
        -: 1511:    replaceOperandWith(6, N.get());
        -: 1512:  }
        -: 1513:  void replaceImportedEntities(DIImportedEntityArray N) {
        -: 1514:    replaceOperandWith(7, N.get());
        -: 1515:  }
        -: 1516:  void replaceMacros(DIMacroNodeArray N) { replaceOperandWith(8, N.get()); }
        -: 1517:  /// @}
        -: 1518:
        -: 1519:  static bool classof(const Metadata *MD) {
        -: 1520:    return MD->getMetadataID() == DICompileUnitKind;
        -: 1521:  }
        -: 1522:};
        -: 1523:
        -: 1524:/// A scope for locals.
        -: 1525:///
        -: 1526:/// A legal scope for lexical blocks, local variables, and debug info
        -: 1527:/// locations.  Subclasses are \a DISubprogram, \a DILexicalBlock, and \a
        -: 1528:/// DILexicalBlockFile.
        -: 1529:class DILocalScope : public DIScope {
        -: 1530:protected:
        -: 1531:  DILocalScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,
        -: 1532:               ArrayRef<Metadata *> Ops)
        -: 1533:      : DIScope(C, ID, Storage, Tag, Ops) {}
        -: 1534:  ~DILocalScope() = default;
        -: 1535:
        -: 1536:public:
        -: 1537:  /// Get the subprogram for this scope.
        -: 1538:  ///
        -: 1539:  /// Return this if it's an \a DISubprogram; otherwise, look up the scope
        -: 1540:  /// chain.
        -: 1541:  DISubprogram *getSubprogram() const;
        -: 1542:
        -: 1543:  /// Get the first non DILexicalBlockFile scope of this scope.
        -: 1544:  ///
        -: 1545:  /// Return this if it's not a \a DILexicalBlockFIle; otherwise, look up the
        -: 1546:  /// scope chain.
        -: 1547:  DILocalScope *getNonLexicalBlockFileScope() const;
        -: 1548:
        -: 1549:  static bool classof(const Metadata *MD) {
        -: 1550:    return MD->getMetadataID() == DISubprogramKind ||
        -: 1551:           MD->getMetadataID() == DILexicalBlockKind ||
        -: 1552:           MD->getMetadataID() == DILexicalBlockFileKind;
        -: 1553:  }
        -: 1554:};
        -: 1555:
        -: 1556:/// Debug location.
        -: 1557:///
        -: 1558:/// A debug location in source code, used for debug info and otherwise.
        -: 1559:class DILocation : public MDNode {
        -: 1560:  friend class LLVMContextImpl;
        -: 1561:  friend class MDNode;
        -: 1562:
        -: 1563:  DILocation(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 1564:             unsigned Column, ArrayRef<Metadata *> MDs, bool ImplicitCode);
        -: 1565:  ~DILocation() { dropAllReferences(); }
        -: 1566:
        -: 1567:  static DILocation *getImpl(LLVMContext &Context, unsigned Line,
        -: 1568:                             unsigned Column, Metadata *Scope,
        -: 1569:                             Metadata *InlinedAt, bool ImplicitCode,
        -: 1570:                             StorageType Storage, bool ShouldCreate = true);
        -: 1571:  static DILocation *getImpl(LLVMContext &Context, unsigned Line,
        -: 1572:                             unsigned Column, DILocalScope *Scope,
        -: 1573:                             DILocation *InlinedAt, bool ImplicitCode,
        -: 1574:                             StorageType Storage, bool ShouldCreate = true) {
        -: 1575:    return getImpl(Context, Line, Column, static_cast<Metadata *>(Scope),
        -: 1576:                   static_cast<Metadata *>(InlinedAt), ImplicitCode, Storage,
        -: 1577:                   ShouldCreate);
        -: 1578:  }
        -: 1579:
        -: 1580:  TempDILocation cloneImpl() const {
        -: 1581:    // Get the raw scope/inlinedAt since it is possible to invoke this on
        -: 1582:    // a DILocation containing temporary metadata.
        -: 1583:    return getTemporary(getContext(), getLine(), getColumn(), getRawScope(),
        -: 1584:                        getRawInlinedAt(), isImplicitCode());
        -: 1585:  }
        -: 1586:
        -: 1587:public:
        -: 1588:  // Disallow replacing operands.
        -: 1589:  void replaceOperandWith(unsigned I, Metadata *New) = delete;
        -: 1590:
        -: 1591:  DEFINE_MDNODE_GET(DILocation,
        -: 1592:                    (unsigned Line, unsigned Column, Metadata *Scope,
        -: 1593:                     Metadata *InlinedAt = nullptr, bool ImplicitCode = false),
        -: 1594:                    (Line, Column, Scope, InlinedAt, ImplicitCode))
        -: 1595:  DEFINE_MDNODE_GET(DILocation,
        -: 1596:                    (unsigned Line, unsigned Column, DILocalScope *Scope,
        -: 1597:                     DILocation *InlinedAt = nullptr,
        -: 1598:                     bool ImplicitCode = false),
        -: 1599:                    (Line, Column, Scope, InlinedAt, ImplicitCode))
        -: 1600:
        -: 1601:  /// Return a (temporary) clone of this.
        -: 1602:  TempDILocation clone() const { return cloneImpl(); }
        -: 1603:
        -: 1604:  unsigned getLine() const { return SubclassData32; }
        -: 1605:  unsigned getColumn() const { return SubclassData16; }
        -: 1606:  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }
        -: 1607:
        -: 1608:  DILocation *getInlinedAt() const {
        -: 1609:    return cast_or_null<DILocation>(getRawInlinedAt());
        -: 1610:  }
        -: 1611:
        -: 1612:  /// Check if the location corresponds to an implicit code.
        -: 1613:  /// When the ImplicitCode flag is true, it means that the Instruction
        -: 1614:  /// with this DILocation has been added by the front-end but it hasn't been
        -: 1615:  /// written explicitly by the user (e.g. cleanup stuff in C++ put on a closing
        -: 1616:  /// bracket). It's useful for code coverage to not show a counter on "empty"
        -: 1617:  /// lines.
        -: 1618:  bool isImplicitCode() const { return SubclassData1; }
        -: 1619:  void setImplicitCode(bool ImplicitCode) { SubclassData1 = ImplicitCode; }
        -: 1620:
        -: 1621:  DIFile *getFile() const { return getScope()->getFile(); }
        -: 1622:  StringRef getFilename() const { return getScope()->getFilename(); }
        -: 1623:  StringRef getDirectory() const { return getScope()->getDirectory(); }
        -: 1624:  Optional<StringRef> getSource() const { return getScope()->getSource(); }
        -: 1625:
        -: 1626:  /// Get the scope where this is inlined.
        -: 1627:  ///
        -: 1628:  /// Walk through \a getInlinedAt() and return \a getScope() from the deepest
        -: 1629:  /// location.
        -: 1630:  DILocalScope *getInlinedAtScope() const {
        -: 1631:    if (auto *IA = getInlinedAt())
        -: 1632:      return IA->getInlinedAtScope();
        -: 1633:    return getScope();
        -: 1634:  }
        -: 1635:
        -: 1636:  /// Get the DWARF discriminator.
        -: 1637:  ///
        -: 1638:  /// DWARF discriminators distinguish identical file locations between
        -: 1639:  /// instructions that are on different basic blocks.
        -: 1640:  ///
        -: 1641:  /// There are 3 components stored in discriminator, from lower bits:
        -: 1642:  ///
        -: 1643:  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs
        -: 1644:  ///                     that are defined by the same source line, but
        -: 1645:  ///                     different basic blocks.
        -: 1646:  /// Duplication factor: assigned by optimizations that will scale down
        -: 1647:  ///                     the execution frequency of the original IR.
        -: 1648:  /// Copy Identifier: assigned by optimizations that clones the IR.
        -: 1649:  ///                  Each copy of the IR will be assigned an identifier.
        -: 1650:  ///
        -: 1651:  /// Encoding:
        -: 1652:  ///
        -: 1653:  /// The above 3 components are encoded into a 32bit unsigned integer in
        -: 1654:  /// order. If the lowest bit is 1, the current component is empty, and the
        -: 1655:  /// next component will start in the next bit. Otherwise, the current
        -: 1656:  /// component is non-empty, and its content starts in the next bit. The
        -: 1657:  /// value of each components is either 5 bit or 12 bit: if the 7th bit
        -: 1658:  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the
        -: 1659:  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to
        -: 1660:  /// represent the component. Thus, the number of bits used for a component
        -: 1661:  /// is either 0 (if it and all the next components are empty); 1 - if it is
        -: 1662:  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both
        -: 1663:  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last
        -: 1664:  /// component is also capped at 0x1ff, even in the case when both first
        -: 1665:  /// components are 0, and we'd technically have 29 bits available.
        -: 1666:  ///
        -: 1667:  /// For precise control over the data being encoded in the discriminator,
        -: 1668:  /// use encodeDiscriminator/decodeDiscriminator.
        -: 1669:
        -: 1670:  inline unsigned getDiscriminator() const;
        -: 1671:
        -: 1672:  // For the regular discriminator, it stands for all empty components if all
        -: 1673:  // the lowest 3 bits are non-zero and all higher 29 bits are unused(zero by
        -: 1674:  // default). Here we fully leverage the higher 29 bits for pseudo probe use.
        -: 1675:  // This is the format:
        -: 1676:  // [2:0] - 0x7
        -: 1677:  // [31:3] - pseudo probe fields guaranteed to be non-zero as a whole
        -: 1678:  // So if the lower 3 bits is non-zero and the others has at least one
        -: 1679:  // non-zero bit, it guarantees to be a pseudo probe discriminator
        -: 1680:  inline static bool isPseudoProbeDiscriminator(unsigned Discriminator) {
        -: 1681:    return ((Discriminator & 0x7) == 0x7) && (Discriminator & 0xFFFFFFF8);
        -: 1682:  }
        -: 1683:
        -: 1684:  /// Returns a new DILocation with updated \p Discriminator.
        -: 1685:  inline const DILocation *cloneWithDiscriminator(unsigned Discriminator) const;
        -: 1686:
        -: 1687:  /// Returns a new DILocation with updated base discriminator \p BD. Only the
        -: 1688:  /// base discriminator is set in the new DILocation, the other encoded values
        -: 1689:  /// are elided.
        -: 1690:  /// If the discriminator cannot be encoded, the function returns None.
        -: 1691:  inline Optional<const DILocation *>
        -: 1692:  cloneWithBaseDiscriminator(unsigned BD) const;
        -: 1693:
        -: 1694:  /// Returns the duplication factor stored in the discriminator, or 1 if no
        -: 1695:  /// duplication factor (or 0) is encoded.
        -: 1696:  inline unsigned getDuplicationFactor() const;
        -: 1697:
        -: 1698:  /// Returns the copy identifier stored in the discriminator.
        -: 1699:  inline unsigned getCopyIdentifier() const;
        -: 1700:
        -: 1701:  /// Returns the base discriminator stored in the discriminator.
        -: 1702:  inline unsigned getBaseDiscriminator() const;
        -: 1703:
        -: 1704:  /// Returns a new DILocation with duplication factor \p DF * current
        -: 1705:  /// duplication factor encoded in the discriminator. The current duplication
        -: 1706:  /// factor is as defined by getDuplicationFactor().
        -: 1707:  /// Returns None if encoding failed.
        -: 1708:  inline Optional<const DILocation *>
        -: 1709:  cloneByMultiplyingDuplicationFactor(unsigned DF) const;
        -: 1710:
        -: 1711:  /// When two instructions are combined into a single instruction we also
        -: 1712:  /// need to combine the original locations into a single location.
        -: 1713:  /// When the locations are the same we can use either location.
        -: 1714:  /// When they differ, we need a third location which is distinct from either.
        -: 1715:  /// If they share a common scope, use this scope and compare the line/column
        -: 1716:  /// pair of the locations with the common scope:
        -: 1717:  /// * if both match, keep the line and column;
        -: 1718:  /// * if only the line number matches, keep the line and set the column as 0;
        -: 1719:  /// * otherwise set line and column as 0.
        -: 1720:  /// If they do not share a common scope the location is ambiguous and can't be
        -: 1721:  /// represented in a line entry. In this case, set line and column as 0 and
        -: 1722:  /// use the scope of any location.
        -: 1723:  ///
        -: 1724:  /// \p LocA \p LocB: The locations to be merged.
        -: 1725:  static const DILocation *getMergedLocation(const DILocation *LocA,
        -: 1726:                                             const DILocation *LocB);
        -: 1727:
        -: 1728:  /// Try to combine the vector of locations passed as input in a single one.
        -: 1729:  /// This function applies getMergedLocation() repeatedly left-to-right.
        -: 1730:  ///
        -: 1731:  /// \p Locs: The locations to be merged.
        -: 1732:  static const DILocation *
        -: 1733:  getMergedLocations(ArrayRef<const DILocation *> Locs);
        -: 1734:
        -: 1735:  /// Return the masked discriminator value for an input discrimnator value D
        -: 1736:  /// (i.e. zero out the (B+1)-th and above bits for D (B is 0-base).
        -: 1737:  // Example: an input of (0x1FF, 7) returns 0xFF.
        -: 1738:  static unsigned getMaskedDiscriminator(unsigned D, unsigned B) {
        -: 1739:    return (D & getN1Bits(B));
        -: 1740:  }
        -: 1741:
        -: 1742:  /// Return the bits used for base discriminators.
        -: 1743:  static unsigned getBaseDiscriminatorBits() { return getBaseFSBitEnd(); }
        -: 1744:
        -: 1745:  /// Returns the base discriminator for a given encoded discriminator \p D.
        -: 1746:  static unsigned
        -: 1747:  getBaseDiscriminatorFromDiscriminator(unsigned D,
        -: 1748:                                        bool IsFSDiscriminator = false) {
        -: 1749:    if (IsFSDiscriminator)
        -: 1750:      return getMaskedDiscriminator(D, getBaseDiscriminatorBits());
        -: 1751:    return getUnsignedFromPrefixEncoding(D);
        -: 1752:  }
        -: 1753:
        -: 1754:  /// Raw encoding of the discriminator. APIs such as cloneWithDuplicationFactor
        -: 1755:  /// have certain special case behavior (e.g. treating empty duplication factor
        -: 1756:  /// as the value '1').
        -: 1757:  /// This API, in conjunction with cloneWithDiscriminator, may be used to
        -: 1758:  /// encode the raw values provided.
        -: 1759:  ///
        -: 1760:  /// \p BD: base discriminator
        -: 1761:  /// \p DF: duplication factor
        -: 1762:  /// \p CI: copy index
        -: 1763:  ///
        -: 1764:  /// The return is None if the values cannot be encoded in 32 bits - for
        -: 1765:  /// example, values for BD or DF larger than 12 bits. Otherwise, the return is
        -: 1766:  /// the encoded value.
        -: 1767:  static Optional<unsigned> encodeDiscriminator(unsigned BD, unsigned DF,
        -: 1768:                                                unsigned CI);
        -: 1769:
        -: 1770:  /// Raw decoder for values in an encoded discriminator D.
        -: 1771:  static void decodeDiscriminator(unsigned D, unsigned &BD, unsigned &DF,
        -: 1772:                                  unsigned &CI);
        -: 1773:
        -: 1774:  /// Returns the duplication factor for a given encoded discriminator \p D, or
        -: 1775:  /// 1 if no value or 0 is encoded.
        -: 1776:  static unsigned getDuplicationFactorFromDiscriminator(unsigned D) {
        -: 1777:    if (EnableFSDiscriminator)
        -: 1778:      return 1;
        -: 1779:    D = getNextComponentInDiscriminator(D);
        -: 1780:    unsigned Ret = getUnsignedFromPrefixEncoding(D);
        -: 1781:    if (Ret == 0)
        -: 1782:      return 1;
        -: 1783:    return Ret;
        -: 1784:  }
        -: 1785:
        -: 1786:  /// Returns the copy identifier for a given encoded discriminator \p D.
        -: 1787:  static unsigned getCopyIdentifierFromDiscriminator(unsigned D) {
        -: 1788:    return getUnsignedFromPrefixEncoding(
        -: 1789:        getNextComponentInDiscriminator(getNextComponentInDiscriminator(D)));
        -: 1790:  }
        -: 1791:
        -: 1792:  Metadata *getRawScope() const { return getOperand(0); }
        -: 1793:  Metadata *getRawInlinedAt() const {
        -: 1794:    if (getNumOperands() == 2)
        -: 1795:      return getOperand(1);
        -: 1796:    return nullptr;
        -: 1797:  }
        -: 1798:
        -: 1799:  static bool classof(const Metadata *MD) {
        -: 1800:    return MD->getMetadataID() == DILocationKind;
        -: 1801:  }
        -: 1802:};
        -: 1803:
        -: 1804:/// Subprogram description.
        -: 1805:class DISubprogram : public DILocalScope {
        -: 1806:  friend class LLVMContextImpl;
        -: 1807:  friend class MDNode;
        -: 1808:
        -: 1809:  unsigned Line;
        -: 1810:  unsigned ScopeLine;
        -: 1811:  unsigned VirtualIndex;
        -: 1812:
        -: 1813:  /// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue
        -: 1814:  /// of method overrides from secondary bases by this amount. It may be
        -: 1815:  /// negative.
        -: 1816:  int ThisAdjustment;
        -: 1817:
        -: 1818:public:
        -: 1819:  /// Debug info subprogram flags.
        -: 1820:  enum DISPFlags : uint32_t {
        -: 1821:#define HANDLE_DISP_FLAG(ID, NAME) SPFlag##NAME = ID,
        -: 1822:#define DISP_FLAG_LARGEST_NEEDED
        -: 1823:#include "llvm/IR/DebugInfoFlags.def"
        -: 1824:    SPFlagNonvirtual = SPFlagZero,
        -: 1825:    SPFlagVirtuality = SPFlagVirtual | SPFlagPureVirtual,
        -: 1826:    LLVM_MARK_AS_BITMASK_ENUM(SPFlagLargest)
        -: 1827:  };
        -: 1828:
        -: 1829:  static DISPFlags getFlag(StringRef Flag);
        -: 1830:  static StringRef getFlagString(DISPFlags Flag);
        -: 1831:
        -: 1832:  /// Split up a flags bitfield for easier printing.
        -: 1833:  ///
        -: 1834:  /// Split \c Flags into \c SplitFlags, a vector of its components.  Returns
        -: 1835:  /// any remaining (unrecognized) bits.
        -: 1836:  static DISPFlags splitFlags(DISPFlags Flags,
        -: 1837:                              SmallVectorImpl<DISPFlags> &SplitFlags);
        -: 1838:
        -: 1839:  // Helper for converting old bitfields to new flags word.
        -: 1840:  static DISPFlags toSPFlags(bool IsLocalToUnit, bool IsDefinition,
        -: 1841:                             bool IsOptimized,
        -: 1842:                             unsigned Virtuality = SPFlagNonvirtual,
        -: 1843:                             bool IsMainSubprogram = false);
        -: 1844:
        -: 1845:private:
        -: 1846:  DIFlags Flags;
        -: 1847:  DISPFlags SPFlags;
        -: 1848:
        -: 1849:  DISubprogram(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 1850:               unsigned ScopeLine, unsigned VirtualIndex, int ThisAdjustment,
        -: 1851:               DIFlags Flags, DISPFlags SPFlags, ArrayRef<Metadata *> Ops);
        -: 1852:  ~DISubprogram() = default;
        -: 1853:
        -: 1854:  static DISubprogram *
        -: 1855:  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,
        -: 1856:          StringRef LinkageName, DIFile *File, unsigned Line,
        -: 1857:          DISubroutineType *Type, unsigned ScopeLine, DIType *ContainingType,
        -: 1858:          unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,
        -: 1859:          DISPFlags SPFlags, DICompileUnit *Unit,
        -: 1860:          DITemplateParameterArray TemplateParams, DISubprogram *Declaration,
        -: 1861:          DINodeArray RetainedNodes, DITypeArray ThrownTypes,
        -: 1862:          DINodeArray Annotations, StringRef TargetFuncName,
        -: 1863:          StorageType Storage, bool ShouldCreate = true) {
        -: 1864:    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),
        -: 1865:                   getCanonicalMDString(Context, LinkageName), File, Line, Type,
        -: 1866:                   ScopeLine, ContainingType, VirtualIndex, ThisAdjustment,
        -: 1867:                   Flags, SPFlags, Unit, TemplateParams.get(), Declaration,
        -: 1868:                   RetainedNodes.get(), ThrownTypes.get(), Annotations.get(),
        -: 1869:                   getCanonicalMDString(Context, TargetFuncName),
        -: 1870:                   Storage, ShouldCreate);
        -: 1871:  }
        -: 1872:  static DISubprogram *
        -: 1873:  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,
        -: 1874:          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,
        -: 1875:          unsigned ScopeLine, Metadata *ContainingType, unsigned VirtualIndex,
        -: 1876:          int ThisAdjustment, DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,
        -: 1877:          Metadata *TemplateParams, Metadata *Declaration,
        -: 1878:          Metadata *RetainedNodes, Metadata *ThrownTypes, Metadata *Annotations,
        -: 1879:          MDString *TargetFuncName, StorageType Storage,
        -: 1880:          bool ShouldCreate = true);
        -: 1881:
        -: 1882:  TempDISubprogram cloneImpl() const {
        -: 1883:    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),
        -: 1884:                        getFile(), getLine(), getType(), getScopeLine(),
        -: 1885:                        getContainingType(), getVirtualIndex(),
        -: 1886:                        getThisAdjustment(), getFlags(), getSPFlags(),
        -: 1887:                        getUnit(), getTemplateParams(), getDeclaration(),
        -: 1888:                        getRetainedNodes(), getThrownTypes(), getAnnotations(),
        -: 1889:                        getTargetFuncName());
        -: 1890:  }
        -: 1891:
        -: 1892:public:
        -: 1893:  DEFINE_MDNODE_GET(
        -: 1894:      DISubprogram,
        -: 1895:      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,
        -: 1896:       unsigned Line, DISubroutineType *Type, unsigned ScopeLine,
        -: 1897:       DIType *ContainingType, unsigned VirtualIndex, int ThisAdjustment,
        -: 1898:       DIFlags Flags, DISPFlags SPFlags, DICompileUnit *Unit,
        -: 1899:       DITemplateParameterArray TemplateParams = nullptr,
        -: 1900:       DISubprogram *Declaration = nullptr, DINodeArray RetainedNodes = nullptr,
        -: 1901:       DITypeArray ThrownTypes = nullptr, DINodeArray Annotations = nullptr,
        -: 1902:       StringRef TargetFuncName = ""),
        -: 1903:      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,
        -: 1904:       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,
        -: 1905:       Declaration, RetainedNodes, ThrownTypes, Annotations, TargetFuncName))
        -: 1906:
        -: 1907:  DEFINE_MDNODE_GET(
        -: 1908:      DISubprogram,
        -: 1909:      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,
        -: 1910:       unsigned Line, Metadata *Type, unsigned ScopeLine,
        -: 1911:       Metadata *ContainingType, unsigned VirtualIndex, int ThisAdjustment,
        -: 1912:       DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,
        -: 1913:       Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,
        -: 1914:       Metadata *RetainedNodes = nullptr, Metadata *ThrownTypes = nullptr,
        -: 1915:       Metadata *Annotations = nullptr, MDString *TargetFuncName = nullptr),
        -: 1916:      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,
        -: 1917:       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,
        -: 1918:       Declaration, RetainedNodes, ThrownTypes, Annotations, TargetFuncName))
        -: 1919:
        -: 1920:  TempDISubprogram clone() const { return cloneImpl(); }
        -: 1921:
        -: 1922:  /// Returns a new temporary DISubprogram with updated Flags
        -: 1923:  TempDISubprogram cloneWithFlags(DIFlags NewFlags) const {
        -: 1924:    auto NewSP = clone();
        -: 1925:    NewSP->Flags = NewFlags;
        -: 1926:    return NewSP;
        -: 1927:  }
        -: 1928:
        -: 1929:public:
        -: 1930:  unsigned getLine() const { return Line; }
        -: 1931:  unsigned getVirtuality() const { return getSPFlags() & SPFlagVirtuality; }
        -: 1932:  unsigned getVirtualIndex() const { return VirtualIndex; }
        -: 1933:  int getThisAdjustment() const { return ThisAdjustment; }
        -: 1934:  unsigned getScopeLine() const { return ScopeLine; }
        -: 1935:  void setScopeLine(unsigned L) {
        -: 1936:    assert(isDistinct());
        -: 1937:    ScopeLine = L;
        -: 1938:  }
        -: 1939:  DIFlags getFlags() const { return Flags; }
        -: 1940:  DISPFlags getSPFlags() const { return SPFlags; }
        -: 1941:  bool isLocalToUnit() const { return getSPFlags() & SPFlagLocalToUnit; }
        -: 1942:  bool isDefinition() const { return getSPFlags() & SPFlagDefinition; }
        -: 1943:  bool isOptimized() const { return getSPFlags() & SPFlagOptimized; }
        -: 1944:  bool isMainSubprogram() const { return getSPFlags() & SPFlagMainSubprogram; }
        -: 1945:
        -: 1946:  bool isArtificial() const { return getFlags() & FlagArtificial; }
        -: 1947:  bool isPrivate() const {
        -: 1948:    return (getFlags() & FlagAccessibility) == FlagPrivate;
        -: 1949:  }
        -: 1950:  bool isProtected() const {
        -: 1951:    return (getFlags() & FlagAccessibility) == FlagProtected;
        -: 1952:  }
        -: 1953:  bool isPublic() const {
        -: 1954:    return (getFlags() & FlagAccessibility) == FlagPublic;
        -: 1955:  }
        -: 1956:  bool isExplicit() const { return getFlags() & FlagExplicit; }
        -: 1957:  bool isPrototyped() const { return getFlags() & FlagPrototyped; }
        -: 1958:  bool areAllCallsDescribed() const {
        -: 1959:    return getFlags() & FlagAllCallsDescribed;
        -: 1960:  }
        -: 1961:  bool isPure() const { return getSPFlags() & SPFlagPure; }
        -: 1962:  bool isElemental() const { return getSPFlags() & SPFlagElemental; }
        -: 1963:  bool isRecursive() const { return getSPFlags() & SPFlagRecursive; }
        -: 1964:  bool isObjCDirect() const { return getSPFlags() & SPFlagObjCDirect; }
        -: 1965:
        -: 1966:  /// Check if this is deleted member function.
        -: 1967:  ///
        -: 1968:  /// Return true if this subprogram is a C++11 special
        -: 1969:  /// member function declared deleted.
        -: 1970:  bool isDeleted() const { return getSPFlags() & SPFlagDeleted; }
        -: 1971:
        -: 1972:  /// Check if this is reference-qualified.
        -: 1973:  ///
        -: 1974:  /// Return true if this subprogram is a C++11 reference-qualified non-static
        -: 1975:  /// member function (void foo() &).
        -: 1976:  bool isLValueReference() const { return getFlags() & FlagLValueReference; }
        -: 1977:
        -: 1978:  /// Check if this is rvalue-reference-qualified.
        -: 1979:  ///
        -: 1980:  /// Return true if this subprogram is a C++11 rvalue-reference-qualified
        -: 1981:  /// non-static member function (void foo() &&).
        -: 1982:  bool isRValueReference() const { return getFlags() & FlagRValueReference; }
        -: 1983:
        -: 1984:  /// Check if this is marked as noreturn.
        -: 1985:  ///
        -: 1986:  /// Return true if this subprogram is C++11 noreturn or C11 _Noreturn
        -: 1987:  bool isNoReturn() const { return getFlags() & FlagNoReturn; }
        -: 1988:
        -: 1989:  // Check if this routine is a compiler-generated thunk.
        -: 1990:  //
        -: 1991:  // Returns true if this subprogram is a thunk generated by the compiler.
        -: 1992:  bool isThunk() const { return getFlags() & FlagThunk; }
        -: 1993:
        -: 1994:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 1995:
        -: 1996:  StringRef getName() const { return getStringOperand(2); }
        -: 1997:  StringRef getLinkageName() const { return getStringOperand(3); }
        -: 1998:  /// Only used by clients of CloneFunction, and only right after the cloning.
        -: 1999:  void replaceLinkageName(MDString *LN) { replaceOperandWith(3, LN); }
        -: 2000:
        -: 2001:  DISubroutineType *getType() const {
        -: 2002:    return cast_or_null<DISubroutineType>(getRawType());
        -: 2003:  }
        -: 2004:  DIType *getContainingType() const {
        -: 2005:    return cast_or_null<DIType>(getRawContainingType());
        -: 2006:  }
        -: 2007:  void replaceType(DISubroutineType *Ty) {
        -: 2008:    assert(isDistinct() && "Only distinct nodes can mutate");
        -: 2009:    replaceOperandWith(4, Ty);
        -: 2010:  }
        -: 2011:
        -: 2012:  DICompileUnit *getUnit() const {
        -: 2013:    return cast_or_null<DICompileUnit>(getRawUnit());
        -: 2014:  }
        -: 2015:  void replaceUnit(DICompileUnit *CU) { replaceOperandWith(5, CU); }
        -: 2016:  DITemplateParameterArray getTemplateParams() const {
        -: 2017:    return cast_or_null<MDTuple>(getRawTemplateParams());
        -: 2018:  }
        -: 2019:  DISubprogram *getDeclaration() const {
        -: 2020:    return cast_or_null<DISubprogram>(getRawDeclaration());
        -: 2021:  }
        -: 2022:  DINodeArray getRetainedNodes() const {
        -: 2023:    return cast_or_null<MDTuple>(getRawRetainedNodes());
        -: 2024:  }
        -: 2025:  DITypeArray getThrownTypes() const {
        -: 2026:    return cast_or_null<MDTuple>(getRawThrownTypes());
        -: 2027:  }
        -: 2028:  DINodeArray getAnnotations() const {
        -: 2029:    return cast_or_null<MDTuple>(getRawAnnotations());
        -: 2030:  }
        -: 2031:  StringRef getTargetFuncName() const {
        -: 2032:    return (getRawTargetFuncName()) ? getStringOperand(12) : StringRef();
        -: 2033:  }
        -: 2034:
        -: 2035:  Metadata *getRawScope() const { return getOperand(1); }
        -: 2036:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -: 2037:  MDString *getRawLinkageName() const { return getOperandAs<MDString>(3); }
        -: 2038:  Metadata *getRawType() const { return getOperand(4); }
        -: 2039:  Metadata *getRawUnit() const { return getOperand(5); }
        -: 2040:  Metadata *getRawDeclaration() const { return getOperand(6); }
        -: 2041:  Metadata *getRawRetainedNodes() const { return getOperand(7); }
        -: 2042:  Metadata *getRawContainingType() const {
        -: 2043:    return getNumOperands() > 8 ? getOperandAs<Metadata>(8) : nullptr;
        -: 2044:  }
        -: 2045:  Metadata *getRawTemplateParams() const {
        -: 2046:    return getNumOperands() > 9 ? getOperandAs<Metadata>(9) : nullptr;
        -: 2047:  }
        -: 2048:  Metadata *getRawThrownTypes() const {
        -: 2049:    return getNumOperands() > 10 ? getOperandAs<Metadata>(10) : nullptr;
        -: 2050:  }
        -: 2051:  Metadata *getRawAnnotations() const {
        -: 2052:    return getNumOperands() > 11 ? getOperandAs<Metadata>(11) : nullptr;
        -: 2053:  }
        -: 2054:  MDString *getRawTargetFuncName() const {
        -: 2055:    return getNumOperands() > 12 ? getOperandAs<MDString>(12) : nullptr;
        -: 2056:  }
        -: 2057:
        -: 2058:  void replaceRawLinkageName(MDString *LinkageName) {
        -: 2059:    replaceOperandWith(3, LinkageName);
        -: 2060:  }
        -: 2061:
        -: 2062:  /// Check if this subprogram describes the given function.
        -: 2063:  ///
        -: 2064:  /// FIXME: Should this be looking through bitcasts?
        -: 2065:  bool describes(const Function *F) const;
        -: 2066:
        -: 2067:  static bool classof(const Metadata *MD) {
        -: 2068:    return MD->getMetadataID() == DISubprogramKind;
        -: 2069:  }
        -: 2070:};
        -: 2071:
        -: 2072:class DILexicalBlockBase : public DILocalScope {
        -: 2073:protected:
        -: 2074:  DILexicalBlockBase(LLVMContext &C, unsigned ID, StorageType Storage,
        -: 2075:                     ArrayRef<Metadata *> Ops);
        -: 2076:  ~DILexicalBlockBase() = default;
        -: 2077:
        -: 2078:public:
        -: 2079:  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }
        -: 2080:
        -: 2081:  Metadata *getRawScope() const { return getOperand(1); }
        -: 2082:
        -: 2083:  static bool classof(const Metadata *MD) {
        -: 2084:    return MD->getMetadataID() == DILexicalBlockKind ||
        -: 2085:           MD->getMetadataID() == DILexicalBlockFileKind;
        -: 2086:  }
        -: 2087:};
        -: 2088:
        -: 2089:class DILexicalBlock : public DILexicalBlockBase {
        -: 2090:  friend class LLVMContextImpl;
        -: 2091:  friend class MDNode;
        -: 2092:
        -: 2093:  unsigned Line;
        -: 2094:  uint16_t Column;
        -: 2095:
        -: 2096:  DILexicalBlock(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 2097:                 unsigned Column, ArrayRef<Metadata *> Ops)
        -: 2098:      : DILexicalBlockBase(C, DILexicalBlockKind, Storage, Ops), Line(Line),
        -: 2099:        Column(Column) {
        -: 2100:    assert(Column < (1u << 16) && "Expected 16-bit column");
        -: 2101:  }
        -: 2102:  ~DILexicalBlock() = default;
        -: 2103:
        -: 2104:  static DILexicalBlock *getImpl(LLVMContext &Context, DILocalScope *Scope,
        -: 2105:                                 DIFile *File, unsigned Line, unsigned Column,
        -: 2106:                                 StorageType Storage,
        -: 2107:                                 bool ShouldCreate = true) {
        -: 2108:    return getImpl(Context, static_cast<Metadata *>(Scope),
        -: 2109:                   static_cast<Metadata *>(File), Line, Column, Storage,
        -: 2110:                   ShouldCreate);
        -: 2111:  }
        -: 2112:
        -: 2113:  static DILexicalBlock *getImpl(LLVMContext &Context, Metadata *Scope,
        -: 2114:                                 Metadata *File, unsigned Line, unsigned Column,
        -: 2115:                                 StorageType Storage, bool ShouldCreate = true);
        -: 2116:
        -: 2117:  TempDILexicalBlock cloneImpl() const {
        -: 2118:    return getTemporary(getContext(), getScope(), getFile(), getLine(),
        -: 2119:                        getColumn());
        -: 2120:  }
        -: 2121:
        -: 2122:public:
        -: 2123:  DEFINE_MDNODE_GET(DILexicalBlock,
        -: 2124:                    (DILocalScope * Scope, DIFile *File, unsigned Line,
        -: 2125:                     unsigned Column),
        -: 2126:                    (Scope, File, Line, Column))
        -: 2127:  DEFINE_MDNODE_GET(DILexicalBlock,
        -: 2128:                    (Metadata * Scope, Metadata *File, unsigned Line,
        -: 2129:                     unsigned Column),
        -: 2130:                    (Scope, File, Line, Column))
        -: 2131:
        -: 2132:  TempDILexicalBlock clone() const { return cloneImpl(); }
        -: 2133:
        -: 2134:  unsigned getLine() const { return Line; }
        -: 2135:  unsigned getColumn() const { return Column; }
        -: 2136:
        -: 2137:  static bool classof(const Metadata *MD) {
        -: 2138:    return MD->getMetadataID() == DILexicalBlockKind;
        -: 2139:  }
        -: 2140:};
        -: 2141:
        -: 2142:class DILexicalBlockFile : public DILexicalBlockBase {
        -: 2143:  friend class LLVMContextImpl;
        -: 2144:  friend class MDNode;
        -: 2145:
        -: 2146:  unsigned Discriminator;
        -: 2147:
        -: 2148:  DILexicalBlockFile(LLVMContext &C, StorageType Storage,
        -: 2149:                     unsigned Discriminator, ArrayRef<Metadata *> Ops)
        -: 2150:      : DILexicalBlockBase(C, DILexicalBlockFileKind, Storage, Ops),
        -: 2151:        Discriminator(Discriminator) {}
        -: 2152:  ~DILexicalBlockFile() = default;
        -: 2153:
        -: 2154:  static DILexicalBlockFile *getImpl(LLVMContext &Context, DILocalScope *Scope,
        -: 2155:                                     DIFile *File, unsigned Discriminator,
        -: 2156:                                     StorageType Storage,
        -: 2157:                                     bool ShouldCreate = true) {
        -: 2158:    return getImpl(Context, static_cast<Metadata *>(Scope),
        -: 2159:                   static_cast<Metadata *>(File), Discriminator, Storage,
        -: 2160:                   ShouldCreate);
        -: 2161:  }
        -: 2162:
        -: 2163:  static DILexicalBlockFile *getImpl(LLVMContext &Context, Metadata *Scope,
        -: 2164:                                     Metadata *File, unsigned Discriminator,
        -: 2165:                                     StorageType Storage,
        -: 2166:                                     bool ShouldCreate = true);
        -: 2167:
        -: 2168:  TempDILexicalBlockFile cloneImpl() const {
        -: 2169:    return getTemporary(getContext(), getScope(), getFile(),
        -: 2170:                        getDiscriminator());
        -: 2171:  }
        -: 2172:
        -: 2173:public:
        -: 2174:  DEFINE_MDNODE_GET(DILexicalBlockFile,
        -: 2175:                    (DILocalScope * Scope, DIFile *File,
        -: 2176:                     unsigned Discriminator),
        -: 2177:                    (Scope, File, Discriminator))
        -: 2178:  DEFINE_MDNODE_GET(DILexicalBlockFile,
        -: 2179:                    (Metadata * Scope, Metadata *File, unsigned Discriminator),
        -: 2180:                    (Scope, File, Discriminator))
        -: 2181:
        -: 2182:  TempDILexicalBlockFile clone() const { return cloneImpl(); }
        -: 2183:  unsigned getDiscriminator() const { return Discriminator; }
        -: 2184:
        -: 2185:  static bool classof(const Metadata *MD) {
        -: 2186:    return MD->getMetadataID() == DILexicalBlockFileKind;
        -: 2187:  }
        -: 2188:};
        -: 2189:
        -: 2190:unsigned DILocation::getDiscriminator() const {
        -: 2191:  if (auto *F = dyn_cast<DILexicalBlockFile>(getScope()))
        -: 2192:    return F->getDiscriminator();
        -: 2193:  return 0;
        -: 2194:}
        -: 2195:
        -: 2196:const DILocation *
        -: 2197:DILocation::cloneWithDiscriminator(unsigned Discriminator) const {
        -: 2198:  DIScope *Scope = getScope();
        -: 2199:  // Skip all parent DILexicalBlockFile that already have a discriminator
        -: 2200:  // assigned. We do not want to have nested DILexicalBlockFiles that have
        -: 2201:  // mutliple discriminators because only the leaf DILexicalBlockFile's
        -: 2202:  // dominator will be used.
        -: 2203:  for (auto *LBF = dyn_cast<DILexicalBlockFile>(Scope);
        -: 2204:       LBF && LBF->getDiscriminator() != 0;
        -: 2205:       LBF = dyn_cast<DILexicalBlockFile>(Scope))
        -: 2206:    Scope = LBF->getScope();
        -: 2207:  DILexicalBlockFile *NewScope =
        -: 2208:      DILexicalBlockFile::get(getContext(), Scope, getFile(), Discriminator);
        -: 2209:  return DILocation::get(getContext(), getLine(), getColumn(), NewScope,
        -: 2210:                         getInlinedAt());
        -: 2211:}
        -: 2212:
        -: 2213:unsigned DILocation::getBaseDiscriminator() const {
        -: 2214:  return getBaseDiscriminatorFromDiscriminator(getDiscriminator(),
        -: 2215:                                               EnableFSDiscriminator);
        -: 2216:}
        -: 2217:
        -: 2218:unsigned DILocation::getDuplicationFactor() const {
        -: 2219:  return getDuplicationFactorFromDiscriminator(getDiscriminator());
        -: 2220:}
        -: 2221:
        -: 2222:unsigned DILocation::getCopyIdentifier() const {
        -: 2223:  return getCopyIdentifierFromDiscriminator(getDiscriminator());
        -: 2224:}
        -: 2225:
        -: 2226:Optional<const DILocation *>
        -: 2227:DILocation::cloneWithBaseDiscriminator(unsigned D) const {
        -: 2228:  unsigned BD, DF, CI;
        -: 2229:
        -: 2230:  if (EnableFSDiscriminator) {
        -: 2231:    BD = getBaseDiscriminator();
        -: 2232:    if (D == BD)
        -: 2233:      return this;
        -: 2234:    return cloneWithDiscriminator(D);
        -: 2235:  }
        -: 2236:
        -: 2237:  decodeDiscriminator(getDiscriminator(), BD, DF, CI);
        -: 2238:  if (D == BD)
        -: 2239:    return this;
        -: 2240:  if (Optional<unsigned> Encoded = encodeDiscriminator(D, DF, CI))
        -: 2241:    return cloneWithDiscriminator(*Encoded);
        -: 2242:  return None;
        -: 2243:}
        -: 2244:
        -: 2245:Optional<const DILocation *>
        -: 2246:DILocation::cloneByMultiplyingDuplicationFactor(unsigned DF) const {
        -: 2247:  assert(!EnableFSDiscriminator && "FSDiscriminator should not call this.");
        -: 2248:
        -: 2249:  DF *= getDuplicationFactor();
        -: 2250:  if (DF <= 1)
        -: 2251:    return this;
        -: 2252:
        -: 2253:  unsigned BD = getBaseDiscriminator();
        -: 2254:  unsigned CI = getCopyIdentifier();
        -: 2255:  if (Optional<unsigned> D = encodeDiscriminator(BD, DF, CI))
        -: 2256:    return cloneWithDiscriminator(*D);
        -: 2257:  return None;
        -: 2258:}
        -: 2259:
        -: 2260:class DINamespace : public DIScope {
        -: 2261:  friend class LLVMContextImpl;
        -: 2262:  friend class MDNode;
        -: 2263:
        -: 2264:  unsigned ExportSymbols : 1;
        -: 2265:
        -: 2266:  DINamespace(LLVMContext &Context, StorageType Storage, bool ExportSymbols,
        -: 2267:              ArrayRef<Metadata *> Ops);
        -: 2268:  ~DINamespace() = default;
        -: 2269:
        -: 2270:  static DINamespace *getImpl(LLVMContext &Context, DIScope *Scope,
        -: 2271:                              StringRef Name, bool ExportSymbols,
        -: 2272:                              StorageType Storage, bool ShouldCreate = true) {
        -: 2273:    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),
        -: 2274:                   ExportSymbols, Storage, ShouldCreate);
        -: 2275:  }
        -: 2276:  static DINamespace *getImpl(LLVMContext &Context, Metadata *Scope,
        -: 2277:                              MDString *Name, bool ExportSymbols,
        -: 2278:                              StorageType Storage, bool ShouldCreate = true);
        -: 2279:
        -: 2280:  TempDINamespace cloneImpl() const {
        -: 2281:    return getTemporary(getContext(), getScope(), getName(),
        -: 2282:                        getExportSymbols());
        -: 2283:  }
        -: 2284:
        -: 2285:public:
        -: 2286:  DEFINE_MDNODE_GET(DINamespace,
        -: 2287:                    (DIScope * Scope, StringRef Name, bool ExportSymbols),
        -: 2288:                    (Scope, Name, ExportSymbols))
        -: 2289:  DEFINE_MDNODE_GET(DINamespace,
        -: 2290:                    (Metadata * Scope, MDString *Name, bool ExportSymbols),
        -: 2291:                    (Scope, Name, ExportSymbols))
        -: 2292:
        -: 2293:  TempDINamespace clone() const { return cloneImpl(); }
        -: 2294:
        -: 2295:  bool getExportSymbols() const { return ExportSymbols; }
        -: 2296:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 2297:  StringRef getName() const { return getStringOperand(2); }
        -: 2298:
        -: 2299:  Metadata *getRawScope() const { return getOperand(1); }
        -: 2300:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -: 2301:
        -: 2302:  static bool classof(const Metadata *MD) {
        -: 2303:    return MD->getMetadataID() == DINamespaceKind;
        -: 2304:  }
        -: 2305:};
        -: 2306:
        -: 2307:/// Represents a module in the programming language, for example, a Clang
        -: 2308:/// module, or a Fortran module.
        -: 2309:class DIModule : public DIScope {
        -: 2310:  friend class LLVMContextImpl;
        -: 2311:  friend class MDNode;
        -: 2312:  unsigned LineNo;
        -: 2313:  bool IsDecl;
        -: 2314:
        -: 2315:  DIModule(LLVMContext &Context, StorageType Storage, unsigned LineNo,
        -: 2316:           bool IsDecl, ArrayRef<Metadata *> Ops);
        -: 2317:  ~DIModule() = default;
        -: 2318:
        -: 2319:  static DIModule *getImpl(LLVMContext &Context, DIFile *File, DIScope *Scope,
        -: 2320:                           StringRef Name, StringRef ConfigurationMacros,
        -: 2321:                           StringRef IncludePath, StringRef APINotesFile,
        -: 2322:                           unsigned LineNo, bool IsDecl, StorageType Storage,
        -: 2323:                           bool ShouldCreate = true) {
        -: 2324:    return getImpl(Context, File, Scope, getCanonicalMDString(Context, Name),
        -: 2325:                   getCanonicalMDString(Context, ConfigurationMacros),
        -: 2326:                   getCanonicalMDString(Context, IncludePath),
        -: 2327:                   getCanonicalMDString(Context, APINotesFile), LineNo, IsDecl,
        -: 2328:                   Storage, ShouldCreate);
        -: 2329:  }
        -: 2330:  static DIModule *getImpl(LLVMContext &Context, Metadata *File,
        -: 2331:                           Metadata *Scope, MDString *Name,
        -: 2332:                           MDString *ConfigurationMacros, MDString *IncludePath,
        -: 2333:                           MDString *APINotesFile, unsigned LineNo, bool IsDecl,
        -: 2334:                           StorageType Storage, bool ShouldCreate = true);
        -: 2335:
        -: 2336:  TempDIModule cloneImpl() const {
        -: 2337:    return getTemporary(getContext(), getFile(), getScope(), getName(),
        -: 2338:                        getConfigurationMacros(), getIncludePath(),
        -: 2339:                        getAPINotesFile(), getLineNo(), getIsDecl());
        -: 2340:  }
        -: 2341:
        -: 2342:public:
        -: 2343:  DEFINE_MDNODE_GET(DIModule,
        -: 2344:                    (DIFile * File, DIScope *Scope, StringRef Name,
        -: 2345:                     StringRef ConfigurationMacros, StringRef IncludePath,
        -: 2346:                     StringRef APINotesFile, unsigned LineNo,
        -: 2347:                     bool IsDecl = false),
        -: 2348:                    (File, Scope, Name, ConfigurationMacros, IncludePath,
        -: 2349:                     APINotesFile, LineNo, IsDecl))
        -: 2350:  DEFINE_MDNODE_GET(DIModule,
        -: 2351:                    (Metadata * File, Metadata *Scope, MDString *Name,
        -: 2352:                     MDString *ConfigurationMacros, MDString *IncludePath,
        -: 2353:                     MDString *APINotesFile, unsigned LineNo,
        -: 2354:                     bool IsDecl = false),
        -: 2355:                    (File, Scope, Name, ConfigurationMacros, IncludePath,
        -: 2356:                     APINotesFile, LineNo, IsDecl))
        -: 2357:
        -: 2358:  TempDIModule clone() const { return cloneImpl(); }
        -: 2359:
        -: 2360:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 2361:  StringRef getName() const { return getStringOperand(2); }
        -: 2362:  StringRef getConfigurationMacros() const { return getStringOperand(3); }
        -: 2363:  StringRef getIncludePath() const { return getStringOperand(4); }
        -: 2364:  StringRef getAPINotesFile() const { return getStringOperand(5); }
        -: 2365:  unsigned getLineNo() const { return LineNo; }
        -: 2366:  bool getIsDecl() const { return IsDecl; }
        -: 2367:
        -: 2368:  Metadata *getRawScope() const { return getOperand(1); }
        -: 2369:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -: 2370:  MDString *getRawConfigurationMacros() const {
        -: 2371:    return getOperandAs<MDString>(3);
        -: 2372:  }
        -: 2373:  MDString *getRawIncludePath() const { return getOperandAs<MDString>(4); }
        -: 2374:  MDString *getRawAPINotesFile() const { return getOperandAs<MDString>(5); }
        -: 2375:
        -: 2376:  static bool classof(const Metadata *MD) {
        -: 2377:    return MD->getMetadataID() == DIModuleKind;
        -: 2378:  }
        -: 2379:};
        -: 2380:
        -: 2381:/// Base class for template parameters.
        -: 2382:class DITemplateParameter : public DINode {
        -: 2383:protected:
        -: 2384:  bool IsDefault;
        -: 2385:
        -: 2386:  DITemplateParameter(LLVMContext &Context, unsigned ID, StorageType Storage,
        -: 2387:                      unsigned Tag, bool IsDefault, ArrayRef<Metadata *> Ops)
        -: 2388:      : DINode(Context, ID, Storage, Tag, Ops), IsDefault(IsDefault) {}
        -: 2389:  ~DITemplateParameter() = default;
        -: 2390:
        -: 2391:public:
        -: 2392:  StringRef getName() const { return getStringOperand(0); }
        -: 2393:  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }
        -: 2394:
        -: 2395:  MDString *getRawName() const { return getOperandAs<MDString>(0); }
        -: 2396:  Metadata *getRawType() const { return getOperand(1); }
        -: 2397:  bool isDefault() const { return IsDefault; }
        -: 2398:
        -: 2399:  static bool classof(const Metadata *MD) {
        -: 2400:    return MD->getMetadataID() == DITemplateTypeParameterKind ||
        -: 2401:           MD->getMetadataID() == DITemplateValueParameterKind;
        -: 2402:  }
        -: 2403:};
        -: 2404:
        -: 2405:class DITemplateTypeParameter : public DITemplateParameter {
        -: 2406:  friend class LLVMContextImpl;
        -: 2407:  friend class MDNode;
        -: 2408:
        -: 2409:  DITemplateTypeParameter(LLVMContext &Context, StorageType Storage,
        -: 2410:                          bool IsDefault, ArrayRef<Metadata *> Ops);
        -: 2411:  ~DITemplateTypeParameter() = default;
        -: 2412:
        -: 2413:  static DITemplateTypeParameter *getImpl(LLVMContext &Context, StringRef Name,
        -: 2414:                                          DIType *Type, bool IsDefault,
        -: 2415:                                          StorageType Storage,
        -: 2416:                                          bool ShouldCreate = true) {
        -: 2417:    return getImpl(Context, getCanonicalMDString(Context, Name), Type,
        -: 2418:                   IsDefault, Storage, ShouldCreate);
        -: 2419:  }
        -: 2420:  static DITemplateTypeParameter *getImpl(LLVMContext &Context, MDString *Name,
        -: 2421:                                          Metadata *Type, bool IsDefault,
        -: 2422:                                          StorageType Storage,
        -: 2423:                                          bool ShouldCreate = true);
        -: 2424:
        -: 2425:  TempDITemplateTypeParameter cloneImpl() const {
        -: 2426:    return getTemporary(getContext(), getName(), getType(), isDefault());
        -: 2427:  }
        -: 2428:
        -: 2429:public:
        -: 2430:  DEFINE_MDNODE_GET(DITemplateTypeParameter,
        -: 2431:                    (StringRef Name, DIType *Type, bool IsDefault),
        -: 2432:                    (Name, Type, IsDefault))
        -: 2433:  DEFINE_MDNODE_GET(DITemplateTypeParameter,
        -: 2434:                    (MDString * Name, Metadata *Type, bool IsDefault),
        -: 2435:                    (Name, Type, IsDefault))
        -: 2436:
        -: 2437:  TempDITemplateTypeParameter clone() const { return cloneImpl(); }
        -: 2438:
        -: 2439:  static bool classof(const Metadata *MD) {
        -: 2440:    return MD->getMetadataID() == DITemplateTypeParameterKind;
        -: 2441:  }
        -: 2442:};
        -: 2443:
        -: 2444:class DITemplateValueParameter : public DITemplateParameter {
        -: 2445:  friend class LLVMContextImpl;
        -: 2446:  friend class MDNode;
        -: 2447:
        -: 2448:  DITemplateValueParameter(LLVMContext &Context, StorageType Storage,
        -: 2449:                           unsigned Tag, bool IsDefault,
        -: 2450:                           ArrayRef<Metadata *> Ops)
        -: 2451:      : DITemplateParameter(Context, DITemplateValueParameterKind, Storage, Tag,
        -: 2452:                            IsDefault, Ops) {}
        -: 2453:  ~DITemplateValueParameter() = default;
        -: 2454:
        -: 2455:  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,
        -: 2456:                                           StringRef Name, DIType *Type,
        -: 2457:                                           bool IsDefault, Metadata *Value,
        -: 2458:                                           StorageType Storage,
        -: 2459:                                           bool ShouldCreate = true) {
        -: 2460:    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), Type,
        -: 2461:                   IsDefault, Value, Storage, ShouldCreate);
        -: 2462:  }
        -: 2463:  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,
        -: 2464:                                           MDString *Name, Metadata *Type,
        -: 2465:                                           bool IsDefault, Metadata *Value,
        -: 2466:                                           StorageType Storage,
        -: 2467:                                           bool ShouldCreate = true);
        -: 2468:
        -: 2469:  TempDITemplateValueParameter cloneImpl() const {
        -: 2470:    return getTemporary(getContext(), getTag(), getName(), getType(),
        -: 2471:                        isDefault(), getValue());
        -: 2472:  }
        -: 2473:
        -: 2474:public:
        -: 2475:  DEFINE_MDNODE_GET(DITemplateValueParameter,
        -: 2476:                    (unsigned Tag, StringRef Name, DIType *Type, bool IsDefault,
        -: 2477:                     Metadata *Value),
        -: 2478:                    (Tag, Name, Type, IsDefault, Value))
        -: 2479:  DEFINE_MDNODE_GET(DITemplateValueParameter,
        -: 2480:                    (unsigned Tag, MDString *Name, Metadata *Type,
        -: 2481:                     bool IsDefault, Metadata *Value),
        -: 2482:                    (Tag, Name, Type, IsDefault, Value))
        -: 2483:
        -: 2484:  TempDITemplateValueParameter clone() const { return cloneImpl(); }
        -: 2485:
        -: 2486:  Metadata *getValue() const { return getOperand(2); }
        -: 2487:
        -: 2488:  static bool classof(const Metadata *MD) {
        -: 2489:    return MD->getMetadataID() == DITemplateValueParameterKind;
        -: 2490:  }
        -: 2491:};
        -: 2492:
        -: 2493:/// Base class for variables.
        -: 2494:class DIVariable : public DINode {
        -: 2495:  unsigned Line;
        -: 2496:  uint32_t AlignInBits;
        -: 2497:
        -: 2498:protected:
        -: 2499:  DIVariable(LLVMContext &C, unsigned ID, StorageType Storage, signed Line,
        -: 2500:             ArrayRef<Metadata *> Ops, uint32_t AlignInBits = 0);
        -: 2501:  ~DIVariable() = default;
        -: 2502:
        -: 2503:public:
        -: 2504:  unsigned getLine() const { return Line; }
        -: 2505:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 2506:  StringRef getName() const { return getStringOperand(1); }
        -: 2507:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 2508:  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }
        -: 2509:  uint32_t getAlignInBits() const { return AlignInBits; }
        -: 2510:  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }
        -: 2511:  /// Determines the size of the variable's type.
        -: 2512:  Optional<uint64_t> getSizeInBits() const;
        -: 2513:
        -: 2514:  /// Return the signedness of this variable's type, or None if this type is
        -: 2515:  /// neither signed nor unsigned.
        -: 2516:  Optional<DIBasicType::Signedness> getSignedness() const {
        -: 2517:    if (auto *BT = dyn_cast<DIBasicType>(getType()))
        -: 2518:      return BT->getSignedness();
        -: 2519:    return None;
        -: 2520:  }
        -: 2521:
        -: 2522:  StringRef getFilename() const {
        -: 2523:    if (auto *F = getFile())
        -: 2524:      return F->getFilename();
        -: 2525:    return "";
        -: 2526:  }
        -: 2527:
        -: 2528:  StringRef getDirectory() const {
        -: 2529:    if (auto *F = getFile())
        -: 2530:      return F->getDirectory();
        -: 2531:    return "";
        -: 2532:  }
        -: 2533:
        -: 2534:  Optional<StringRef> getSource() const {
        -: 2535:    if (auto *F = getFile())
        -: 2536:      return F->getSource();
        -: 2537:    return None;
        -: 2538:  }
        -: 2539:
        -: 2540:  Metadata *getRawScope() const { return getOperand(0); }
        -: 2541:  MDString *getRawName() const { return getOperandAs<MDString>(1); }
        -: 2542:  Metadata *getRawFile() const { return getOperand(2); }
        -: 2543:  Metadata *getRawType() const { return getOperand(3); }
        -: 2544:
        -: 2545:  static bool classof(const Metadata *MD) {
        -: 2546:    return MD->getMetadataID() == DILocalVariableKind ||
        -: 2547:           MD->getMetadataID() == DIGlobalVariableKind;
        -: 2548:  }
        -: 2549:};
        -: 2550:
        -: 2551:/// DWARF expression.
        -: 2552:///
        -: 2553:/// This is (almost) a DWARF expression that modifies the location of a
        -: 2554:/// variable, or the location of a single piece of a variable, or (when using
        -: 2555:/// DW_OP_stack_value) is the constant variable value.
        -: 2556:///
        -: 2557:/// TODO: Co-allocate the expression elements.
        -: 2558:/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary
        -: 2559:/// storage types.
        -: 2560:class DIExpression : public MDNode {
        -: 2561:  friend class LLVMContextImpl;
        -: 2562:  friend class MDNode;
        -: 2563:
        -: 2564:  std::vector<uint64_t> Elements;
        -: 2565:
        -: 2566:  DIExpression(LLVMContext &C, StorageType Storage, ArrayRef<uint64_t> Elements)
        -: 2567:      : MDNode(C, DIExpressionKind, Storage, None),
        -: 2568:        Elements(Elements.begin(), Elements.end()) {}
        -: 2569:  ~DIExpression() = default;
        -: 2570:
        -: 2571:  static DIExpression *getImpl(LLVMContext &Context,
        -: 2572:                               ArrayRef<uint64_t> Elements, StorageType Storage,
        -: 2573:                               bool ShouldCreate = true);
        -: 2574:
        -: 2575:  TempDIExpression cloneImpl() const {
        -: 2576:    return getTemporary(getContext(), getElements());
        -: 2577:  }
        -: 2578:
        -: 2579:public:
    #####: 2580:  DEFINE_MDNODE_GET(DIExpression, (ArrayRef<uint64_t> Elements), (Elements))
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2581:
        -: 2582:  TempDIExpression clone() const { return cloneImpl(); }
        -: 2583:
        -: 2584:  ArrayRef<uint64_t> getElements() const { return Elements; }
        -: 2585:
        -: 2586:  unsigned getNumElements() const { return Elements.size(); }
        -: 2587:
        -: 2588:  uint64_t getElement(unsigned I) const {
        -: 2589:    assert(I < Elements.size() && "Index out of range");
        -: 2590:    return Elements[I];
        -: 2591:  }
        -: 2592:
        -: 2593:  enum SignedOrUnsignedConstant { SignedConstant, UnsignedConstant };
        -: 2594:  /// Determine whether this represents a constant value, if so
        -: 2595:  // return it's sign information.
        -: 2596:  llvm::Optional<SignedOrUnsignedConstant> isConstant() const;
        -: 2597:
        -: 2598:  /// Return the number of unique location operands referred to (via
        -: 2599:  /// DW_OP_LLVM_arg) in this expression; this is not necessarily the number of
        -: 2600:  /// instances of DW_OP_LLVM_arg within the expression.
        -: 2601:  /// For example, for the expression:
        -: 2602:  ///   (DW_OP_LLVM_arg 0, DW_OP_LLVM_arg 1, DW_OP_plus,
        -: 2603:  ///    DW_OP_LLVM_arg 0, DW_OP_mul)
        -: 2604:  /// This function would return 2, as there are two unique location operands
        -: 2605:  /// (0 and 1).
        -: 2606:  uint64_t getNumLocationOperands() const;
        -: 2607:
        -: 2608:  using element_iterator = ArrayRef<uint64_t>::iterator;
        -: 2609:
        -: 2610:  element_iterator elements_begin() const { return getElements().begin(); }
        -: 2611:  element_iterator elements_end() const { return getElements().end(); }
        -: 2612:
        -: 2613:  /// A lightweight wrapper around an expression operand.
        -: 2614:  ///
        -: 2615:  /// TODO: Store arguments directly and change \a DIExpression to store a
        -: 2616:  /// range of these.
        -: 2617:  class ExprOperand {
        -: 2618:    const uint64_t *Op = nullptr;
        -: 2619:
        -: 2620:  public:
        -: 2621:    ExprOperand() = default;
        -: 2622:    explicit ExprOperand(const uint64_t *Op) : Op(Op) {}
        -: 2623:
        -: 2624:    const uint64_t *get() const { return Op; }
        -: 2625:
        -: 2626:    /// Get the operand code.
        -: 2627:    uint64_t getOp() const { return *Op; }
        -: 2628:
        -: 2629:    /// Get an argument to the operand.
        -: 2630:    ///
        -: 2631:    /// Never returns the operand itself.
        -: 2632:    uint64_t getArg(unsigned I) const { return Op[I + 1]; }
        -: 2633:
        -: 2634:    unsigned getNumArgs() const { return getSize() - 1; }
        -: 2635:
        -: 2636:    /// Return the size of the operand.
        -: 2637:    ///
        -: 2638:    /// Return the number of elements in the operand (1 + args).
        -: 2639:    unsigned getSize() const;
        -: 2640:
        -: 2641:    /// Append the elements of this operand to \p V.
        -: 2642:    void appendToVector(SmallVectorImpl<uint64_t> &V) const {
        -: 2643:      V.append(get(), get() + getSize());
        -: 2644:    }
        -: 2645:  };
        -: 2646:
        -: 2647:  /// An iterator for expression operands.
        -: 2648:  class expr_op_iterator {
        -: 2649:    ExprOperand Op;
        -: 2650:
        -: 2651:  public:
        -: 2652:    using iterator_category = std::input_iterator_tag;
        -: 2653:    using value_type = ExprOperand;
        -: 2654:    using difference_type = std::ptrdiff_t;
        -: 2655:    using pointer = value_type *;
        -: 2656:    using reference = value_type &;
        -: 2657:
        -: 2658:    expr_op_iterator() = default;
        -: 2659:    explicit expr_op_iterator(element_iterator I) : Op(I) {}
        -: 2660:
        -: 2661:    element_iterator getBase() const { return Op.get(); }
        -: 2662:    const ExprOperand &operator*() const { return Op; }
        -: 2663:    const ExprOperand *operator->() const { return &Op; }
        -: 2664:
        -: 2665:    expr_op_iterator &operator++() {
        -: 2666:      increment();
        -: 2667:      return *this;
        -: 2668:    }
        -: 2669:    expr_op_iterator operator++(int) {
        -: 2670:      expr_op_iterator T(*this);
        -: 2671:      increment();
        -: 2672:      return T;
        -: 2673:    }
        -: 2674:
        -: 2675:    /// Get the next iterator.
        -: 2676:    ///
        -: 2677:    /// \a std::next() doesn't work because this is technically an
        -: 2678:    /// input_iterator, but it's a perfectly valid operation.  This is an
        -: 2679:    /// accessor to provide the same functionality.
        -: 2680:    expr_op_iterator getNext() const { return ++expr_op_iterator(*this); }
        -: 2681:
        -: 2682:    bool operator==(const expr_op_iterator &X) const {
        -: 2683:      return getBase() == X.getBase();
        -: 2684:    }
        -: 2685:    bool operator!=(const expr_op_iterator &X) const {
        -: 2686:      return getBase() != X.getBase();
        -: 2687:    }
        -: 2688:
        -: 2689:  private:
        -: 2690:    void increment() { Op = ExprOperand(getBase() + Op.getSize()); }
        -: 2691:  };
        -: 2692:
        -: 2693:  /// Visit the elements via ExprOperand wrappers.
        -: 2694:  ///
        -: 2695:  /// These range iterators visit elements through \a ExprOperand wrappers.
        -: 2696:  /// This is not guaranteed to be a valid range unless \a isValid() gives \c
        -: 2697:  /// true.
        -: 2698:  ///
        -: 2699:  /// \pre \a isValid() gives \c true.
        -: 2700:  /// @{
        -: 2701:  expr_op_iterator expr_op_begin() const {
        -: 2702:    return expr_op_iterator(elements_begin());
        -: 2703:  }
        -: 2704:  expr_op_iterator expr_op_end() const {
        -: 2705:    return expr_op_iterator(elements_end());
        -: 2706:  }
        -: 2707:  iterator_range<expr_op_iterator> expr_ops() const {
        -: 2708:    return {expr_op_begin(), expr_op_end()};
        -: 2709:  }
        -: 2710:  /// @}
        -: 2711:
        -: 2712:  bool isValid() const;
        -: 2713:
        -: 2714:  static bool classof(const Metadata *MD) {
        -: 2715:    return MD->getMetadataID() == DIExpressionKind;
        -: 2716:  }
        -: 2717:
        -: 2718:  /// Return whether the first element a DW_OP_deref.
        -: 2719:  bool startsWithDeref() const;
        -: 2720:
        -: 2721:  /// Holds the characteristics of one fragment of a larger variable.
        -: 2722:  struct FragmentInfo {
        -: 2723:    uint64_t SizeInBits;
        -: 2724:    uint64_t OffsetInBits;
        -: 2725:  };
        -: 2726:
        -: 2727:  /// Retrieve the details of this fragment expression.
        -: 2728:  static Optional<FragmentInfo> getFragmentInfo(expr_op_iterator Start,
        -: 2729:                                                expr_op_iterator End);
        -: 2730:
        -: 2731:  /// Retrieve the details of this fragment expression.
        -: 2732:  Optional<FragmentInfo> getFragmentInfo() const {
        -: 2733:    return getFragmentInfo(expr_op_begin(), expr_op_end());
        -: 2734:  }
        -: 2735:
        -: 2736:  /// Return whether this is a piece of an aggregate variable.
        -: 2737:  bool isFragment() const { return getFragmentInfo().has_value(); }
        -: 2738:
        -: 2739:  /// Return whether this is an implicit location description.
        -: 2740:  bool isImplicit() const;
        -: 2741:
        -: 2742:  /// Return whether the location is computed on the expression stack, meaning
        -: 2743:  /// it cannot be a simple register location.
        -: 2744:  bool isComplex() const;
        -: 2745:
        -: 2746:  /// Append \p Ops with operations to apply the \p Offset.
        -: 2747:  static void appendOffset(SmallVectorImpl<uint64_t> &Ops, int64_t Offset);
        -: 2748:
        -: 2749:  /// If this is a constant offset, extract it. If there is no expression,
        -: 2750:  /// return true with an offset of zero.
        -: 2751:  bool extractIfOffset(int64_t &Offset) const;
        -: 2752:
        -: 2753:  /// Returns true iff this DIExpression contains at least one instance of
        -: 2754:  /// `DW_OP_LLVM_arg, n` for all n in [0, N).
        -: 2755:  bool hasAllLocationOps(unsigned N) const;
        -: 2756:
        -: 2757:  /// Checks if the last 4 elements of the expression are DW_OP_constu <DWARF
        -: 2758:  /// Address Space> DW_OP_swap DW_OP_xderef and extracts the <DWARF Address
        -: 2759:  /// Space>.
        -: 2760:  static const DIExpression *extractAddressClass(const DIExpression *Expr,
        -: 2761:                                                 unsigned &AddrClass);
        -: 2762:
        -: 2763:  /// Used for DIExpression::prepend.
        -: 2764:  enum PrependOps : uint8_t {
        -: 2765:    ApplyOffset = 0,
        -: 2766:    DerefBefore = 1 << 0,
        -: 2767:    DerefAfter = 1 << 1,
        -: 2768:    StackValue = 1 << 2,
        -: 2769:    EntryValue = 1 << 3
        -: 2770:  };
        -: 2771:
        -: 2772:  /// Prepend \p DIExpr with a deref and offset operation and optionally turn it
        -: 2773:  /// into a stack value or/and an entry value.
        -: 2774:  static DIExpression *prepend(const DIExpression *Expr, uint8_t Flags,
        -: 2775:                               int64_t Offset = 0);
        -: 2776:
        -: 2777:  /// Prepend \p DIExpr with the given opcodes and optionally turn it into a
        -: 2778:  /// stack value.
        -: 2779:  static DIExpression *prependOpcodes(const DIExpression *Expr,
        -: 2780:                                      SmallVectorImpl<uint64_t> &Ops,
        -: 2781:                                      bool StackValue = false,
        -: 2782:                                      bool EntryValue = false);
        -: 2783:
        -: 2784:  /// Append the opcodes \p Ops to \p DIExpr. Unlike \ref appendToStack, the
        -: 2785:  /// returned expression is a stack value only if \p DIExpr is a stack value.
        -: 2786:  /// If \p DIExpr describes a fragment, the returned expression will describe
        -: 2787:  /// the same fragment.
        -: 2788:  static DIExpression *append(const DIExpression *Expr, ArrayRef<uint64_t> Ops);
        -: 2789:
        -: 2790:  /// Convert \p DIExpr into a stack value if it isn't one already by appending
        -: 2791:  /// DW_OP_deref if needed, and appending \p Ops to the resulting expression.
        -: 2792:  /// If \p DIExpr describes a fragment, the returned expression will describe
        -: 2793:  /// the same fragment.
        -: 2794:  static DIExpression *appendToStack(const DIExpression *Expr,
        -: 2795:                                     ArrayRef<uint64_t> Ops);
        -: 2796:
        -: 2797:  /// Create a copy of \p Expr by appending the given list of \p Ops to each
        -: 2798:  /// instance of the operand `DW_OP_LLVM_arg, \p ArgNo`. This is used to
        -: 2799:  /// modify a specific location used by \p Expr, such as when salvaging that
        -: 2800:  /// location.
        -: 2801:  static DIExpression *appendOpsToArg(const DIExpression *Expr,
        -: 2802:                                      ArrayRef<uint64_t> Ops, unsigned ArgNo,
        -: 2803:                                      bool StackValue = false);
        -: 2804:
        -: 2805:  /// Create a copy of \p Expr with each instance of
        -: 2806:  /// `DW_OP_LLVM_arg, \p OldArg` replaced with `DW_OP_LLVM_arg, \p NewArg`,
        -: 2807:  /// and each instance of `DW_OP_LLVM_arg, Arg` with `DW_OP_LLVM_arg, Arg - 1`
        -: 2808:  /// for all Arg > \p OldArg.
        -: 2809:  /// This is used when replacing one of the operands of a debug value list
        -: 2810:  /// with another operand in the same list and deleting the old operand.
        -: 2811:  static DIExpression *replaceArg(const DIExpression *Expr, uint64_t OldArg,
        -: 2812:                                  uint64_t NewArg);
        -: 2813:
        -: 2814:  /// Create a DIExpression to describe one part of an aggregate variable that
        -: 2815:  /// is fragmented across multiple Values. The DW_OP_LLVM_fragment operation
        -: 2816:  /// will be appended to the elements of \c Expr. If \c Expr already contains
        -: 2817:  /// a \c DW_OP_LLVM_fragment \c OffsetInBits is interpreted as an offset
        -: 2818:  /// into the existing fragment.
        -: 2819:  ///
        -: 2820:  /// \param OffsetInBits Offset of the piece in bits.
        -: 2821:  /// \param SizeInBits   Size of the piece in bits.
        -: 2822:  /// \return             Creating a fragment expression may fail if \c Expr
        -: 2823:  ///                     contains arithmetic operations that would be
        -: 2824:  ///                     truncated.
        -: 2825:  static Optional<DIExpression *>
        -: 2826:  createFragmentExpression(const DIExpression *Expr, unsigned OffsetInBits,
        -: 2827:                           unsigned SizeInBits);
        -: 2828:
        -: 2829:  /// Determine the relative position of the fragments passed in.
        -: 2830:  /// Returns -1 if this is entirely before Other, 0 if this and Other overlap,
        -: 2831:  /// 1 if this is entirely after Other.
        -: 2832:  static int fragmentCmp(const FragmentInfo &A, const FragmentInfo &B) {
        -: 2833:    uint64_t l1 = A.OffsetInBits;
        -: 2834:    uint64_t l2 = B.OffsetInBits;
        -: 2835:    uint64_t r1 = l1 + A.SizeInBits;
        -: 2836:    uint64_t r2 = l2 + B.SizeInBits;
        -: 2837:    if (r1 <= l2)
        -: 2838:      return -1;
        -: 2839:    else if (r2 <= l1)
        -: 2840:      return 1;
        -: 2841:    else
        -: 2842:      return 0;
        -: 2843:  }
        -: 2844:
        -: 2845:  using ExtOps = std::array<uint64_t, 6>;
        -: 2846:
        -: 2847:  /// Returns the ops for a zero- or sign-extension in a DIExpression.
        -: 2848:  static ExtOps getExtOps(unsigned FromSize, unsigned ToSize, bool Signed);
        -: 2849:
        -: 2850:  /// Append a zero- or sign-extension to \p Expr. Converts the expression to a
        -: 2851:  /// stack value if it isn't one already.
        -: 2852:  static DIExpression *appendExt(const DIExpression *Expr, unsigned FromSize,
        -: 2853:                                 unsigned ToSize, bool Signed);
        -: 2854:
        -: 2855:  /// Check if fragments overlap between a pair of FragmentInfos.
        -: 2856:  static bool fragmentsOverlap(const FragmentInfo &A, const FragmentInfo &B) {
        -: 2857:    return fragmentCmp(A, B) == 0;
        -: 2858:  }
        -: 2859:
        -: 2860:  /// Determine the relative position of the fragments described by this
        -: 2861:  /// DIExpression and \p Other. Calls static fragmentCmp implementation.
        -: 2862:  int fragmentCmp(const DIExpression *Other) const {
        -: 2863:    auto Fragment1 = *getFragmentInfo();
        -: 2864:    auto Fragment2 = *Other->getFragmentInfo();
        -: 2865:    return fragmentCmp(Fragment1, Fragment2);
        -: 2866:  }
        -: 2867:
        -: 2868:  /// Check if fragments overlap between this DIExpression and \p Other.
        -: 2869:  bool fragmentsOverlap(const DIExpression *Other) const {
        -: 2870:    if (!isFragment() || !Other->isFragment())
        -: 2871:      return true;
        -: 2872:    return fragmentCmp(Other) == 0;
        -: 2873:  }
        -: 2874:
        -: 2875:  /// Check if the expression consists of exactly one entry value operand.
        -: 2876:  /// (This is the only configuration of entry values that is supported.)
        -: 2877:  bool isEntryValue() const;
        -: 2878:
        -: 2879:  /// Try to shorten an expression with an initial constant operand.
        -: 2880:  /// Returns a new expression and constant on success, or the original
        -: 2881:  /// expression and constant on failure.
        -: 2882:  std::pair<DIExpression *, const ConstantInt *>
        -: 2883:  constantFold(const ConstantInt *CI);
        -: 2884:};
        -: 2885:
        -: 2886:inline bool operator==(const DIExpression::FragmentInfo &A,
        -: 2887:                       const DIExpression::FragmentInfo &B) {
        -: 2888:  return std::tie(A.SizeInBits, A.OffsetInBits) ==
        -: 2889:         std::tie(B.SizeInBits, B.OffsetInBits);
        -: 2890:}
        -: 2891:
        -: 2892:inline bool operator<(const DIExpression::FragmentInfo &A,
        -: 2893:                      const DIExpression::FragmentInfo &B) {
        -: 2894:  return std::tie(A.SizeInBits, A.OffsetInBits) <
        -: 2895:         std::tie(B.SizeInBits, B.OffsetInBits);
        -: 2896:}
        -: 2897:
        -: 2898:template <> struct DenseMapInfo<DIExpression::FragmentInfo> {
        -: 2899:  using FragInfo = DIExpression::FragmentInfo;
        -: 2900:  static const uint64_t MaxVal = std::numeric_limits<uint64_t>::max();
        -: 2901:
        -: 2902:  static inline FragInfo getEmptyKey() { return {MaxVal, MaxVal}; }
        -: 2903:
        -: 2904:  static inline FragInfo getTombstoneKey() { return {MaxVal - 1, MaxVal - 1}; }
        -: 2905:
        -: 2906:  static unsigned getHashValue(const FragInfo &Frag) {
        -: 2907:    return (Frag.SizeInBits & 0xffff) << 16 | (Frag.OffsetInBits & 0xffff);
        -: 2908:  }
        -: 2909:
        -: 2910:  static bool isEqual(const FragInfo &A, const FragInfo &B) { return A == B; }
        -: 2911:};
        -: 2912:
        -: 2913:/// Global variables.
        -: 2914:///
        -: 2915:/// TODO: Remove DisplayName.  It's always equal to Name.
        -: 2916:class DIGlobalVariable : public DIVariable {
        -: 2917:  friend class LLVMContextImpl;
        -: 2918:  friend class MDNode;
        -: 2919:
        -: 2920:  bool IsLocalToUnit;
        -: 2921:  bool IsDefinition;
        -: 2922:
        -: 2923:  DIGlobalVariable(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 2924:                   bool IsLocalToUnit, bool IsDefinition, uint32_t AlignInBits,
        -: 2925:                   ArrayRef<Metadata *> Ops)
        -: 2926:      : DIVariable(C, DIGlobalVariableKind, Storage, Line, Ops, AlignInBits),
        -: 2927:        IsLocalToUnit(IsLocalToUnit), IsDefinition(IsDefinition) {}
        -: 2928:  ~DIGlobalVariable() = default;
        -: 2929:
        -: 2930:  static DIGlobalVariable *
        -: 2931:  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,
        -: 2932:          StringRef LinkageName, DIFile *File, unsigned Line, DIType *Type,
        -: 2933:          bool IsLocalToUnit, bool IsDefinition,
        -: 2934:          DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,
        -: 2935:          uint32_t AlignInBits, DINodeArray Annotations, StorageType Storage,
        -: 2936:          bool ShouldCreate = true) {
        -: 2937:    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),
        -: 2938:                   getCanonicalMDString(Context, LinkageName), File, Line, Type,
        -: 2939:                   IsLocalToUnit, IsDefinition, StaticDataMemberDeclaration,
        -: 2940:                   cast_or_null<Metadata>(TemplateParams), AlignInBits,
        -: 2941:                   Annotations.get(), Storage, ShouldCreate);
        -: 2942:  }
        -: 2943:  static DIGlobalVariable *
        -: 2944:  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,
        -: 2945:          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,
        -: 2946:          bool IsLocalToUnit, bool IsDefinition,
        -: 2947:          Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,
        -: 2948:          uint32_t AlignInBits, Metadata *Annotations, StorageType Storage,
        -: 2949:          bool ShouldCreate = true);
        -: 2950:
        -: 2951:  TempDIGlobalVariable cloneImpl() const {
        -: 2952:    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),
        -: 2953:                        getFile(), getLine(), getType(), isLocalToUnit(),
        -: 2954:                        isDefinition(), getStaticDataMemberDeclaration(),
        -: 2955:                        getTemplateParams(), getAlignInBits(),
        -: 2956:                        getAnnotations());
        -: 2957:  }
        -: 2958:
        -: 2959:public:
        -: 2960:  DEFINE_MDNODE_GET(
        -: 2961:      DIGlobalVariable,
        -: 2962:      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,
        -: 2963:       unsigned Line, DIType *Type, bool IsLocalToUnit, bool IsDefinition,
        -: 2964:       DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,
        -: 2965:       uint32_t AlignInBits, DINodeArray Annotations),
        -: 2966:      (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit, IsDefinition,
        -: 2967:       StaticDataMemberDeclaration, TemplateParams, AlignInBits, Annotations))
        -: 2968:  DEFINE_MDNODE_GET(
        -: 2969:      DIGlobalVariable,
        -: 2970:      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,
        -: 2971:       unsigned Line, Metadata *Type, bool IsLocalToUnit, bool IsDefinition,
        -: 2972:       Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,
        -: 2973:       uint32_t AlignInBits, Metadata *Annotations),
        -: 2974:      (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit, IsDefinition,
        -: 2975:       StaticDataMemberDeclaration, TemplateParams, AlignInBits, Annotations))
        -: 2976:
        -: 2977:  TempDIGlobalVariable clone() const { return cloneImpl(); }
        -: 2978:
        -: 2979:  bool isLocalToUnit() const { return IsLocalToUnit; }
        -: 2980:  bool isDefinition() const { return IsDefinition; }
        -: 2981:  StringRef getDisplayName() const { return getStringOperand(4); }
        -: 2982:  StringRef getLinkageName() const { return getStringOperand(5); }
        -: 2983:  DIDerivedType *getStaticDataMemberDeclaration() const {
        -: 2984:    return cast_or_null<DIDerivedType>(getRawStaticDataMemberDeclaration());
        -: 2985:  }
        -: 2986:  DINodeArray getAnnotations() const {
        -: 2987:    return cast_or_null<MDTuple>(getRawAnnotations());
        -: 2988:  }
        -: 2989:
        -: 2990:  MDString *getRawLinkageName() const { return getOperandAs<MDString>(5); }
        -: 2991:  Metadata *getRawStaticDataMemberDeclaration() const { return getOperand(6); }
        -: 2992:  Metadata *getRawTemplateParams() const { return getOperand(7); }
        -: 2993:  MDTuple *getTemplateParams() const { return getOperandAs<MDTuple>(7); }
        -: 2994:  Metadata *getRawAnnotations() const { return getOperand(8); }
        -: 2995:
        -: 2996:  static bool classof(const Metadata *MD) {
        -: 2997:    return MD->getMetadataID() == DIGlobalVariableKind;
        -: 2998:  }
        -: 2999:};
        -: 3000:
        -: 3001:class DICommonBlock : public DIScope {
        -: 3002:  unsigned LineNo;
        -: 3003:
        -: 3004:  friend class LLVMContextImpl;
        -: 3005:  friend class MDNode;
        -: 3006:
        -: 3007:  DICommonBlock(LLVMContext &Context, StorageType Storage, unsigned LineNo,
        -: 3008:                ArrayRef<Metadata *> Ops);
        -: 3009:
        -: 3010:  static DICommonBlock *getImpl(LLVMContext &Context, DIScope *Scope,
        -: 3011:                                DIGlobalVariable *Decl, StringRef Name,
        -: 3012:                                DIFile *File, unsigned LineNo,
        -: 3013:                                StorageType Storage, bool ShouldCreate = true) {
        -: 3014:    return getImpl(Context, Scope, Decl, getCanonicalMDString(Context, Name),
        -: 3015:                   File, LineNo, Storage, ShouldCreate);
        -: 3016:  }
        -: 3017:  static DICommonBlock *getImpl(LLVMContext &Context, Metadata *Scope,
        -: 3018:                                Metadata *Decl, MDString *Name, Metadata *File,
        -: 3019:                                unsigned LineNo, StorageType Storage,
        -: 3020:                                bool ShouldCreate = true);
        -: 3021:
        -: 3022:  TempDICommonBlock cloneImpl() const {
        -: 3023:    return getTemporary(getContext(), getScope(), getDecl(), getName(),
        -: 3024:                        getFile(), getLineNo());
        -: 3025:  }
        -: 3026:
        -: 3027:public:
        -: 3028:  DEFINE_MDNODE_GET(DICommonBlock,
        -: 3029:                    (DIScope * Scope, DIGlobalVariable *Decl, StringRef Name,
        -: 3030:                     DIFile *File, unsigned LineNo),
        -: 3031:                    (Scope, Decl, Name, File, LineNo))
        -: 3032:  DEFINE_MDNODE_GET(DICommonBlock,
        -: 3033:                    (Metadata * Scope, Metadata *Decl, MDString *Name,
        -: 3034:                     Metadata *File, unsigned LineNo),
        -: 3035:                    (Scope, Decl, Name, File, LineNo))
        -: 3036:
        -: 3037:  TempDICommonBlock clone() const { return cloneImpl(); }
        -: 3038:
        -: 3039:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 3040:  DIGlobalVariable *getDecl() const {
        -: 3041:    return cast_or_null<DIGlobalVariable>(getRawDecl());
        -: 3042:  }
        -: 3043:  StringRef getName() const { return getStringOperand(2); }
        -: 3044:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 3045:  unsigned getLineNo() const { return LineNo; }
        -: 3046:
        -: 3047:  Metadata *getRawScope() const { return getOperand(0); }
        -: 3048:  Metadata *getRawDecl() const { return getOperand(1); }
        -: 3049:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -: 3050:  Metadata *getRawFile() const { return getOperand(3); }
        -: 3051:
        -: 3052:  static bool classof(const Metadata *MD) {
        -: 3053:    return MD->getMetadataID() == DICommonBlockKind;
        -: 3054:  }
        -: 3055:};
        -: 3056:
        -: 3057:/// Local variable.
        -: 3058:///
        -: 3059:/// TODO: Split up flags.
        -: 3060:class DILocalVariable : public DIVariable {
        -: 3061:  friend class LLVMContextImpl;
        -: 3062:  friend class MDNode;
        -: 3063:
        -: 3064:  unsigned Arg : 16;
        -: 3065:  DIFlags Flags;
        -: 3066:
        -: 3067:  DILocalVariable(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 3068:                  unsigned Arg, DIFlags Flags, uint32_t AlignInBits,
        -: 3069:                  ArrayRef<Metadata *> Ops)
        -: 3070:      : DIVariable(C, DILocalVariableKind, Storage, Line, Ops, AlignInBits),
        -: 3071:        Arg(Arg), Flags(Flags) {
        -: 3072:    assert(Arg < (1 << 16) && "DILocalVariable: Arg out of range");
        -: 3073:  }
        -: 3074:  ~DILocalVariable() = default;
        -: 3075:
        -: 3076:  static DILocalVariable *getImpl(LLVMContext &Context, DIScope *Scope,
        -: 3077:                                  StringRef Name, DIFile *File, unsigned Line,
        -: 3078:                                  DIType *Type, unsigned Arg, DIFlags Flags,
        -: 3079:                                  uint32_t AlignInBits, DINodeArray Annotations,
        -: 3080:                                  StorageType Storage,
        -: 3081:                                  bool ShouldCreate = true) {
        -: 3082:    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,
        -: 3083:                   Line, Type, Arg, Flags, AlignInBits, Annotations.get(),
        -: 3084:                   Storage, ShouldCreate);
        -: 3085:  }
        -: 3086:  static DILocalVariable *getImpl(LLVMContext &Context, Metadata *Scope,
        -: 3087:                                  MDString *Name, Metadata *File, unsigned Line,
        -: 3088:                                  Metadata *Type, unsigned Arg, DIFlags Flags,
        -: 3089:                                  uint32_t AlignInBits, Metadata *Annotations,
        -: 3090:                                  StorageType Storage,
        -: 3091:                                  bool ShouldCreate = true);
        -: 3092:
        -: 3093:  TempDILocalVariable cloneImpl() const {
        -: 3094:    return getTemporary(getContext(), getScope(), getName(), getFile(),
        -: 3095:                        getLine(), getType(), getArg(), getFlags(),
        -: 3096:                        getAlignInBits(), getAnnotations());
        -: 3097:  }
        -: 3098:
        -: 3099:public:
        -: 3100:  DEFINE_MDNODE_GET(DILocalVariable,
        -: 3101:                    (DILocalScope * Scope, StringRef Name, DIFile *File,
        -: 3102:                     unsigned Line, DIType *Type, unsigned Arg, DIFlags Flags,
        -: 3103:                     uint32_t AlignInBits, DINodeArray Annotations),
        -: 3104:                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits,
        -: 3105:                     Annotations))
        -: 3106:  DEFINE_MDNODE_GET(DILocalVariable,
        -: 3107:                    (Metadata * Scope, MDString *Name, Metadata *File,
        -: 3108:                     unsigned Line, Metadata *Type, unsigned Arg, DIFlags Flags,
        -: 3109:                     uint32_t AlignInBits, Metadata *Annotations),
        -: 3110:                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits,
        -: 3111:                     Annotations))
        -: 3112:
        -: 3113:  TempDILocalVariable clone() const { return cloneImpl(); }
        -: 3114:
        -: 3115:  /// Get the local scope for this variable.
        -: 3116:  ///
        -: 3117:  /// Variables must be defined in a local scope.
        -: 3118:  DILocalScope *getScope() const {
        -: 3119:    return cast<DILocalScope>(DIVariable::getScope());
        -: 3120:  }
        -: 3121:
        -: 3122:  bool isParameter() const { return Arg; }
        -: 3123:  unsigned getArg() const { return Arg; }
        -: 3124:  DIFlags getFlags() const { return Flags; }
        -: 3125:
        -: 3126:  DINodeArray getAnnotations() const {
        -: 3127:    return cast_or_null<MDTuple>(getRawAnnotations());
        -: 3128:  }
        -: 3129:  Metadata *getRawAnnotations() const { return getOperand(4); }
        -: 3130:
        -: 3131:  bool isArtificial() const { return getFlags() & FlagArtificial; }
        -: 3132:  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }
        -: 3133:
        -: 3134:  /// Check that a location is valid for this variable.
        -: 3135:  ///
        -: 3136:  /// Check that \c DL exists, is in the same subprogram, and has the same
        -: 3137:  /// inlined-at location as \c this.  (Otherwise, it's not a valid attachment
        -: 3138:  /// to a \a DbgInfoIntrinsic.)
        -: 3139:  bool isValidLocationForIntrinsic(const DILocation *DL) const {
        -: 3140:    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();
        -: 3141:  }
        -: 3142:
        -: 3143:  static bool classof(const Metadata *MD) {
        -: 3144:    return MD->getMetadataID() == DILocalVariableKind;
        -: 3145:  }
        -: 3146:};
        -: 3147:
        -: 3148:/// Label.
        -: 3149:///
        -: 3150:class DILabel : public DINode {
        -: 3151:  friend class LLVMContextImpl;
        -: 3152:  friend class MDNode;
        -: 3153:
        -: 3154:  unsigned Line;
        -: 3155:
        -: 3156:  DILabel(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 3157:          ArrayRef<Metadata *> Ops);
        -: 3158:  ~DILabel() = default;
        -: 3159:
        -: 3160:  static DILabel *getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,
        -: 3161:                          DIFile *File, unsigned Line, StorageType Storage,
        -: 3162:                          bool ShouldCreate = true) {
        -: 3163:    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,
        -: 3164:                   Line, Storage, ShouldCreate);
        -: 3165:  }
        -: 3166:  static DILabel *getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,
        -: 3167:                          Metadata *File, unsigned Line, StorageType Storage,
        -: 3168:                          bool ShouldCreate = true);
        -: 3169:
        -: 3170:  TempDILabel cloneImpl() const {
        -: 3171:    return getTemporary(getContext(), getScope(), getName(), getFile(),
        -: 3172:                        getLine());
        -: 3173:  }
        -: 3174:
        -: 3175:public:
        -: 3176:  DEFINE_MDNODE_GET(DILabel,
        -: 3177:                    (DILocalScope * Scope, StringRef Name, DIFile *File,
        -: 3178:                     unsigned Line),
        -: 3179:                    (Scope, Name, File, Line))
        -: 3180:  DEFINE_MDNODE_GET(DILabel,
        -: 3181:                    (Metadata * Scope, MDString *Name, Metadata *File,
        -: 3182:                     unsigned Line),
        -: 3183:                    (Scope, Name, File, Line))
        -: 3184:
        -: 3185:  TempDILabel clone() const { return cloneImpl(); }
        -: 3186:
        -: 3187:  /// Get the local scope for this label.
        -: 3188:  ///
        -: 3189:  /// Labels must be defined in a local scope.
        -: 3190:  DILocalScope *getScope() const {
        -: 3191:    return cast_or_null<DILocalScope>(getRawScope());
        -: 3192:  }
        -: 3193:  unsigned getLine() const { return Line; }
        -: 3194:  StringRef getName() const { return getStringOperand(1); }
        -: 3195:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 3196:
        -: 3197:  Metadata *getRawScope() const { return getOperand(0); }
        -: 3198:  MDString *getRawName() const { return getOperandAs<MDString>(1); }
        -: 3199:  Metadata *getRawFile() const { return getOperand(2); }
        -: 3200:
        -: 3201:  /// Check that a location is valid for this label.
        -: 3202:  ///
        -: 3203:  /// Check that \c DL exists, is in the same subprogram, and has the same
        -: 3204:  /// inlined-at location as \c this.  (Otherwise, it's not a valid attachment
        -: 3205:  /// to a \a DbgInfoIntrinsic.)
        -: 3206:  bool isValidLocationForIntrinsic(const DILocation *DL) const {
        -: 3207:    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();
        -: 3208:  }
        -: 3209:
        -: 3210:  static bool classof(const Metadata *MD) {
        -: 3211:    return MD->getMetadataID() == DILabelKind;
        -: 3212:  }
        -: 3213:};
        -: 3214:
        -: 3215:class DIObjCProperty : public DINode {
        -: 3216:  friend class LLVMContextImpl;
        -: 3217:  friend class MDNode;
        -: 3218:
        -: 3219:  unsigned Line;
        -: 3220:  unsigned Attributes;
        -: 3221:
        -: 3222:  DIObjCProperty(LLVMContext &C, StorageType Storage, unsigned Line,
        -: 3223:                 unsigned Attributes, ArrayRef<Metadata *> Ops);
        -: 3224:  ~DIObjCProperty() = default;
        -: 3225:
        -: 3226:  static DIObjCProperty *
        -: 3227:  getImpl(LLVMContext &Context, StringRef Name, DIFile *File, unsigned Line,
        -: 3228:          StringRef GetterName, StringRef SetterName, unsigned Attributes,
        -: 3229:          DIType *Type, StorageType Storage, bool ShouldCreate = true) {
        -: 3230:    return getImpl(Context, getCanonicalMDString(Context, Name), File, Line,
        -: 3231:                   getCanonicalMDString(Context, GetterName),
        -: 3232:                   getCanonicalMDString(Context, SetterName), Attributes, Type,
        -: 3233:                   Storage, ShouldCreate);
        -: 3234:  }
        -: 3235:  static DIObjCProperty *getImpl(LLVMContext &Context, MDString *Name,
        -: 3236:                                 Metadata *File, unsigned Line,
        -: 3237:                                 MDString *GetterName, MDString *SetterName,
        -: 3238:                                 unsigned Attributes, Metadata *Type,
        -: 3239:                                 StorageType Storage, bool ShouldCreate = true);
        -: 3240:
        -: 3241:  TempDIObjCProperty cloneImpl() const {
        -: 3242:    return getTemporary(getContext(), getName(), getFile(), getLine(),
        -: 3243:                        getGetterName(), getSetterName(), getAttributes(),
        -: 3244:                        getType());
        -: 3245:  }
        -: 3246:
        -: 3247:public:
        -: 3248:  DEFINE_MDNODE_GET(DIObjCProperty,
        -: 3249:                    (StringRef Name, DIFile *File, unsigned Line,
        -: 3250:                     StringRef GetterName, StringRef SetterName,
        -: 3251:                     unsigned Attributes, DIType *Type),
        -: 3252:                    (Name, File, Line, GetterName, SetterName, Attributes,
        -: 3253:                     Type))
        -: 3254:  DEFINE_MDNODE_GET(DIObjCProperty,
        -: 3255:                    (MDString * Name, Metadata *File, unsigned Line,
        -: 3256:                     MDString *GetterName, MDString *SetterName,
        -: 3257:                     unsigned Attributes, Metadata *Type),
        -: 3258:                    (Name, File, Line, GetterName, SetterName, Attributes,
        -: 3259:                     Type))
        -: 3260:
        -: 3261:  TempDIObjCProperty clone() const { return cloneImpl(); }
        -: 3262:
        -: 3263:  unsigned getLine() const { return Line; }
        -: 3264:  unsigned getAttributes() const { return Attributes; }
        -: 3265:  StringRef getName() const { return getStringOperand(0); }
        -: 3266:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 3267:  StringRef getGetterName() const { return getStringOperand(2); }
        -: 3268:  StringRef getSetterName() const { return getStringOperand(3); }
        -: 3269:  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }
        -: 3270:
        -: 3271:  StringRef getFilename() const {
        -: 3272:    if (auto *F = getFile())
        -: 3273:      return F->getFilename();
        -: 3274:    return "";
        -: 3275:  }
        -: 3276:
        -: 3277:  StringRef getDirectory() const {
        -: 3278:    if (auto *F = getFile())
        -: 3279:      return F->getDirectory();
        -: 3280:    return "";
        -: 3281:  }
        -: 3282:
        -: 3283:  MDString *getRawName() const { return getOperandAs<MDString>(0); }
        -: 3284:  Metadata *getRawFile() const { return getOperand(1); }
        -: 3285:  MDString *getRawGetterName() const { return getOperandAs<MDString>(2); }
        -: 3286:  MDString *getRawSetterName() const { return getOperandAs<MDString>(3); }
        -: 3287:  Metadata *getRawType() const { return getOperand(4); }
        -: 3288:
        -: 3289:  static bool classof(const Metadata *MD) {
        -: 3290:    return MD->getMetadataID() == DIObjCPropertyKind;
        -: 3291:  }
        -: 3292:};
        -: 3293:
        -: 3294:/// An imported module (C++ using directive or similar).
        -: 3295:class DIImportedEntity : public DINode {
        -: 3296:  friend class LLVMContextImpl;
        -: 3297:  friend class MDNode;
        -: 3298:
        -: 3299:  unsigned Line;
        -: 3300:
        -: 3301:  DIImportedEntity(LLVMContext &C, StorageType Storage, unsigned Tag,
        -: 3302:                   unsigned Line, ArrayRef<Metadata *> Ops)
        -: 3303:      : DINode(C, DIImportedEntityKind, Storage, Tag, Ops), Line(Line) {}
        -: 3304:  ~DIImportedEntity() = default;
        -: 3305:
        -: 3306:  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,
        -: 3307:                                   DIScope *Scope, DINode *Entity, DIFile *File,
        -: 3308:                                   unsigned Line, StringRef Name,
        -: 3309:                                   DINodeArray Elements, StorageType Storage,
        -: 3310:                                   bool ShouldCreate = true) {
        -: 3311:    return getImpl(Context, Tag, Scope, Entity, File, Line,
        -: 3312:                   getCanonicalMDString(Context, Name), Elements.get(), Storage,
        -: 3313:                   ShouldCreate);
        -: 3314:  }
        -: 3315:  static DIImportedEntity *
        -: 3316:  getImpl(LLVMContext &Context, unsigned Tag, Metadata *Scope, Metadata *Entity,
        -: 3317:          Metadata *File, unsigned Line, MDString *Name, Metadata *Elements,
        -: 3318:          StorageType Storage, bool ShouldCreate = true);
        -: 3319:
        -: 3320:  TempDIImportedEntity cloneImpl() const {
        -: 3321:    return getTemporary(getContext(), getTag(), getScope(), getEntity(),
        -: 3322:                        getFile(), getLine(), getName(), getElements());
        -: 3323:  }
        -: 3324:
        -: 3325:public:
        -: 3326:  DEFINE_MDNODE_GET(DIImportedEntity,
        -: 3327:                    (unsigned Tag, DIScope *Scope, DINode *Entity, DIFile *File,
        -: 3328:                     unsigned Line, StringRef Name = "",
        -: 3329:                     DINodeArray Elements = nullptr),
        -: 3330:                    (Tag, Scope, Entity, File, Line, Name, Elements))
        -: 3331:  DEFINE_MDNODE_GET(DIImportedEntity,
        -: 3332:                    (unsigned Tag, Metadata *Scope, Metadata *Entity,
        -: 3333:                     Metadata *File, unsigned Line, MDString *Name,
        -: 3334:                     Metadata *Elements = nullptr),
        -: 3335:                    (Tag, Scope, Entity, File, Line, Name, Elements))
        -: 3336:
        -: 3337:  TempDIImportedEntity clone() const { return cloneImpl(); }
        -: 3338:
        -: 3339:  unsigned getLine() const { return Line; }
        -: 3340:  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }
        -: 3341:  DINode *getEntity() const { return cast_or_null<DINode>(getRawEntity()); }
        -: 3342:  StringRef getName() const { return getStringOperand(2); }
        -: 3343:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 3344:  DINodeArray getElements() const {
        -: 3345:    return cast_or_null<MDTuple>(getRawElements());
        -: 3346:  }
        -: 3347:
        -: 3348:  Metadata *getRawScope() const { return getOperand(0); }
        -: 3349:  Metadata *getRawEntity() const { return getOperand(1); }
        -: 3350:  MDString *getRawName() const { return getOperandAs<MDString>(2); }
        -: 3351:  Metadata *getRawFile() const { return getOperand(3); }
        -: 3352:  Metadata *getRawElements() const { return getOperand(4); }
        -: 3353:
        -: 3354:  static bool classof(const Metadata *MD) {
        -: 3355:    return MD->getMetadataID() == DIImportedEntityKind;
        -: 3356:  }
        -: 3357:};
        -: 3358:
        -: 3359:/// A pair of DIGlobalVariable and DIExpression.
        -: 3360:class DIGlobalVariableExpression : public MDNode {
        -: 3361:  friend class LLVMContextImpl;
        -: 3362:  friend class MDNode;
        -: 3363:
        -: 3364:  DIGlobalVariableExpression(LLVMContext &C, StorageType Storage,
        -: 3365:                             ArrayRef<Metadata *> Ops)
        -: 3366:      : MDNode(C, DIGlobalVariableExpressionKind, Storage, Ops) {}
        -: 3367:  ~DIGlobalVariableExpression() = default;
        -: 3368:
        -: 3369:  static DIGlobalVariableExpression *
        -: 3370:  getImpl(LLVMContext &Context, Metadata *Variable, Metadata *Expression,
        -: 3371:          StorageType Storage, bool ShouldCreate = true);
        -: 3372:
        -: 3373:  TempDIGlobalVariableExpression cloneImpl() const {
        -: 3374:    return getTemporary(getContext(), getVariable(), getExpression());
        -: 3375:  }
        -: 3376:
        -: 3377:public:
        -: 3378:  DEFINE_MDNODE_GET(DIGlobalVariableExpression,
        -: 3379:                    (Metadata * Variable, Metadata *Expression),
        -: 3380:                    (Variable, Expression))
        -: 3381:
        -: 3382:  TempDIGlobalVariableExpression clone() const { return cloneImpl(); }
        -: 3383:
        -: 3384:  Metadata *getRawVariable() const { return getOperand(0); }
        -: 3385:
        -: 3386:  DIGlobalVariable *getVariable() const {
        -: 3387:    return cast_or_null<DIGlobalVariable>(getRawVariable());
        -: 3388:  }
        -: 3389:
        -: 3390:  Metadata *getRawExpression() const { return getOperand(1); }
        -: 3391:
        -: 3392:  DIExpression *getExpression() const {
        -: 3393:    return cast<DIExpression>(getRawExpression());
        -: 3394:  }
        -: 3395:
        -: 3396:  static bool classof(const Metadata *MD) {
        -: 3397:    return MD->getMetadataID() == DIGlobalVariableExpressionKind;
        -: 3398:  }
        -: 3399:};
        -: 3400:
        -: 3401:/// Macro Info DWARF-like metadata node.
        -: 3402:///
        -: 3403:/// A metadata node with a DWARF macro info (i.e., a constant named
        -: 3404:/// \c DW_MACINFO_*, defined in llvm/BinaryFormat/Dwarf.h).  Called \a
        -: 3405:/// DIMacroNode
        -: 3406:/// because it's potentially used for non-DWARF output.
        -: 3407:class DIMacroNode : public MDNode {
        -: 3408:  friend class LLVMContextImpl;
        -: 3409:  friend class MDNode;
        -: 3410:
        -: 3411:protected:
        -: 3412:  DIMacroNode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned MIType,
        -: 3413:              ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)
        -: 3414:      : MDNode(C, ID, Storage, Ops1, Ops2) {
        -: 3415:    assert(MIType < 1u << 16);
        -: 3416:    SubclassData16 = MIType;
        -: 3417:  }
        -: 3418:  ~DIMacroNode() = default;
        -: 3419:
        -: 3420:  template <class Ty> Ty *getOperandAs(unsigned I) const {
        -: 3421:    return cast_or_null<Ty>(getOperand(I));
        -: 3422:  }
        -: 3423:
        -: 3424:  StringRef getStringOperand(unsigned I) const {
        -: 3425:    if (auto *S = getOperandAs<MDString>(I))
        -: 3426:      return S->getString();
        -: 3427:    return StringRef();
        -: 3428:  }
        -: 3429:
        -: 3430:  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {
        -: 3431:    if (S.empty())
        -: 3432:      return nullptr;
        -: 3433:    return MDString::get(Context, S);
        -: 3434:  }
        -: 3435:
        -: 3436:public:
        -: 3437:  unsigned getMacinfoType() const { return SubclassData16; }
        -: 3438:
        -: 3439:  static bool classof(const Metadata *MD) {
        -: 3440:    switch (MD->getMetadataID()) {
        -: 3441:    default:
        -: 3442:      return false;
        -: 3443:    case DIMacroKind:
        -: 3444:    case DIMacroFileKind:
        -: 3445:      return true;
        -: 3446:    }
        -: 3447:  }
        -: 3448:};
        -: 3449:
        -: 3450:class DIMacro : public DIMacroNode {
        -: 3451:  friend class LLVMContextImpl;
        -: 3452:  friend class MDNode;
        -: 3453:
        -: 3454:  unsigned Line;
        -: 3455:
        -: 3456:  DIMacro(LLVMContext &C, StorageType Storage, unsigned MIType, unsigned Line,
        -: 3457:          ArrayRef<Metadata *> Ops)
        -: 3458:      : DIMacroNode(C, DIMacroKind, Storage, MIType, Ops), Line(Line) {}
        -: 3459:  ~DIMacro() = default;
        -: 3460:
        -: 3461:  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,
        -: 3462:                          StringRef Name, StringRef Value, StorageType Storage,
        -: 3463:                          bool ShouldCreate = true) {
        -: 3464:    return getImpl(Context, MIType, Line, getCanonicalMDString(Context, Name),
        -: 3465:                   getCanonicalMDString(Context, Value), Storage, ShouldCreate);
        -: 3466:  }
        -: 3467:  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,
        -: 3468:                          MDString *Name, MDString *Value, StorageType Storage,
        -: 3469:                          bool ShouldCreate = true);
        -: 3470:
        -: 3471:  TempDIMacro cloneImpl() const {
        -: 3472:    return getTemporary(getContext(), getMacinfoType(), getLine(), getName(),
        -: 3473:                        getValue());
        -: 3474:  }
        -: 3475:
        -: 3476:public:
        -: 3477:  DEFINE_MDNODE_GET(DIMacro,
        -: 3478:                    (unsigned MIType, unsigned Line, StringRef Name,
        -: 3479:                     StringRef Value = ""),
        -: 3480:                    (MIType, Line, Name, Value))
        -: 3481:  DEFINE_MDNODE_GET(DIMacro,
        -: 3482:                    (unsigned MIType, unsigned Line, MDString *Name,
        -: 3483:                     MDString *Value),
        -: 3484:                    (MIType, Line, Name, Value))
        -: 3485:
        -: 3486:  TempDIMacro clone() const { return cloneImpl(); }
        -: 3487:
        -: 3488:  unsigned getLine() const { return Line; }
        -: 3489:
        -: 3490:  StringRef getName() const { return getStringOperand(0); }
        -: 3491:  StringRef getValue() const { return getStringOperand(1); }
        -: 3492:
        -: 3493:  MDString *getRawName() const { return getOperandAs<MDString>(0); }
        -: 3494:  MDString *getRawValue() const { return getOperandAs<MDString>(1); }
        -: 3495:
        -: 3496:  static bool classof(const Metadata *MD) {
        -: 3497:    return MD->getMetadataID() == DIMacroKind;
        -: 3498:  }
        -: 3499:};
        -: 3500:
        -: 3501:class DIMacroFile : public DIMacroNode {
        -: 3502:  friend class LLVMContextImpl;
        -: 3503:  friend class MDNode;
        -: 3504:
        -: 3505:  unsigned Line;
        -: 3506:
        -: 3507:  DIMacroFile(LLVMContext &C, StorageType Storage, unsigned MIType,
        -: 3508:              unsigned Line, ArrayRef<Metadata *> Ops)
        -: 3509:      : DIMacroNode(C, DIMacroFileKind, Storage, MIType, Ops), Line(Line) {}
        -: 3510:  ~DIMacroFile() = default;
        -: 3511:
        -: 3512:  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,
        -: 3513:                              unsigned Line, DIFile *File,
        -: 3514:                              DIMacroNodeArray Elements, StorageType Storage,
        -: 3515:                              bool ShouldCreate = true) {
        -: 3516:    return getImpl(Context, MIType, Line, static_cast<Metadata *>(File),
        -: 3517:                   Elements.get(), Storage, ShouldCreate);
        -: 3518:  }
        -: 3519:
        -: 3520:  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,
        -: 3521:                              unsigned Line, Metadata *File, Metadata *Elements,
        -: 3522:                              StorageType Storage, bool ShouldCreate = true);
        -: 3523:
        -: 3524:  TempDIMacroFile cloneImpl() const {
        -: 3525:    return getTemporary(getContext(), getMacinfoType(), getLine(), getFile(),
        -: 3526:                        getElements());
        -: 3527:  }
        -: 3528:
        -: 3529:public:
        -: 3530:  DEFINE_MDNODE_GET(DIMacroFile,
        -: 3531:                    (unsigned MIType, unsigned Line, DIFile *File,
        -: 3532:                     DIMacroNodeArray Elements),
        -: 3533:                    (MIType, Line, File, Elements))
        -: 3534:  DEFINE_MDNODE_GET(DIMacroFile,
        -: 3535:                    (unsigned MIType, unsigned Line, Metadata *File,
        -: 3536:                     Metadata *Elements),
        -: 3537:                    (MIType, Line, File, Elements))
        -: 3538:
        -: 3539:  TempDIMacroFile clone() const { return cloneImpl(); }
        -: 3540:
        -: 3541:  void replaceElements(DIMacroNodeArray Elements) {
        -: 3542:#ifndef NDEBUG
        -: 3543:    for (DIMacroNode *Op : getElements())
        -: 3544:      assert(is_contained(Elements->operands(), Op) &&
        -: 3545:             "Lost a macro node during macro node list replacement");
        -: 3546:#endif
        -: 3547:    replaceOperandWith(1, Elements.get());
        -: 3548:  }
        -: 3549:
        -: 3550:  unsigned getLine() const { return Line; }
        -: 3551:  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }
        -: 3552:
        -: 3553:  DIMacroNodeArray getElements() const {
        -: 3554:    return cast_or_null<MDTuple>(getRawElements());
        -: 3555:  }
        -: 3556:
        -: 3557:  Metadata *getRawFile() const { return getOperand(0); }
        -: 3558:  Metadata *getRawElements() const { return getOperand(1); }
        -: 3559:
        -: 3560:  static bool classof(const Metadata *MD) {
        -: 3561:    return MD->getMetadataID() == DIMacroFileKind;
        -: 3562:  }
        -: 3563:};
        -: 3564:
        -: 3565:/// List of ValueAsMetadata, to be used as an argument to a dbg.value
        -: 3566:/// intrinsic.
        -: 3567:class DIArgList : public MDNode {
        -: 3568:  friend class LLVMContextImpl;
        -: 3569:  friend class MDNode;
        -: 3570:  using iterator = SmallVectorImpl<ValueAsMetadata *>::iterator;
        -: 3571:
        -: 3572:  SmallVector<ValueAsMetadata *, 4> Args;
        -: 3573:
        -: 3574:  DIArgList(LLVMContext &C, StorageType Storage,
        -: 3575:            ArrayRef<ValueAsMetadata *> Args)
        -: 3576:      : MDNode(C, DIArgListKind, Storage, None),
        -: 3577:        Args(Args.begin(), Args.end()) {
        -: 3578:    track();
        -: 3579:  }
        -: 3580:  ~DIArgList() { untrack(); }
        -: 3581:
        -: 3582:  static DIArgList *getImpl(LLVMContext &Context,
        -: 3583:                            ArrayRef<ValueAsMetadata *> Args,
        -: 3584:                            StorageType Storage, bool ShouldCreate = true);
        -: 3585:
        -: 3586:  TempDIArgList cloneImpl() const {
        -: 3587:    return getTemporary(getContext(), getArgs());
        -: 3588:  }
        -: 3589:
        -: 3590:  void track();
        -: 3591:  void untrack();
        -: 3592:  void dropAllReferences();
        -: 3593:
        -: 3594:public:
        -: 3595:  DEFINE_MDNODE_GET(DIArgList, (ArrayRef<ValueAsMetadata *> Args), (Args))
        -: 3596:
        -: 3597:  TempDIArgList clone() const { return cloneImpl(); }
        -: 3598:
        -: 3599:  ArrayRef<ValueAsMetadata *> getArgs() const { return Args; }
        -: 3600:
        -: 3601:  iterator args_begin() { return Args.begin(); }
        -: 3602:  iterator args_end() { return Args.end(); }
        -: 3603:
        -: 3604:  static bool classof(const Metadata *MD) {
        -: 3605:    return MD->getMetadataID() == DIArgListKind;
        -: 3606:  }
        -: 3607:
        -: 3608:  void handleChangedOperand(void *Ref, Metadata *New);
        -: 3609:};
        -: 3610:
        -: 3611:/// Identifies a unique instance of a variable.
        -: 3612:///
        -: 3613:/// Storage for identifying a potentially inlined instance of a variable,
        -: 3614:/// or a fragment thereof. This guarantees that exactly one variable instance
        -: 3615:/// may be identified by this class, even when that variable is a fragment of
        -: 3616:/// an aggregate variable and/or there is another inlined instance of the same
        -: 3617:/// source code variable nearby.
        -: 3618:/// This class does not necessarily uniquely identify that variable: it is
        -: 3619:/// possible that a DebugVariable with different parameters may point to the
        -: 3620:/// same variable instance, but not that one DebugVariable points to multiple
        -: 3621:/// variable instances.
        -: 3622:class DebugVariable {
        -: 3623:  using FragmentInfo = DIExpression::FragmentInfo;
        -: 3624:
        -: 3625:  const DILocalVariable *Variable;
        -: 3626:  Optional<FragmentInfo> Fragment;
        -: 3627:  const DILocation *InlinedAt;
        -: 3628:
        -: 3629:  /// Fragment that will overlap all other fragments. Used as default when
        -: 3630:  /// caller demands a fragment.
        -: 3631:  static const FragmentInfo DefaultFragment;
        -: 3632:
        -: 3633:public:
        -: 3634:  DebugVariable(const DbgVariableIntrinsic *DII);
        -: 3635:
        -: 3636:  DebugVariable(const DILocalVariable *Var, Optional<FragmentInfo> FragmentInfo,
        -: 3637:                const DILocation *InlinedAt)
        -: 3638:      : Variable(Var), Fragment(FragmentInfo), InlinedAt(InlinedAt) {}
        -: 3639:
        -: 3640:  DebugVariable(const DILocalVariable *Var, const DIExpression *DIExpr,
        -: 3641:                const DILocation *InlinedAt)
        -: 3642:      : Variable(Var),
        -: 3643:        Fragment(DIExpr ? DIExpr->getFragmentInfo() : NoneType()),
        -: 3644:        InlinedAt(InlinedAt) {}
        -: 3645:
        -: 3646:  const DILocalVariable *getVariable() const { return Variable; }
        -: 3647:  Optional<FragmentInfo> getFragment() const { return Fragment; }
        -: 3648:  const DILocation *getInlinedAt() const { return InlinedAt; }
        -: 3649:
        -: 3650:  FragmentInfo getFragmentOrDefault() const {
        -: 3651:    return Fragment.value_or(DefaultFragment);
        -: 3652:  }
        -: 3653:
        -: 3654:  static bool isDefaultFragment(const FragmentInfo F) {
        -: 3655:    return F == DefaultFragment;
        -: 3656:  }
        -: 3657:
        -: 3658:  bool operator==(const DebugVariable &Other) const {
        -: 3659:    return std::tie(Variable, Fragment, InlinedAt) ==
        -: 3660:           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);
        -: 3661:  }
        -: 3662:
        -: 3663:  bool operator<(const DebugVariable &Other) const {
        -: 3664:    return std::tie(Variable, Fragment, InlinedAt) <
        -: 3665:           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);
        -: 3666:  }
        -: 3667:};
        -: 3668:
        -: 3669:template <> struct DenseMapInfo<DebugVariable> {
        -: 3670:  using FragmentInfo = DIExpression::FragmentInfo;
        -: 3671:
        -: 3672:  /// Empty key: no key should be generated that has no DILocalVariable.
        -: 3673:  static inline DebugVariable getEmptyKey() {
        -: 3674:    return DebugVariable(nullptr, NoneType(), nullptr);
        -: 3675:  }
        -: 3676:
        -: 3677:  /// Difference in tombstone is that the Optional is meaningful.
        -: 3678:  static inline DebugVariable getTombstoneKey() {
        -: 3679:    return DebugVariable(nullptr, {{0, 0}}, nullptr);
        -: 3680:  }
        -: 3681:
        -: 3682:  static unsigned getHashValue(const DebugVariable &D) {
        -: 3683:    unsigned HV = 0;
        -: 3684:    const Optional<FragmentInfo> Fragment = D.getFragment();
        -: 3685:    if (Fragment)
        -: 3686:      HV = DenseMapInfo<FragmentInfo>::getHashValue(*Fragment);
        -: 3687:
        -: 3688:    return hash_combine(D.getVariable(), HV, D.getInlinedAt());
        -: 3689:  }
        -: 3690:
        -: 3691:  static bool isEqual(const DebugVariable &A, const DebugVariable &B) {
        -: 3692:    return A == B;
        -: 3693:  }
        -: 3694:};
        -: 3695:
        -: 3696:} // end namespace llvm
        -: 3697:
        -: 3698:#undef DEFINE_MDNODE_GET_UNPACK_IMPL
        -: 3699:#undef DEFINE_MDNODE_GET_UNPACK
        -: 3700:#undef DEFINE_MDNODE_GET
        -: 3701:
        -: 3702:#endif // LLVM_IR_DEBUGINFOMETADATA_H
