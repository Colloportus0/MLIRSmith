        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorConversion.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SparseTensor/Transforms/CMakeFiles/obj.MLIRSparseTensorTransforms.dir/SparseTensorConversion.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SparseTensor/Transforms/CMakeFiles/obj.MLIRSparseTensorTransforms.dir/SparseTensorConversion.cpp.gcda
        -:    0:Runs:128629
        -:    1://===- SparseTensorConversion.cpp - Sparse tensor primitives conversion ---===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// A pass that converts sparse tensor primitives into calls into a runtime
        -:   10:// support library. Sparse tensor types are converted into opaque pointers
        -:   11:// to the underlying sparse storage schemes. The use of opaque pointers
        -:   12:// together with runtime support library keeps the conversion relatively
        -:   13:// simple, but at the expense of IR opacity, which obscures opportunities
        -:   14:// for subsequent optimization of the IR. An alternative is provided by
        -:   15:// the SparseTensorCodegen pass.
        -:   16://
        -:   17://===----------------------------------------------------------------------===//
        -:   18:
        -:   19:#include "CodegenUtils.h"
        -:   20:
        -:   21:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h"
        -:   22:#include "mlir/Dialect/Bufferization/IR/Bufferization.h"
        -:   23:#include "mlir/Dialect/Linalg/Utils/Utils.h"
        -:   24:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   25:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   26:#include "mlir/Dialect/SparseTensor/IR/Enums.h"
        -:   27:#include "mlir/Dialect/SparseTensor/IR/SparseTensor.h"
        -:   28:#include "mlir/Dialect/SparseTensor/Transforms/Passes.h"
        -:   29:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   30:#include "mlir/Transforms/DialectConversion.h"
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace mlir::sparse_tensor;
        -:   34:
        -:   35:namespace {
        -:   36:
        -:   37://===----------------------------------------------------------------------===//
        -:   38:// Helper methods.
        -:   39://===----------------------------------------------------------------------===//
        -:   40:
        -:   41:/// Maps each sparse tensor type to an opaque pointer.
function _ZN12_GLOBAL__N_1L24convertSparseTensorTypesEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:   42:static Optional<Type> convertSparseTensorTypes(Type type) {
    #####:   43:  if (getSparseTensorEncoding(type) != nullptr)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   44:    return LLVM::LLVMPointerType::get(IntegerType::get(type.getContext(), 8));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   45:  return llvm::None;
        -:   46:}
        -:   47:
        -:   48:/// Replaces the `op` with  a `CallOp` to the function reference returned
        -:   49:/// by `getFunc()`.
function _ZN12_GLOBAL__N_1L21replaceOpWithFuncCallERN4mlir12RewriterBaseEPNS0_9OperationEN4llvm9StringRefENS0_9TypeRangeENS0_10ValueRangeENS0_13sparse_tensor14EmitCInterfaceE called 0 returned 0% blocks executed 0%
    #####:   50:static func::CallOp replaceOpWithFuncCall(RewriterBase &rewriter, Operation *op,
        -:   51:                                          StringRef name, TypeRange resultType,
        -:   52:                                          ValueRange operands,
        -:   53:                                          EmitCInterface emitCInterface) {
    #####:   54:  auto fn = getFunc(op->getParentOfType<ModuleOp>(), name, resultType, operands,
    #####:   55:                    emitCInterface);
call    0 never executed
call    1 never executed
    #####:   56:  return rewriter.replaceOpWithNewOp<func::CallOp>(op, resultType, fn,
    #####:   57:                                                   operands);
call    0 never executed
        -:   58:}
        -:   59:
        -:   60:/// Generates dimension size call.
function _ZN12_GLOBAL__N_1L14genDimSizeCallERN4mlir9OpBuilderENS0_8LocationERNS0_13sparse_tensor24SparseTensorEncodingAttrENS0_5ValueEm called 0 returned 0% blocks executed 0%
    #####:   61:static Value genDimSizeCall(OpBuilder &builder, Location loc,
        -:   62:                            SparseTensorEncodingAttr &enc, Value src,
        -:   63:                            uint64_t idx) {
        -:   64:  // Generate the call.
    #####:   65:  StringRef name = "sparseDimSize";
call    0 never executed
    #####:   66:  SmallVector<Value, 2> params{
    #####:   67:      src, constantIndex(builder, loc, toStoredDim(enc, idx))};
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   68:  Type iTp = builder.getIndexType();
call    0 never executed
    #####:   69:  return createFuncCall(builder, loc, name, iTp, params, EmitCInterface::Off)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   70:      .getResult(0);
branch  0 never executed
branch  1 never executed
        -:   71:}
        -:   72:
        -:   73:/// Generates a call into the "swiss army knife" method of the sparse runtime
        -:   74:/// support library for materializing sparse tensors into the computation.
function _ZN12_GLOBAL__N_1L10genNewCallERN4mlir9OpBuilderENS0_8LocationEN4llvm8ArrayRefINS0_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:   75:static Value genNewCall(OpBuilder &builder, Location loc,
        -:   76:                        ArrayRef<Value> params) {
    #####:   77:  StringRef name = "newSparseTensor";
call    0 never executed
    #####:   78:  Type pTp = getOpaquePointerType(builder);
call    0 never executed
    #####:   79:  return createFuncCall(builder, loc, name, pTp, params, EmitCInterface::On)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   80:      .getResult(0);
        -:   81:}
        -:   82:
        -:   83:/// Compute the size from type (for static sizes) or from an already-converted
        -:   84:/// opaque pointer source (for dynamic sizes) at the given dimension.
function _ZN12_GLOBAL__N_1L16sizeFromPtrAtDimERN4mlir9OpBuilderENS0_8LocationERNS0_13sparse_tensor24SparseTensorEncodingAttrENS0_10ShapedTypeENS0_5ValueEj called 0 returned 0% blocks executed 0%
    #####:   85:static Value sizeFromPtrAtDim(OpBuilder &builder, Location loc,
        -:   86:                              SparseTensorEncodingAttr &enc, ShapedType stp,
        -:   87:                              Value src, unsigned dim) {
    #####:   88:  auto shape = stp.getShape();
call    0 never executed
    #####:   89:  if (shape[dim] == ShapedType::kDynamicSize)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   90:    return genDimSizeCall(builder, loc, enc, src, dim);
call    0 never executed
    #####:   91:  return constantIndex(builder, loc, shape[dim]);
call    0 never executed
        -:   92:}
        -:   93:
        -:   94:/// Populates given sizes array from type (for static sizes) and from
        -:   95:/// an already-converted opaque pointer source (for dynamic sizes).
function _ZN12_GLOBAL__N_1L12sizesFromPtrERN4mlir9OpBuilderERN4llvm11SmallVectorINS0_5ValueELj4EEENS0_8LocationERNS0_13sparse_tensor24SparseTensorEncodingAttrENS0_10ShapedTypeES5_ called 0 returned 0% blocks executed 0%
    #####:   96:static void sizesFromPtr(OpBuilder &builder, SmallVector<Value, 4> &sizes,
        -:   97:                         Location loc, SparseTensorEncodingAttr &enc,
        -:   98:                         ShapedType stp, Value src) {
    #####:   99:  for (unsigned i = 0, rank = stp.getRank(); i < rank; i++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:    sizes.push_back(sizeFromPtrAtDim(builder, loc, enc, stp, src, i));
call    0 never executed
call    1 never executed
    #####:  101:}
        -:  102:
        -:  103:/// Populates given sizes array from type.
function _ZN12_GLOBAL__N_1L13sizesFromTypeERN4mlir9OpBuilderERN4llvm11SmallVectorINS0_5ValueELj4EEENS0_8LocationENS0_10ShapedTypeE called 0 returned 0% blocks executed 0%
    #####:  104:static void sizesFromType(OpBuilder &builder, SmallVector<Value, 4> &sizes,
        -:  105:                          Location loc, ShapedType stp) {
    #####:  106:  auto shape = stp.getShape();
call    0 never executed
    #####:  107:  for (unsigned i = 0, rank = stp.getRank(); i < rank; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:    uint64_t s = shape[i] == ShapedType::kDynamicSize ? 0 : shape[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  109:    sizes.push_back(constantIndex(builder, loc, s));
call    0 never executed
call    1 never executed
        -:  110:  }
    #####:  111:}
        -:  112:
        -:  113:/// Populates the given sizes array for concatenation from type (for static
        -:  114:/// sizes) and from an already-converted opaque pointer source (for dynamic
        -:  115:/// sizes).
function _ZN12_GLOBAL__N_1L21concatSizesFromInputsERN4mlir9OpBuilderERN4llvm11SmallVectorINS0_5ValueELj4EEENS0_8LocationENS0_10ShapedTypeENS0_10ValueRangeEj called 0 returned 0% blocks executed 0%
    #####:  116:static void concatSizesFromInputs(OpBuilder &builder,
        -:  117:                                  SmallVector<Value, 4> &sizes, Location loc,
        -:  118:                                  ShapedType dstTp, ValueRange srcs,
        -:  119:                                  unsigned dim) {
    #####:  120:  auto dstShape = dstTp.getShape();
call    0 never executed
        -:  121:
    #####:  122:  auto srcTp = srcs[0].getType().cast<ShapedType>();
call    0 never executed
call    1 never executed
    #####:  123:  auto srcEnc = getSparseTensorEncoding(srcTp);
call    0 never executed
        -:  124:  // We first fills the sizes from an input tensor, and then
        -:  125:  // compute the size of the concatenation dimension if necessary.
    #####:  126:  if (srcEnc)
branch  0 never executed
branch  1 never executed
        -:  127:    // Reuses sizes from an arbitrary input tensor is fine.
    #####:  128:    sizesFromPtr(builder, sizes, loc, srcEnc, srcTp, srcs[0]);
call    0 never executed
call    1 never executed
        -:  129:  else
    #####:  130:    sizesFromSrc(builder, sizes, loc, srcs[0]);
call    0 never executed
call    1 never executed
        -:  131:
        -:  132:  // Sum up on the `dim` if the dimension is dynamic.
    #####:  133:  if (dstShape[dim] != ShapedType::kDynamicSize) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  134:    // Faithfully take the static size.
    #####:  135:    sizes[dim] = constantIndex(builder, loc, dstShape[dim]);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  136:  } else {
        -:  137:    // Else, compute the shape dynamically.
    #####:  138:    for (size_t i = 1, sz = srcs.size(); i < sz; i++) {
branch  0 never executed
branch  1 never executed
    #####:  139:      auto srcTp = srcs[i].getType().cast<ShapedType>();
call    0 never executed
call    1 never executed
    #####:  140:      auto encSrc = getSparseTensorEncoding(srcTp);
call    0 never executed
    #####:  141:      Value srcSz =
    #####:  142:          encSrc ? sizeFromPtrAtDim(builder, loc, encSrc, srcTp, srcs[i], dim)
call    0 never executed
call    1 never executed
    #####:  143:                 : linalg::createOrFoldDimOp(builder, loc, srcs[i], dim);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  144:      // Sum up all the sizes.
    #####:  145:      sizes[dim] = builder.create<arith::AddIOp>(loc, sizes[dim], srcSz);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  146:    }
        -:  147:  }
    #####:  148:}
        -:  149:
        -:  150:/// Generates an uninitialized buffer of the given size and type,
        -:  151:/// but returns it as type `memref<? x $tp>` (rather than as type
        -:  152:/// `memref<$sz x $tp>`). Unlike temporary buffers on the stack,
        -:  153:/// this buffer must be explicitly deallocated by client.
function _ZN12_GLOBAL__N_1L8genAllocERN4mlir12RewriterBaseENS0_8LocationENS0_5ValueENS0_4TypeE called 0 returned 0% blocks executed 0%
    #####:  154:static Value genAlloc(RewriterBase &rewriter, Location loc, Value sz, Type tp) {
    #####:  155:  auto memTp = MemRefType::get({ShapedType::kDynamicSize}, tp);
call    0 never executed
call    1 never executed
    #####:  156:  return rewriter.create<memref::AllocOp>(loc, memTp, ValueRange{sz});
call    0 never executed
call    1 never executed
        -:  157:}
        -:  158:
        -:  159:/// Generates a temporary buffer of the given type and given contents.
function _ZN12_GLOBAL__N_1L9genBufferERN4mlir9OpBuilderENS0_8LocationENS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  160:static Value genBuffer(OpBuilder &builder, Location loc, ValueRange values) {
    #####:  161:  unsigned sz = values.size();
branch  0 never executed
branch  1 never executed
    #####:  162:  assert(sz >= 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  163:  Value buffer = genAlloca(builder, loc, sz, values[0].getType());
call    0 never executed
call    1 never executed
    #####:  164:  for (unsigned i = 0; i < sz; i++) {
branch  0 never executed
branch  1 never executed
    #####:  165:    Value idx = constantIndex(builder, loc, i);
call    0 never executed
    #####:  166:    builder.create<memref::StoreOp>(loc, values[i], buffer, idx);
call    0 never executed
call    1 never executed
        -:  167:  }
    #####:  168:  return buffer;
        -:  169:}
        -:  170:
        -:  171:/// Populates parameters required to call the "swiss army knife" method of the
        -:  172:/// sparse runtime support library for materializing sparse tensors into the
        -:  173:/// computation.
function _ZN12_GLOBAL__N_1L9newParamsERN4mlir9OpBuilderERN4llvm11SmallVectorINS0_5ValueELj8EEENS0_8LocationENS0_10ShapedTypeERNS0_13sparse_tensor24SparseTensorEncodingAttrENSA_6ActionENS0_10ValueRangeES5_ called 0 returned 0% blocks executed 0%
    #####:  174:static void newParams(OpBuilder &builder, SmallVector<Value, 8> &params,
        -:  175:                      Location loc, ShapedType stp,
        -:  176:                      SparseTensorEncodingAttr &enc, Action action,
        -:  177:                      ValueRange szs, Value ptr = Value()) {
    #####:  178:  ArrayRef<DimLevelType> dlt = enc.getDimLevelType();
call    0 never executed
    #####:  179:  unsigned sz = dlt.size();
        -:  180:  // Sparsity annotations.
    #####:  181:  SmallVector<Value, 4> attrs;
    #####:  182:  for (unsigned i = 0; i < sz; i++)
branch  0 never executed
branch  1 never executed
    #####:  183:    attrs.push_back(constantDimLevelTypeEncoding(builder, loc, dlt[i]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  184:  params.push_back(genBuffer(builder, loc, attrs));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  185:  // Dimension sizes array of the enveloping tensor. Useful for either
        -:  186:  // verification of external data, or for construction of internal data.
    #####:  187:  params.push_back(genBuffer(builder, loc, szs));
call    0 never executed
call    1 never executed
        -:  188:  // Dimension order permutation array. This is the "identity" permutation by
        -:  189:  // default, or otherwise the "reverse" permutation of a given ordering, so
        -:  190:  // that indices can be mapped quickly to the right position.
    #####:  191:  SmallVector<Value, 4> rev(sz);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  192:  for (unsigned i = 0; i < sz; i++)
branch  0 never executed
branch  1 never executed
    #####:  193:    rev[toOrigDim(enc, i)] = constantIndex(builder, loc, i);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  194:  params.push_back(genBuffer(builder, loc, rev));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  195:  // Secondary and primary types encoding.
    #####:  196:  Type elemTp = stp.getElementType();
call    0 never executed
    #####:  197:  params.push_back(constantPointerTypeEncoding(builder, loc, enc));
call    0 never executed
call    1 never executed
    #####:  198:  params.push_back(constantIndexTypeEncoding(builder, loc, enc));
call    0 never executed
call    1 never executed
    #####:  199:  params.push_back(constantPrimaryTypeEncoding(builder, loc, elemTp));
call    0 never executed
call    1 never executed
        -:  200:  // User action.
    #####:  201:  params.push_back(constantAction(builder, loc, action));
call    0 never executed
call    1 never executed
        -:  202:  // Payload pointer.
    #####:  203:  if (!ptr)
branch  0 never executed
branch  1 never executed
    #####:  204:    ptr = builder.create<LLVM::NullOp>(loc, getOpaquePointerType(builder));
call    0 never executed
call    1 never executed
    #####:  205:  params.push_back(ptr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  206:}
        -:  207:
        -:  208:/// Generates a call to obtain the values array.
function _ZN12_GLOBAL__N_1L13genValuesCallERN4mlir9OpBuilderENS0_8LocationENS0_10ShapedTypeENS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  209:static Value genValuesCall(OpBuilder &builder, Location loc, ShapedType tp,
        -:  210:                           ValueRange ptr) {
    #####:  211:  SmallString<15> name{"sparseValues",
call    0 never executed
    #####:  212:                       primaryTypeFunctionSuffix(tp.getElementType())};
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  213:  return createFuncCall(builder, loc, name, tp, ptr, EmitCInterface::On)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  214:      .getResult(0);
branch  0 never executed
branch  1 never executed
        -:  215:}
        -:  216:
        -:  217:/// Generates a call to release/delete a `SparseTensorCOO`.
function _ZN12_GLOBAL__N_1L13genDelCOOCallERN4mlir9OpBuilderENS0_8LocationENS0_4TypeENS0_5ValueE called 0 returned 0% blocks executed 0%
    #####:  218:static void genDelCOOCall(OpBuilder &builder, Location loc, Type elemTp,
        -:  219:                          Value coo) {
    #####:  220:  SmallString<21> name{"delSparseTensorCOO", primaryTypeFunctionSuffix(elemTp)};
call    0 never executed
call    1 never executed
    #####:  221:  createFuncCall(builder, loc, name, {}, coo, EmitCInterface::Off);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  222:}
        -:  223:
        -:  224:/// Generates a call to release/delete a `SparseTensorIterator`.
function _ZN12_GLOBAL__N_1L18genDelIteratorCallERN4mlir9OpBuilderENS0_8LocationENS0_4TypeENS0_5ValueE called 0 returned 0% blocks executed 0%
    #####:  225:static void genDelIteratorCall(OpBuilder &builder, Location loc, Type elemTp,
        -:  226:                               Value iter) {
    #####:  227:  SmallString<26> name{"delSparseTensorIterator",
call    0 never executed
    #####:  228:                       primaryTypeFunctionSuffix(elemTp)};
call    0 never executed
call    1 never executed
    #####:  229:  createFuncCall(builder, loc, name, {}, iter, EmitCInterface::Off);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  230:}
        -:  231:
        -:  232:/// Generates a call that adds one element to a coordinate scheme.
        -:  233:/// In particular, this generates code like the following:
        -:  234:///   val = a[i1,..,ik];
        -:  235:///   if val != 0
        -:  236:///     t->add(&val, [i1,..,ik], [p1,..,pk]);
function _ZN12_GLOBAL__N_1L13genAddEltCallERN4mlir9OpBuilderENS0_8LocationENS0_4TypeENS0_5ValueES5_S5_S5_ called 0 returned 0% blocks executed 0%
    #####:  237:static void genAddEltCall(OpBuilder &builder, Location loc, Type eltType,
        -:  238:                          Value ptr, Value valPtr, Value ind, Value perm) {
    #####:  239:  SmallString<9> name{"addElt", primaryTypeFunctionSuffix(eltType)};
call    0 never executed
call    1 never executed
    #####:  240:  SmallVector<Value, 4> params{ptr, valPtr, ind, perm};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  241:  Type pTp = getOpaquePointerType(builder);
call    0 never executed
    #####:  242:  createFuncCall(builder, loc, name, pTp, params, EmitCInterface::On);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  243:}
        -:  244:
        -:  245:/// Generates a call to `iter->getNext()`.  If there is a next element,
        -:  246:/// then it is copied into the out-parameters `ind` and `elemPtr`,
        -:  247:/// and the return value is true.  If there isn't a next element, then
        -:  248:/// the return value is false.
function _ZN12_GLOBAL__N_1L14genGetNextCallERN4mlir9OpBuilderENS0_8LocationENS0_5ValueES4_S4_ called 0 returned 0% blocks executed 0%
    #####:  249:static Value genGetNextCall(OpBuilder &builder, Location loc, Value iter,
        -:  250:                            Value ind, Value elemPtr) {
    #####:  251:  Type elemTp = elemPtr.getType().cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####:  252:  SmallString<10> name{"getNext", primaryTypeFunctionSuffix(elemTp)};
call    0 never executed
call    1 never executed
    #####:  253:  SmallVector<Value, 3> params{iter, ind, elemPtr};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  254:  Type i1 = builder.getI1Type();
call    0 never executed
    #####:  255:  return createFuncCall(builder, loc, name, i1, params, EmitCInterface::On)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  256:      .getResult(0);
branch  0 never executed
branch  1 never executed
        -:  257:}
        -:  258:
        -:  259:/// Generates code to deallocate a dense buffer.
    #####:  260:static void deallocDenseTensor(OpBuilder &builder, Location loc, Value buffer) {
    #####:  261:  builder.create<memref::DeallocOp>(loc, buffer);
        -:  262:}
        -:  263:
        -:  264:/// Converts a pointer to COO (from calls to iter->next()) into a vector of
        -:  265:/// indices, apply (optional) `offset` on `offsetDim`.
function _ZN12_GLOBAL__N_1L11loadIndicesERN4mlir9OpBuilderENS0_8LocationEjNS0_5ValueEjS4_ called 0 returned 0% blocks executed 0%
    #####:  266:static SmallVector<Value, 4> loadIndices(OpBuilder &builder, Location loc,
        -:  267:                                         unsigned rank, Value ind,
        -:  268:                                         unsigned offsetDim = 0,
        -:  269:                                         Value offset = Value()) {
    #####:  270:  SmallVector<Value, 4> ivs;
branch  0 never executed
branch  1 never executed
    #####:  271:  ivs.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  272:  for (unsigned i = 0; i < rank; i++) {
branch  0 never executed
branch  1 never executed
    #####:  273:    Value idx = constantIndex(builder, loc, i);
call    0 never executed
    #####:  274:    idx = builder.create<memref::LoadOp>(loc, ind, idx);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  275:    if (offsetDim == i && offset)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  276:      idx = builder.create<arith::AddIOp>(loc, idx, offset);
call    0 never executed
    #####:  277:    ivs.push_back(idx);
call    0 never executed
        -:  278:  }
    #####:  279:  return ivs;
        -:  280:}
        -:  281:
        -:  282:/// Converts the vector indices and store it into the memory pointed by
        -:  283:/// `ind`, apply (optional) `offset` on `offsetDim`.
function _ZN12_GLOBAL__N_1L12storeIndicesERN4mlir9OpBuilderENS0_8LocationEjNS0_5ValueENS0_10ValueRangeEjS4_ called 0 returned 0% blocks executed 0%
    #####:  284:static void storeIndices(OpBuilder &builder, Location loc, unsigned rank,
        -:  285:                         Value ind, ValueRange ivs, unsigned offsetDim = 0,
        -:  286:                         Value offset = Value()) {
    #####:  287:  for (unsigned i = 0; i < rank; i++) {
branch  0 never executed
branch  1 never executed
    #####:  288:    Value idx = ivs[i];
call    0 never executed
    #####:  289:    if (offsetDim == i && offset)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  290:      idx = builder.create<arith::AddIOp>(loc, idx, offset);
call    0 never executed
    #####:  291:    builder.create<memref::StoreOp>(loc, idx, ind,
    #####:  292:                                    constantIndex(builder, loc, i));
call    0 never executed
call    1 never executed
        -:  293:  }
    #####:  294:}
        -:  295:
        -:  296:/// Inserts a value stored in `elemPtr` into a dense tensor created by
        -:  297:/// allocDenseTensor().
function _ZN12_GLOBAL__N_1L27insertScalarIntoDenseTensorERN4mlir9OpBuilderENS0_8LocationENS0_5ValueES4_NS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  298:static void insertScalarIntoDenseTensor(OpBuilder &builder, Location loc,
        -:  299:                                        Value elemPtr, Value tensor,
        -:  300:                                        ValueRange ivs) {
    #####:  301:  Value elemV = builder.create<memref::LoadOp>(loc, elemPtr);
call    0 never executed
call    1 never executed
    #####:  302:  builder.create<memref::StoreOp>(loc, elemV, tensor, ivs);
call    0 never executed
    #####:  303:}
        -:  304:
        -:  305:/// Determine if the runtime library supports direct conversion to the
        -:  306:/// given target `dimTypes`.
    #####:  307:static bool canUseDirectConversion(ArrayRef<DimLevelType> dimTypes) {
    #####:  308:  bool alreadyCompressed = false;
    #####:  309:  for (uint64_t rank = dimTypes.size(), r = 0; r < rank; r++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  310:    const DimLevelType dlt = dimTypes[r];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  311:    if (isCompressedDLT(dlt)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  312:      if (alreadyCompressed)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  313:        return false; // Multiple compressed dimensions not yet supported.
        -:  314:      alreadyCompressed = true;
    #####:  315:    } else if (isDenseDLT(dlt)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  316:      if (alreadyCompressed)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  317:        return false; // Dense after Compressed not yet supported.
    #####:  318:    } else if (isSingletonDLT(dlt)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  319:      // Direct conversion doesn't have any particular problems with
        -:  320:      // singleton after compressed.
        -:  321:    } else { // TODO: investigate
        -:  322:      return false;
        -:  323:    }
        -:  324:  }
        -:  325:  return true;
        -:  326:}
        -:  327:
        -:  328:/// Helper method to translate indices during a reshaping operation.
        -:  329:/// TODO: provide as general utility to MLIR at large?
function _ZN12_GLOBAL__N_1L16translateIndicesEN4mlir8LocationERNS0_25ConversionPatternRewriterEN4llvm8ArrayRefINS4_11SmallVectorIlLj2EEEEENS0_10TensorTypeES9_NS0_5ValueESA_NS5_ISA_EESB_ called 0 returned 0% blocks executed 0%
    #####:  330:static void translateIndices(Location loc, ConversionPatternRewriter &rewriter,
        -:  331:                             ArrayRef<ReassociationIndices> reassociation,
        -:  332:                             TensorType dstTp, TensorType srcTp, Value dstIdx,
        -:  333:                             Value srcIdx, ArrayRef<Value> dstShape,
        -:  334:                             ArrayRef<Value> srcShape) {
    #####:  335:  unsigned dstRank = dstTp.getRank();
call    0 never executed
    #####:  336:  unsigned srcRank = srcTp.getRank();
call    0 never executed
        -:  337:
    #####:  338:  SmallVector<Value, 4> srcIndices;
    #####:  339:  for (unsigned i = 0; i < srcRank; i++) {
branch  0 never executed
branch  1 never executed
    #####:  340:    Value idx = rewriter.create<memref::LoadOp>(
    #####:  341:        loc, srcIdx, constantIndex(rewriter, loc, i));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  342:    srcIndices.push_back(idx);
call    0 never executed
        -:  343:  }
        -:  344:
    #####:  345:  SmallVector<Value, 4> dstIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  346:  translateIndicesArray(rewriter, loc, reassociation, srcIndices, srcShape,
call    0 never executed
call    1 never executed
        -:  347:                        dstShape, dstIndices);
        -:  348:
    #####:  349:  for (unsigned i = 0; i < dstRank; i++)
branch  0 never executed
branch  1 never executed
    #####:  350:    rewriter.create<memref::StoreOp>(loc, dstIndices[i], dstIdx,
    #####:  351:                                     constantIndex(rewriter, loc, i));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  352:}
        -:  353:
        -:  354:/// Generate code for a general sparse to sparse reshaping operation.
        -:  355:/// Note that unlike dense reshaping (which can be done with a "cheap"
        -:  356:/// change of view), sparse reshaping is currently done with actual
        -:  357:/// data shuffling.
        -:  358:///
        -:  359:/// TODO: proportional to nnz, but still a lot of data movement
        -:  360:///       https://github.com/llvm/llvm-project/issues/56477
        -:  361:///
        -:  362:///   iter = src->toCOO();
        -:  363:///   coo = newSparseCOO()
        -:  364:///   while (elem = iter->getNext()) {
        -:  365:///     coo->add(reshape(elem.indices), elem.value)
        -:  366:///   }
        -:  367:///   s = newSparseTensor(coo)
        -:  368:template <typename ReshapeOp>
        -:  369:static LogicalResult
    #####:  370:genSparse2SparseReshape(ReshapeOp op, typename ReshapeOp::Adaptor adaptor,
        -:  371:                        ConversionPatternRewriter &rewriter) {
    #####:  372:  Location loc = op.getLoc();
    #####:  373:  auto srcTp = op.getSrc().getType().template cast<RankedTensorType>();
    #####:  374:  auto dstTp = op.getResult().getType().template cast<RankedTensorType>();
    #####:  375:  auto encSrc = getSparseTensorEncoding(srcTp);
    #####:  376:  auto encDst = getSparseTensorEncoding(dstTp);
    #####:  377:  if (!encDst || !encSrc)
    #####:  378:    return failure();
        -:  379:
    #####:  380:  unsigned srcRank = srcTp.getRank();
    #####:  381:  unsigned dstRank = dstTp.getRank();
    #####:  382:  Type elemTp = srcTp.getElementType();
    #####:  383:  assert(elemTp == dstTp.getElementType() &&
        -:  384:         "reshape should not change element type");
        -:  385:  // Start an iterator over the source tensor (in original index order).
    #####:  386:  auto noPerm = SparseTensorEncodingAttr::get(
        -:  387:      op->getContext(), encSrc.getDimLevelType(), AffineMap(), AffineMap(),
        -:  388:      encSrc.getPointerBitWidth(), encSrc.getIndexBitWidth());
    #####:  389:  SmallVector<Value, 4> srcSizes;
    #####:  390:  SmallVector<Value, 8> params;
    #####:  391:  sizesFromPtr(rewriter, srcSizes, loc, encSrc, srcTp, adaptor.getSrc());
    #####:  392:  newParams(rewriter, params, loc, srcTp, noPerm, Action::kToIterator, srcSizes,
        -:  393:            adaptor.getSrc());
    #####:  394:  Value iter = genNewCall(rewriter, loc, params);
        -:  395:  // Start a new COO for the destination tensor.
    #####:  396:  SmallVector<Value, 4> dstSizes;
    #####:  397:  params.clear();
    #####:  398:  if (dstTp.hasStaticShape()) {
    #####:  399:    sizesFromType(rewriter, dstSizes, loc, dstTp);
        -:  400:  } else {
    #####:  401:    ArrayRef<int64_t> dstShape = dstTp.getShape();
    #####:  402:    genReshapeDstShape(loc, rewriter, dstSizes, srcSizes, dstShape,
        -:  403:                       op.getReassociationIndices());
        -:  404:  }
    #####:  405:  newParams(rewriter, params, loc, dstTp, encDst, Action::kEmptyCOO, dstSizes);
    #####:  406:  Value coo = genNewCall(rewriter, loc, params);
    #####:  407:  Value dstPerm = params[2];
        -:  408:  // Construct a while loop over the iterator.
    #####:  409:  Value srcIdx = genAlloca(rewriter, loc, srcRank, rewriter.getIndexType());
    #####:  410:  Value dstIdx = genAlloca(rewriter, loc, dstRank, rewriter.getIndexType());
    #####:  411:  Value elemPtr = genAllocaScalar(rewriter, loc, elemTp);
    #####:  412:  SmallVector<Value> noArgs;
    #####:  413:  SmallVector<Type> noTypes;
    #####:  414:  auto whileOp = rewriter.create<scf::WhileOp>(loc, noTypes, noArgs);
    #####:  415:  Block *before = rewriter.createBlock(&whileOp.getBefore(), {}, noTypes);
    #####:  416:  rewriter.setInsertionPointToEnd(before);
    #####:  417:  Value cond = genGetNextCall(rewriter, loc, iter, srcIdx, elemPtr);
    #####:  418:  rewriter.create<scf::ConditionOp>(loc, cond, before->getArguments());
        -:  419:  // Translate indices from source to target and insert. Note that we do
        -:  420:  // not need to store the value in elemPtr, as the value is still there.
    #####:  421:  Block *after = rewriter.createBlock(&whileOp.getAfter(), {}, noTypes);
    #####:  422:  rewriter.setInsertionPointToStart(after);
    #####:  423:  translateIndices(loc, rewriter, op.getReassociationIndices(), dstTp, srcTp,
        -:  424:                   dstIdx, srcIdx, dstSizes, srcSizes);
    #####:  425:  genAddEltCall(rewriter, loc, elemTp, coo, elemPtr, dstIdx, dstPerm);
    #####:  426:  rewriter.create<scf::YieldOp>(loc);
        -:  427:  // Final call to construct sparse tensor storage and free temporary resources.
    #####:  428:  rewriter.setInsertionPointAfter(whileOp);
    #####:  429:  params[6] = constantAction(rewriter, loc, Action::kFromCOO);
    #####:  430:  params[7] = coo;
    #####:  431:  Value dst = genNewCall(rewriter, loc, params);
    #####:  432:  genDelCOOCall(rewriter, loc, elemTp, coo);
    #####:  433:  genDelIteratorCall(rewriter, loc, elemTp, iter);
    #####:  434:  rewriter.replaceOp(op, dst);
    #####:  435:  return success();
        -:  436:}
------------------
_ZN12_GLOBAL__N_1L23genSparse2SparseReshapeIN4mlir6tensor13ExpandShapeOpEEENS1_13LogicalResultET_NS5_7AdaptorERNS1_25ConversionPatternRewriterE:
function _ZN12_GLOBAL__N_1L23genSparse2SparseReshapeIN4mlir6tensor13ExpandShapeOpEEENS1_13LogicalResultET_NS5_7AdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  370:genSparse2SparseReshape(ReshapeOp op, typename ReshapeOp::Adaptor adaptor,
        -:  371:                        ConversionPatternRewriter &rewriter) {
    #####:  372:  Location loc = op.getLoc();
call    0 never executed
    #####:  373:  auto srcTp = op.getSrc().getType().template cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  374:  auto dstTp = op.getResult().getType().template cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  375:  auto encSrc = getSparseTensorEncoding(srcTp);
call    0 never executed
    #####:  376:  auto encDst = getSparseTensorEncoding(dstTp);
call    0 never executed
    #####:  377:  if (!encDst || !encSrc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  378:    return failure();
        -:  379:
    #####:  380:  unsigned srcRank = srcTp.getRank();
call    0 never executed
    #####:  381:  unsigned dstRank = dstTp.getRank();
call    0 never executed
    #####:  382:  Type elemTp = srcTp.getElementType();
call    0 never executed
    #####:  383:  assert(elemTp == dstTp.getElementType() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  384:         "reshape should not change element type");
        -:  385:  // Start an iterator over the source tensor (in original index order).
    #####:  386:  auto noPerm = SparseTensorEncodingAttr::get(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  387:      op->getContext(), encSrc.getDimLevelType(), AffineMap(), AffineMap(),
        -:  388:      encSrc.getPointerBitWidth(), encSrc.getIndexBitWidth());
    #####:  389:  SmallVector<Value, 4> srcSizes;
    #####:  390:  SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  391:  sizesFromPtr(rewriter, srcSizes, loc, encSrc, srcTp, adaptor.getSrc());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  392:  newParams(rewriter, params, loc, srcTp, noPerm, Action::kToIterator, srcSizes,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  393:            adaptor.getSrc());
    #####:  394:  Value iter = genNewCall(rewriter, loc, params);
call    0 never executed
call    1 never executed
        -:  395:  // Start a new COO for the destination tensor.
    #####:  396:  SmallVector<Value, 4> dstSizes;
branch  0 never executed
branch  1 never executed
    #####:  397:  params.clear();
call    0 never executed
    #####:  398:  if (dstTp.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  399:    sizesFromType(rewriter, dstSizes, loc, dstTp);
call    0 never executed
        -:  400:  } else {
    #####:  401:    ArrayRef<int64_t> dstShape = dstTp.getShape();
call    0 never executed
    #####:  402:    genReshapeDstShape(loc, rewriter, dstSizes, srcSizes, dstShape,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  403:                       op.getReassociationIndices());
        -:  404:  }
    #####:  405:  newParams(rewriter, params, loc, dstTp, encDst, Action::kEmptyCOO, dstSizes);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  406:  Value coo = genNewCall(rewriter, loc, params);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  407:  Value dstPerm = params[2];
        -:  408:  // Construct a while loop over the iterator.
    #####:  409:  Value srcIdx = genAlloca(rewriter, loc, srcRank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  410:  Value dstIdx = genAlloca(rewriter, loc, dstRank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  411:  Value elemPtr = genAllocaScalar(rewriter, loc, elemTp);
call    0 never executed
call    1 never executed
    #####:  412:  SmallVector<Value> noArgs;
branch  0 never executed
branch  1 never executed
    #####:  413:  SmallVector<Type> noTypes;
branch  0 never executed
branch  1 never executed
    #####:  414:  auto whileOp = rewriter.create<scf::WhileOp>(loc, noTypes, noArgs);
call    0 never executed
    #####:  415:  Block *before = rewriter.createBlock(&whileOp.getBefore(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  416:  rewriter.setInsertionPointToEnd(before);
call    0 never executed
    #####:  417:  Value cond = genGetNextCall(rewriter, loc, iter, srcIdx, elemPtr);
call    0 never executed
    #####:  418:  rewriter.create<scf::ConditionOp>(loc, cond, before->getArguments());
call    0 never executed
        -:  419:  // Translate indices from source to target and insert. Note that we do
        -:  420:  // not need to store the value in elemPtr, as the value is still there.
    #####:  421:  Block *after = rewriter.createBlock(&whileOp.getAfter(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  422:  rewriter.setInsertionPointToStart(after);
call    0 never executed
    #####:  423:  translateIndices(loc, rewriter, op.getReassociationIndices(), dstTp, srcTp,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  424:                   dstIdx, srcIdx, dstSizes, srcSizes);
    #####:  425:  genAddEltCall(rewriter, loc, elemTp, coo, elemPtr, dstIdx, dstPerm);
call    0 never executed
    #####:  426:  rewriter.create<scf::YieldOp>(loc);
call    0 never executed
        -:  427:  // Final call to construct sparse tensor storage and free temporary resources.
    #####:  428:  rewriter.setInsertionPointAfter(whileOp);
call    0 never executed
    #####:  429:  params[6] = constantAction(rewriter, loc, Action::kFromCOO);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  430:  params[7] = coo;
call    0 never executed
    #####:  431:  Value dst = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  432:  genDelCOOCall(rewriter, loc, elemTp, coo);
call    0 never executed
    #####:  433:  genDelIteratorCall(rewriter, loc, elemTp, iter);
call    0 never executed
call    1 never executed
    #####:  434:  rewriter.replaceOp(op, dst);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  435:  return success();
branch  0 never executed
branch  1 never executed
        -:  436:}
------------------
_ZN12_GLOBAL__N_1L23genSparse2SparseReshapeIN4mlir6tensor15CollapseShapeOpEEENS1_13LogicalResultET_NS5_7AdaptorERNS1_25ConversionPatternRewriterE:
function _ZN12_GLOBAL__N_1L23genSparse2SparseReshapeIN4mlir6tensor15CollapseShapeOpEEENS1_13LogicalResultET_NS5_7AdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  370:genSparse2SparseReshape(ReshapeOp op, typename ReshapeOp::Adaptor adaptor,
        -:  371:                        ConversionPatternRewriter &rewriter) {
    #####:  372:  Location loc = op.getLoc();
call    0 never executed
    #####:  373:  auto srcTp = op.getSrc().getType().template cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  374:  auto dstTp = op.getResult().getType().template cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  375:  auto encSrc = getSparseTensorEncoding(srcTp);
call    0 never executed
    #####:  376:  auto encDst = getSparseTensorEncoding(dstTp);
call    0 never executed
    #####:  377:  if (!encDst || !encSrc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  378:    return failure();
        -:  379:
    #####:  380:  unsigned srcRank = srcTp.getRank();
call    0 never executed
    #####:  381:  unsigned dstRank = dstTp.getRank();
call    0 never executed
    #####:  382:  Type elemTp = srcTp.getElementType();
call    0 never executed
    #####:  383:  assert(elemTp == dstTp.getElementType() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  384:         "reshape should not change element type");
        -:  385:  // Start an iterator over the source tensor (in original index order).
    #####:  386:  auto noPerm = SparseTensorEncodingAttr::get(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  387:      op->getContext(), encSrc.getDimLevelType(), AffineMap(), AffineMap(),
        -:  388:      encSrc.getPointerBitWidth(), encSrc.getIndexBitWidth());
    #####:  389:  SmallVector<Value, 4> srcSizes;
    #####:  390:  SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  391:  sizesFromPtr(rewriter, srcSizes, loc, encSrc, srcTp, adaptor.getSrc());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  392:  newParams(rewriter, params, loc, srcTp, noPerm, Action::kToIterator, srcSizes,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  393:            adaptor.getSrc());
    #####:  394:  Value iter = genNewCall(rewriter, loc, params);
call    0 never executed
call    1 never executed
        -:  395:  // Start a new COO for the destination tensor.
    #####:  396:  SmallVector<Value, 4> dstSizes;
branch  0 never executed
branch  1 never executed
    #####:  397:  params.clear();
call    0 never executed
    #####:  398:  if (dstTp.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  399:    sizesFromType(rewriter, dstSizes, loc, dstTp);
call    0 never executed
        -:  400:  } else {
    #####:  401:    ArrayRef<int64_t> dstShape = dstTp.getShape();
call    0 never executed
    #####:  402:    genReshapeDstShape(loc, rewriter, dstSizes, srcSizes, dstShape,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  403:                       op.getReassociationIndices());
        -:  404:  }
    #####:  405:  newParams(rewriter, params, loc, dstTp, encDst, Action::kEmptyCOO, dstSizes);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  406:  Value coo = genNewCall(rewriter, loc, params);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  407:  Value dstPerm = params[2];
        -:  408:  // Construct a while loop over the iterator.
    #####:  409:  Value srcIdx = genAlloca(rewriter, loc, srcRank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  410:  Value dstIdx = genAlloca(rewriter, loc, dstRank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  411:  Value elemPtr = genAllocaScalar(rewriter, loc, elemTp);
call    0 never executed
call    1 never executed
    #####:  412:  SmallVector<Value> noArgs;
branch  0 never executed
branch  1 never executed
    #####:  413:  SmallVector<Type> noTypes;
branch  0 never executed
branch  1 never executed
    #####:  414:  auto whileOp = rewriter.create<scf::WhileOp>(loc, noTypes, noArgs);
call    0 never executed
    #####:  415:  Block *before = rewriter.createBlock(&whileOp.getBefore(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  416:  rewriter.setInsertionPointToEnd(before);
call    0 never executed
    #####:  417:  Value cond = genGetNextCall(rewriter, loc, iter, srcIdx, elemPtr);
call    0 never executed
    #####:  418:  rewriter.create<scf::ConditionOp>(loc, cond, before->getArguments());
call    0 never executed
        -:  419:  // Translate indices from source to target and insert. Note that we do
        -:  420:  // not need to store the value in elemPtr, as the value is still there.
    #####:  421:  Block *after = rewriter.createBlock(&whileOp.getAfter(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  422:  rewriter.setInsertionPointToStart(after);
call    0 never executed
    #####:  423:  translateIndices(loc, rewriter, op.getReassociationIndices(), dstTp, srcTp,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  424:                   dstIdx, srcIdx, dstSizes, srcSizes);
    #####:  425:  genAddEltCall(rewriter, loc, elemTp, coo, elemPtr, dstIdx, dstPerm);
call    0 never executed
    #####:  426:  rewriter.create<scf::YieldOp>(loc);
call    0 never executed
        -:  427:  // Final call to construct sparse tensor storage and free temporary resources.
    #####:  428:  rewriter.setInsertionPointAfter(whileOp);
call    0 never executed
    #####:  429:  params[6] = constantAction(rewriter, loc, Action::kFromCOO);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  430:  params[7] = coo;
call    0 never executed
    #####:  431:  Value dst = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  432:  genDelCOOCall(rewriter, loc, elemTp, coo);
call    0 never executed
    #####:  433:  genDelIteratorCall(rewriter, loc, elemTp, iter);
call    0 never executed
call    1 never executed
    #####:  434:  rewriter.replaceOp(op, dst);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  435:  return success();
branch  0 never executed
branch  1 never executed
        -:  436:}
------------------
        -:  437:
        -:  438:// Generates a while loop that iterates over the COO list extracted
        -:  439:// from `t`, using `bodyBuilder` to build the loop body.
        -:  440://   while (elem = coo->getNext()) {
        -:  441://     bodyBuilder
        -:  442://   }
        -:  443:// TODO: It can be used by other operators (ReshapeOp, ConvertOP) conversion to
        -:  444:// reduce code repetition!
        -:  445:// TODO: rename to `genSparseIterationLoop`?
function _ZN12_GLOBAL__N_1L25genSparseCOOIterationLoopERN4mlir25ConversionPatternRewriterENS0_8LocationENS0_5ValueENS0_16RankedTensorTypeEN4llvm12function_refIFvRNS0_9OpBuilderES3_S4_S4_EEE called 0 returned 0% blocks executed 0%
    #####:  446:static void genSparseCOOIterationLoop(
        -:  447:    ConversionPatternRewriter &rewriter, Location loc, Value t,
        -:  448:    RankedTensorType tensorTp,
        -:  449:    function_ref<void(OpBuilder &, Location, Value, Value)> bodyBuilder) {
    #####:  450:  auto enc = getSparseTensorEncoding(tensorTp);
call    0 never executed
    #####:  451:  assert(enc && "Generating Sparse Tensor COO Loop on a Dense Tensor!");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:
    #####:  453:  unsigned rank = tensorTp.getRank();
call    0 never executed
    #####:  454:  Type elemTp = tensorTp.getElementType();
call    0 never executed
        -:  455:
        -:  456:  // Start an iterator over the tensor (in original index order).
    #####:  457:  auto noPerm = SparseTensorEncodingAttr::get(
        -:  458:      rewriter.getContext(), enc.getDimLevelType(), AffineMap(), AffineMap(),
    #####:  459:      enc.getPointerBitWidth(), enc.getIndexBitWidth());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  460:  SmallVector<Value, 4> sizes;
call    0 never executed
    #####:  461:  SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  462:  sizesFromPtr(rewriter, sizes, loc, noPerm, tensorTp, t);
call    0 never executed
call    1 never executed
    #####:  463:  newParams(rewriter, params, loc, tensorTp, noPerm, Action::kToIterator, sizes,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  464:            t);
    #####:  465:  Value iter = genNewCall(rewriter, loc, params);
call    0 never executed
        -:  466:
        -:  467:  // Construct a while loop over the iterator.
    #####:  468:  Value srcIdx = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  469:  Value elemPtr = genAllocaScalar(rewriter, loc, elemTp);
call    0 never executed
    #####:  470:  SmallVector<Value> noArgs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  471:  SmallVector<Type> noTypes;
branch  0 never executed
branch  1 never executed
    #####:  472:  auto whileOp = rewriter.create<scf::WhileOp>(loc, noTypes, noArgs);
call    0 never executed
    #####:  473:  Block *before = rewriter.createBlock(&whileOp.getBefore(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  474:  rewriter.setInsertionPointToEnd(before);
call    0 never executed
    #####:  475:  Value cond = genGetNextCall(rewriter, loc, iter, srcIdx, elemPtr);
call    0 never executed
    #####:  476:  rewriter.create<scf::ConditionOp>(loc, cond, before->getArguments());
call    0 never executed
    #####:  477:  Block *after = rewriter.createBlock(&whileOp.getAfter(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  478:  rewriter.setInsertionPointToStart(after);
call    0 never executed
        -:  479:  // Callback here to build loop body.
    #####:  480:  bodyBuilder(rewriter, loc, srcIdx, elemPtr);
call    0 never executed
    #####:  481:  rewriter.create<scf::YieldOp>(loc);
call    0 never executed
        -:  482:  // Finish generating loop.
    #####:  483:  rewriter.setInsertionPointAfter(whileOp);
call    0 never executed
        -:  484:
        -:  485:  // Free memory for iterator.
    #####:  486:  genDelIteratorCall(rewriter, loc, elemTp, iter);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  487:}
        -:  488:
        -:  489:// Generate loop that iterates over a dense tensor.
        -:  490://   for i1 in dim1
        -:  491://    ..
        -:  492://     for ik in dimk
        -:  493://       val = a[i1,..,ik]
        -:  494://       if val != 0
        -:  495://         bodyBuilder(v, [i1, ..., ik])
        -:  496:// TODO: It can be used by other operators (ReshapeOp, ConvertOP) conversion to
        -:  497:// reduce code repetition!
function _ZN12_GLOBAL__N_1L27genDenseTensorIterationLoopERN4mlir25ConversionPatternRewriterENS0_8LocationENS0_5ValueENS0_16RankedTensorTypeEN4llvm12function_refIFvRNS0_9OpBuilderES3_NS0_10ValueRangeEEEE called 0 returned 0% blocks executed 0%
    #####:  498:static void genDenseTensorIterationLoop(
        -:  499:    ConversionPatternRewriter &rewriter, Location loc, Value t,
        -:  500:    RankedTensorType tensorTp,
        -:  501:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilder) {
    #####:  502:  assert(!getSparseTensorEncoding(tensorTp) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  503:         "Generating Dense Tensor Loop on a Sparse Tensor!");
        -:  504:
    #####:  505:  unsigned rank = tensorTp.getRank();
call    0 never executed
    #####:  506:  Value zero = constantIndex(rewriter, loc, 0);
call    0 never executed
    #####:  507:  Value one = constantIndex(rewriter, loc, 1);
call    0 never executed
        -:  508:
    #####:  509:  SmallVector<Value> lo;
    #####:  510:  SmallVector<Value> hi;
branch  0 never executed
branch  1 never executed
    #####:  511:  SmallVector<Value> st;
branch  0 never executed
branch  1 never executed
        -:  512:
        -:  513:  // Fill out loop iteration information.
    #####:  514:  for (unsigned i = 0; i < rank; i++) {
branch  0 never executed
branch  1 never executed
    #####:  515:    lo.push_back(zero);
call    0 never executed
    #####:  516:    hi.push_back(linalg::createOrFoldDimOp(rewriter, loc, t, i));
call    0 never executed
call    1 never executed
    #####:  517:    st.push_back(one);
call    0 never executed
        -:  518:  }
        -:  519:
    #####:  520:  scf::buildLoopNest(rewriter, loc, lo, hi, st, {},
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  521:                     [&](OpBuilder &builder, Location loc, ValueRange ivs,
        -:  522:                         ValueRange args) -> scf::ValueVector {
        -:  523:                       // Invoke callback to build the body of the loop.
    #####:  524:                       bodyBuilder(builder, loc, ivs);
call    0 never executed
    #####:  525:                       return {};
        -:  526:                     });
    #####:  527:}
        -:  528:
        -:  529://===----------------------------------------------------------------------===//
        -:  530:// Conversion rules.
        -:  531://===----------------------------------------------------------------------===//
        -:  532:
        -:  533:/// Sparse conversion rule for returns.
        -:  534:class SparseReturnConverter : public OpConversionPattern<func::ReturnOp> {
        -:  535:public:
        -:  536:  using OpConversionPattern::OpConversionPattern;
        -:  537:  LogicalResult
function _ZNK12_GLOBAL__N_121SparseReturnConverter15matchAndRewriteEN4mlir4func8ReturnOpENS2_15ReturnOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  538:  matchAndRewrite(func::ReturnOp op, OpAdaptor adaptor,
        -:  539:                  ConversionPatternRewriter &rewriter) const override {
    #####:  540:    rewriter.replaceOpWithNewOp<func::ReturnOp>(op, adaptor.getOperands());
call    0 never executed
call    1 never executed
    #####:  541:    return success();
        -:  542:  }
        -:  543:};
        -:  544:
        -:  545:/// Sparse conversion rule for dimension accesses.
        -:  546:class SparseTensorToDimSizeConverter
        -:  547:    : public OpConversionPattern<tensor::DimOp> {
        -:  548:public:
        -:  549:  using OpConversionPattern::OpConversionPattern;
        -:  550:  LogicalResult
function _ZNK12_GLOBAL__N_130SparseTensorToDimSizeConverter15matchAndRewriteEN4mlir6tensor5DimOpENS2_12DimOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  551:  matchAndRewrite(tensor::DimOp op, OpAdaptor adaptor,
        -:  552:                  ConversionPatternRewriter &rewriter) const override {
        -:  553:    // Only rewrite annotated DimOp with constant index.
    #####:  554:    auto enc = getSparseTensorEncoding(op.getSource().getType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  555:    if (!enc)
branch  0 never executed
branch  1 never executed
    #####:  556:      return failure();
    #####:  557:    Optional<int64_t> index = op.getConstantIndex();
call    0 never executed
    #####:  558:    if (!index)
branch  0 never executed
branch  1 never executed
    #####:  559:      return failure();
        -:  560:    // Generate the call.
    #####:  561:    Value src = adaptor.getOperands()[0];
call    0 never executed
call    1 never executed
    #####:  562:    int64_t idx = *index;
call    0 never executed
    #####:  563:    rewriter.replaceOp(op,
call    0 never executed
    #####:  564:                       genDimSizeCall(rewriter, op->getLoc(), enc, src, idx));
call    0 never executed
call    1 never executed
    #####:  565:    return success();
        -:  566:  }
        -:  567:};
        -:  568:
        -:  569:/// Sparse conversion rule for trivial tensor casts.
        -:  570:class SparseCastConverter : public OpConversionPattern<tensor::CastOp> {
        -:  571:public:
        -:  572:  using OpConversionPattern::OpConversionPattern;
        -:  573:  LogicalResult
function _ZNK12_GLOBAL__N_119SparseCastConverter15matchAndRewriteEN4mlir6tensor6CastOpENS2_13CastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  574:  matchAndRewrite(tensor::CastOp op, OpAdaptor adaptor,
        -:  575:                  ConversionPatternRewriter &rewriter) const override {
        -:  576:    // Only rewrite identically annotated source/dest.
    #####:  577:    auto encDst = getSparseTensorEncoding(op.getType());
call    0 never executed
call    1 never executed
    #####:  578:    auto encSrc = getSparseTensorEncoding(op.getSource().getType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  579:    if (!encDst || encDst != encSrc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  580:      return failure();
    #####:  581:    rewriter.replaceOp(op, adaptor.getOperands());
call    0 never executed
call    1 never executed
    #####:  582:    return success();
        -:  583:  }
        -:  584:};
        -:  585:
        -:  586:/// Sparse conversion rule for a reshape operator.
        -:  587:template <typename ReshapeOp>
        -:  588:class SparseReshapeConverter : public OpConversionPattern<ReshapeOp> {
        -:  589:public:
        -:  590:  using OpAdaptor = typename OpConversionPattern<ReshapeOp>::OpAdaptor;
        -:  591:  using OpConversionPattern<ReshapeOp>::OpConversionPattern;
        -:  592:  LogicalResult
    #####:  593:  matchAndRewrite(ReshapeOp op, OpAdaptor adaptor,
        -:  594:                  ConversionPatternRewriter &rewriter) const override {
    #####:  595:    return genSparse2SparseReshape(op, adaptor, rewriter);
        -:  596:  }
------------------
_ZNK12_GLOBAL__N_122SparseReshapeConverterIN4mlir6tensor13ExpandShapeOpEE15matchAndRewriteES3_NS2_20ExpandShapeOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122SparseReshapeConverterIN4mlir6tensor13ExpandShapeOpEE15matchAndRewriteES3_NS2_20ExpandShapeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  593:  matchAndRewrite(ReshapeOp op, OpAdaptor adaptor,
        -:  594:                  ConversionPatternRewriter &rewriter) const override {
    #####:  595:    return genSparse2SparseReshape(op, adaptor, rewriter);
call    0 never executed
        -:  596:  }
------------------
_ZNK12_GLOBAL__N_122SparseReshapeConverterIN4mlir6tensor15CollapseShapeOpEE15matchAndRewriteES3_NS2_22CollapseShapeOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122SparseReshapeConverterIN4mlir6tensor15CollapseShapeOpEE15matchAndRewriteES3_NS2_22CollapseShapeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  593:  matchAndRewrite(ReshapeOp op, OpAdaptor adaptor,
        -:  594:                  ConversionPatternRewriter &rewriter) const override {
    #####:  595:    return genSparse2SparseReshape(op, adaptor, rewriter);
call    0 never executed
        -:  596:  }
------------------
        -:  597:};
        -:  598:
        -:  599:/// Sparse conversion rule for the new operator.
        -:  600:class SparseTensorNewConverter : public OpConversionPattern<NewOp> {
        -:  601:public:
        -:  602:  using OpConversionPattern::OpConversionPattern;
        -:  603:  LogicalResult
function _ZNK12_GLOBAL__N_124SparseTensorNewConverter15matchAndRewriteEN4mlir13sparse_tensor5NewOpENS2_12NewOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  604:  matchAndRewrite(NewOp op, OpAdaptor adaptor,
        -:  605:                  ConversionPatternRewriter &rewriter) const override {
    #####:  606:    Location loc = op.getLoc();
call    0 never executed
    #####:  607:    Type resType = op.getType();
call    0 never executed
    #####:  608:    auto enc = getSparseTensorEncoding(resType);
call    0 never executed
    #####:  609:    if (!enc)
branch  0 never executed
branch  1 never executed
    #####:  610:      return failure();
        -:  611:    // Generate the call to construct tensor from ptr. The sizes are
        -:  612:    // inferred from the result type of the new operator.
    #####:  613:    SmallVector<Value, 4> sizes;
call    0 never executed
    #####:  614:    SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  615:    ShapedType stp = resType.cast<ShapedType>();
call    0 never executed
    #####:  616:    sizesFromType(rewriter, sizes, loc, stp);
call    0 never executed
    #####:  617:    Value ptr = adaptor.getOperands()[0];
call    0 never executed
call    1 never executed
    #####:  618:    newParams(rewriter, params, loc, stp, enc, Action::kFromFile, sizes, ptr);
call    0 never executed
call    1 never executed
    #####:  619:    rewriter.replaceOp(op, genNewCall(rewriter, loc, params));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  620:    return success();
branch  0 never executed
branch  1 never executed
        -:  621:  }
        -:  622:};
        -:  623:
        -:  624:/// Sparse conversion rule for the alloc operator.
        -:  625:class SparseTensorAllocConverter
        -:  626:    : public OpConversionPattern<bufferization::AllocTensorOp> {
        -:  627:public:
        -:  628:  using OpConversionPattern::OpConversionPattern;
        -:  629:  LogicalResult
function _ZNK12_GLOBAL__N_126SparseTensorAllocConverter15matchAndRewriteEN4mlir13bufferization13AllocTensorOpENS2_20AllocTensorOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  630:  matchAndRewrite(bufferization::AllocTensorOp op, OpAdaptor adaptor,
        -:  631:                  ConversionPatternRewriter &rewriter) const override {
    #####:  632:    if (op.getCopy())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  633:      return rewriter.notifyMatchFailure(op,
    #####:  634:                                         "sparse tensor copy not implemented");
call    0 never executed
    #####:  635:    Location loc = op.getLoc();
call    0 never executed
    #####:  636:    RankedTensorType resType = op.getType();
call    0 never executed
    #####:  637:    auto enc = getSparseTensorEncoding(resType);
call    0 never executed
    #####:  638:    if (!enc)
branch  0 never executed
branch  1 never executed
    #####:  639:      return failure();
        -:  640:    // Gather all dimension sizes as SSA values.
    #####:  641:    SmallVector<Value> sizes;
    #####:  642:    unsigned int operandCtr = 0;
    #####:  643:    for (int64_t i = 0; i < resType.getRank(); ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  644:      if (resType.isDynamicDim(i)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  645:        sizes.push_back(adaptor.getOperands()[operandCtr++]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  646:      } else {
    #####:  647:        sizes.push_back(
call    0 never executed
    #####:  648:            rewriter.create<arith::ConstantIndexOp>(loc, op.getStaticSize(i)));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  649:      }
        -:  650:    }
        -:  651:    // Generate the call to construct empty tensor. The sizes are
        -:  652:    // explicitly defined by the arguments to the alloc operator.
    #####:  653:    SmallVector<Value, 8> params;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  654:    ShapedType stp = resType.cast<ShapedType>();
call    0 never executed
    #####:  655:    newParams(rewriter, params, loc, stp, enc, Action::kEmpty, sizes);
call    0 never executed
call    1 never executed
    #####:  656:    rewriter.replaceOp(op, genNewCall(rewriter, loc, params));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  657:    return success();
branch  0 never executed
branch  1 never executed
        -:  658:  }
        -:  659:};
        -:  660:
        -:  661:/// Sparse conversion rule for the convert operator.
        -:  662:class SparseTensorConvertConverter : public OpConversionPattern<ConvertOp> {
        -:  663:public:
        -:  664:  using OpConversionPattern::OpConversionPattern;
        -:  665:  SparseTensorConvertConverter(MLIRContext *context,
        -:  666:                               SparseTensorConversionOptions o)
        -:  667:      : OpConversionPattern<ConvertOp>(context), options(o) {}
function _ZN12_GLOBAL__N_128SparseTensorConvertConverterC2ERN4mlir13TypeConverterEPNS1_11MLIRContextENS1_29SparseTensorConversionOptionsE called 1017 returned 100% blocks executed 100%
     1017:  668:  SparseTensorConvertConverter(TypeConverter &typeConv, MLIRContext *context,
        -:  669:                               SparseTensorConversionOptions o)
     1017:  670:      : OpConversionPattern<ConvertOp>(typeConv, context), options(o) {}
call    0 returned 100%
call    1 returned 100%
        -:  671:
        -:  672:  LogicalResult
function _ZNK12_GLOBAL__N_128SparseTensorConvertConverter15matchAndRewriteEN4mlir13sparse_tensor9ConvertOpENS2_16ConvertOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  673:  matchAndRewrite(ConvertOp op, OpAdaptor adaptor,
        -:  674:                  ConversionPatternRewriter &rewriter) const override {
    #####:  675:    Location loc = op->getLoc();
call    0 never executed
    #####:  676:    Type resType = op.getType();
call    0 never executed
    #####:  677:    Type srcType = op.getSource().getType();
call    0 never executed
call    1 never executed
    #####:  678:    auto encDst = getSparseTensorEncoding(resType);
call    0 never executed
    #####:  679:    auto encSrc = getSparseTensorEncoding(srcType);
call    0 never executed
    #####:  680:    Value src = adaptor.getOperands()[0];
call    0 never executed
call    1 never executed
    #####:  681:    if (encDst && encSrc) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  682:      // This is a sparse => sparse conversion, which is handled as follows:
        -:  683:      //   t = src->toCOO();         ; src to COO in dst order
        -:  684:      //   dst = newSparseTensor(t)
        -:  685:      // Using the coordinate scheme as an intermediate does not always
        -:  686:      // yield the fastest conversion but avoids the need for a full
        -:  687:      // O(N^2) conversion matrix.
    #####:  688:      if (encDst == encSrc) {
branch  0 never executed
branch  1 never executed
    #####:  689:        rewriter.replaceOp(op, adaptor.getOperands()); // hidden nop cast
call    0 never executed
call    1 never executed
    #####:  690:        return success();
        -:  691:      }
    #####:  692:      SmallVector<Value, 4> sizes;
call    0 never executed
    #####:  693:      SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  694:      ShapedType stp = srcType.cast<ShapedType>();
call    0 never executed
    #####:  695:      sizesFromPtr(rewriter, sizes, loc, encSrc, stp, src);
call    0 never executed
    #####:  696:      bool useDirectConversion;
    #####:  697:      switch (options.sparseToSparseStrategy) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  698:      case SparseToSparseConversionStrategy::kViaCOO:
        -:  699:        useDirectConversion = false;
        -:  700:        break;
    #####:  701:      case SparseToSparseConversionStrategy::kDirect:
    #####:  702:        useDirectConversion = true;
    #####:  703:        assert(canUseDirectConversion(encDst.getDimLevelType()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  704:               "Unsupported target for direct sparse-to-sparse conversion");
        -:  705:        break;
    #####:  706:      case SparseToSparseConversionStrategy::kAuto:
    #####:  707:        useDirectConversion = canUseDirectConversion(encDst.getDimLevelType());
call    0 never executed
        -:  708:        break;
        -:  709:      }
    #####:  710:      if (useDirectConversion) {
branch  0 never executed
branch  1 never executed
    #####:  711:        newParams(rewriter, params, loc, stp, encDst, Action::kSparseToSparse,
call    0 never executed
call    1 never executed
        -:  712:                  sizes, src);
    #####:  713:        rewriter.replaceOp(op, genNewCall(rewriter, loc, params));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  714:      } else { // use via-COO conversion.
        -:  715:        // Set up encoding with right mix of src and dst so that the two
        -:  716:        // method calls can share most parameters, while still providing
        -:  717:        // the correct sparsity information to either of them.
    #####:  718:        auto enc = SparseTensorEncodingAttr::get(
        -:  719:            op->getContext(), encDst.getDimLevelType(), encDst.getDimOrdering(),
        -:  720:            encDst.getHigherOrdering(), encSrc.getPointerBitWidth(),
    #####:  721:            encSrc.getIndexBitWidth());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  722:        newParams(rewriter, params, loc, stp, enc, Action::kToCOO, sizes, src);
call    0 never executed
call    1 never executed
    #####:  723:        Value coo = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  724:        params[3] = constantPointerTypeEncoding(rewriter, loc, encDst);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  725:        params[4] = constantIndexTypeEncoding(rewriter, loc, encDst);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  726:        params[6] = constantAction(rewriter, loc, Action::kFromCOO);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  727:        params[7] = coo;
branch  0 never executed
branch  1 never executed
    #####:  728:        Value dst = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  729:        genDelCOOCall(rewriter, loc, stp.getElementType(), coo);
call    0 never executed
call    1 never executed
    #####:  730:        rewriter.replaceOp(op, dst);
call    0 never executed
call    1 never executed
        -:  731:      }
    #####:  732:      return success();
branch  0 never executed
branch  1 never executed
        -:  733:    }
    #####:  734:    if (!encDst && encSrc) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  735:      // This is sparse => dense conversion, which is handled as follows:
        -:  736:      //   dst = new Tensor(0);
        -:  737:      //   iter = new SparseTensorIterator(src);
        -:  738:      //   while (elem = iter->getNext()) {
        -:  739:      //     dst[elem.indices] = elem.value;
        -:  740:      //   }
        -:  741:      //   delete iter;
    #####:  742:      RankedTensorType dstTensorTp = resType.cast<RankedTensorType>();
call    0 never executed
    #####:  743:      RankedTensorType srcTensorTp = srcType.cast<RankedTensorType>();
call    0 never executed
    #####:  744:      unsigned rank = dstTensorTp.getRank();
call    0 never executed
    #####:  745:      Type elemTp = dstTensorTp.getElementType();
call    0 never executed
        -:  746:      // Fabricate a no-permutation encoding for newParams().
        -:  747:      // The pointer/index types must be those of `src`.
        -:  748:      // The dimLevelTypes aren't actually used by Action::kToIterator.
    #####:  749:      encDst = SparseTensorEncodingAttr::get(
        -:  750:          op->getContext(),
    #####:  751:          SmallVector<DimLevelType>(rank, DimLevelType::Dense), AffineMap(),
call    0 never executed
call    1 never executed
    #####:  752:          AffineMap(), encSrc.getPointerBitWidth(), encSrc.getIndexBitWidth());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  753:      SmallVector<Value, 4> sizes;
call    0 never executed
    #####:  754:      SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  755:      sizesFromPtr(rewriter, sizes, loc, encSrc, srcTensorTp, src);
call    0 never executed
call    1 never executed
    #####:  756:      newParams(rewriter, params, loc, dstTensorTp, encDst, Action::kToIterator,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  757:                sizes, src);
    #####:  758:      Value iter = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  759:      Value ind = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  760:      Value elemPtr = genAllocaScalar(rewriter, loc, elemTp);
call    0 never executed
    #####:  761:      Block *insertionBlock = rewriter.getInsertionBlock();
call    0 never executed
        -:  762:      // TODO: Dense buffers should be allocated/deallocated via the callback
        -:  763:      // in BufferizationOptions.
    #####:  764:      Value dst = allocDenseTensor(rewriter, loc, dstTensorTp, sizes);
call    0 never executed
call    1 never executed
    #####:  765:      SmallVector<Value> noArgs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  766:      SmallVector<Type> noTypes;
branch  0 never executed
branch  1 never executed
    #####:  767:      auto whileOp = rewriter.create<scf::WhileOp>(loc, noTypes, noArgs);
call    0 never executed
    #####:  768:      Block *before = rewriter.createBlock(&whileOp.getBefore(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  769:      rewriter.setInsertionPointToEnd(before);
call    0 never executed
    #####:  770:      Value cond = genGetNextCall(rewriter, loc, iter, ind, elemPtr);
call    0 never executed
    #####:  771:      rewriter.create<scf::ConditionOp>(loc, cond, before->getArguments());
call    0 never executed
    #####:  772:      Block *after = rewriter.createBlock(&whileOp.getAfter(), {}, noTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  773:      rewriter.setInsertionPointToStart(after);
call    0 never executed
    #####:  774:      SmallVector<Value, 4> ivs = loadIndices(rewriter, loc, rank, ind);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  775:      insertScalarIntoDenseTensor(rewriter, loc, elemPtr, dst, ivs);
call    0 never executed
call    1 never executed
    #####:  776:      rewriter.create<scf::YieldOp>(loc);
call    0 never executed
    #####:  777:      rewriter.setInsertionPointAfter(whileOp);
call    0 never executed
    #####:  778:      genDelIteratorCall(rewriter, loc, elemTp, iter);
call    0 never executed
    #####:  779:      rewriter.replaceOpWithNewOp<bufferization::ToTensorOp>(op, resType, dst);
call    0 never executed
        -:  780:      // Deallocate the buffer.
    #####:  781:      if (bufferization::allocationDoesNotEscape(op->getOpResult(0))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  782:        rewriter.setInsertionPoint(insertionBlock->getTerminator());
call    0 never executed
call    1 never executed
    #####:  783:        deallocDenseTensor(rewriter, loc, dst);
call    0 never executed
        -:  784:      }
    #####:  785:      return success();
branch  0 never executed
branch  1 never executed
        -:  786:    }
    #####:  787:    if (!encDst && !encSrc) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  788:      // dense => dense
    #####:  789:      return failure();
        -:  790:    }
        -:  791:    // This is a dense => sparse conversion or a sparse constant in COO =>
        -:  792:    // sparse conversion, which is handled as follows:
        -:  793:    //   t = newSparseCOO()
        -:  794:    //   ...code to fill the COO tensor t...
        -:  795:    //   s = newSparseTensor(t)
        -:  796:    //
        -:  797:    // To fill the COO tensor from a dense tensor:
        -:  798:    //   for i1 in dim1
        -:  799:    //    ..
        -:  800:    //     for ik in dimk
        -:  801:    //       val = a[i1,..,ik]
        -:  802:    //       if val != 0
        -:  803:    //         t->add(val, [i1,..,ik], [p1,..,pk])
        -:  804:    //
        -:  805:    // To fill the COO tensor from a sparse constant in COO format:
        -:  806:    //   for i in range(NNZ)
        -:  807:    //     val = values[i]
        -:  808:    //     [i1,..,ik] = indices[i]
        -:  809:    //     t->add(val, [i1,..,ik], [p1,..,pk])
        -:  810:    //
        -:  811:    // Note that the dense tensor traversal code is actually implemented
        -:  812:    // using MLIR IR to avoid having to expose too much low-level
        -:  813:    // memref traversal details to the runtime support library.
        -:  814:    // Also note that the code below only generates the "new" ops and
        -:  815:    // the loop-nest per se; whereas the entire body of the innermost
        -:  816:    // loop is generated by genAddElt().
    #####:  817:    ShapedType stp = resType.cast<ShapedType>();
call    0 never executed
    #####:  818:    unsigned rank = stp.getRank();
call    0 never executed
    #####:  819:    SmallVector<Value, 4> sizes;
call    0 never executed
    #####:  820:    SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####:  821:    sizesFromSrc(rewriter, sizes, loc, src);
call    0 never executed
    #####:  822:    newParams(rewriter, params, loc, stp, encDst, Action::kEmptyCOO, sizes);
call    0 never executed
call    1 never executed
    #####:  823:    Value coo = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  824:    Value ind = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  825:    Value perm = params[2];
branch  0 never executed
branch  1 never executed
    #####:  826:    Type eltType = stp.getElementType();
call    0 never executed
    #####:  827:    Value elemPtr = genAllocaScalar(rewriter, loc, eltType);
call    0 never executed
    #####:  828:    genDenseTensorOrSparseConstantIterLoop(
call    0 never executed
        -:  829:        rewriter, loc, src, rank,
function _ZZNK12_GLOBAL__N_128SparseTensorConvertConverter15matchAndRewriteEN4mlir13sparse_tensor9ConvertOpENS2_16ConvertOpAdaptorERNS1_25ConversionPatternRewriterEENKUlRNS1_9OpBuilderENS1_8LocationENS1_5ValueENS1_10ValueRangeEE_clES8_S9_SA_SB_ called 0 returned 0% blocks executed 0%
    #####:  830:        [&](OpBuilder &builder, Location loc, Value val, ValueRange indices) {
    #####:  831:          for (unsigned i = 0; i < rank; i++) {
branch  0 never executed
branch  1 never executed
    #####:  832:            Value idx = constantIndex(builder, loc, i);
call    0 never executed
    #####:  833:            builder.create<memref::StoreOp>(loc, indices[i], ind, idx);
call    0 never executed
call    1 never executed
        -:  834:          }
    #####:  835:          builder.create<memref::StoreOp>(loc, val, elemPtr);
call    0 never executed
    #####:  836:          genAddEltCall(builder, loc, eltType, coo, elemPtr, ind, perm);
call    0 never executed
    #####:  837:        });
        -:  838:    // Final call to construct sparse tensor storage.
    #####:  839:    params[6] = constantAction(rewriter, loc, Action::kFromCOO);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  840:    params[7] = coo;
branch  0 never executed
branch  1 never executed
    #####:  841:    Value dst = genNewCall(rewriter, loc, params);
call    0 never executed
    #####:  842:    genDelCOOCall(rewriter, loc, eltType, coo);
call    0 never executed
    #####:  843:    rewriter.replaceOp(op, dst);
call    0 never executed
call    1 never executed
    #####:  844:    return success();
branch  0 never executed
branch  1 never executed
        -:  845:  }
        -:  846:
        -:  847:private:
        -:  848:  /// Options to control sparse code generation.
        -:  849:  SparseTensorConversionOptions options;
        -:  850:};
        -:  851:
        -:  852:/// Sparse conversion rule for the dealloc operator.
        -:  853:class SparseTensorDeallocConverter
        -:  854:    : public OpConversionPattern<bufferization::DeallocTensorOp> {
        -:  855:public:
        -:  856:  using OpConversionPattern::OpConversionPattern;
        -:  857:  LogicalResult
function _ZNK12_GLOBAL__N_128SparseTensorDeallocConverter15matchAndRewriteEN4mlir13bufferization15DeallocTensorOpENS2_22DeallocTensorOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  858:  matchAndRewrite(bufferization::DeallocTensorOp op, OpAdaptor adaptor,
        -:  859:                  ConversionPatternRewriter &rewriter) const override {
    #####:  860:    auto enc = getSparseTensorEncoding(op.getTensor().getType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  861:    if (!enc)
branch  0 never executed
branch  1 never executed
    #####:  862:      return failure();
    #####:  863:    StringRef name = "delSparseTensor";
call    0 never executed
    #####:  864:    createFuncCall(rewriter, op->getLoc(), name, {}, adaptor.getOperands(),
    #####:  865:                   EmitCInterface::Off);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  866:    rewriter.eraseOp(op);
call    0 never executed
    #####:  867:    return success();
        -:  868:  }
        -:  869:};
        -:  870:
        -:  871:/// Sparse conversion rule for pointer accesses.
        -:  872:class SparseTensorToPointersConverter
        -:  873:    : public OpConversionPattern<ToPointersOp> {
        -:  874:public:
        -:  875:  using OpConversionPattern::OpConversionPattern;
        -:  876:  LogicalResult
function _ZNK12_GLOBAL__N_131SparseTensorToPointersConverter15matchAndRewriteEN4mlir13sparse_tensor12ToPointersOpENS2_19ToPointersOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  877:  matchAndRewrite(ToPointersOp op, OpAdaptor adaptor,
        -:  878:                  ConversionPatternRewriter &rewriter) const override {
    #####:  879:    Type resType = op.getType();
call    0 never executed
    #####:  880:    Type ptrType = resType.cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####:  881:    SmallString<16> name{"sparsePointers", overheadTypeFunctionSuffix(ptrType)};
call    0 never executed
call    1 never executed
    #####:  882:    Value dim =
    #####:  883:        constantIndex(rewriter, op->getLoc(), op.getDimension().getZExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  884:    replaceOpWithFuncCall(rewriter, op, name, resType,
    #####:  885:                          {adaptor.getTensor(), dim}, EmitCInterface::On);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  886:    return success();
branch  0 never executed
branch  1 never executed
        -:  887:  }
        -:  888:};
        -:  889:
        -:  890:/// Sparse conversion rule for index accesses.
        -:  891:class SparseTensorToIndicesConverter : public OpConversionPattern<ToIndicesOp> {
        -:  892:public:
        -:  893:  using OpConversionPattern::OpConversionPattern;
        -:  894:  LogicalResult
function _ZNK12_GLOBAL__N_130SparseTensorToIndicesConverter15matchAndRewriteEN4mlir13sparse_tensor11ToIndicesOpENS2_18ToIndicesOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  895:  matchAndRewrite(ToIndicesOp op, OpAdaptor adaptor,
        -:  896:                  ConversionPatternRewriter &rewriter) const override {
    #####:  897:    Type resType = op.getType();
call    0 never executed
    #####:  898:    Type indType = resType.cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####:  899:    SmallString<15> name{"sparseIndices", overheadTypeFunctionSuffix(indType)};
call    0 never executed
call    1 never executed
    #####:  900:    Value dim =
    #####:  901:        constantIndex(rewriter, op->getLoc(), op.getDimension().getZExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  902:    replaceOpWithFuncCall(rewriter, op, name, resType,
    #####:  903:                          {adaptor.getTensor(), dim}, EmitCInterface::On);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  904:    return success();
branch  0 never executed
branch  1 never executed
        -:  905:  }
        -:  906:};
        -:  907:
        -:  908:/// Sparse conversion rule for value accesses.
        -:  909:class SparseTensorToValuesConverter : public OpConversionPattern<ToValuesOp> {
        -:  910:public:
        -:  911:  using OpConversionPattern::OpConversionPattern;
        -:  912:  LogicalResult
function _ZNK12_GLOBAL__N_129SparseTensorToValuesConverter15matchAndRewriteEN4mlir13sparse_tensor10ToValuesOpENS2_17ToValuesOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  913:  matchAndRewrite(ToValuesOp op, OpAdaptor adaptor,
        -:  914:                  ConversionPatternRewriter &rewriter) const override {
    #####:  915:    auto resType = op.getType().cast<ShapedType>();
call    0 never executed
    #####:  916:    rewriter.replaceOp(op, genValuesCall(rewriter, op.getLoc(), resType,
call    0 never executed
    #####:  917:                                         adaptor.getOperands()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  918:    return success();
        -:  919:  }
        -:  920:};
        -:  921:
        -:  922:/// Sparse conversion rule for number of entries operator.
        -:  923:class SparseNumberOfEntriesConverter
        -:  924:    : public OpConversionPattern<NumberOfEntriesOp> {
        -:  925:public:
        -:  926:  using OpConversionPattern::OpConversionPattern;
        -:  927:  LogicalResult
function _ZNK12_GLOBAL__N_130SparseNumberOfEntriesConverter15matchAndRewriteEN4mlir13sparse_tensor17NumberOfEntriesOpENS2_24NumberOfEntriesOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  928:  matchAndRewrite(NumberOfEntriesOp op, OpAdaptor adaptor,
        -:  929:                  ConversionPatternRewriter &rewriter) const override {
    #####:  930:    Location loc = op.getLoc();
call    0 never executed
        -:  931:    // Query values array size for the actually stored values size.
    #####:  932:    Type eltType = op.getTensor().getType().cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  933:    auto resTp = MemRefType::get({ShapedType::kDynamicSize}, eltType);
call    0 never executed
call    1 never executed
    #####:  934:    Value values = genValuesCall(rewriter, loc, resTp, adaptor.getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  935:    rewriter.replaceOpWithNewOp<memref::DimOp>(op, values,
    #####:  936:                                               constantIndex(rewriter, loc, 0));
call    0 never executed
call    1 never executed
    #####:  937:    return success();
        -:  938:  }
        -:  939:};
        -:  940:
        -:  941:/// Sparse conversion rule for tensor rematerialization.
        -:  942:class SparseTensorLoadConverter : public OpConversionPattern<LoadOp> {
        -:  943:public:
        -:  944:  using OpConversionPattern::OpConversionPattern;
        -:  945:  LogicalResult
function _ZNK12_GLOBAL__N_125SparseTensorLoadConverter15matchAndRewriteEN4mlir13sparse_tensor6LoadOpENS2_13LoadOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  946:  matchAndRewrite(LoadOp op, OpAdaptor adaptor,
        -:  947:                  ConversionPatternRewriter &rewriter) const override {
    #####:  948:    if (op.getHasInserts()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  949:      // Finalize any pending insertions.
    #####:  950:      StringRef name = "endInsert";
call    0 never executed
    #####:  951:      createFuncCall(rewriter, op->getLoc(), name, {}, adaptor.getOperands(),
    #####:  952:                     EmitCInterface::Off);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  953:    }
    #####:  954:    rewriter.replaceOp(op, adaptor.getOperands());
call    0 never executed
call    1 never executed
    #####:  955:    return success();
        -:  956:  }
        -:  957:};
        -:  958:
        -:  959:/// Sparse conversion rule for the insertion operator.
        -:  960:class SparseTensorInsertConverter : public OpConversionPattern<InsertOp> {
        -:  961:public:
        -:  962:  using OpConversionPattern::OpConversionPattern;
        -:  963:  LogicalResult
function _ZNK12_GLOBAL__N_127SparseTensorInsertConverter15matchAndRewriteEN4mlir13sparse_tensor8InsertOpENS2_15InsertOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  964:  matchAndRewrite(InsertOp op, OpAdaptor adaptor,
        -:  965:                  ConversionPatternRewriter &rewriter) const override {
        -:  966:    // Note that the current regime only allows for strict lexicographic
        -:  967:    // index order. All values are passed by reference through stack
        -:  968:    // allocated memrefs.
    #####:  969:    Location loc = op->getLoc();
call    0 never executed
    #####:  970:    auto tp = op.getTensor().getType().cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  971:    auto elemTp = tp.getElementType();
call    0 never executed
    #####:  972:    unsigned rank = tp.getRank();
call    0 never executed
    #####:  973:    auto mref = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####:  974:    auto vref = genAllocaScalar(rewriter, loc, elemTp);
    #####:  975:    for (unsigned i = 0; i < rank; i++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  976:      rewriter.create<memref::StoreOp>(loc, adaptor.getIndices()[i], mref,
call    0 never executed
    #####:  977:                                       constantIndex(rewriter, loc, i));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  978:    rewriter.create<memref::StoreOp>(loc, adaptor.getValue(), vref);
call    0 never executed
call    1 never executed
    #####:  979:    SmallString<12> name{"lexInsert", primaryTypeFunctionSuffix(elemTp)};
call    0 never executed
call    1 never executed
    #####:  980:    createFuncCall(rewriter, loc, name, {}, {adaptor.getTensor(), mref, vref},
call    0 never executed
    #####:  981:                   EmitCInterface::On);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  982:    rewriter.replaceOp(op, adaptor.getTensor());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  983:    return success();
branch  0 never executed
branch  1 never executed
        -:  984:  }
        -:  985:};
        -:  986:
        -:  987:/// Sparse conversion rule for the expand operator.
        -:  988:class SparseTensorExpandConverter : public OpConversionPattern<ExpandOp> {
        -:  989:public:
        -:  990:  using OpConversionPattern::OpConversionPattern;
        -:  991:  LogicalResult
function _ZNK12_GLOBAL__N_127SparseTensorExpandConverter15matchAndRewriteEN4mlir13sparse_tensor8ExpandOpENS2_15ExpandOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  992:  matchAndRewrite(ExpandOp op, OpAdaptor adaptor,
        -:  993:                  ConversionPatternRewriter &rewriter) const override {
    #####:  994:    Location loc = op->getLoc();
call    0 never executed
    #####:  995:    RankedTensorType srcType =
    #####:  996:        op.getTensor().getType().cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  997:    Type eltType = srcType.getElementType();
call    0 never executed
    #####:  998:    Type boolType = rewriter.getIntegerType(1);
call    0 never executed
    #####:  999:    Type idxType = rewriter.getIndexType();
call    0 never executed
        -: 1000:    // All initialization should be done on entry of the loop nest.
    #####: 1001:    rewriter.setInsertionPointAfter(op.getTensor().getDefiningOp());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1002:    // Determine the size for access expansion (always the innermost stored
        -: 1003:    // dimension size, translated back to original dimension).
    #####: 1004:    auto enc = getSparseTensorEncoding(srcType);
call    0 never executed
    #####: 1005:    unsigned innerDim = toOrigDim(srcType, srcType.getRank() - 1);
call    0 never executed
call    1 never executed
    #####: 1006:    auto sz = sizeFromPtrAtDim(rewriter, loc, enc, srcType, adaptor.getTensor(),
    #####: 1007:                               innerDim);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1008:    // Allocate temporary buffers for values, filled-switch, and indices.
        -: 1009:    // We do not use stack buffers for this, since the expanded size may
        -: 1010:    // be rather large (as it envelops a single expanded dense dimension).
    #####: 1011:    Value values = genAlloc(rewriter, loc, sz, eltType);
call    0 never executed
    #####: 1012:    Value filled = genAlloc(rewriter, loc, sz, boolType);
call    0 never executed
    #####: 1013:    Value indices = genAlloc(rewriter, loc, sz, idxType);
call    0 never executed
    #####: 1014:    Value zero = constantZero(rewriter, loc, idxType);
call    0 never executed
        -: 1015:    // Reset the values/filled-switch to all-zero/false. Note that this
        -: 1016:    // introduces an O(N) operation into the computation, but this reset
        -: 1017:    // operation is amortized over the innermost loops for the access
        -: 1018:    // pattern expansion. As noted in the operation doc, we would like
        -: 1019:    // to amortize this setup cost even between kernels.
    #####: 1020:    rewriter.create<linalg::FillOp>(
    #####: 1021:        loc, ValueRange{constantZero(rewriter, loc, eltType)},
call    0 never executed
    #####: 1022:        ValueRange{values});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1023:    rewriter.create<linalg::FillOp>(
    #####: 1024:        loc, ValueRange{constantZero(rewriter, loc, boolType)},
call    0 never executed
    #####: 1025:        ValueRange{filled});
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1026:    // Replace expansion op with these buffers and initial index.
    #####: 1027:    assert(op.getNumResults() == 4);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1028:    rewriter.replaceOp(op, {values, filled, indices, zero});
call    0 never executed
call    1 never executed
    #####: 1029:    return success();
        -: 1030:  }
        -: 1031:};
        -: 1032:
        -: 1033:/// Sparse conversion rule for the compress operator.
        -: 1034:class SparseTensorCompressConverter : public OpConversionPattern<CompressOp> {
        -: 1035:public:
        -: 1036:  using OpConversionPattern::OpConversionPattern;
        -: 1037:  LogicalResult
function _ZNK12_GLOBAL__N_129SparseTensorCompressConverter15matchAndRewriteEN4mlir13sparse_tensor10CompressOpENS2_17CompressOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1038:  matchAndRewrite(CompressOp op, OpAdaptor adaptor,
        -: 1039:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1040:    Location loc = op->getLoc();
call    0 never executed
        -: 1041:    // Note that this method call resets the values/filled-switch back to
        -: 1042:    // all-zero/false by only iterating over the set elements, so the
        -: 1043:    // complexity remains proportional to the sparsity of the expanded
        -: 1044:    // access pattern.
    #####: 1045:    Value values = adaptor.getValues();
call    0 never executed
    #####: 1046:    Value filled = adaptor.getFilled();
call    0 never executed
    #####: 1047:    Value added = adaptor.getAdded();
call    0 never executed
    #####: 1048:    Value count = adaptor.getCount();
call    0 never executed
    #####: 1049:    Value tensor = adaptor.getTensor();
call    0 never executed
    #####: 1050:    auto tp = op.getTensor().getType().cast<RankedTensorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1051:    Type elemTp = tp.getElementType();
call    0 never executed
    #####: 1052:    unsigned rank = tp.getRank();
call    0 never executed
    #####: 1053:    auto mref = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####: 1054:    for (unsigned i = 0; i < rank - 1; i++)
branch  0 never executed
branch  1 never executed
    #####: 1055:      rewriter.create<memref::StoreOp>(loc, adaptor.getIndices()[i], mref,
call    0 never executed
    #####: 1056:                                       constantIndex(rewriter, loc, i));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1057:    SmallString<12> name{"expInsert", primaryTypeFunctionSuffix(elemTp)};
call    0 never executed
call    1 never executed
    #####: 1058:    createFuncCall(rewriter, loc, name, {},
        -: 1059:                   {tensor, mref, values, filled, added, count},
    #####: 1060:                   EmitCInterface::On);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1061:    rewriter.replaceOp(op, adaptor.getTensor());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1062:    // Deallocate the buffers on exit of the loop nest.
    #####: 1063:    Operation *parent = getTop(op);
call    0 never executed
    #####: 1064:    rewriter.setInsertionPointAfter(parent);
call    0 never executed
    #####: 1065:    rewriter.create<memref::DeallocOp>(loc, values);
call    0 never executed
    #####: 1066:    rewriter.create<memref::DeallocOp>(loc, filled);
call    0 never executed
    #####: 1067:    rewriter.create<memref::DeallocOp>(loc, added);
call    0 never executed
    #####: 1068:    return success();
branch  0 never executed
branch  1 never executed
        -: 1069:  }
        -: 1070:};
        -: 1071:
        -: 1072:/// Sparse conversion rule for the concatenate operator.
        -: 1073:class SparseTensorConcatConverter : public OpConversionPattern<ConcatenateOp> {
        -: 1074:public:
        -: 1075:  using OpConversionPattern::OpConversionPattern;
        -: 1076:  LogicalResult
function _ZNK12_GLOBAL__N_127SparseTensorConcatConverter15matchAndRewriteEN4mlir13sparse_tensor13ConcatenateOpENS2_20ConcatenateOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1077:  matchAndRewrite(ConcatenateOp op, OpAdaptor adaptor,
        -: 1078:                  ConversionPatternRewriter &rewriter) const override {
        -: 1079:    // The conversion works as follow:
        -: 1080:    // (1). When output is sparse, and mix of inputs:
        -: 1081:    //    a_sparse = concat (b_dense, c_sparse, ....)
        -: 1082:    // =>
        -: 1083:    //    coo_for_a = newSparseCOO(shapeOf(a))
        -: 1084:    //    for i, j, k // dense input
        -: 1085:    //      coo->add(adjustForOffset(i,j,k), b[i,j,k])
        -: 1086:    //
        -: 1087:    //    for elem in sparse_input
        -: 1088:    //      coo->add(adjustForOffset(elem.indices), elem.value)
        -: 1089:    //    ...
        -: 1090:    //    a = newSparseTensor(coo_for_a)
        -: 1091:    //    return a
        -: 1092:    //
        -: 1093:    // (2). When output is dense, and mix of inputs:
        -: 1094:    //    a_dense = concat (b_dense, c_sparse, ....)
        -: 1095:    // =>
        -: 1096:    //    a = malloc(shapeOf(a))
        -: 1097:    //    for i, j, k // dense input
        -: 1098:    //      a[ adjustForOffset(i,j,k) ] = b[i,j,k]
        -: 1099:    //
        -: 1100:    //    for elem in sparse_input
        -: 1101:    //      a[ adjustForOffset(elem.indices) ] = elem.value
        -: 1102:    //    return a
    #####: 1103:    Location loc = op.getLoc();
call    0 never executed
    #####: 1104:    auto dstTp = op.getType().cast<RankedTensorType>();
call    0 never executed
call    1 never executed
    #####: 1105:    auto encDst = getSparseTensorEncoding(dstTp);
call    0 never executed
    #####: 1106:    Type elemTp = dstTp.getElementType();
call    0 never executed
    #####: 1107:    uint64_t concatDim = op.getDimension().getZExtValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1108:    unsigned rank = dstTp.getRank();
call    0 never executed
        -: 1109:
    #####: 1110:    Value dst;     // destination tensor
    #####: 1111:    Value dstPerm; // destination tensor permutation (if sparse out)
        -: 1112:    // A pointer to the value being inserted (if dense => sparse)
    #####: 1113:    Value elemPtr;
        -: 1114:    // Memory that holds the COO for destination tensor (if sparse out)
    #####: 1115:    Value dstIdx;
        -: 1116:    // The offset applied to the dimenstion to be concated (starting from 0)
    #####: 1117:    Value offset = constantIndex(rewriter, loc, 0);
call    0 never executed
        -: 1118:
    #####: 1119:    SmallVector<Value, 4> sizes;
call    0 never executed
    #####: 1120:    SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####: 1121:    concatSizesFromInputs(rewriter, sizes, loc, dstTp, op.getInputs(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1122:                          concatDim);
        -: 1123:
    #####: 1124:    if (encDst) {
branch  0 never executed
branch  1 never executed
        -: 1125:      // Start a new COO for the destination tensor.
    #####: 1126:      newParams(rewriter, params, loc, dstTp, encDst, Action::kEmptyCOO, sizes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1127:      dst = genNewCall(rewriter, loc, params);
call    0 never executed
    #####: 1128:      dstPerm = params[2];
branch  0 never executed
branch  1 never executed
    #####: 1129:      elemPtr = genAllocaScalar(rewriter, loc, elemTp);
call    0 never executed
    #####: 1130:      dstIdx = genAlloca(rewriter, loc, rank, rewriter.getIndexType());
call    0 never executed
call    1 never executed
        -: 1131:    } else {
        -: 1132:      // TODO: Dense buffers should be allocated/deallocated via the callback
        -: 1133:      // in BufferizationOptions.
    #####: 1134:      dst = allocDenseTensor(rewriter, loc, dstTp, sizes);
call    0 never executed
call    1 never executed
        -: 1135:    }
    #####: 1136:    for (auto it : llvm::zip(op.getInputs(), adaptor.getInputs())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1137:      Value orignalOp = std::get<0>(it); // Input (with encoding) from Op
call    0 never executed
    #####: 1138:      Value adaptedOp = std::get<1>(it); // Input (type converted) from adaptor
call    0 never executed
    #####: 1139:      RankedTensorType srcTp = orignalOp.getType().cast<RankedTensorType>();
call    0 never executed
    #####: 1140:      auto encSrc = getSparseTensorEncoding(srcTp);
call    0 never executed
    #####: 1141:      if (encSrc) {
branch  0 never executed
branch  1 never executed
    #####: 1142:        genSparseCOOIterationLoop(
call    0 never executed
        -: 1143:            rewriter, loc, adaptedOp, srcTp,
function _ZZNK12_GLOBAL__N_127SparseTensorConcatConverter15matchAndRewriteEN4mlir13sparse_tensor13ConcatenateOpENS2_20ConcatenateOpAdaptorERNS1_25ConversionPatternRewriterEENKUlRNS1_9OpBuilderENS1_8LocationENS1_5ValueESA_E_clES8_S9_SA_SA_ called 0 returned 0% blocks executed 0%
    #####: 1144:            [&](OpBuilder &builder, Location loc, Value idx,
        -: 1145:                Value elemPtr) -> void {
    #####: 1146:              auto indVec =
    #####: 1147:                  loadIndices(builder, loc, rank, idx, concatDim, offset);
call    0 never executed
    #####: 1148:              if (encDst) {
branch  0 never executed
branch  1 never executed
        -: 1149:                // Case: sparse => sparse
    #####: 1150:                storeIndices(builder, loc, rank, dstIdx, indVec);
call    0 never executed
call    1 never executed
    #####: 1151:                genAddEltCall(builder, loc, elemTp, dst, elemPtr, dstIdx,
    #####: 1152:                              dstPerm);
call    0 never executed
        -: 1153:              } else {
        -: 1154:                // Case: sparse => dense
    #####: 1155:                insertScalarIntoDenseTensor(builder, loc, elemPtr, dst, indVec);
call    0 never executed
call    1 never executed
        -: 1156:              }
    #####: 1157:            });
        -: 1158:      } else {
    #####: 1159:        genDenseTensorIterationLoop(
call    0 never executed
        -: 1160:            rewriter, loc, adaptedOp, srcTp,
function _ZZNK12_GLOBAL__N_127SparseTensorConcatConverter15matchAndRewriteEN4mlir13sparse_tensor13ConcatenateOpENS2_20ConcatenateOpAdaptorERNS1_25ConversionPatternRewriterEENKUlRNS1_9OpBuilderENS1_8LocationENS1_10ValueRangeEE0_clES8_S9_SA_ called 0 returned 0% blocks executed 0%
    #####: 1161:            [&](OpBuilder &builder, Location loc, ValueRange idx) -> void {
    #####: 1162:              if (encDst) {
branch  0 never executed
branch  1 never executed
        -: 1163:                // Case: dense => sparse
    #####: 1164:                storeIndices(builder, loc, rank, dstIdx, idx, concatDim,
    #####: 1165:                             offset);
call    0 never executed
    #####: 1166:                Value val = genValueForDense(builder, loc, adaptedOp, idx);
call    0 never executed
    #####: 1167:                builder.create<memref::StoreOp>(loc, val, elemPtr);
call    0 never executed
    #####: 1168:                genAddEltCall(builder, loc, elemTp, dst, elemPtr, dstIdx,
    #####: 1169:                              dstPerm);
call    0 never executed
        -: 1170:              } else {
        -: 1171:                // Case: dense => dense
    #####: 1172:                Value val = genValueForDense(builder, loc, adaptedOp, idx);
call    0 never executed
    #####: 1173:                SmallVector<Value, 4> indVec(idx);
call    0 never executed
        -: 1174:                // Apply offset.
    #####: 1175:                indVec[concatDim] = builder.create<arith::AddIOp>(
branch  0 never executed
branch  1 never executed
    #####: 1176:                    loc, indVec[concatDim], offset);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1177:                builder.create<memref::StoreOp>(loc, val, dst, indVec);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1178:              }
    #####: 1179:            });
        -: 1180:      }
        -: 1181:      // Accumulate offset.
        -: 1182:      // TODO: avoid calling sparseDimSize multiple times by caching the result!
    #####: 1183:      Value curDim = encSrc ? sizeFromPtrAtDim(rewriter, loc, encSrc, srcTp,
    #####: 1184:                                               adaptedOp, concatDim)
call    0 never executed
call    1 never executed
        -: 1185:                            : linalg::createOrFoldDimOp(rewriter, loc,
    #####: 1186:                                                        adaptedOp, concatDim);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1187:
    #####: 1188:      offset = rewriter.create<arith::AddIOp>(loc, offset, curDim);
call    0 never executed
        -: 1189:    }
    #####: 1190:    if (encDst) {
branch  0 never executed
branch  1 never executed
    #####: 1191:      params[6] = constantAction(rewriter, loc, Action::kFromCOO);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1192:      // In sparse output case, the destination holds the COO.
    #####: 1193:      Value coo = dst;
    #####: 1194:      params[7] = coo;
branch  0 never executed
branch  1 never executed
    #####: 1195:      dst = genNewCall(rewriter, loc, params);
call    0 never executed
        -: 1196:      // Release resources.
    #####: 1197:      genDelCOOCall(rewriter, loc, elemTp, coo);
call    0 never executed
    #####: 1198:      rewriter.replaceOp(op, dst);
call    0 never executed
call    1 never executed
        -: 1199:    } else {
    #####: 1200:      rewriter.replaceOpWithNewOp<bufferization::ToTensorOp>(op, dstTp, dst);
call    0 never executed
        -: 1201:    }
    #####: 1202:    return success();
branch  0 never executed
branch  1 never executed
        -: 1203:  }
        -: 1204:};
        -: 1205:
        -: 1206:/// Sparse conversion rule for the output operator.
        -: 1207:class SparseTensorOutConverter : public OpConversionPattern<OutOp> {
        -: 1208:public:
        -: 1209:  using OpConversionPattern::OpConversionPattern;
        -: 1210:  LogicalResult
function _ZNK12_GLOBAL__N_124SparseTensorOutConverter15matchAndRewriteEN4mlir13sparse_tensor5OutOpENS2_12OutOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1211:  matchAndRewrite(OutOp op, OpAdaptor adaptor,
        -: 1212:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1213:    Location loc = op->getLoc();
call    0 never executed
    #####: 1214:    ShapedType srcType = op.getTensor().getType().cast<ShapedType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1215:    // Convert to default permuted COO.
    #####: 1216:    Value src = adaptor.getOperands()[0];
call    0 never executed
call    1 never executed
    #####: 1217:    auto encSrc = getSparseTensorEncoding(srcType);
call    0 never executed
    #####: 1218:    SmallVector<Value, 4> sizes;
call    0 never executed
    #####: 1219:    SmallVector<Value, 8> params;
branch  0 never executed
branch  1 never executed
    #####: 1220:    sizesFromPtr(rewriter, sizes, loc, encSrc, srcType, src);
call    0 never executed
    #####: 1221:    auto enc = SparseTensorEncodingAttr::get(
        -: 1222:        op->getContext(), encSrc.getDimLevelType(), AffineMap(), AffineMap(),
    #####: 1223:        encSrc.getPointerBitWidth(), encSrc.getIndexBitWidth());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1224:    newParams(rewriter, params, loc, srcType, enc, Action::kToCOO, sizes, src);
call    0 never executed
call    1 never executed
    #####: 1225:    Value coo = genNewCall(rewriter, loc, params);
call    0 never executed
        -: 1226:    // Then output the tensor to external file with indices in the externally
        -: 1227:    // visible lexicographic index order. A sort is required if the source was
        -: 1228:    // not in that order yet (note that the sort can be dropped altogether if
        -: 1229:    // external format does not care about the order at all, but here we assume
        -: 1230:    // it does).
    #####: 1231:    bool sort =
    #####: 1232:        encSrc.getDimOrdering() && !encSrc.getDimOrdering().isIdentity();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1233:    params.clear();
call    0 never executed
    #####: 1234:    params.push_back(coo);
call    0 never executed
    #####: 1235:    params.push_back(adaptor.getOperands()[1]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1236:    params.push_back(constantI1(rewriter, loc, sort));
call    0 never executed
call    1 never executed
    #####: 1237:    Type eltType = srcType.getElementType();
call    0 never executed
    #####: 1238:    SmallString<18> name{"outSparseTensor", primaryTypeFunctionSuffix(eltType)};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1239:    createFuncCall(rewriter, loc, name, {}, params, EmitCInterface::Off);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1240:    genDelCOOCall(rewriter, loc, eltType, coo);
call    0 never executed
    #####: 1241:    rewriter.eraseOp(op);
call    0 never executed
    #####: 1242:    return success();
branch  0 never executed
branch  1 never executed
        -: 1243:  }
        -: 1244:};
        -: 1245:
        -: 1246:} // namespace
        -: 1247:
        -: 1248://===----------------------------------------------------------------------===//
        -: 1249:// Sparse tensor type conversion into opaque pointer.
        -: 1250://===----------------------------------------------------------------------===//
        -: 1251:
function _ZN4mlir30SparseTensorTypeToPtrConverterC2Ev called 1017 returned 100% blocks executed 100%
     1017: 1252:mlir::SparseTensorTypeToPtrConverter::SparseTensorTypeToPtrConverter() {
call    0 returned 100%
    1017*: 1253:  addConversion([](Type type) { return type; });
call    0 never executed
call    1 returned 100%
     1017: 1254:  addConversion(convertSparseTensorTypes);
call    0 returned 100%
     1017: 1255:}
        -: 1256:
        -: 1257://===----------------------------------------------------------------------===//
        -: 1258:// Public method for populating conversion rules.
        -: 1259://===----------------------------------------------------------------------===//
        -: 1260:
        -: 1261:/// Populates the given patterns list with conversion rules required for
        -: 1262:/// the sparsification of linear algebra operations.
function _ZN4mlir38populateSparseTensorConversionPatternsERNS_13TypeConverterERNS_17RewritePatternSetERKNS_29SparseTensorConversionOptionsE called 1017 returned 100% blocks executed 100%
     1017: 1263:void mlir::populateSparseTensorConversionPatterns(
        -: 1264:    TypeConverter &typeConverter, RewritePatternSet &patterns,
        -: 1265:    const SparseTensorConversionOptions &options) {
     1017: 1266:  patterns.add<SparseReturnConverter, SparseTensorToDimSizeConverter,
        -: 1267:               SparseCastConverter, SparseTensorNewConverter,
        -: 1268:               SparseReshapeConverter<tensor::ExpandShapeOp>,
        -: 1269:               SparseReshapeConverter<tensor::CollapseShapeOp>,
        -: 1270:               SparseTensorConcatConverter, SparseTensorAllocConverter,
        -: 1271:               SparseTensorDeallocConverter, SparseTensorToPointersConverter,
        -: 1272:               SparseTensorToIndicesConverter, SparseTensorToValuesConverter,
        -: 1273:               SparseNumberOfEntriesConverter, SparseTensorLoadConverter,
        -: 1274:               SparseTensorInsertConverter, SparseTensorExpandConverter,
        -: 1275:               SparseTensorCompressConverter, SparseTensorOutConverter>(
     1017: 1276:      typeConverter, patterns.getContext());
call    0 returned 100%
        -: 1277:
     1017: 1278:  patterns.add<SparseTensorConvertConverter>(typeConverter,
     1017: 1279:                                             patterns.getContext(), options);
call    0 returned 100%
     1017: 1280:}
