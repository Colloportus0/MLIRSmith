        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Vector/Transforms/VectorUnroll.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorUnroll.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorUnroll.cpp.gcda
        -:    0:Runs:128654
        -:    1://===- VectorUnrollDistribute.cpp - patterns to do vector unrolling -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements patterns to do vector unrolling and vector distribution.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   14:#include "mlir/Dialect/Utils/IndexingUtils.h"
        -:   15:#include "mlir/Dialect/Vector/Transforms/VectorTransforms.h"
        -:   16:#include "mlir/IR/ImplicitLocOpBuilder.h"
        -:   17:#include "mlir/Interfaces/VectorInterfaces.h"
        -:   18:#include "mlir/Support/MathExtras.h"
        -:   19:#include "llvm/ADT/MapVector.h"
        -:   20:#include "llvm/ADT/STLExtras.h"
        -:   21:#include <numeric>
        -:   22:
        -:   23:#define DEBUG_TYPE "vector-unrolling"
        -:   24:
        -:   25:using namespace mlir;
        -:   26:using namespace mlir::vector;
        -:   27:
        -:   28:/// During unrolling from `originalShape` to `targetShape` return the offset for
        -:   29:/// the slice `index`.
function _ZL15getVectorOffsetN4llvm8ArrayRefIlEES1_l called 0 returned 0% blocks executed 0%
    #####:   30:static SmallVector<int64_t, 4> getVectorOffset(ArrayRef<int64_t> originalShape,
        -:   31:                                               ArrayRef<int64_t> targetShape,
        -:   32:                                               int64_t index) {
    #####:   33:  SmallVector<int64_t, 4> dstSliceStrides =
    #####:   34:      computeStrides(originalShape, targetShape);
call    0 never executed
    #####:   35:  SmallVector<int64_t, 4> vectorOffsets = delinearize(dstSliceStrides, index);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   36:  SmallVector<int64_t, 4> elementOffsets =
call    0 never executed
    #####:   37:      computeElementOffsetsFromVectorSliceOffsets(targetShape, vectorOffsets);
call    0 never executed
    #####:   38:  return elementOffsets;
branch  0 never executed
branch  1 never executed
        -:   39:}
        -:   40:
        -:   41:/// A functor that accomplishes the same thing as `getVectorOffset` but allows
        -:   42:/// for reordering the traversal of the dimensions. The order of traversal is
        -:   43:/// given in "for loop order" (outer to inner).
        -:   44:namespace {
        -:   45:class DecomposeShapeIterator {
        -:   46:private:
        -:   47:  SmallVector<int64_t, 4> vectorShape;
        -:   48:  SmallVector<int64_t> loopOrder;
        -:   49:  SmallVector<int64_t> sliceStrides;
        -:   50:  int64_t maxIndexVal{1};
        -:   51:
        -:   52:public:
function _ZN12_GLOBAL__N_122DecomposeShapeIteratorC2EN4llvm8ArrayRefIlEES3_S3_ called 0 returned 0% blocks executed 0%
    #####:   53:  DecomposeShapeIterator(ArrayRef<int64_t> originalShape,
        -:   54:                         ArrayRef<int64_t> targetShape,
        -:   55:                         ArrayRef<int64_t> loopOrder)
    #####:   56:      : vectorShape(targetShape.begin(), targetShape.end()),
        -:   57:        loopOrder(loopOrder.begin(), loopOrder.end()),
    #####:   58:        sliceStrides(originalShape.size()) {
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   59:    assert(originalShape.size() == targetShape.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:    assert(loopOrder.size() == targetShape.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   61:
        -:   62:    // Compute the count for each dimension.
    #####:   63:    SmallVector<int64_t> sliceDimCounts(originalShape.size());
call    0 never executed
    #####:   64:    for (unsigned r = 0; r < originalShape.size(); ++r) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   65:      sliceDimCounts[r] = ceilDiv(originalShape[r], targetShape[r]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   66:      maxIndexVal *= sliceDimCounts[r];
        -:   67:    }
        -:   68:
        -:   69:    // Reversing "loop order" gives dimensions from fastest varying to slowest
        -:   70:    // varying (smallest stride to largest stride).
        -:   71:    int64_t accum = 1;
    #####:   72:    for (auto idx : llvm::reverse(loopOrder)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   73:      sliceStrides[idx] = accum;
branch  0 never executed
branch  1 never executed
    #####:   74:      accum *= sliceDimCounts[idx];
branch  0 never executed
branch  1 never executed
        -:   75:    }
    #####:   76:  }
        -:   77:
        -:   78:  // Turn the linear index into a d-tuple based on units of vectors of size
        -:   79:  // `vectorShape`. The linear index is assumed to represent traversal of the
        -:   80:  // dimensions based on `order`.
function _ZNK12_GLOBAL__N_122DecomposeShapeIterator11delinearizeEl called 0 returned 0% blocks executed 0%
    #####:   81:  SmallVector<int64_t> delinearize(int64_t index) const {
        -:   82:    // Traverse in for loop order (largest stride to smallest stride).
    #####:   83:    SmallVector<int64_t> vectorOffsets(sliceStrides.size());
call    0 never executed
    #####:   84:    for (auto idx : loopOrder) {
branch  0 never executed
branch  1 never executed
    #####:   85:      vectorOffsets[idx] = index / sliceStrides[idx];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      index %= sliceStrides[idx];
        -:   87:    }
    #####:   88:    return vectorOffsets;
        -:   89:  }
        -:   90:
    #####:   91:  int64_t maxIndex() const { return maxIndexVal; }
        -:   92:
        -:   93:  /// Return the offset within d-tuple based on the ordering given by
        -:   94:  /// `loopOrder`.
function _ZNK12_GLOBAL__N_122DecomposeShapeIterator15getVectorOffsetEl called 0 returned 0% blocks executed 0%
    #####:   95:  SmallVector<int64_t> getVectorOffset(int64_t index) const {
    #####:   96:    SmallVector<int64_t> vectorOffsets = delinearize(index);
call    0 never executed
    #####:   97:    SmallVector<int64_t> elementOffsets =
call    0 never executed
    #####:   98:        computeElementOffsetsFromVectorSliceOffsets(vectorShape, vectorOffsets);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   99:    return elementOffsets;
branch  0 never executed
branch  1 never executed
        -:  100:  }
        -:  101:};
        -:  102:} // namespace
        -:  103:
        -:  104:/// Compute the indices of the slice `index` for a tranfer op.
function _ZL20sliceTransferIndicesN4llvm8ArrayRefIlEENS0_IN4mlir5ValueEEENS2_9AffineMapENS2_8LocationERNS2_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  105:static SmallVector<Value> sliceTransferIndices(ArrayRef<int64_t> elementOffsets,
        -:  106:                                               ArrayRef<Value> indices,
        -:  107:                                               AffineMap permutationMap,
        -:  108:                                               Location loc,
        -:  109:                                               OpBuilder &builder) {
    #####:  110:  MLIRContext *ctx = builder.getContext();
call    0 never executed
function _ZZL20sliceTransferIndicesN4llvm8ArrayRefIlEENS0_IN4mlir5ValueEEENS2_9AffineMapENS2_8LocationERNS2_9OpBuilderEENKUlNS2_10AffineExprEE_clES9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  111:  auto isBroadcast = [](AffineExpr expr) {
    #####:  112:    if (auto constExpr = expr.dyn_cast<AffineConstantExpr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  113:      return constExpr.getValue() == 0;
call    0 never executed
    #####:  114:    return false;
        -:  115:  };
        -:  116:  // Compute 'sliceIndices' by adding 'sliceOffsets[i]' to 'indices[i]'.
    #####:  117:  SmallVector<Value> slicedIndices(indices.begin(), indices.end());
call    0 never executed
    #####:  118:  for (const auto &dim : llvm::enumerate(permutationMap.getResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  119:    if (isBroadcast(dim.value()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  120:      continue;
    #####:  121:    unsigned pos = dim.value().cast<AffineDimExpr>().getPosition();
call    0 never executed
call    1 never executed
    #####:  122:    auto expr = getAffineDimExpr(0, builder.getContext()) +
call    0 never executed
    #####:  123:                getAffineConstantExpr(elementOffsets[dim.index()], ctx);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  124:    auto map = AffineMap::get(/*dimCount=*/1, /*symbolCount=*/0, expr);
call    0 never executed
    #####:  125:    slicedIndices[pos] = builder.create<AffineApplyOp>(loc, map, indices[pos]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  126:  }
    #####:  127:  return slicedIndices;
        -:  128:}
        -:  129:
        -:  130:// Clones `op` into a new operations that takes `operands` and returns
        -:  131:// `resultTypes`.
function _ZL27cloneOpWithOperandsAndTypesRN4mlir9OpBuilderENS_8LocationEPNS_9OperationEN4llvm8ArrayRefINS_5ValueEEENS6_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  132:static Operation *cloneOpWithOperandsAndTypes(OpBuilder &builder, Location loc,
        -:  133:                                              Operation *op,
        -:  134:                                              ArrayRef<Value> operands,
        -:  135:                                              ArrayRef<Type> resultTypes) {
    #####:  136:  return builder.create(loc, op->getName().getIdentifier(), operands,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  137:                        resultTypes, op->getAttrs());
        -:  138:}
        -:  139:
        -:  140:/// Return the target shape for unrolling for the given `op`. Return llvm::None
        -:  141:/// if the op shouldn't be or cannot be unrolled.
        -:  142:static Optional<SmallVector<int64_t, 4>>
function _ZL14getTargetShapeRKN4mlir6vector19UnrollVectorOptionsEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  143:getTargetShape(const vector::UnrollVectorOptions &options, Operation *op) {
    #####:  144:  if (options.filterConstraint && failed(options.filterConstraint(op)))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  145:    return llvm::None;
    #####:  146:  assert(options.nativeShape &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  147:         "vector unrolling expects the native shape or native"
        -:  148:         "shape call back function to be set");
    #####:  149:  auto unrollableVectorOp = dyn_cast<VectorUnrollOpInterface>(op);
call    0 never executed
    #####:  150:  if (!unrollableVectorOp)
branch  0 never executed
branch  1 never executed
    #####:  151:    return llvm::None;
    #####:  152:  auto maybeUnrollShape = unrollableVectorOp.getShapeForUnroll();
call    0 never executed
    #####:  153:  if (!maybeUnrollShape)
branch  0 never executed
branch  1 never executed
    #####:  154:    return llvm::None;
    #####:  155:  Optional<SmallVector<int64_t, 4>> targetShape = options.nativeShape(op);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  156:  if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  157:    return llvm::None;
    #####:  158:  auto maybeShapeRatio = shapeRatio(*maybeUnrollShape, *targetShape);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  159:  if (!maybeShapeRatio ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  160:      llvm::all_of(*maybeShapeRatio, [](int64_t v) { return v == 1; }))
branch  0 never executed
branch  1 never executed
    #####:  161:    return llvm::None;
    #####:  162:  return targetShape;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  163:}
        -:  164:
        -:  165:static SmallVector<int64_t>
function _ZL14getUnrollOrderjPN4mlir9OperationERKNS_6vector19UnrollVectorOptionsE called 0 returned 0% blocks executed 0%
    #####:  166:getUnrollOrder(unsigned numLoops, Operation *op,
        -:  167:               const vector::UnrollVectorOptions &options) {
    #####:  168:  SmallVector<int64_t> loopOrder =
    #####:  169:      llvm::to_vector(llvm::seq<int64_t>(0, static_cast<int64_t>(numLoops)));
call    0 never executed
call    1 never executed
    #####:  170:  if (options.traversalOrderCallback != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  171:    Optional<SmallVector<int64_t>> order = options.traversalOrderCallback(op);
call    0 never executed
    #####:  172:    if (order) {
branch  0 never executed
branch  1 never executed
    #####:  173:      loopOrder = std::move(*order);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  174:    }
        -:  175:  }
    #####:  176:  return loopOrder;
        -:  177:}
        -:  178:
        -:  179:namespace {
        -:  180:
        -:  181:struct UnrollTransferReadPattern
        -:  182:    : public OpRewritePattern<vector::TransferReadOp> {
function _ZN12_GLOBAL__N_125UnrollTransferReadPatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  183:  UnrollTransferReadPattern(MLIRContext *context,
        -:  184:                            const vector::UnrollVectorOptions &options,
        -:  185:                            PatternBenefit benefit = 1)
    #####:  186:      : OpRewritePattern<vector::TransferReadOp>(context, benefit),
    #####:  187:        options(options) {}
call    0 never executed
call    1 never executed
        -:  188:
function _ZNK12_GLOBAL__N_125UnrollTransferReadPattern15matchAndRewriteEN4mlir6vector14TransferReadOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  189:  LogicalResult matchAndRewrite(vector::TransferReadOp readOp,
        -:  190:                                PatternRewriter &rewriter) const override {
        -:  191:    // TODO: support 0-d corner case.
    #####:  192:    if (readOp.getTransferRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  193:      return failure();
    #####:  194:    if (readOp.getMask())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  195:      return failure();
    #####:  196:    auto targetShape = getTargetShape(options, readOp);
call    0 never executed
    #####:  197:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  198:      return failure();
    #####:  199:    auto sourceVectorType = readOp.getVectorType();
call    0 never executed
    #####:  200:    SmallVector<int64_t, 4> strides(targetShape->size(), 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  201:    Location loc = readOp.getLoc();
call    0 never executed
    #####:  202:    ArrayRef<int64_t> originalSize = readOp.getVectorType().getShape();
call    0 never executed
call    1 never executed
        -:  203:
        -:  204:    // Prepare the result vector;
    #####:  205:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  206:        loc, sourceVectorType, rewriter.getZeroAttr(sourceVectorType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  207:    auto targetType =
    #####:  208:        VectorType::get(*targetShape, sourceVectorType.getElementType());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  209:    SmallVector<Value, 4> originalIndices(readOp.getIndices().begin(),
call    0 never executed
    #####:  210:                                          readOp.getIndices().end());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  211:
    #####:  212:    SmallVector<int64_t> loopOrder =
    #####:  213:        getUnrollOrder(originalSize.size(), readOp, options);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:    DecomposeShapeIterator indexToOffsets(originalSize, *targetShape,
branch  0 never executed
branch  1 never executed
    #####:  215:                                          loopOrder);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  216:    for (int64_t i = 0; i < indexToOffsets.maxIndex(); i++) {
branch  0 never executed
branch  1 never executed
    #####:  217:      SmallVector<int64_t, 4> elementOffsets =
    #####:  218:          indexToOffsets.getVectorOffset(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  219:      SmallVector<Value, 4> indices =
    #####:  220:          sliceTransferIndices(elementOffsets, originalIndices,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  221:                               readOp.getPermutationMap(), loc, rewriter);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  222:      auto slicedRead = rewriter.create<vector::TransferReadOp>(
    #####:  223:          loc, targetType, readOp.getSource(), indices,
call    0 never executed
    #####:  224:          readOp.getPermutationMapAttr(), readOp.getPadding(), readOp.getMask(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  225:          readOp.getInBoundsAttr());
call    0 never executed
call    1 never executed
        -:  226:
    #####:  227:      result = rewriter.create<vector::InsertStridedSliceOp>(
branch  0 never executed
branch  1 never executed
    #####:  228:          loc, slicedRead, result, elementOffsets, strides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  229:    }
    #####:  230:    rewriter.replaceOp(readOp, result);
call    0 never executed
call    1 never executed
    #####:  231:    return success();
call    0 never executed
        -:  232:  }
        -:  233:
        -:  234:private:
        -:  235:  vector::UnrollVectorOptions options;
        -:  236:};
        -:  237:
        -:  238:struct UnrollTransferWritePattern
        -:  239:    : public OpRewritePattern<vector::TransferWriteOp> {
function _ZN12_GLOBAL__N_126UnrollTransferWritePatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  240:  UnrollTransferWritePattern(MLIRContext *context,
        -:  241:                             const vector::UnrollVectorOptions &options,
        -:  242:                             PatternBenefit benefit = 1)
    #####:  243:      : OpRewritePattern<vector::TransferWriteOp>(context, benefit),
    #####:  244:        options(options) {}
call    0 never executed
call    1 never executed
        -:  245:
function _ZNK12_GLOBAL__N_126UnrollTransferWritePattern15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  246:  LogicalResult matchAndRewrite(vector::TransferWriteOp writeOp,
        -:  247:                                PatternRewriter &rewriter) const override {
        -:  248:    // TODO: support 0-d corner case.
    #####:  249:    if (writeOp.getTransferRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  250:      return failure();
        -:  251:
    #####:  252:    if (writeOp.getMask())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:      return failure();
    #####:  254:    auto targetShape = getTargetShape(options, writeOp);
call    0 never executed
    #####:  255:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  256:      return failure();
    #####:  257:    auto sourceVectorType = writeOp.getVectorType();
call    0 never executed
    #####:  258:    SmallVector<int64_t, 4> strides(targetShape->size(), 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  259:    Location loc = writeOp.getLoc();
call    0 never executed
    #####:  260:    ArrayRef<int64_t> originalSize = sourceVectorType.getShape();
call    0 never executed
    #####:  261:    SmallVector<Value, 4> originalIndices(writeOp.getIndices().begin(),
call    0 never executed
    #####:  262:                                          writeOp.getIndices().end());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  263:
    #####:  264:    SmallVector<int64_t> loopOrder =
    #####:  265:        getUnrollOrder(originalSize.size(), writeOp, options);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  266:    DecomposeShapeIterator indexToOffsets(originalSize, *targetShape,
branch  0 never executed
branch  1 never executed
    #####:  267:                                          loopOrder);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  268:    Value resultTensor;
    #####:  269:    for (int64_t i = 0; i < indexToOffsets.maxIndex(); i++) {
branch  0 never executed
branch  1 never executed
    #####:  270:      SmallVector<int64_t, 4> elementOffsets =
    #####:  271:          indexToOffsets.getVectorOffset(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  272:      Value slicedVector = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  273:          loc, writeOp.getVector(), elementOffsets, *targetShape, strides);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  274:      SmallVector<Value, 4> indices =
    #####:  275:          sliceTransferIndices(elementOffsets, originalIndices,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  276:                               writeOp.getPermutationMap(), loc, rewriter);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  277:      Operation *slicedWrite = rewriter.create<vector::TransferWriteOp>(
    #####:  278:          loc, slicedVector, resultTensor ? resultTensor : writeOp.getSource(),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  279:          indices, writeOp.getPermutationMapAttr(), writeOp.getInBoundsAttr());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  280:      // For the tensor case update the destination for the next transfer write.
    #####:  281:      if (!slicedWrite->getResults().empty())
branch  0 never executed
branch  1 never executed
    #####:  282:        resultTensor = slicedWrite->getResult(0);
        -:  283:    }
    #####:  284:    if (resultTensor)
branch  0 never executed
branch  1 never executed
    #####:  285:      rewriter.replaceOp(writeOp, resultTensor);
call    0 never executed
call    1 never executed
        -:  286:    else
    #####:  287:      rewriter.eraseOp(writeOp);
call    0 never executed
    #####:  288:    return success();
call    0 never executed
        -:  289:  }
        -:  290:
        -:  291:private:
        -:  292:  vector::UnrollVectorOptions options;
        -:  293:};
        -:  294:
        -:  295:struct OffsetMapInfo {
    #####:  296:  static SmallVector<int64_t> getEmptyKey() { return {int64_t(-1)}; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  297:
    #####:  298:  static SmallVector<int64_t> getTombstoneKey() { return {int64_t(-2)}; }
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  299:
    #####:  300:  static unsigned getHashValue(const SmallVector<int64_t> &v) {
    #####:  301:    return static_cast<unsigned>(llvm::hash_combine_range(v.begin(), v.end()));
call    0 never executed
        -:  302:  }
        -:  303:
    #####:  304:  static bool isEqual(const SmallVector<int64_t> &lhs,
        -:  305:                      const SmallVector<int64_t> &rhs) {
    #####:  306:    return lhs == rhs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -:  307:  }
        -:  308:};
        -:  309:
        -:  310:struct UnrollContractionPattern
        -:  311:    : public OpRewritePattern<vector::ContractionOp> {
function _ZN12_GLOBAL__N_124UnrollContractionPatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  312:  UnrollContractionPattern(MLIRContext *context,
        -:  313:                           const vector::UnrollVectorOptions &options,
        -:  314:                           PatternBenefit benefit = 1)
    #####:  315:      : OpRewritePattern<vector::ContractionOp>(context, benefit),
    #####:  316:        options(options) {}
call    0 never executed
call    1 never executed
        -:  317:
function _ZNK12_GLOBAL__N_124UnrollContractionPattern15matchAndRewriteEN4mlir6vector13ContractionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  318:  LogicalResult matchAndRewrite(vector::ContractionOp contractOp,
        -:  319:                                PatternRewriter &rewriter) const override {
    #####:  320:    auto targetShape = getTargetShape(options, contractOp);
call    0 never executed
    #####:  321:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  322:      return failure();
    #####:  323:    auto dstVecType = contractOp.getResultType().cast<VectorType>();
call    0 never executed
    #####:  324:    SmallVector<int64_t, 4> originalSize = *contractOp.getShapeForUnroll();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:  325:
    #####:  326:    Location loc = contractOp.getLoc();
call    0 never executed
    #####:  327:    unsigned accIndex = vector::ContractionOp::getAccOperandIndex();
call    0 never executed
    #####:  328:    AffineMap dstAffineMap = contractOp.getIndexingMapsArray()[accIndex];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  329:    llvm::MapVector<
call    0 never executed
        -:  330:        SmallVector<int64_t>, Value,
        -:  331:        llvm::DenseMap<SmallVector<int64_t>, unsigned, OffsetMapInfo>>
    #####:  332:        accCache;
branch  0 never executed
branch  1 never executed
        -:  333:
    #####:  334:    SmallVector<int64_t> loopOrder = getUnrollOrder(
    #####:  335:        contractOp.getIteratorTypes().size(), contractOp, options);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  336:    DecomposeShapeIterator indexToOffsets(originalSize, *targetShape,
branch  0 never executed
branch  1 never executed
    #####:  337:                                          loopOrder);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  338:    const int64_t sliceCount = indexToOffsets.maxIndex();
    #####:  339:    for (int64_t i = 0; i < sliceCount; i++) {
branch  0 never executed
branch  1 never executed
    #####:  340:      SmallVector<int64_t, 4> offsets = indexToOffsets.getVectorOffset(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  341:      SmallVector<Value, 4> slicesOperands(contractOp.getNumOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  342:
        -:  343:      // Helper to coompute the new shape of each operand and extract the slice.
function _ZZNK12_GLOBAL__N_124UnrollContractionPattern15matchAndRewriteEN4mlir6vector13ContractionOpERNS1_15PatternRewriterEENKUljNS1_5ValueENS1_9AffineMapEN4llvm8ArrayRefIlEEE_clEjS6_S7_SA_ called 0 returned 0% blocks executed 0%
    #####:  344:      auto extractOperand = [&](unsigned index, Value operand,
        -:  345:                                AffineMap permutationMap,
        -:  346:                                ArrayRef<int64_t> operandOffets) {
    #####:  347:        SmallVector<int64_t> operandShape = applyPermutationMap(
    #####:  348:            permutationMap, ArrayRef<int64_t>(*targetShape));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  349:        SmallVector<int64_t, 4> operandStrides(operandOffets.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  350:        slicesOperands[index] = rewriter.create<vector::ExtractStridedSliceOp>(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  351:            loc, operand, operandOffets, operandShape, operandStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  352:      };
        -:  353:
        -:  354:      // Extract the new lhs operand.
    #####:  355:      AffineMap lhsPermutationMap = contractOp.getIndexingMapsArray()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  356:      SmallVector<int64_t> lhsOffets =
call    0 never executed
    #####:  357:          applyPermutationMap(lhsPermutationMap, ArrayRef<int64_t>(offsets));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  358:      extractOperand(0, contractOp.getLhs(), lhsPermutationMap, lhsOffets);
call    0 never executed
call    1 never executed
        -:  359:      // If there is a mask associated to lhs, extract it as well.
    #####:  360:      if (slicesOperands.size() > 3)
branch  0 never executed
branch  1 never executed
    #####:  361:        extractOperand(3, contractOp.getMasks()[0], lhsPermutationMap,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  362:                       lhsOffets);
        -:  363:
        -:  364:      // Extract the new rhs operand.
    #####:  365:      AffineMap rhsPermutationMap = contractOp.getIndexingMapsArray()[1];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  366:      SmallVector<int64_t> rhsOffets =
call    0 never executed
    #####:  367:          applyPermutationMap(rhsPermutationMap, ArrayRef<int64_t>(offsets));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  368:      extractOperand(1, contractOp.getRhs(), rhsPermutationMap, rhsOffets);
call    0 never executed
call    1 never executed
        -:  369:      // If there is a mask associated to rhs, extract it as well.
    #####:  370:      if (slicesOperands.size() > 4)
branch  0 never executed
branch  1 never executed
    #####:  371:        extractOperand(4, contractOp.getMasks()[1], rhsPermutationMap,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  372:                       rhsOffets);
        -:  373:
    #####:  374:      AffineMap accPermutationMap = contractOp.getIndexingMapsArray()[2];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  375:      SmallVector<int64_t> accOffets =
call    0 never executed
    #####:  376:          applyPermutationMap(accPermutationMap, ArrayRef<int64_t>(offsets));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  377:      // If a version of the accumulator has already been computed, use it
        -:  378:      // otherwise extract the first version from the original operand.
    #####:  379:      auto accIt = accCache.find(accOffets);
call    0 never executed
    #####:  380:      if (accIt != accCache.end())
branch  0 never executed
branch  1 never executed
    #####:  381:        slicesOperands[2] = accIt->second;
branch  0 never executed
branch  1 never executed
        -:  382:      else
    #####:  383:        extractOperand(2, contractOp.getAcc(), accPermutationMap, accOffets);
call    0 never executed
call    1 never executed
        -:  384:
    #####:  385:      SmallVector<int64_t> dstShape =
branch  0 never executed
branch  1 never executed
    #####:  386:          applyPermutationMap(dstAffineMap, ArrayRef<int64_t>(*targetShape));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:      auto targetType = VectorType::get(dstShape, dstVecType.getElementType());
call    0 never executed
call    1 never executed
    #####:  388:      Operation *newOp = cloneOpWithOperandsAndTypes(
call    0 never executed
        -:  389:          rewriter, loc, contractOp, slicesOperands, targetType);
        -:  390:
    #####:  391:      SmallVector<int64_t> dstOffets =
call    0 never executed
    #####:  392:          applyPermutationMap(dstAffineMap, ArrayRef<int64_t>(offsets));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  393:      // Save the accumulated value untill all the loops are unrolled since
        -:  394:      // reduction loop keep updating the accumulator.
    #####:  395:      accCache[dstOffets] = newOp->getResult(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  396:    }
        -:  397:    // Assemble back the accumulator into a single vector.
    #####:  398:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  399:        loc, dstVecType, rewriter.getZeroAttr(dstVecType));
call    0 never executed
call    1 never executed
    #####:  400:    for (const auto &it : accCache) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  401:      SmallVector<int64_t> dstStrides(it.first.size(), 1);
call    0 never executed
    #####:  402:      result = rewriter.create<vector::InsertStridedSliceOp>(
branch  0 never executed
branch  1 never executed
    #####:  403:          loc, it.second, result, it.first, dstStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  404:    }
    #####:  405:    rewriter.replaceOp(contractOp, result);
call    0 never executed
call    1 never executed
    #####:  406:    return success();
call    0 never executed
        -:  407:  }
        -:  408:
        -:  409:private:
        -:  410:  vector::UnrollVectorOptions options;
        -:  411:};
        -:  412:
        -:  413:struct UnrollMultiReductionPattern
        -:  414:    : public OpRewritePattern<vector::MultiDimReductionOp> {
function _ZN12_GLOBAL__N_127UnrollMultiReductionPatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  415:  UnrollMultiReductionPattern(MLIRContext *context,
        -:  416:                              const vector::UnrollVectorOptions &options,
        -:  417:                              PatternBenefit benefit = 1)
    #####:  418:      : OpRewritePattern<vector::MultiDimReductionOp>(context, benefit),
    #####:  419:        options(options) {}
call    0 never executed
call    1 never executed
        -:  420:
function _ZNK12_GLOBAL__N_127UnrollMultiReductionPattern15matchAndRewriteEN4mlir6vector19MultiDimReductionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  421:  LogicalResult matchAndRewrite(vector::MultiDimReductionOp reductionOp,
        -:  422:                                PatternRewriter &rewriter) const override {
    #####:  423:    Optional<SmallVector<int64_t, 4>> targetShape =
    #####:  424:        getTargetShape(options, reductionOp);
call    0 never executed
    #####:  425:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  426:      return failure();
    #####:  427:    SmallVector<int64_t, 4> originalSize = *reductionOp.getShapeForUnroll();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  428:    SmallVector<int64_t, 4> ratio = *shapeRatio(originalSize, *targetShape);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  429:    llvm::MapVector<
call    0 never executed
        -:  430:        SmallVector<int64_t>, Value,
        -:  431:        llvm::DenseMap<SmallVector<int64_t>, unsigned, OffsetMapInfo>>
    #####:  432:        accCache;
branch  0 never executed
branch  1 never executed
        -:  433:    // Compute shape ratio of 'shape' and 'sizes'.
    #####:  434:    int64_t sliceCount = computeMaxLinearIndex(ratio);
call    0 never executed
    #####:  435:    Location loc = reductionOp.getLoc();
    #####:  436:    for (int64_t i = 0; i < sliceCount; i++) {
branch  0 never executed
branch  1 never executed
    #####:  437:      SmallVector<int64_t, 4> offsets =
branch  0 never executed
branch  1 never executed
    #####:  438:          getVectorOffset(originalSize, *targetShape, i);
call    0 never executed
        -:  439:
    #####:  440:      SmallVector<Value> operands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  441:      SmallVector<int64_t, 4> operandStrides(offsets.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  442:      Value slicedOperand = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  443:          loc, reductionOp.getSource(), offsets, *targetShape, operandStrides);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  444:      operands.push_back(slicedOperand);
call    0 never executed
    #####:  445:      SmallVector<int64_t> dstShape;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  446:      SmallVector<int64_t> destOffset;
branch  0 never executed
branch  1 never executed
    #####:  447:      for (size_t i : llvm::seq(size_t(0), targetShape->size())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  448:        if (!reductionOp.isReducedDim(i)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  449:          destOffset.push_back(offsets[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  450:          dstShape.push_back((*targetShape)[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  451:        }
        -:  452:      }
    #####:  453:      Value acc;
    #####:  454:      SmallVector<int64_t, 4> accStrides(destOffset.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  455:      // If a version of the accumulator has already been computed, use it
        -:  456:      // otherwise extract the first version from the original operand.
    #####:  457:      auto accIt = accCache.find(destOffset);
call    0 never executed
    #####:  458:      if (accIt != accCache.end())
branch  0 never executed
branch  1 never executed
    #####:  459:        acc = accIt->second;
        -:  460:      else
    #####:  461:        acc = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  462:            loc, reductionOp.getAcc(), destOffset, dstShape, accStrides);
call    0 never executed
call    1 never executed
    #####:  463:      operands.push_back(acc);
call    0 never executed
    #####:  464:      auto targetType = VectorType::get(
    #####:  465:          dstShape, reductionOp.getSourceVectorType().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  466:      Operation *newOp = cloneOpWithOperandsAndTypes(rewriter, loc, reductionOp,
call    0 never executed
        -:  467:                                                     operands, targetType);
    #####:  468:      Value result = newOp->getResult(0);
call    0 never executed
    #####:  469:      accCache[destOffset] = result;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  470:    }
        -:  471:    // Assemble back the accumulator into a single vector.
    #####:  472:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  473:        loc, reductionOp.getDestType(),
    #####:  474:        rewriter.getZeroAttr(reductionOp.getDestType()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  475:    for (const auto &it : accCache) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  476:      SmallVector<int64_t> dstStrides(it.first.size(), 1);
call    0 never executed
    #####:  477:      result = rewriter.create<vector::InsertStridedSliceOp>(
branch  0 never executed
branch  1 never executed
    #####:  478:          loc, it.second, result, it.first, dstStrides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  479:    }
    #####:  480:    rewriter.replaceOp(reductionOp, result);
call    0 never executed
call    1 never executed
    #####:  481:    return success();
call    0 never executed
        -:  482:  }
        -:  483:
        -:  484:private:
        -:  485:  vector::UnrollVectorOptions options;
        -:  486:};
        -:  487:
        -:  488:struct UnrollElementwisePattern : public RewritePattern {
function _ZN12_GLOBAL__N_124UnrollElementwisePatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  489:  UnrollElementwisePattern(MLIRContext *context,
        -:  490:                           const vector::UnrollVectorOptions &options,
        -:  491:                           PatternBenefit benefit = 1)
    #####:  492:      : RewritePattern(MatchAnyOpTypeTag(), benefit, context),
    #####:  493:        options(options) {}
call    0 never executed
call    1 never executed
        -:  494:
function _ZNK12_GLOBAL__N_124UnrollElementwisePattern15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  495:  LogicalResult matchAndRewrite(Operation *op,
        -:  496:                                PatternRewriter &rewriter) const override {
    #####:  497:    if (!OpTrait::hasElementwiseMappableTraits(op) || op->getNumResults() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  498:      return failure();
    #####:  499:    auto targetShape = getTargetShape(options, op);
call    0 never executed
    #####:  500:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  501:      return failure();
    #####:  502:    auto dstVecType = op->getResult(0).getType().cast<VectorType>();
call    0 never executed
    #####:  503:    SmallVector<int64_t, 4> originalSize =
    #####:  504:        *cast<VectorUnrollOpInterface>(op).getShapeForUnroll();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  505:    SmallVector<int64_t, 4> ratio = *shapeRatio(originalSize, *targetShape);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  506:    int64_t sliceCount = computeMaxLinearIndex(ratio);
call    0 never executed
    #####:  507:    Location loc = op->getLoc();
call    0 never executed
        -:  508:    // Prepare the result vector.
    #####:  509:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  510:        loc, dstVecType, rewriter.getZeroAttr(dstVecType));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  511:    SmallVector<int64_t, 4> strides(targetShape->size(), 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  512:    VectorType newVecType =
    #####:  513:        VectorType::get(*targetShape, dstVecType.getElementType());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  514:    for (int64_t i = 0; i < sliceCount; i++) {
branch  0 never executed
branch  1 never executed
    #####:  515:      SmallVector<int64_t, 4> offsets =
branch  0 never executed
branch  1 never executed
    #####:  516:          getVectorOffset(originalSize, *targetShape, i);
call    0 never executed
    #####:  517:      SmallVector<Value, 4> extractOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  518:      for (OpOperand &operand : op->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  519:        auto vecType = operand.get().getType().template dyn_cast<VectorType>();
call    0 never executed
    #####:  520:        if (!vecType) {
branch  0 never executed
branch  1 never executed
    #####:  521:          extractOperands.push_back(operand.get());
call    0 never executed
    #####:  522:          continue;
        -:  523:        }
    #####:  524:        extractOperands.push_back(
call    0 never executed
    #####:  525:            rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  526:                loc, operand.get(), offsets, *targetShape, strides));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  527:      }
    #####:  528:      Operation *newOp = cloneOpWithOperandsAndTypes(
call    0 never executed
        -:  529:          rewriter, loc, op, extractOperands, newVecType);
    #####:  530:      result = rewriter.create<vector::InsertStridedSliceOp>(
branch  0 never executed
branch  1 never executed
    #####:  531:          loc, newOp->getResult(0), result, offsets, strides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  532:    }
    #####:  533:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  534:    return success();
branch  0 never executed
branch  1 never executed
        -:  535:  }
        -:  536:
        -:  537:private:
        -:  538:  vector::UnrollVectorOptions options;
        -:  539:};
        -:  540:
        -:  541:struct UnrollReductionPattern : public OpRewritePattern<vector::ReductionOp> {
function _ZN12_GLOBAL__N_122UnrollReductionPatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  542:  UnrollReductionPattern(MLIRContext *context,
        -:  543:                         const vector::UnrollVectorOptions &options,
        -:  544:                         PatternBenefit benefit = 1)
    #####:  545:      : OpRewritePattern<vector::ReductionOp>(context, benefit),
    #####:  546:        options(options) {}
call    0 never executed
call    1 never executed
        -:  547:
function _ZNK12_GLOBAL__N_122UnrollReductionPattern15matchAndRewriteEN4mlir6vector11ReductionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  548:  LogicalResult matchAndRewrite(vector::ReductionOp reductionOp,
        -:  549:                                PatternRewriter &rewriter) const override {
    #####:  550:    Optional<SmallVector<int64_t, 4>> targetShape =
    #####:  551:        getTargetShape(options, reductionOp);
call    0 never executed
    #####:  552:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  553:      return failure();
    #####:  554:    SmallVector<int64_t> originalSize = *reductionOp.getShapeForUnroll();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  555:    int64_t ratio = (*shapeRatio(originalSize, *targetShape))[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:  556:
        -:  557:    // Create unrolled vector reduction.
    #####:  558:    Location loc = reductionOp.getLoc();
    #####:  559:    Value accumulator = nullptr;
    #####:  560:    for (int64_t i = 0; i < ratio; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  561:      SmallVector<int64_t> offsets =
branch  0 never executed
branch  1 never executed
    #####:  562:          getVectorOffset(originalSize, *targetShape, i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  563:      SmallVector<int64_t> strides(offsets.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  564:      Value slicedOperand = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  565:          loc, reductionOp.getVector(), offsets, *targetShape, strides);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  566:      Operation *newOp = cloneOpWithOperandsAndTypes(
call    0 never executed
    #####:  567:          rewriter, loc, reductionOp, slicedOperand, reductionOp.getType());
call    0 never executed
    #####:  568:      Value result = newOp->getResult(0);
branch  0 never executed
branch  1 never executed
        -:  569:
    #####:  570:      if (!accumulator) {
branch  0 never executed
branch  1 never executed
        -:  571:        // This is the first reduction.
    #####:  572:        accumulator = result;
        -:  573:      } else {
        -:  574:        // On subsequent reduction, combine with the accumulator.
    #####:  575:        accumulator = makeArithReduction(rewriter, loc, reductionOp.getKind(),
    #####:  576:                                         accumulator, result);
call    0 never executed
call    1 never executed
        -:  577:      }
        -:  578:    }
        -:  579:
    #####:  580:    rewriter.replaceOp(reductionOp, accumulator);
call    0 never executed
call    1 never executed
    #####:  581:    return success();
branch  0 never executed
branch  1 never executed
        -:  582:  }
        -:  583:
        -:  584:private:
        -:  585:  const vector::UnrollVectorOptions options;
        -:  586:};
        -:  587:
        -:  588:struct UnrollTranposePattern : public OpRewritePattern<vector::TransposeOp> {
function _ZN12_GLOBAL__N_121UnrollTranposePatternC2EPN4mlir11MLIRContextERKNS1_6vector19UnrollVectorOptionsENS1_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  589:  UnrollTranposePattern(MLIRContext *context,
        -:  590:                        const vector::UnrollVectorOptions &options,
        -:  591:                        PatternBenefit benefit = 1)
    #####:  592:      : OpRewritePattern<vector::TransposeOp>(context, benefit),
    #####:  593:        options(options) {}
call    0 never executed
call    1 never executed
        -:  594:
function _ZNK12_GLOBAL__N_121UnrollTranposePattern15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  595:  LogicalResult matchAndRewrite(vector::TransposeOp tranposeOp,
        -:  596:                                PatternRewriter &rewriter) const override {
    #####:  597:    if (tranposeOp.getResultType().getRank() == 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  598:      return failure();
    #####:  599:    auto targetShape = getTargetShape(options, tranposeOp);
call    0 never executed
    #####:  600:    if (!targetShape)
branch  0 never executed
branch  1 never executed
    #####:  601:      return failure();
    #####:  602:    auto originalVectorType = tranposeOp.getResultType();
call    0 never executed
    #####:  603:    SmallVector<int64_t, 4> strides(targetShape->size(), 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  604:    Location loc = tranposeOp.getLoc();
call    0 never executed
    #####:  605:    ArrayRef<int64_t> originalSize = originalVectorType.getShape();
call    0 never executed
    #####:  606:    SmallVector<int64_t, 4> ratio = *shapeRatio(originalSize, *targetShape);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  607:    int64_t sliceCount = computeMaxLinearIndex(ratio);
call    0 never executed
        -:  608:    // Prepare the result vector;
    #####:  609:    Value result = rewriter.create<arith::ConstantOp>(
    #####:  610:        loc, originalVectorType, rewriter.getZeroAttr(originalVectorType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  611:    SmallVector<int64_t> permutation;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  612:    tranposeOp.getTransp(permutation);
    #####:  613:    for (int64_t i = 0; i < sliceCount; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  614:      SmallVector<int64_t, 4> elementOffsets =
branch  0 never executed
branch  1 never executed
    #####:  615:          getVectorOffset(originalSize, *targetShape, i);
call    0 never executed
    #####:  616:      SmallVector<int64_t, 4> permutedOffsets(elementOffsets.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  617:      SmallVector<int64_t, 4> permutedShape(elementOffsets.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  618:      // Compute the source offsets and shape.
    #####:  619:      for (auto &indices : llvm::enumerate(permutation)) {
branch  0 never executed
branch  1 never executed
    #####:  620:        permutedOffsets[indices.value()] = elementOffsets[indices.index()];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  621:        permutedShape[indices.value()] = (*targetShape)[indices.index()];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  622:      }
    #####:  623:      Value slicedOperand = rewriter.create<vector::ExtractStridedSliceOp>(
    #####:  624:          loc, tranposeOp.getVector(), permutedOffsets, permutedShape, strides);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  625:      Value tranposedSlice =
    #####:  626:          rewriter.create<vector::TransposeOp>(loc, slicedOperand, permutation);
call    0 never executed
call    1 never executed
    #####:  627:      result = rewriter.create<vector::InsertStridedSliceOp>(
branch  0 never executed
branch  1 never executed
    #####:  628:          loc, tranposedSlice, result, elementOffsets, strides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  629:    }
    #####:  630:    rewriter.replaceOp(tranposeOp, result);
call    0 never executed
call    1 never executed
    #####:  631:    return success();
branch  0 never executed
branch  1 never executed
        -:  632:  }
        -:  633:
        -:  634:private:
        -:  635:  vector::UnrollVectorOptions options;
        -:  636:};
        -:  637:
        -:  638:} // namespace
        -:  639:
function _ZN4mlir6vector28populateVectorUnrollPatternsERNS_17RewritePatternSetERKNS0_19UnrollVectorOptionsENS_14PatternBenefitE called 0 returned 0% blocks executed 0%
    #####:  640:void mlir::vector::populateVectorUnrollPatterns(
        -:  641:    RewritePatternSet &patterns, const UnrollVectorOptions &options,
        -:  642:    PatternBenefit benefit) {
    #####:  643:  patterns.add<UnrollTransferReadPattern, UnrollTransferWritePattern,
        -:  644:               UnrollContractionPattern, UnrollElementwisePattern,
        -:  645:               UnrollReductionPattern, UnrollMultiReductionPattern,
    #####:  646:               UnrollTranposePattern>(patterns.getContext(), options, benefit);
call    0 never executed
    #####:  647:}
