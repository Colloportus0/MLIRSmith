        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Affine/Analysis/AffineAnalysis.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/AffineAnalysis.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/AffineAnalysis.cpp.gcda
        -:    0:Runs:128637
        -:    1://===- AffineAnalysis.cpp - Affine structures analysis routines -----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements miscellaneous analysis routines for affine structures
        -:   10:// (expressions, maps, sets), and other utilities relying on such analysis.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/Affine/Analysis/AffineAnalysis.h"
        -:   15:#include "mlir/Analysis/SliceAnalysis.h"
        -:   16:#include "mlir/Dialect/Affine/Analysis/LoopAnalysis.h"
        -:   17:#include "mlir/Dialect/Affine/Analysis/Utils.h"
        -:   18:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   19:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   20:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   21:#include "mlir/IR/AffineExprVisitor.h"
        -:   22:#include "mlir/IR/BuiltinOps.h"
        -:   23:#include "mlir/IR/IntegerSet.h"
        -:   24:#include "mlir/Interfaces/SideEffectInterfaces.h"
        -:   25:#include "mlir/Interfaces/ViewLikeInterface.h"
        -:   26:#include "llvm/ADT/TypeSwitch.h"
        -:   27:#include "llvm/Support/Debug.h"
        -:   28:#include "llvm/Support/raw_ostream.h"
        -:   29:
        -:   30:#define DEBUG_TYPE "affine-analysis"
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace presburger;
        -:   34:
        -:   35:/// Get the value that is being reduced by `pos`-th reduction in the loop if
        -:   36:/// such a reduction can be performed by affine parallel loops. This assumes
        -:   37:/// floating-point operations are commutative. On success, `kind` will be the
        -:   38:/// reduction kind suitable for use in affine parallel loop builder. If the
        -:   39:/// reduction is not supported, returns null.
function _ZL21getSupportedReductionN4mlir11AffineForOpEjRNS_5arith13AtomicRMWKindE called 0 returned 0% blocks executed 0%
    #####:   40:static Value getSupportedReduction(AffineForOp forOp, unsigned pos,
        -:   41:                                   arith::AtomicRMWKind &kind) {
    #####:   42:  SmallVector<Operation *> combinerOps;
call    0 never executed
    #####:   43:  Value reducedVal =
    #####:   44:      matchReduction(forOp.getRegionIterArgs(), pos, combinerOps);
call    0 never executed
call    1 never executed
    #####:   45:  if (!reducedVal)
branch  0 never executed
branch  1 never executed
    #####:   46:    return nullptr;
        -:   47:
        -:   48:  // Expected only one combiner operation.
    #####:   49:  if (combinerOps.size() > 1)
branch  0 never executed
branch  1 never executed
    #####:   50:    return nullptr;
        -:   51:
    #####:   52:  Operation *combinerOp = combinerOps.back();
call    0 never executed
    #####:   53:  Optional<arith::AtomicRMWKind> maybeKind =
call    0 never executed
    #####:   54:      TypeSwitch<Operation *, Optional<arith::AtomicRMWKind>>(combinerOp)
    #####:   55:          .Case([](arith::AddFOp) { return arith::AtomicRMWKind::addf; })
call    0 never executed
    #####:   56:          .Case([](arith::MulFOp) { return arith::AtomicRMWKind::mulf; })
call    0 never executed
    #####:   57:          .Case([](arith::AddIOp) { return arith::AtomicRMWKind::addi; })
call    0 never executed
    #####:   58:          .Case([](arith::AndIOp) { return arith::AtomicRMWKind::andi; })
call    0 never executed
    #####:   59:          .Case([](arith::OrIOp) { return arith::AtomicRMWKind::ori; })
call    0 never executed
    #####:   60:          .Case([](arith::MulIOp) { return arith::AtomicRMWKind::muli; })
call    0 never executed
    #####:   61:          .Case([](arith::MinFOp) { return arith::AtomicRMWKind::minf; })
call    0 never executed
    #####:   62:          .Case([](arith::MaxFOp) { return arith::AtomicRMWKind::maxf; })
call    0 never executed
    #####:   63:          .Case([](arith::MinSIOp) { return arith::AtomicRMWKind::mins; })
call    0 never executed
    #####:   64:          .Case([](arith::MaxSIOp) { return arith::AtomicRMWKind::maxs; })
call    0 never executed
    #####:   65:          .Case([](arith::MinUIOp) { return arith::AtomicRMWKind::minu; })
call    0 never executed
    #####:   66:          .Case([](arith::MaxUIOp) { return arith::AtomicRMWKind::maxu; })
call    0 never executed
        -:   67:          .Default([](Operation *) -> Optional<arith::AtomicRMWKind> {
        -:   68:            // TODO: AtomicRMW supports other kinds of reductions this is
        -:   69:            // currently not detecting, add those when the need arises.
    #####:   70:            return llvm::None;
    #####:   71:          });
branch  0 never executed
branch  1 never executed
    #####:   72:  if (!maybeKind)
branch  0 never executed
branch  1 never executed
    #####:   73:    return nullptr;
        -:   74:
    #####:   75:  kind = *maybeKind;
    #####:   76:  return reducedVal;
        -:   77:}
        -:   78:
        -:   79:/// Populate `supportedReductions` with descriptors of the supported reductions.
function _ZN4mlir22getSupportedReductionsENS_11AffineForOpERN4llvm15SmallVectorImplINS_13LoopReductionEEE called 0 returned 0% blocks executed 0%
    #####:   80:void mlir::getSupportedReductions(
        -:   81:    AffineForOp forOp, SmallVectorImpl<LoopReduction> &supportedReductions) {
    #####:   82:  unsigned numIterArgs = forOp.getNumIterOperands();
call    0 never executed
    #####:   83:  if (numIterArgs == 0)
branch  0 never executed
branch  1 never executed
        -:   84:    return;
    #####:   85:  supportedReductions.reserve(numIterArgs);
branch  0 never executed
branch  1 never executed
    #####:   86:  for (unsigned i = 0; i < numIterArgs; ++i) {
branch  0 never executed
branch  1 never executed
    #####:   87:    arith::AtomicRMWKind kind;
    #####:   88:    if (Value value = getSupportedReduction(forOp, i, kind))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   89:      supportedReductions.emplace_back(LoopReduction{kind, i, value});
call    0 never executed
        -:   90:  }
        -:   91:}
        -:   92:
        -:   93:/// Returns true if `forOp' is a parallel loop. If `parallelReductions` is
        -:   94:/// provided, populates it with descriptors of the parallelizable reductions and
        -:   95:/// treats them as not preventing parallelization.
function _ZN4mlir14isLoopParallelENS_11AffineForOpEPN4llvm15SmallVectorImplINS_13LoopReductionEEE called 0 returned 0% blocks executed 0%
    #####:   96:bool mlir::isLoopParallel(AffineForOp forOp,
        -:   97:                          SmallVectorImpl<LoopReduction> *parallelReductions) {
    #####:   98:  unsigned numIterArgs = forOp.getNumIterOperands();
call    0 never executed
        -:   99:
        -:  100:  // Loop is not parallel if it has SSA loop-carried dependences and reduction
        -:  101:  // detection is not requested.
    #####:  102:  if (numIterArgs > 0 && !parallelReductions)
branch  0 never executed
branch  1 never executed
        -:  103:    return false;
        -:  104:
        -:  105:  // Find supported reductions of requested.
    #####:  106:  if (parallelReductions) {
branch  0 never executed
branch  1 never executed
    #####:  107:    getSupportedReductions(forOp, *parallelReductions);
call    0 never executed
        -:  108:    // Return later to allow for identifying all parallel reductions even if the
        -:  109:    // loop is not parallel.
    #####:  110:    if (parallelReductions->size() != numIterArgs)
branch  0 never executed
branch  1 never executed
        -:  111:      return false;
        -:  112:  }
        -:  113:
        -:  114:  // Check memory dependences.
    #####:  115:  return isLoopMemoryParallel(forOp);
call    0 never executed
        -:  116:}
        -:  117:
        -:  118:/// Returns true if `v` is allocated locally to `enclosingOp` -- i.e., it is
        -:  119:/// allocated by an operation nested within `enclosingOp`.
function _ZL16isLocallyDefinedN4mlir5ValueEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  120:static bool isLocallyDefined(Value v, Operation *enclosingOp) {
    #####:  121:  Operation *defOp = v.getDefiningOp();
call    0 never executed
    #####:  122:  if (!defOp)
branch  0 never executed
branch  1 never executed
        -:  123:    return false;
        -:  124:
    #####:  125:  if (hasSingleEffect<MemoryEffects::Allocate>(defOp, v) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  126:      enclosingOp->isProperAncestor(defOp))
call    0 never executed
        -:  127:    return true;
        -:  128:
        -:  129:  // Aliasing ops.
    #####:  130:  auto viewOp = dyn_cast<ViewLikeOpInterface>(defOp);
call    0 never executed
    #####:  131:  return viewOp && isLocallyDefined(viewOp.getViewSource(), enclosingOp);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  132:}
        -:  133:
function _ZN4mlir20isLoopMemoryParallelENS_11AffineForOpE called 0 returned 0% blocks executed 0%
    #####:  134:bool mlir::isLoopMemoryParallel(AffineForOp forOp) {
        -:  135:  // Any memref-typed iteration arguments are treated as serializing.
    #####:  136:  if (llvm::any_of(forOp.getResultTypes(),
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  137:                   [](Type type) { return type.isa<BaseMemRefType>(); }))
        -:  138:    return false;
        -:  139:
        -:  140:  // Collect all load and store ops in loop nest rooted at 'forOp'.
    #####:  141:  SmallVector<Operation *, 8> loadAndStoreOps;
call    0 never executed
function _ZZN4mlir20isLoopMemoryParallelENS_11AffineForOpEENKUlPNS_9OperationEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  142:  auto walkResult = forOp.walk([&](Operation *op) -> WalkResult {
    #####:  143:    if (auto readOp = dyn_cast<AffineReadOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  144:      // Memrefs that are allocated inside `forOp` need not be considered.
    #####:  145:      if (!isLocallyDefined(readOp.getMemRef(), forOp))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  146:        loadAndStoreOps.push_back(op);
call    0 never executed
    #####:  147:    } else if (auto writeOp = dyn_cast<AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  148:      // Filter out stores the same way as above.
    #####:  149:      if (!isLocallyDefined(writeOp.getMemRef(), forOp))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  150:        loadAndStoreOps.push_back(op);
call    0 never executed
    #####:  151:    } else if (!isa<AffineForOp, AffineYieldOp, AffineIfOp>(op) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  152:               !hasSingleEffect<MemoryEffects::Allocate>(op) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  153:               !MemoryEffectOpInterface::hasNoEffect(op)) {
call    0 never executed
        -:  154:      // Alloc-like ops inside `forOp` are fine (they don't impact parallelism)
        -:  155:      // as long as they don't escape the loop (which has been checked above).
    #####:  156:      return WalkResult::interrupt();
        -:  157:    }
        -:  158:
    #####:  159:    return WalkResult::advance();
    #####:  160:  });
call    0 never executed
        -:  161:
        -:  162:  // Stop early if the loop has unknown ops with side effects.
    #####:  163:  if (walkResult.wasInterrupted())
branch  0 never executed
branch  1 never executed
        -:  164:    return false;
        -:  165:
        -:  166:  // Dep check depth would be number of enclosing loops + 1.
    #####:  167:  unsigned depth = getNestingDepth(forOp) + 1;
call    0 never executed
        -:  168:
        -:  169:  // Check dependences between all pairs of ops in 'loadAndStoreOps'.
    #####:  170:  for (auto *srcOp : loadAndStoreOps) {
branch  0 never executed
branch  1 never executed
    #####:  171:    MemRefAccess srcAccess(srcOp);
call    0 never executed
    #####:  172:    for (auto *dstOp : loadAndStoreOps) {
branch  0 never executed
branch  1 never executed
    #####:  173:      MemRefAccess dstAccess(dstOp);
call    0 never executed
    #####:  174:      FlatAffineValueConstraints dependenceConstraints;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  175:      DependenceResult result = checkMemrefAccessDependence(
        -:  176:          srcAccess, dstAccess, depth, &dependenceConstraints,
    #####:  177:          /*dependenceComponents=*/nullptr);
call    0 never executed
    #####:  178:      if (result.value != DependenceResult::NoDependence)
branch  0 never executed
branch  1 never executed
    #####:  179:        return false;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  180:    }
        -:  181:  }
        -:  182:  return true;
        -:  183:}
        -:  184:
        -:  185:/// Returns the sequence of AffineApplyOp Operations operation in
        -:  186:/// 'affineApplyOps', which are reachable via a search starting from 'operands',
        -:  187:/// and ending at operands which are not defined by AffineApplyOps.
        -:  188:// TODO: Add a method to AffineApplyOp which forward substitutes the
        -:  189:// AffineApplyOp into any user AffineApplyOps.
function _ZN4mlir26getReachableAffineApplyOpsEN4llvm8ArrayRefINS_5ValueEEERNS0_15SmallVectorImplIPNS_9OperationEEE called 0 returned 0% blocks executed 0%
    #####:  190:void mlir::getReachableAffineApplyOps(
        -:  191:    ArrayRef<Value> operands, SmallVectorImpl<Operation *> &affineApplyOps) {
    #####:  192:  struct State {
        -:  193:    // The ssa value for this node in the DFS traversal.
        -:  194:    Value value;
        -:  195:    // The operand index of 'value' to explore next during DFS traversal.
        -:  196:    unsigned operandIndex;
        -:  197:  };
    #####:  198:  SmallVector<State, 4> worklist;
    #####:  199:  for (auto operand : operands) {
branch  0 never executed
branch  1 never executed
    #####:  200:    worklist.push_back({operand, 0});
call    0 never executed
        -:  201:  }
        -:  202:
    #####:  203:  while (!worklist.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  204:    State &state = worklist.back();
call    0 never executed
    #####:  205:    auto *opInst = state.value.getDefiningOp();
call    0 never executed
        -:  206:    // Note: getDefiningOp will return nullptr if the operand is not an
        -:  207:    // Operation (i.e. block argument), which is a terminator for the search.
    #####:  208:    if (!isa_and_nonnull<AffineApplyOp>(opInst)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  209:      worklist.pop_back();
call    0 never executed
    #####:  210:      continue;
        -:  211:    }
        -:  212:
    #####:  213:    if (state.operandIndex == 0) {
branch  0 never executed
branch  1 never executed
        -:  214:      // Pre-Visit: Add 'opInst' to reachable sequence.
    #####:  215:      affineApplyOps.push_back(opInst);
call    0 never executed
        -:  216:    }
    #####:  217:    if (state.operandIndex < opInst->getNumOperands()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  218:      // Visit: Add next 'affineApplyOp' operand to worklist.
        -:  219:      // Get next operand to visit at 'operandIndex'.
    #####:  220:      auto nextOperand = opInst->getOperand(state.operandIndex);
call    0 never executed
        -:  221:      // Increment 'operandIndex' in 'state'.
    #####:  222:      ++state.operandIndex;
        -:  223:      // Add 'nextOperand' to worklist.
    #####:  224:      worklist.push_back({nextOperand, 0});
call    0 never executed
        -:  225:    } else {
        -:  226:      // Post-visit: done visiting operands AffineApplyOp, pop off stack.
    #####:  227:      worklist.pop_back();
call    0 never executed
        -:  228:    }
        -:  229:  }
    #####:  230:}
        -:  231:
        -:  232:// Builds a system of constraints with dimensional variables corresponding to
        -:  233:// the loop IVs of the forOps appearing in that order. Any symbols founds in
        -:  234:// the bound operands are added as symbols in the system. Returns failure for
        -:  235:// the yet unimplemented cases.
        -:  236:// TODO: Handle non-unit steps through local variables or stride information in
        -:  237:// FlatAffineValueConstraints. (For eg., by using iv - lb % step = 0 and/or by
        -:  238:// introducing a method in FlatAffineValueConstraints
        -:  239:// setExprStride(ArrayRef<int64_t> expr, int64_t stride)
function _ZN4mlir11getIndexSetEN4llvm15MutableArrayRefIPNS_9OperationEEEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  240:LogicalResult mlir::getIndexSet(MutableArrayRef<Operation *> ops,
        -:  241:                                FlatAffineValueConstraints *domain) {
    #####:  242:  SmallVector<Value, 4> indices;
    #####:  243:  SmallVector<AffineForOp, 8> forOps;
branch  0 never executed
branch  1 never executed
    #####:  244:  for (Operation *op : ops) {
branch  0 never executed
branch  1 never executed
    #####:  245:    if (!isa<AffineForOp, AffineIfOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  246:      // TODO: Support affine.parallel ops.
    #####:  247:      LLVM_DEBUG(llvm::dbgs() << "getIndexSet only handles affine.for/if ops");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  248:      return failure();
        -:  249:    }
    #####:  250:    if (AffineForOp forOp = dyn_cast<AffineForOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  251:      forOps.push_back(forOp);
call    0 never executed
        -:  252:  }
    #####:  253:  extractForInductionVars(forOps, &indices);
call    0 never executed
        -:  254:  // Reset while associated Values in 'indices' to the domain.
    #####:  255:  domain->reset(forOps.size(), /*numSymbols=*/0, /*numLocals=*/0, indices);
call    0 never executed
    #####:  256:  for (Operation *op : ops) {
branch  0 never executed
branch  1 never executed
        -:  257:    // Add constraints from forOp's bounds.
    #####:  258:    if (AffineForOp forOp = dyn_cast<AffineForOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  259:      if (failed(domain->addAffineForOpDomain(forOp)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  260:        return failure();
    #####:  261:    } else if (AffineIfOp ifOp = dyn_cast<AffineIfOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  262:      domain->addAffineIfOpDomain(ifOp);
call    0 never executed
        -:  263:    }
        -:  264:  }
    #####:  265:  return success();
branch  0 never executed
branch  1 never executed
        -:  266:}
        -:  267:
        -:  268:/// Computes the iteration domain for 'op' and populates 'indexSet', which
        -:  269:/// encapsulates the constraints involving loops surrounding 'op' and
        -:  270:/// potentially involving any Function symbols. The dimensional variables in
        -:  271:/// 'indexSet' correspond to the loops surrounding 'op' from outermost to
        -:  272:/// innermost.
function _ZL13getOpIndexSetPN4mlir9OperationEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  273:static LogicalResult getOpIndexSet(Operation *op,
        -:  274:                                   FlatAffineValueConstraints *indexSet) {
    #####:  275:  SmallVector<Operation *, 4> ops;
call    0 never executed
    #####:  276:  getEnclosingAffineOps(*op, &ops);
call    0 never executed
    #####:  277:  return getIndexSet(ops, indexSet);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  278:}
        -:  279:
        -:  280:// Returns the number of outer loop common to 'src/dstDomain'.
        -:  281:// Loops common to 'src/dst' domains are added to 'commonLoops' if non-null.
        -:  282:static unsigned
function _ZL17getNumCommonLoopsRKN4mlir26FlatAffineValueConstraintsES2_PN4llvm15SmallVectorImplINS_11AffineForOpEEE called 0 returned 0% blocks executed 0%
    #####:  283:getNumCommonLoops(const FlatAffineValueConstraints &srcDomain,
        -:  284:                  const FlatAffineValueConstraints &dstDomain,
        -:  285:                  SmallVectorImpl<AffineForOp> *commonLoops = nullptr) {
        -:  286:  // Find the number of common loops shared by src and dst accesses.
    #####:  287:  unsigned minNumLoops =
    #####:  288:      std::min(srcDomain.getNumDimVars(), dstDomain.getNumDimVars());
branch  0 never executed
branch  1 never executed
    #####:  289:  unsigned numCommonLoops = 0;
    #####:  290:  for (unsigned i = 0; i < minNumLoops; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  291:    if (!isForInductionVar(srcDomain.getValue(i)) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  292:        !isForInductionVar(dstDomain.getValue(i)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  293:        srcDomain.getValue(i) != dstDomain.getValue(i))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  294:      break;
    #####:  295:    if (commonLoops != nullptr)
branch  0 never executed
branch  1 never executed
    #####:  296:      commonLoops->push_back(getForInductionVarOwner(srcDomain.getValue(i)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  297:    ++numCommonLoops;
        -:  298:  }
    #####:  299:  if (commonLoops != nullptr)
branch  0 never executed
branch  1 never executed
    #####:  300:    assert(commonLoops->size() == numCommonLoops);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  301:  return numCommonLoops;
        -:  302:}
        -:  303:
        -:  304:/// Returns the closest surrounding block common to `opA` and `opB`. `opA` and
        -:  305:/// `opB` should be in the same affine scope and thus such a block is guaranteed
        -:  306:/// to exist.
function _ZL14getCommonBlockPN4mlir9OperationES1_ called 0 returned 0% blocks executed 0%
    #####:  307:static Block *getCommonBlock(Operation *opA, Operation *opB) {
        -:  308:  // Get the chain of ancestor blocks for the given `MemRefAccess` instance. The
        -:  309:  // chain extends up to and includnig an op that starts an affine scope.
    #####:  310:  auto getChainOfAncestorBlocks =
function _ZZL14getCommonBlockPN4mlir9OperationES1_ENKUlS1_RN4llvm15SmallVectorImplIPNS_5BlockEEEE_clES1_S7_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  311:      [&](Operation *op, SmallVectorImpl<Block *> &ancestorBlocks) {
    #####:  312:        Block *currBlock = op->getBlock();
        -:  313:        // Loop terminates when the currBlock is nullptr or its parent operation
        -:  314:        // holds an affine scope.
    #####:  315:        while (currBlock &&
branch  0 never executed
branch  1 never executed
    #####:  316:               !currBlock->getParentOp()->hasTrait<OpTrait::AffineScope>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  317:          ancestorBlocks.push_back(currBlock);
call    0 never executed
    #####:  318:          currBlock = currBlock->getParentOp()->getBlock();
call    0 never executed
        -:  319:        }
    #####:  320:        assert(currBlock &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  321:               "parent op starting an affine scope is always expected");
    #####:  322:        ancestorBlocks.push_back(currBlock);
call    0 never executed
    #####:  323:      };
        -:  324:
        -:  325:  // Find the closest common block including those in AffineIf.
    #####:  326:  SmallVector<Block *, 4> srcAncestorBlocks, dstAncestorBlocks;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:  getChainOfAncestorBlocks(opA, srcAncestorBlocks);
call    0 never executed
    #####:  328:  getChainOfAncestorBlocks(opB, dstAncestorBlocks);
call    0 never executed
        -:  329:
    #####:  330:  Block *commonBlock = nullptr;
    #####:  331:  for (int i = srcAncestorBlocks.size() - 1, j = dstAncestorBlocks.size() - 1;
    #####:  332:       i >= 0 && j >= 0 && srcAncestorBlocks[i] == dstAncestorBlocks[j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  333:       i--, j--)
    #####:  334:    commonBlock = srcAncestorBlocks[i];
        -:  335:  // This is guaranteed since both ops are from the same affine scope.
    #####:  336:  assert(commonBlock && "ops expected to have a common surrounding block");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  337:  return commonBlock;
branch  0 never executed
branch  1 never executed
        -:  338:}
        -:  339:
        -:  340:/// Returns true if the ancestor operation of 'srcAccess' appears before the
        -:  341:/// ancestor operation of 'dstAccess' in their common ancestral block. The
        -:  342:/// operations for `srcAccess` and `dstAccess` are expected to be in the same
        -:  343:/// affine scope.
        -:  344:static bool srcAppearsBeforeDstInAncestralBlock(const MemRefAccess &srcAccess,
        -:  345:                                                const MemRefAccess &dstAccess) {
        -:  346:  // Get Block common to 'srcAccess.opInst' and 'dstAccess.opInst'.
        -:  347:  auto *commonBlock = getCommonBlock(srcAccess.opInst, dstAccess.opInst);
        -:  348:  // Check the dominance relationship between the respective ancestors of the
        -:  349:  // src and dst in the Block of the innermost among the common loops.
        -:  350:  auto *srcInst = commonBlock->findAncestorOpInBlock(*srcAccess.opInst);
        -:  351:  assert(srcInst && "src access op must lie in common block");
        -:  352:  auto *dstInst = commonBlock->findAncestorOpInBlock(*dstAccess.opInst);
        -:  353:  assert(dstInst && "dest access op must lie in common block");
        -:  354:
        -:  355:  // Determine whether dstInst comes after srcInst.
        -:  356:  return srcInst->isBeforeInBlock(dstInst);
        -:  357:}
        -:  358:
        -:  359:// Adds ordering constraints to 'dependenceDomain' based on number of loops
        -:  360:// common to 'src/dstDomain' and requested 'loopDepth'.
        -:  361:// Note that 'loopDepth' cannot exceed the number of common loops plus one.
        -:  362:// EX: Given a loop nest of depth 2 with IVs 'i' and 'j':
        -:  363:// *) If 'loopDepth == 1' then one constraint is added: i' >= i + 1
        -:  364:// *) If 'loopDepth == 2' then two constraints are added: i == i' and j' > j + 1
        -:  365:// *) If 'loopDepth == 3' then two constraints are added: i == i' and j == j'
        -:  366:static void
function _ZL22addOrderingConstraintsRKN4mlir26FlatAffineValueConstraintsES2_jPS0_ called 0 returned 0% blocks executed 0%
    #####:  367:addOrderingConstraints(const FlatAffineValueConstraints &srcDomain,
        -:  368:                       const FlatAffineValueConstraints &dstDomain,
        -:  369:                       unsigned loopDepth,
        -:  370:                       FlatAffineValueConstraints *dependenceDomain) {
    #####:  371:  unsigned numCols = dependenceDomain->getNumCols();
call    0 never executed
    #####:  372:  SmallVector<int64_t, 4> eq(numCols);
call    0 never executed
    #####:  373:  unsigned numSrcDims = srcDomain.getNumDimVars();
call    0 never executed
    #####:  374:  unsigned numCommonLoops = getNumCommonLoops(srcDomain, dstDomain);
call    0 never executed
    #####:  375:  unsigned numCommonLoopConstraints = std::min(numCommonLoops, loopDepth);
branch  0 never executed
branch  1 never executed
    #####:  376:  for (unsigned i = 0; i < numCommonLoopConstraints; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  377:    std::fill(eq.begin(), eq.end(), 0);
    #####:  378:    eq[i] = -1;
branch  0 never executed
branch  1 never executed
    #####:  379:    eq[i + numSrcDims] = 1;
branch  0 never executed
branch  1 never executed
    #####:  380:    if (i == loopDepth - 1) {
branch  0 never executed
branch  1 never executed
    #####:  381:      eq[numCols - 1] = -1;
branch  0 never executed
branch  1 never executed
    #####:  382:      dependenceDomain->addInequality(eq);
call    0 never executed
        -:  383:    } else {
    #####:  384:      dependenceDomain->addEquality(eq);
call    0 never executed
        -:  385:    }
        -:  386:  }
    #####:  387:}
        -:  388:
        -:  389:// Computes distance and direction vectors in 'dependences', by adding
        -:  390:// variables to 'dependenceDomain' which represent the difference of the IVs,
        -:  391:// eliminating all other variables, and reading off distance vectors from
        -:  392:// equality constraints (if possible), and direction vectors from inequalities.
        -:  393:static void computeDirectionVector(
        -:  394:    const FlatAffineValueConstraints &srcDomain,
        -:  395:    const FlatAffineValueConstraints &dstDomain, unsigned loopDepth,
        -:  396:    FlatAffineValueConstraints *dependenceDomain,
        -:  397:    SmallVector<DependenceComponent, 2> *dependenceComponents) {
        -:  398:  // Find the number of common loops shared by src and dst accesses.
        -:  399:  SmallVector<AffineForOp, 4> commonLoops;
        -:  400:  unsigned numCommonLoops =
        -:  401:      getNumCommonLoops(srcDomain, dstDomain, &commonLoops);
        -:  402:  if (numCommonLoops == 0)
        -:  403:    return;
        -:  404:  // Compute direction vectors for requested loop depth.
        -:  405:  unsigned numIdsToEliminate = dependenceDomain->getNumVars();
        -:  406:  // Add new variables to 'dependenceDomain' to represent the direction
        -:  407:  // constraints for each shared loop.
        -:  408:  dependenceDomain->insertDimVar(/*pos=*/0, /*num=*/numCommonLoops);
        -:  409:
        -:  410:  // Add equality constraints for each common loop, setting newly introduced
        -:  411:  // variable at column 'j' to the 'dst' IV minus the 'src IV.
        -:  412:  SmallVector<int64_t, 4> eq;
        -:  413:  eq.resize(dependenceDomain->getNumCols());
        -:  414:  unsigned numSrcDims = srcDomain.getNumDimVars();
        -:  415:  // Constraint variables format:
        -:  416:  // [num-common-loops][num-src-dim-ids][num-dst-dim-ids][num-symbols][constant]
        -:  417:  for (unsigned j = 0; j < numCommonLoops; ++j) {
        -:  418:    std::fill(eq.begin(), eq.end(), 0);
        -:  419:    eq[j] = 1;
        -:  420:    eq[j + numCommonLoops] = 1;
        -:  421:    eq[j + numCommonLoops + numSrcDims] = -1;
        -:  422:    dependenceDomain->addEquality(eq);
        -:  423:  }
        -:  424:
        -:  425:  // Eliminate all variables other than the direction variables just added.
        -:  426:  dependenceDomain->projectOut(numCommonLoops, numIdsToEliminate);
        -:  427:
        -:  428:  // Scan each common loop variable column and set direction vectors based
        -:  429:  // on eliminated constraint system.
        -:  430:  dependenceComponents->resize(numCommonLoops);
        -:  431:  for (unsigned j = 0; j < numCommonLoops; ++j) {
        -:  432:    (*dependenceComponents)[j].op = commonLoops[j].getOperation();
        -:  433:    auto lbConst =
        -:  434:        dependenceDomain->getConstantBound64(IntegerPolyhedron::LB, j);
        -:  435:    (*dependenceComponents)[j].lb =
        -:  436:        lbConst.value_or(std::numeric_limits<int64_t>::min());
        -:  437:    auto ubConst =
        -:  438:        dependenceDomain->getConstantBound64(IntegerPolyhedron::UB, j);
        -:  439:    (*dependenceComponents)[j].ub =
        -:  440:        ubConst.value_or(std::numeric_limits<int64_t>::max());
        -:  441:  }
        -:  442:}
        -:  443:
function _ZNK4mlir12MemRefAccess17getAccessRelationERNS_18FlatAffineRelationE called 0 returned 0% blocks executed 0%
    #####:  444:LogicalResult MemRefAccess::getAccessRelation(FlatAffineRelation &rel) const {
        -:  445:  // Create set corresponding to domain of access.
    #####:  446:  FlatAffineValueConstraints domain;
call    0 never executed
    #####:  447:  if (failed(getOpIndexSet(opInst, &domain)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  448:    return failure();
call    0 never executed
        -:  449:
        -:  450:  // Get access relation from access map.
    #####:  451:  AffineValueMap accessValueMap;
call    0 never executed
    #####:  452:  getAccessMap(&accessValueMap);
call    0 never executed
    #####:  453:  if (failed(getRelationFromMap(accessValueMap, rel)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  454:    return failure();
        -:  455:
    #####:  456:  FlatAffineRelation domainRel(rel.getNumDomainDims(), /*numRangeDims=*/0,
    #####:  457:                               domain);
call    0 never executed
call    1 never executed
        -:  458:
        -:  459:  // Merge and align domain ids of `ret` and ids of `domain`. Since the domain
        -:  460:  // of the access map is a subset of the domain of access, the domain ids of
        -:  461:  // `ret` are guranteed to be a subset of ids of `domain`.
    #####:  462:  for (unsigned i = 0, e = domain.getNumDimVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  463:    unsigned loc;
    #####:  464:    if (rel.findVar(domain.getValue(i), &loc)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  465:      rel.swapVar(i, loc);
call    0 never executed
        -:  466:    } else {
    #####:  467:      rel.insertDomainVar(i);
call    0 never executed
    #####:  468:      rel.setValue(i, domain.getValue(i));
call    0 never executed
call    1 never executed
        -:  469:    }
        -:  470:  }
        -:  471:
        -:  472:  // Append domain constraints to `rel`.
    #####:  473:  domainRel.appendRangeVar(rel.getNumRangeDims());
call    0 never executed
    #####:  474:  domainRel.mergeSymbolVars(rel);
call    0 never executed
    #####:  475:  domainRel.mergeLocalVars(rel);
call    0 never executed
    #####:  476:  rel.append(domainRel);
call    0 never executed
        -:  477:
    #####:  478:  return success();
call    0 never executed
        -:  479:}
        -:  480:
        -:  481:// Populates 'accessMap' with composition of AffineApplyOps reachable from
        -:  482:// indices of MemRefAccess.
function _ZNK4mlir12MemRefAccess12getAccessMapEPNS_14AffineValueMapE called 0 returned 0% blocks executed 0%
    #####:  483:void MemRefAccess::getAccessMap(AffineValueMap *accessMap) const {
        -:  484:  // Get affine map from AffineLoad/Store.
    #####:  485:  AffineMap map;
    #####:  486:  if (auto loadOp = dyn_cast<AffineReadOpInterface>(opInst))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  487:    map = loadOp.getAffineMap();
call    0 never executed
        -:  488:  else
    #####:  489:    map = cast<AffineWriteOpInterface>(opInst).getAffineMap();
call    0 never executed
call    1 never executed
        -:  490:
    #####:  491:  SmallVector<Value, 8> operands(indices.begin(), indices.end());
call    0 never executed
    #####:  492:  fullyComposeAffineMapAndOperands(&map, &operands);
call    0 never executed
    #####:  493:  map = simplifyAffineMap(map);
call    0 never executed
    #####:  494:  canonicalizeMapAndOperands(&map, &operands);
call    0 never executed
    #####:  495:  accessMap->reset(map, operands);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  496:}
        -:  497:
        -:  498:// Builds a flat affine constraint system to check if there exists a dependence
        -:  499:// between memref accesses 'srcAccess' and 'dstAccess'.
        -:  500:// Returns 'NoDependence' if the accesses can be definitively shown not to
        -:  501:// access the same element.
        -:  502:// Returns 'HasDependence' if the accesses do access the same element.
        -:  503:// Returns 'Failure' if an error or unsupported case was encountered.
        -:  504:// If a dependence exists, returns in 'dependenceComponents' a direction
        -:  505:// vector for the dependence, with a component for each loop IV in loops
        -:  506:// common to both accesses (see Dependence in AffineAnalysis.h for details).
        -:  507://
        -:  508:// The memref access dependence check is comprised of the following steps:
        -:  509:// *) Build access relation for each access. An access relation maps elements
        -:  510://    of an iteration domain to the element(s) of an array domain accessed by
        -:  511://    that iteration of the associated statement through some array reference.
        -:  512:// *) Compute the dependence relation by composing access relation of
        -:  513://    `srcAccess` with the inverse of access relation of `dstAccess`.
        -:  514://    Doing this builds a relation between iteration domain of `srcAccess`
        -:  515://    to the iteration domain of `dstAccess` which access the same memory
        -:  516://    location.
        -:  517:// *) Add ordering constraints for `srcAccess` to be accessed before
        -:  518://    `dstAccess`.
        -:  519://
        -:  520:// This method builds a constraint system with the following column format:
        -:  521://
        -:  522://  [src-dim-variables, dst-dim-variables, symbols, constant]
        -:  523://
        -:  524:// For example, given the following MLIR code with "source" and "destination"
        -:  525:// accesses to the same memref label, and symbols %M, %N, %K:
        -:  526://
        -:  527://   affine.for %i0 = 0 to 100 {
        -:  528://     affine.for %i1 = 0 to 50 {
        -:  529://       %a0 = affine.apply
        -:  530://         (d0, d1) -> (d0 * 2 - d1 * 4 + s1, d1 * 3 - s0) (%i0, %i1)[%M, %N]
        -:  531://       // Source memref access.
        -:  532://       store %v0, %m[%a0#0, %a0#1] : memref<4x4xf32>
        -:  533://     }
        -:  534://   }
        -:  535://
        -:  536://   affine.for %i2 = 0 to 100 {
        -:  537://     affine.for %i3 = 0 to 50 {
        -:  538://       %a1 = affine.apply
        -:  539://         (d0, d1) -> (d0 * 7 + d1 * 9 - s1, d1 * 11 + s0) (%i2, %i3)[%K, %M]
        -:  540://       // Destination memref access.
        -:  541://       %v1 = load %m[%a1#0, %a1#1] : memref<4x4xf32>
        -:  542://     }
        -:  543://   }
        -:  544://
        -:  545:// The access relation for `srcAccess` would be the following:
        -:  546://
        -:  547://   [src_dim0, src_dim1, mem_dim0, mem_dim1,  %N,   %M,  const]
        -:  548://       2        -4       -1         0         1     0     0     = 0
        -:  549://       0         3        0        -1         0    -1     0     = 0
        -:  550://       1         0        0         0         0     0     0    >= 0
        -:  551://      -1         0        0         0         0     0     100  >= 0
        -:  552://       0         1        0         0         0     0     0    >= 0
        -:  553://       0        -1        0         0         0     0     50   >= 0
        -:  554://
        -:  555://  The access relation for `dstAccess` would be the following:
        -:  556://
        -:  557://   [dst_dim0, dst_dim1, mem_dim0, mem_dim1,  %M,   %K,  const]
        -:  558://       7         9       -1         0        -1     0     0     = 0
        -:  559://       0         11       0        -1         0    -1     0     = 0
        -:  560://       1         0        0         0         0     0     0    >= 0
        -:  561://      -1         0        0         0         0     0     100  >= 0
        -:  562://       0         1        0         0         0     0     0    >= 0
        -:  563://       0        -1        0         0         0     0     50   >= 0
        -:  564://
        -:  565://  The equalities in the above relations correspond to the access maps while
        -:  566://  the inequalities corresspond to the iteration domain constraints.
        -:  567://
        -:  568:// The dependence relation formed:
        -:  569://
        -:  570://   [src_dim0, src_dim1, dst_dim0, dst_dim1,  %M,   %N,   %K,  const]
        -:  571://      2         -4        -7        -9        1     1     0     0    = 0
        -:  572://      0          3         0        -11      -1     0     1     0    = 0
        -:  573://       1         0         0         0        0     0     0     0    >= 0
        -:  574://      -1         0         0         0        0     0     0     100  >= 0
        -:  575://       0         1         0         0        0     0     0     0    >= 0
        -:  576://       0        -1         0         0        0     0     0     50   >= 0
        -:  577://       0         0         1         0        0     0     0     0    >= 0
        -:  578://       0         0        -1         0        0     0     0     100  >= 0
        -:  579://       0         0         0         1        0     0     0     0    >= 0
        -:  580://       0         0         0        -1        0     0     0     50   >= 0
        -:  581://
        -:  582://
        -:  583:// TODO: Support AffineExprs mod/floordiv/ceildiv.
function _ZN4mlir27checkMemrefAccessDependenceERKNS_12MemRefAccessES2_jPNS_26FlatAffineValueConstraintsEPN4llvm11SmallVectorINS_19DependenceComponentELj2EEEb called 0 returned 0% blocks executed 0%
    #####:  584:DependenceResult mlir::checkMemrefAccessDependence(
        -:  585:    const MemRefAccess &srcAccess, const MemRefAccess &dstAccess,
        -:  586:    unsigned loopDepth, FlatAffineValueConstraints *dependenceConstraints,
        -:  587:    SmallVector<DependenceComponent, 2> *dependenceComponents, bool allowRAR) {
    #####:  588:  LLVM_DEBUG(llvm::dbgs() << "Checking for dependence at depth: "
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  589:                          << Twine(loopDepth) << " between:\n";);
    #####:  590:  LLVM_DEBUG(srcAccess.opInst->dump(););
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  591:  LLVM_DEBUG(dstAccess.opInst->dump(););
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  592:
        -:  593:  // Return 'NoDependence' if these accesses do not access the same memref.
    #####:  594:  if (srcAccess.memref != dstAccess.memref)
branch  0 never executed
branch  1 never executed
    #####:  595:    return DependenceResult::NoDependence;
        -:  596:
        -:  597:  // Return 'NoDependence' if one of these accesses is not an
        -:  598:  // AffineWriteOpInterface.
    #####:  599:  if (!allowRAR && !isa<AffineWriteOpInterface>(srcAccess.opInst) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  600:      !isa<AffineWriteOpInterface>(dstAccess.opInst))
call    0 never executed
    #####:  601:    return DependenceResult::NoDependence;
        -:  602:
        -:  603:  // We can't analyze further if the ops lie in different affine scopes.
    #####:  604:  if (getAffineScope(srcAccess.opInst) != getAffineScope(dstAccess.opInst))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  605:    return DependenceResult::Failure;
        -:  606:
        -:  607:  // Create access relation from each MemRefAccess.
    #####:  608:  FlatAffineRelation srcRel, dstRel;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  609:  if (failed(srcAccess.getAccessRelation(srcRel)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  610:    return DependenceResult::Failure;
    #####:  611:  if (failed(dstAccess.getAccessRelation(dstRel)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  612:    return DependenceResult::Failure;
        -:  613:
    #####:  614:  FlatAffineValueConstraints srcDomain = srcRel.getDomainSet();
call    0 never executed
call    1 never executed
    #####:  615:  FlatAffineValueConstraints dstDomain = dstRel.getDomainSet();
call    0 never executed
call    1 never executed
        -:  616:
        -:  617:  // Return 'NoDependence' if loopDepth > numCommonLoops and if the ancestor
        -:  618:  // operation of 'srcAccess' does not properly dominate the ancestor
        -:  619:  // operation of 'dstAccess' in the same common operation block.
        -:  620:  // Note: this check is skipped if 'allowRAR' is true, because because RAR
        -:  621:  // deps can exist irrespective of lexicographic ordering b/w src and dst.
    #####:  622:  unsigned numCommonLoops = getNumCommonLoops(srcDomain, dstDomain);
call    0 never executed
    #####:  623:  assert(loopDepth <= numCommonLoops + 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  624:  if (!allowRAR && loopDepth > numCommonLoops &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  625:      !srcAppearsBeforeDstInAncestralBlock(srcAccess, dstAccess)) {
call    0 never executed
    #####:  626:    return DependenceResult::NoDependence;
        -:  627:  }
        -:  628:
        -:  629:  // Compute the dependence relation by composing `srcRel` with the inverse of
        -:  630:  // `dstRel`. Doing this builds a relation between iteration domain of
        -:  631:  // `srcAccess` to the iteration domain of `dstAccess` which access the same
        -:  632:  // memory locations.
    #####:  633:  dstRel.inverse();
call    0 never executed
    #####:  634:  dstRel.compose(srcRel);
call    0 never executed
    #####:  635:  *dependenceConstraints = dstRel;
call    0 never executed
        -:  636:
        -:  637:  // Add 'src' happens before 'dst' ordering constraints.
    #####:  638:  addOrderingConstraints(srcDomain, dstDomain, loopDepth,
call    0 never executed
        -:  639:                         dependenceConstraints);
        -:  640:
        -:  641:  // Return 'NoDependence' if the solution space is empty: no dependence.
    #####:  642:  if (dependenceConstraints->isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  643:    return DependenceResult::NoDependence;
        -:  644:
        -:  645:  // Compute dependence direction vector and return true.
    #####:  646:  if (dependenceComponents != nullptr)
branch  0 never executed
branch  1 never executed
    #####:  647:    computeDirectionVector(srcDomain, dstDomain, loopDepth,
call    0 never executed
        -:  648:                           dependenceConstraints, dependenceComponents);
        -:  649:
    #####:  650:  LLVM_DEBUG(llvm::dbgs() << "Dependence polyhedron:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  651:  LLVM_DEBUG(dependenceConstraints->dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  652:  return DependenceResult::HasDependence;
        -:  653:}
        -:  654:
        -:  655:/// Gathers dependence components for dependences between all ops in loop nest
        -:  656:/// rooted at 'forOp' at loop depths in range [1, maxLoopDepth].
function _ZN4mlir23getDependenceComponentsENS_11AffineForOpEjPSt6vectorIN4llvm11SmallVectorINS_19DependenceComponentELj2EEESaIS5_EE called 0 returned 0% blocks executed 0%
    #####:  657:void mlir::getDependenceComponents(
        -:  658:    AffineForOp forOp, unsigned maxLoopDepth,
        -:  659:    std::vector<SmallVector<DependenceComponent, 2>> *depCompsVec) {
        -:  660:  // Collect all load and store ops in loop nest rooted at 'forOp'.
    #####:  661:  SmallVector<Operation *, 8> loadAndStoreOps;
call    0 never executed
function _ZZN4mlir23getDependenceComponentsENS_11AffineForOpEjPSt6vectorIN4llvm11SmallVectorINS_19DependenceComponentELj2EEESaIS5_EEENKUlPNS_9OperationEE_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  662:  forOp->walk([&](Operation *op) {
call    0 never executed
    #####:  663:    if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  664:      loadAndStoreOps.push_back(op);
call    0 never executed
    #####:  665:  });
        -:  666:
    #####:  667:  unsigned numOps = loadAndStoreOps.size();
    #####:  668:  for (unsigned d = 1; d <= maxLoopDepth; ++d) {
branch  0 never executed
branch  1 never executed
    #####:  669:    for (unsigned i = 0; i < numOps; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  670:      auto *srcOp = loadAndStoreOps[i];
branch  0 never executed
branch  1 never executed
    #####:  671:      MemRefAccess srcAccess(srcOp);
    #####:  672:      for (unsigned j = 0; j < numOps; ++j) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  673:        auto *dstOp = loadAndStoreOps[j];
branch  0 never executed
branch  1 never executed
    #####:  674:        MemRefAccess dstAccess(dstOp);
call    0 never executed
        -:  675:
    #####:  676:        FlatAffineValueConstraints dependenceConstraints;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  677:        SmallVector<DependenceComponent, 2> depComps;
call    0 never executed
call    1 never executed
        -:  678:        // TODO: Explore whether it would be profitable to pre-compute and store
        -:  679:        // deps instead of repeatedly checking.
    #####:  680:        DependenceResult result = checkMemrefAccessDependence(
    #####:  681:            srcAccess, dstAccess, d, &dependenceConstraints, &depComps);
call    0 never executed
    #####:  682:        if (hasDependence(result))
branch  0 never executed
branch  1 never executed
    #####:  683:          depCompsVec->push_back(depComps);
call    0 never executed
        -:  684:      }
        -:  685:    }
        -:  686:  }
    #####:  687:}
