        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/Instruction.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===-- llvm/Instruction.h - Instruction class definition -------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains the declaration of the Instruction class, which is the
        -:   10:// base class for all of the LLVM instructions.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_IR_INSTRUCTION_H
        -:   15:#define LLVM_IR_INSTRUCTION_H
        -:   16:
        -:   17:#include "llvm/ADT/ArrayRef.h"
        -:   18:#include "llvm/ADT/Bitfields.h"
        -:   19:#include "llvm/ADT/None.h"
        -:   20:#include "llvm/ADT/StringRef.h"
        -:   21:#include "llvm/ADT/ilist_node.h"
        -:   22:#include "llvm/IR/DebugLoc.h"
        -:   23:#include "llvm/IR/SymbolTableListTraits.h"
        -:   24:#include "llvm/IR/User.h"
        -:   25:#include "llvm/IR/Value.h"
        -:   26:#include "llvm/Support/AtomicOrdering.h"
        -:   27:#include <cstdint>
        -:   28:#include <utility>
        -:   29:
        -:   30:namespace llvm {
        -:   31:
        -:   32:class BasicBlock;
        -:   33:class FastMathFlags;
        -:   34:class MDNode;
        -:   35:class Module;
        -:   36:struct AAMDNodes;
        -:   37:
        -:   38:template <> struct ilist_alloc_traits<Instruction> {
        -:   39:  static inline void deleteNode(Instruction *V);
        -:   40:};
        -:   41:
        -:   42:class Instruction : public User,
        -:   43:                    public ilist_node_with_parent<Instruction, BasicBlock> {
        -:   44:  BasicBlock *Parent;
        -:   45:  DebugLoc DbgLoc;                         // 'dbg' Metadata cache.
        -:   46:
        -:   47:  /// Relative order of this instruction in its parent basic block. Used for
        -:   48:  /// O(1) local dominance checks between instructions.
        -:   49:  mutable unsigned Order = 0;
        -:   50:
        -:   51:protected:
        -:   52:  // The 15 first bits of `Value::SubclassData` are available for subclasses of
        -:   53:  // `Instruction` to use.
        -:   54:  using OpaqueField = Bitfield::Element<uint16_t, 0, 15>;
        -:   55:
        -:   56:  // Template alias so that all Instruction storing alignment use the same
        -:   57:  // definiton.
        -:   58:  // Valid alignments are powers of two from 2^0 to 2^MaxAlignmentExponent =
        -:   59:  // 2^32. We store them as Log2(Alignment), so we need 6 bits to encode the 33
        -:   60:  // possible values.
        -:   61:  template <unsigned Offset>
        -:   62:  using AlignmentBitfieldElementT =
        -:   63:      typename Bitfield::Element<unsigned, Offset, 6,
        -:   64:                                 Value::MaxAlignmentExponent>;
        -:   65:
        -:   66:  template <unsigned Offset>
        -:   67:  using BoolBitfieldElementT = typename Bitfield::Element<bool, Offset, 1>;
        -:   68:
        -:   69:  template <unsigned Offset>
        -:   70:  using AtomicOrderingBitfieldElementT =
        -:   71:      typename Bitfield::Element<AtomicOrdering, Offset, 3,
        -:   72:                                 AtomicOrdering::LAST>;
        -:   73:
        -:   74:private:
        -:   75:  // The last bit is used to store whether the instruction has metadata attached
        -:   76:  // or not.
        -:   77:  using HasMetadataField = Bitfield::Element<bool, 15, 1>;
        -:   78:
        -:   79:protected:
        -:   80:  ~Instruction(); // Use deleteValue() to delete a generic Instruction.
        -:   81:
        -:   82:public:
        -:   83:  Instruction(const Instruction &) = delete;
        -:   84:  Instruction &operator=(const Instruction &) = delete;
        -:   85:
        -:   86:  /// Specialize the methods defined in Value, as we know that an instruction
        -:   87:  /// can only be used by other instructions.
        -:   88:  Instruction       *user_back()       { return cast<Instruction>(*user_begin());}
        -:   89:  const Instruction *user_back() const { return cast<Instruction>(*user_begin());}
        -:   90:
        -:   91:  inline const BasicBlock *getParent() const { return Parent; }
        -:   92:  inline       BasicBlock *getParent()       { return Parent; }
        -:   93:
        -:   94:  /// Return the module owning the function this instruction belongs to
        -:   95:  /// or nullptr it the function does not have a module.
        -:   96:  ///
        -:   97:  /// Note: this is undefined behavior if the instruction does not have a
        -:   98:  /// parent, or the parent basic block does not have a parent function.
        -:   99:  const Module *getModule() const;
        -:  100:  Module *getModule() {
        -:  101:    return const_cast<Module *>(
        -:  102:                           static_cast<const Instruction *>(this)->getModule());
        -:  103:  }
        -:  104:
        -:  105:  /// Return the function this instruction belongs to.
        -:  106:  ///
        -:  107:  /// Note: it is undefined behavior to call this on an instruction not
        -:  108:  /// currently inserted into a function.
        -:  109:  const Function *getFunction() const;
        -:  110:  Function *getFunction() {
        -:  111:    return const_cast<Function *>(
        -:  112:                         static_cast<const Instruction *>(this)->getFunction());
        -:  113:  }
        -:  114:
        -:  115:  /// This method unlinks 'this' from the containing basic block, but does not
        -:  116:  /// delete it.
        -:  117:  void removeFromParent();
        -:  118:
        -:  119:  /// This method unlinks 'this' from the containing basic block and deletes it.
        -:  120:  ///
        -:  121:  /// \returns an iterator pointing to the element after the erased one
        -:  122:  SymbolTableList<Instruction>::iterator eraseFromParent();
        -:  123:
        -:  124:  /// Insert an unlinked instruction into a basic block immediately before
        -:  125:  /// the specified instruction.
        -:  126:  void insertBefore(Instruction *InsertPos);
        -:  127:
        -:  128:  /// Insert an unlinked instruction into a basic block immediately after the
        -:  129:  /// specified instruction.
        -:  130:  void insertAfter(Instruction *InsertPos);
        -:  131:
        -:  132:  /// Unlink this instruction from its current basic block and insert it into
        -:  133:  /// the basic block that MovePos lives in, right before MovePos.
        -:  134:  void moveBefore(Instruction *MovePos);
        -:  135:
        -:  136:  /// Unlink this instruction and insert into BB before I.
        -:  137:  ///
        -:  138:  /// \pre I is a valid iterator into BB.
        -:  139:  void moveBefore(BasicBlock &BB, SymbolTableList<Instruction>::iterator I);
        -:  140:
        -:  141:  /// Unlink this instruction from its current basic block and insert it into
        -:  142:  /// the basic block that MovePos lives in, right after MovePos.
        -:  143:  void moveAfter(Instruction *MovePos);
        -:  144:
        -:  145:  /// Given an instruction Other in the same basic block as this instruction,
        -:  146:  /// return true if this instruction comes before Other. In this worst case,
        -:  147:  /// this takes linear time in the number of instructions in the block. The
        -:  148:  /// results are cached, so in common cases when the block remains unmodified,
        -:  149:  /// it takes constant time.
        -:  150:  bool comesBefore(const Instruction *Other) const;
        -:  151:
        -:  152:  /// Get the first insertion point at which the result of this instruction
        -:  153:  /// is defined. This is *not* the directly following instruction in a number
        -:  154:  /// of cases, e.g. phi nodes or terminators that return values. This function
        -:  155:  /// may return null if the insertion after the definition is not possible,
        -:  156:  /// e.g. due to a catchswitch terminator.
        -:  157:  Instruction *getInsertionPointAfterDef();
        -:  158:
        -:  159:  //===--------------------------------------------------------------------===//
        -:  160:  // Subclass classification.
        -:  161:  //===--------------------------------------------------------------------===//
        -:  162:
        -:  163:  /// Returns a member of one of the enums like Instruction::Add.
    #####:  164:  unsigned getOpcode() const { return getValueID() - InstructionVal; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  165:
        -:  166:  const char *getOpcodeName() const { return getOpcodeName(getOpcode()); }
        -:  167:  bool isTerminator() const { return isTerminator(getOpcode()); }
        -:  168:  bool isUnaryOp() const { return isUnaryOp(getOpcode()); }
        -:  169:  bool isBinaryOp() const { return isBinaryOp(getOpcode()); }
        -:  170:  bool isIntDivRem() const { return isIntDivRem(getOpcode()); }
        -:  171:  bool isShift() const { return isShift(getOpcode()); }
        -:  172:  bool isCast() const { return isCast(getOpcode()); }
        -:  173:  bool isFuncletPad() const { return isFuncletPad(getOpcode()); }
        -:  174:  bool isExceptionalTerminator() const {
        -:  175:    return isExceptionalTerminator(getOpcode());
        -:  176:  }
        -:  177:
        -:  178:  /// It checks if this instruction is the only user of at least one of
        -:  179:  /// its operands.
        -:  180:  bool isOnlyUserOfAnyOperand();
        -:  181:
        -:  182:  static const char* getOpcodeName(unsigned OpCode);
        -:  183:
        -:  184:  static inline bool isTerminator(unsigned OpCode) {
        -:  185:    return OpCode >= TermOpsBegin && OpCode < TermOpsEnd;
        -:  186:  }
        -:  187:
        -:  188:  static inline bool isUnaryOp(unsigned Opcode) {
        -:  189:    return Opcode >= UnaryOpsBegin && Opcode < UnaryOpsEnd;
        -:  190:  }
        -:  191:  static inline bool isBinaryOp(unsigned Opcode) {
        -:  192:    return Opcode >= BinaryOpsBegin && Opcode < BinaryOpsEnd;
        -:  193:  }
        -:  194:
        -:  195:  static inline bool isIntDivRem(unsigned Opcode) {
        -:  196:    return Opcode == UDiv || Opcode == SDiv || Opcode == URem || Opcode == SRem;
        -:  197:  }
        -:  198:
        -:  199:  /// Determine if the Opcode is one of the shift instructions.
        -:  200:  static inline bool isShift(unsigned Opcode) {
        -:  201:    return Opcode >= Shl && Opcode <= AShr;
        -:  202:  }
        -:  203:
        -:  204:  /// Return true if this is a logical shift left or a logical shift right.
        -:  205:  inline bool isLogicalShift() const {
        -:  206:    return getOpcode() == Shl || getOpcode() == LShr;
        -:  207:  }
        -:  208:
        -:  209:  /// Return true if this is an arithmetic shift right.
        -:  210:  inline bool isArithmeticShift() const {
        -:  211:    return getOpcode() == AShr;
        -:  212:  }
        -:  213:
        -:  214:  /// Determine if the Opcode is and/or/xor.
        -:  215:  static inline bool isBitwiseLogicOp(unsigned Opcode) {
        -:  216:    return Opcode == And || Opcode == Or || Opcode == Xor;
        -:  217:  }
        -:  218:
        -:  219:  /// Return true if this is and/or/xor.
        -:  220:  inline bool isBitwiseLogicOp() const {
        -:  221:    return isBitwiseLogicOp(getOpcode());
        -:  222:  }
        -:  223:
        -:  224:  /// Determine if the OpCode is one of the CastInst instructions.
        -:  225:  static inline bool isCast(unsigned OpCode) {
        -:  226:    return OpCode >= CastOpsBegin && OpCode < CastOpsEnd;
        -:  227:  }
        -:  228:
        -:  229:  /// Determine if the OpCode is one of the FuncletPadInst instructions.
        -:  230:  static inline bool isFuncletPad(unsigned OpCode) {
        -:  231:    return OpCode >= FuncletPadOpsBegin && OpCode < FuncletPadOpsEnd;
        -:  232:  }
        -:  233:
        -:  234:  /// Returns true if the OpCode is a terminator related to exception handling.
        -:  235:  static inline bool isExceptionalTerminator(unsigned OpCode) {
        -:  236:    switch (OpCode) {
        -:  237:    case Instruction::CatchSwitch:
        -:  238:    case Instruction::CatchRet:
        -:  239:    case Instruction::CleanupRet:
        -:  240:    case Instruction::Invoke:
        -:  241:    case Instruction::Resume:
        -:  242:      return true;
        -:  243:    default:
        -:  244:      return false;
        -:  245:    }
        -:  246:  }
        -:  247:
        -:  248:  //===--------------------------------------------------------------------===//
        -:  249:  // Metadata manipulation.
        -:  250:  //===--------------------------------------------------------------------===//
        -:  251:
        -:  252:  /// Return true if this instruction has any metadata attached to it.
        -:  253:  bool hasMetadata() const { return DbgLoc || Value::hasMetadata(); }
        -:  254:
        -:  255:  /// Return true if this instruction has metadata attached to it other than a
        -:  256:  /// debug location.
        -:  257:  bool hasMetadataOtherThanDebugLoc() const { return Value::hasMetadata(); }
        -:  258:
        -:  259:  /// Return true if this instruction has the given type of metadata attached.
        -:  260:  bool hasMetadata(unsigned KindID) const {
        -:  261:    return getMetadata(KindID) != nullptr;
        -:  262:  }
        -:  263:
        -:  264:  /// Return true if this instruction has the given type of metadata attached.
        -:  265:  bool hasMetadata(StringRef Kind) const {
        -:  266:    return getMetadata(Kind) != nullptr;
        -:  267:  }
        -:  268:
        -:  269:  /// Get the metadata of given kind attached to this Instruction.
        -:  270:  /// If the metadata is not found then return null.
        -:  271:  MDNode *getMetadata(unsigned KindID) const {
        -:  272:    if (!hasMetadata()) return nullptr;
        -:  273:    return getMetadataImpl(KindID);
        -:  274:  }
        -:  275:
        -:  276:  /// Get the metadata of given kind attached to this Instruction.
        -:  277:  /// If the metadata is not found then return null.
        -:  278:  MDNode *getMetadata(StringRef Kind) const {
        -:  279:    if (!hasMetadata()) return nullptr;
        -:  280:    return getMetadataImpl(Kind);
        -:  281:  }
        -:  282:
        -:  283:  /// Get all metadata attached to this Instruction. The first element of each
        -:  284:  /// pair returned is the KindID, the second element is the metadata value.
        -:  285:  /// This list is returned sorted by the KindID.
        -:  286:  void
        -:  287:  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const {
        -:  288:    if (hasMetadata())
        -:  289:      getAllMetadataImpl(MDs);
        -:  290:  }
        -:  291:
        -:  292:  /// This does the same thing as getAllMetadata, except that it filters out the
        -:  293:  /// debug location.
        -:  294:  void getAllMetadataOtherThanDebugLoc(
        -:  295:      SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const {
        -:  296:    Value::getAllMetadata(MDs);
        -:  297:  }
        -:  298:
        -:  299:  /// Set the metadata of the specified kind to the specified node. This updates
        -:  300:  /// or replaces metadata if already present, or removes it if Node is null.
        -:  301:  void setMetadata(unsigned KindID, MDNode *Node);
        -:  302:  void setMetadata(StringRef Kind, MDNode *Node);
        -:  303:
        -:  304:  /// Copy metadata from \p SrcInst to this instruction. \p WL, if not empty,
        -:  305:  /// specifies the list of meta data that needs to be copied. If \p WL is
        -:  306:  /// empty, all meta data will be copied.
        -:  307:  void copyMetadata(const Instruction &SrcInst,
        -:  308:                    ArrayRef<unsigned> WL = ArrayRef<unsigned>());
        -:  309:
        -:  310:  /// If the instruction has "branch_weights" MD_prof metadata and the MDNode
        -:  311:  /// has three operands (including name string), swap the order of the
        -:  312:  /// metadata.
        -:  313:  void swapProfMetadata();
        -:  314:
        -:  315:  /// Drop all unknown metadata except for debug locations.
        -:  316:  /// @{
        -:  317:  /// Passes are required to drop metadata they don't understand. This is a
        -:  318:  /// convenience method for passes to do so.
        -:  319:  /// dropUndefImplyingAttrsAndUnknownMetadata should be used instead of
        -:  320:  /// this API if the Instruction being modified is a call.
        -:  321:  void dropUnknownNonDebugMetadata(ArrayRef<unsigned> KnownIDs);
        -:  322:  void dropUnknownNonDebugMetadata() {
        -:  323:    return dropUnknownNonDebugMetadata(None);
        -:  324:  }
        -:  325:  void dropUnknownNonDebugMetadata(unsigned ID1) {
        -:  326:    return dropUnknownNonDebugMetadata(makeArrayRef(ID1));
        -:  327:  }
        -:  328:  void dropUnknownNonDebugMetadata(unsigned ID1, unsigned ID2) {
        -:  329:    unsigned IDs[] = {ID1, ID2};
        -:  330:    return dropUnknownNonDebugMetadata(IDs);
        -:  331:  }
        -:  332:  /// @}
        -:  333:
        -:  334:  /// Adds an !annotation metadata node with \p Annotation to this instruction.
        -:  335:  /// If this instruction already has !annotation metadata, append \p Annotation
        -:  336:  /// to the existing node.
        -:  337:  void addAnnotationMetadata(StringRef Annotation);
        -:  338:
        -:  339:  /// Returns the AA metadata for this instruction.
        -:  340:  AAMDNodes getAAMetadata() const;
        -:  341:
        -:  342:  /// Sets the AA metadata on this instruction from the AAMDNodes structure.
        -:  343:  void setAAMetadata(const AAMDNodes &N);
        -:  344:
        -:  345:  /// Retrieve total raw weight values of a branch.
        -:  346:  /// Returns true on success with profile total weights filled in.
        -:  347:  /// Returns false if no metadata was found.
        -:  348:  bool extractProfTotalWeight(uint64_t &TotalVal) const;
        -:  349:
        -:  350:  /// Set the debug location information for this instruction.
        -:  351:  void setDebugLoc(DebugLoc Loc) { DbgLoc = std::move(Loc); }
        -:  352:
        -:  353:  /// Return the debug location for this node as a DebugLoc.
        -:  354:  const DebugLoc &getDebugLoc() const { return DbgLoc; }
        -:  355:
        -:  356:  /// Set or clear the nuw flag on this instruction, which must be an operator
        -:  357:  /// which supports this flag. See LangRef.html for the meaning of this flag.
        -:  358:  void setHasNoUnsignedWrap(bool b = true);
        -:  359:
        -:  360:  /// Set or clear the nsw flag on this instruction, which must be an operator
        -:  361:  /// which supports this flag. See LangRef.html for the meaning of this flag.
        -:  362:  void setHasNoSignedWrap(bool b = true);
        -:  363:
        -:  364:  /// Set or clear the exact flag on this instruction, which must be an operator
        -:  365:  /// which supports this flag. See LangRef.html for the meaning of this flag.
        -:  366:  void setIsExact(bool b = true);
        -:  367:
        -:  368:  /// Determine whether the no unsigned wrap flag is set.
        -:  369:  bool hasNoUnsignedWrap() const LLVM_READONLY;
        -:  370:
        -:  371:  /// Determine whether the no signed wrap flag is set.
        -:  372:  bool hasNoSignedWrap() const LLVM_READONLY;
        -:  373:
        -:  374:  /// Return true if this operator has flags which may cause this instruction
        -:  375:  /// to evaluate to poison despite having non-poison inputs.
        -:  376:  bool hasPoisonGeneratingFlags() const LLVM_READONLY;
        -:  377:
        -:  378:  /// Drops flags that may cause this instruction to evaluate to poison despite
        -:  379:  /// having non-poison inputs.
        -:  380:  void dropPoisonGeneratingFlags();
        -:  381:
        -:  382:  /// This function drops non-debug unknown metadata (through
        -:  383:  /// dropUnknownNonDebugMetadata). For calls, it also drops parameter and 
        -:  384:  /// return attributes that can cause undefined behaviour. Both of these should
        -:  385:  /// be done by passes which move instructions in IR.
        -:  386:  void
        -:  387:  dropUndefImplyingAttrsAndUnknownMetadata(ArrayRef<unsigned> KnownIDs = {});
        -:  388:
        -:  389:  /// Determine whether the exact flag is set.
        -:  390:  bool isExact() const LLVM_READONLY;
        -:  391:
        -:  392:  /// Set or clear all fast-math-flags on this instruction, which must be an
        -:  393:  /// operator which supports this flag. See LangRef.html for the meaning of
        -:  394:  /// this flag.
        -:  395:  void setFast(bool B);
        -:  396:
        -:  397:  /// Set or clear the reassociation flag on this instruction, which must be
        -:  398:  /// an operator which supports this flag. See LangRef.html for the meaning of
        -:  399:  /// this flag.
        -:  400:  void setHasAllowReassoc(bool B);
        -:  401:
        -:  402:  /// Set or clear the no-nans flag on this instruction, which must be an
        -:  403:  /// operator which supports this flag. See LangRef.html for the meaning of
        -:  404:  /// this flag.
        -:  405:  void setHasNoNaNs(bool B);
        -:  406:
        -:  407:  /// Set or clear the no-infs flag on this instruction, which must be an
        -:  408:  /// operator which supports this flag. See LangRef.html for the meaning of
        -:  409:  /// this flag.
        -:  410:  void setHasNoInfs(bool B);
        -:  411:
        -:  412:  /// Set or clear the no-signed-zeros flag on this instruction, which must be
        -:  413:  /// an operator which supports this flag. See LangRef.html for the meaning of
        -:  414:  /// this flag.
        -:  415:  void setHasNoSignedZeros(bool B);
        -:  416:
        -:  417:  /// Set or clear the allow-reciprocal flag on this instruction, which must be
        -:  418:  /// an operator which supports this flag. See LangRef.html for the meaning of
        -:  419:  /// this flag.
        -:  420:  void setHasAllowReciprocal(bool B);
        -:  421:
        -:  422:  /// Set or clear the allow-contract flag on this instruction, which must be
        -:  423:  /// an operator which supports this flag. See LangRef.html for the meaning of
        -:  424:  /// this flag.
        -:  425:  void setHasAllowContract(bool B);
        -:  426:
        -:  427:  /// Set or clear the approximate-math-functions flag on this instruction,
        -:  428:  /// which must be an operator which supports this flag. See LangRef.html for
        -:  429:  /// the meaning of this flag.
        -:  430:  void setHasApproxFunc(bool B);
        -:  431:
        -:  432:  /// Convenience function for setting multiple fast-math flags on this
        -:  433:  /// instruction, which must be an operator which supports these flags. See
        -:  434:  /// LangRef.html for the meaning of these flags.
        -:  435:  void setFastMathFlags(FastMathFlags FMF);
        -:  436:
        -:  437:  /// Convenience function for transferring all fast-math flag values to this
        -:  438:  /// instruction, which must be an operator which supports these flags. See
        -:  439:  /// LangRef.html for the meaning of these flags.
        -:  440:  void copyFastMathFlags(FastMathFlags FMF);
        -:  441:
        -:  442:  /// Determine whether all fast-math-flags are set.
        -:  443:  bool isFast() const LLVM_READONLY;
        -:  444:
        -:  445:  /// Determine whether the allow-reassociation flag is set.
        -:  446:  bool hasAllowReassoc() const LLVM_READONLY;
        -:  447:
        -:  448:  /// Determine whether the no-NaNs flag is set.
        -:  449:  bool hasNoNaNs() const LLVM_READONLY;
        -:  450:
        -:  451:  /// Determine whether the no-infs flag is set.
        -:  452:  bool hasNoInfs() const LLVM_READONLY;
        -:  453:
        -:  454:  /// Determine whether the no-signed-zeros flag is set.
        -:  455:  bool hasNoSignedZeros() const LLVM_READONLY;
        -:  456:
        -:  457:  /// Determine whether the allow-reciprocal flag is set.
        -:  458:  bool hasAllowReciprocal() const LLVM_READONLY;
        -:  459:
        -:  460:  /// Determine whether the allow-contract flag is set.
        -:  461:  bool hasAllowContract() const LLVM_READONLY;
        -:  462:
        -:  463:  /// Determine whether the approximate-math-functions flag is set.
        -:  464:  bool hasApproxFunc() const LLVM_READONLY;
        -:  465:
        -:  466:  /// Convenience function for getting all the fast-math flags, which must be an
        -:  467:  /// operator which supports these flags. See LangRef.html for the meaning of
        -:  468:  /// these flags.
        -:  469:  FastMathFlags getFastMathFlags() const LLVM_READONLY;
        -:  470:
        -:  471:  /// Copy I's fast-math flags
        -:  472:  void copyFastMathFlags(const Instruction *I);
        -:  473:
        -:  474:  /// Convenience method to copy supported exact, fast-math, and (optionally)
        -:  475:  /// wrapping flags from V to this instruction.
        -:  476:  void copyIRFlags(const Value *V, bool IncludeWrapFlags = true);
        -:  477:
        -:  478:  /// Logical 'and' of any supported wrapping, exact, and fast-math flags of
        -:  479:  /// V and this instruction.
        -:  480:  void andIRFlags(const Value *V);
        -:  481:
        -:  482:  /// Merge 2 debug locations and apply it to the Instruction. If the
        -:  483:  /// instruction is a CallIns, we need to traverse the inline chain to find
        -:  484:  /// the common scope. This is not efficient for N-way merging as each time
        -:  485:  /// you merge 2 iterations, you need to rebuild the hashmap to find the
        -:  486:  /// common scope. However, we still choose this API because:
        -:  487:  ///  1) Simplicity: it takes 2 locations instead of a list of locations.
        -:  488:  ///  2) In worst case, it increases the complexity from O(N*I) to
        -:  489:  ///     O(2*N*I), where N is # of Instructions to merge, and I is the
        -:  490:  ///     maximum level of inline stack. So it is still linear.
        -:  491:  ///  3) Merging of call instructions should be extremely rare in real
        -:  492:  ///     applications, thus the N-way merging should be in code path.
        -:  493:  /// The DebugLoc attached to this instruction will be overwritten by the
        -:  494:  /// merged DebugLoc.
        -:  495:  void applyMergedLocation(const DILocation *LocA, const DILocation *LocB);
        -:  496:
        -:  497:  /// Updates the debug location given that the instruction has been hoisted
        -:  498:  /// from a block to a predecessor of that block.
        -:  499:  /// Note: it is undefined behavior to call this on an instruction not
        -:  500:  /// currently inserted into a function.
        -:  501:  void updateLocationAfterHoist();
        -:  502:
        -:  503:  /// Drop the instruction's debug location. This does not guarantee removal
        -:  504:  /// of the !dbg source location attachment, as it must set a line 0 location
        -:  505:  /// with scope information attached on call instructions. To guarantee
        -:  506:  /// removal of the !dbg attachment, use the \ref setDebugLoc() API.
        -:  507:  /// Note: it is undefined behavior to call this on an instruction not
        -:  508:  /// currently inserted into a function.
        -:  509:  void dropLocation();
        -:  510:
        -:  511:private:
        -:  512:  // These are all implemented in Metadata.cpp.
        -:  513:  MDNode *getMetadataImpl(unsigned KindID) const;
        -:  514:  MDNode *getMetadataImpl(StringRef Kind) const;
        -:  515:  void
        -:  516:  getAllMetadataImpl(SmallVectorImpl<std::pair<unsigned, MDNode *>> &) const;
        -:  517:
        -:  518:public:
        -:  519:  //===--------------------------------------------------------------------===//
        -:  520:  // Predicates and helper methods.
        -:  521:  //===--------------------------------------------------------------------===//
        -:  522:
        -:  523:  /// Return true if the instruction is associative:
        -:  524:  ///
        -:  525:  ///   Associative operators satisfy:  x op (y op z) === (x op y) op z
        -:  526:  ///
        -:  527:  /// In LLVM, the Add, Mul, And, Or, and Xor operators are associative.
        -:  528:  ///
        -:  529:  bool isAssociative() const LLVM_READONLY;
        -:  530:  static bool isAssociative(unsigned Opcode) {
        -:  531:    return Opcode == And || Opcode == Or || Opcode == Xor ||
        -:  532:           Opcode == Add || Opcode == Mul;
        -:  533:  }
        -:  534:
        -:  535:  /// Return true if the instruction is commutative:
        -:  536:  ///
        -:  537:  ///   Commutative operators satisfy: (x op y) === (y op x)
        -:  538:  ///
        -:  539:  /// In LLVM, these are the commutative operators, plus SetEQ and SetNE, when
        -:  540:  /// applied to any type.
        -:  541:  ///
        -:  542:  bool isCommutative() const LLVM_READONLY;
        -:  543:  static bool isCommutative(unsigned Opcode) {
        -:  544:    switch (Opcode) {
        -:  545:    case Add: case FAdd:
        -:  546:    case Mul: case FMul:
        -:  547:    case And: case Or: case Xor:
        -:  548:      return true;
        -:  549:    default:
        -:  550:      return false;
        -:  551:  }
        -:  552:  }
        -:  553:
        -:  554:  /// Return true if the instruction is idempotent:
        -:  555:  ///
        -:  556:  ///   Idempotent operators satisfy:  x op x === x
        -:  557:  ///
        -:  558:  /// In LLVM, the And and Or operators are idempotent.
        -:  559:  ///
        -:  560:  bool isIdempotent() const { return isIdempotent(getOpcode()); }
        -:  561:  static bool isIdempotent(unsigned Opcode) {
        -:  562:    return Opcode == And || Opcode == Or;
        -:  563:  }
        -:  564:
        -:  565:  /// Return true if the instruction is nilpotent:
        -:  566:  ///
        -:  567:  ///   Nilpotent operators satisfy:  x op x === Id,
        -:  568:  ///
        -:  569:  ///   where Id is the identity for the operator, i.e. a constant such that
        -:  570:  ///     x op Id === x and Id op x === x for all x.
        -:  571:  ///
        -:  572:  /// In LLVM, the Xor operator is nilpotent.
        -:  573:  ///
        -:  574:  bool isNilpotent() const { return isNilpotent(getOpcode()); }
        -:  575:  static bool isNilpotent(unsigned Opcode) {
        -:  576:    return Opcode == Xor;
        -:  577:  }
        -:  578:
        -:  579:  /// Return true if this instruction may modify memory.
        -:  580:  bool mayWriteToMemory() const LLVM_READONLY;
        -:  581:
        -:  582:  /// Return true if this instruction may read memory.
        -:  583:  bool mayReadFromMemory() const LLVM_READONLY;
        -:  584:
        -:  585:  /// Return true if this instruction may read or write memory.
        -:  586:  bool mayReadOrWriteMemory() const {
        -:  587:    return mayReadFromMemory() || mayWriteToMemory();
        -:  588:  }
        -:  589:
        -:  590:  /// Return true if this instruction has an AtomicOrdering of unordered or
        -:  591:  /// higher.
        -:  592:  bool isAtomic() const LLVM_READONLY;
        -:  593:
        -:  594:  /// Return true if this atomic instruction loads from memory.
        -:  595:  bool hasAtomicLoad() const LLVM_READONLY;
        -:  596:
        -:  597:  /// Return true if this atomic instruction stores to memory.
        -:  598:  bool hasAtomicStore() const LLVM_READONLY;
        -:  599:
        -:  600:  /// Return true if this instruction has a volatile memory access.
        -:  601:  bool isVolatile() const LLVM_READONLY;
        -:  602:
        -:  603:  /// Return true if this instruction may throw an exception.
        -:  604:  bool mayThrow() const LLVM_READONLY;
        -:  605:
        -:  606:  /// Return true if this instruction behaves like a memory fence: it can load
        -:  607:  /// or store to memory location without being given a memory location.
        -:  608:  bool isFenceLike() const {
        -:  609:    switch (getOpcode()) {
        -:  610:    default:
        -:  611:      return false;
        -:  612:    // This list should be kept in sync with the list in mayWriteToMemory for
        -:  613:    // all opcodes which don't have a memory location.
        -:  614:    case Instruction::Fence:
        -:  615:    case Instruction::CatchPad:
        -:  616:    case Instruction::CatchRet:
        -:  617:    case Instruction::Call:
        -:  618:    case Instruction::Invoke:
        -:  619:      return true;
        -:  620:    }
        -:  621:  }
        -:  622:
        -:  623:  /// Return true if the instruction may have side effects.
        -:  624:  ///
        -:  625:  /// Side effects are:
        -:  626:  ///  * Writing to memory.
        -:  627:  ///  * Unwinding.
        -:  628:  ///  * Not returning (e.g. an infinite loop).
        -:  629:  ///
        -:  630:  /// Note that this does not consider malloc and alloca to have side
        -:  631:  /// effects because the newly allocated memory is completely invisible to
        -:  632:  /// instructions which don't use the returned value.  For cases where this
        -:  633:  /// matters, isSafeToSpeculativelyExecute may be more appropriate.
        -:  634:  bool mayHaveSideEffects() const LLVM_READONLY;
        -:  635:
        -:  636:  /// Return true if the instruction can be removed if the result is unused.
        -:  637:  ///
        -:  638:  /// When constant folding some instructions cannot be removed even if their
        -:  639:  /// results are unused. Specifically terminator instructions and calls that
        -:  640:  /// may have side effects cannot be removed without semantically changing the
        -:  641:  /// generated program.
        -:  642:  bool isSafeToRemove() const LLVM_READONLY;
        -:  643:
        -:  644:  /// Return true if the instruction will return (unwinding is considered as
        -:  645:  /// a form of returning control flow here).
        -:  646:  bool willReturn() const LLVM_READONLY;
        -:  647:
        -:  648:  /// Return true if the instruction is a variety of EH-block.
        -:  649:  bool isEHPad() const {
        -:  650:    switch (getOpcode()) {
        -:  651:    case Instruction::CatchSwitch:
        -:  652:    case Instruction::CatchPad:
        -:  653:    case Instruction::CleanupPad:
        -:  654:    case Instruction::LandingPad:
        -:  655:      return true;
        -:  656:    default:
        -:  657:      return false;
        -:  658:    }
        -:  659:  }
        -:  660:
        -:  661:  /// Return true if the instruction is a llvm.lifetime.start or
        -:  662:  /// llvm.lifetime.end marker.
        -:  663:  bool isLifetimeStartOrEnd() const LLVM_READONLY;
        -:  664:
        -:  665:  /// Return true if the instruction is a llvm.launder.invariant.group or
        -:  666:  /// llvm.strip.invariant.group.
        -:  667:  bool isLaunderOrStripInvariantGroup() const LLVM_READONLY;
        -:  668:
        -:  669:  /// Return true if the instruction is a DbgInfoIntrinsic or PseudoProbeInst.
        -:  670:  bool isDebugOrPseudoInst() const LLVM_READONLY;
        -:  671:
        -:  672:  /// Return a pointer to the next non-debug instruction in the same basic
        -:  673:  /// block as 'this', or nullptr if no such instruction exists. Skip any pseudo
        -:  674:  /// operations if \c SkipPseudoOp is true.
        -:  675:  const Instruction *
        -:  676:  getNextNonDebugInstruction(bool SkipPseudoOp = false) const;
        -:  677:  Instruction *getNextNonDebugInstruction(bool SkipPseudoOp = false) {
        -:  678:    return const_cast<Instruction *>(
        -:  679:        static_cast<const Instruction *>(this)->getNextNonDebugInstruction(
        -:  680:            SkipPseudoOp));
        -:  681:  }
        -:  682:
        -:  683:  /// Return a pointer to the previous non-debug instruction in the same basic
        -:  684:  /// block as 'this', or nullptr if no such instruction exists. Skip any pseudo
        -:  685:  /// operations if \c SkipPseudoOp is true.
        -:  686:  const Instruction *
        -:  687:  getPrevNonDebugInstruction(bool SkipPseudoOp = false) const;
        -:  688:  Instruction *getPrevNonDebugInstruction(bool SkipPseudoOp = false) {
        -:  689:    return const_cast<Instruction *>(
        -:  690:        static_cast<const Instruction *>(this)->getPrevNonDebugInstruction(
        -:  691:            SkipPseudoOp));
        -:  692:  }
        -:  693:
        -:  694:  /// Create a copy of 'this' instruction that is identical in all ways except
        -:  695:  /// the following:
        -:  696:  ///   * The instruction has no parent
        -:  697:  ///   * The instruction has no name
        -:  698:  ///
        -:  699:  Instruction *clone() const;
        -:  700:
        -:  701:  /// Return true if the specified instruction is exactly identical to the
        -:  702:  /// current one. This means that all operands match and any extra information
        -:  703:  /// (e.g. load is volatile) agree.
        -:  704:  bool isIdenticalTo(const Instruction *I) const LLVM_READONLY;
        -:  705:
        -:  706:  /// This is like isIdenticalTo, except that it ignores the
        -:  707:  /// SubclassOptionalData flags, which may specify conditions under which the
        -:  708:  /// instruction's result is undefined.
        -:  709:  bool isIdenticalToWhenDefined(const Instruction *I) const LLVM_READONLY;
        -:  710:
        -:  711:  /// When checking for operation equivalence (using isSameOperationAs) it is
        -:  712:  /// sometimes useful to ignore certain attributes.
        -:  713:  enum OperationEquivalenceFlags {
        -:  714:    /// Check for equivalence ignoring load/store alignment.
        -:  715:    CompareIgnoringAlignment = 1<<0,
        -:  716:    /// Check for equivalence treating a type and a vector of that type
        -:  717:    /// as equivalent.
        -:  718:    CompareUsingScalarTypes = 1<<1
        -:  719:  };
        -:  720:
        -:  721:  /// This function determines if the specified instruction executes the same
        -:  722:  /// operation as the current one. This means that the opcodes, type, operand
        -:  723:  /// types and any other factors affecting the operation must be the same. This
        -:  724:  /// is similar to isIdenticalTo except the operands themselves don't have to
        -:  725:  /// be identical.
        -:  726:  /// @returns true if the specified instruction is the same operation as
        -:  727:  /// the current one.
        -:  728:  /// Determine if one instruction is the same operation as another.
        -:  729:  bool isSameOperationAs(const Instruction *I, unsigned flags = 0) const LLVM_READONLY;
        -:  730:
        -:  731:  /// Return true if there are any uses of this instruction in blocks other than
        -:  732:  /// the specified block. Note that PHI nodes are considered to evaluate their
        -:  733:  /// operands in the corresponding predecessor block.
        -:  734:  bool isUsedOutsideOfBlock(const BasicBlock *BB) const LLVM_READONLY;
        -:  735:
        -:  736:  /// Return the number of successors that this instruction has. The instruction
        -:  737:  /// must be a terminator.
        -:  738:  unsigned getNumSuccessors() const LLVM_READONLY;
        -:  739:
        -:  740:  /// Return the specified successor. This instruction must be a terminator.
        -:  741:  BasicBlock *getSuccessor(unsigned Idx) const LLVM_READONLY;
        -:  742:
        -:  743:  /// Update the specified successor to point at the provided block. This
        -:  744:  /// instruction must be a terminator.
        -:  745:  void setSuccessor(unsigned Idx, BasicBlock *BB);
        -:  746:
        -:  747:  /// Replace specified successor OldBB to point at the provided block.
        -:  748:  /// This instruction must be a terminator.
        -:  749:  void replaceSuccessorWith(BasicBlock *OldBB, BasicBlock *NewBB);
        -:  750:
        -:  751:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  752:  static bool classof(const Value *V) {
        -:  753:    return V->getValueID() >= Value::InstructionVal;
        -:  754:  }
        -:  755:
        -:  756:  //----------------------------------------------------------------------
        -:  757:  // Exported enumerations.
        -:  758:  //
        -:  759:  enum TermOps {       // These terminate basic blocks
        -:  760:#define  FIRST_TERM_INST(N)             TermOpsBegin = N,
        -:  761:#define HANDLE_TERM_INST(N, OPC, CLASS) OPC = N,
        -:  762:#define   LAST_TERM_INST(N)             TermOpsEnd = N+1
        -:  763:#include "llvm/IR/Instruction.def"
        -:  764:  };
        -:  765:
        -:  766:  enum UnaryOps {
        -:  767:#define  FIRST_UNARY_INST(N)             UnaryOpsBegin = N,
        -:  768:#define HANDLE_UNARY_INST(N, OPC, CLASS) OPC = N,
        -:  769:#define   LAST_UNARY_INST(N)             UnaryOpsEnd = N+1
        -:  770:#include "llvm/IR/Instruction.def"
        -:  771:  };
        -:  772:
        -:  773:  enum BinaryOps {
        -:  774:#define  FIRST_BINARY_INST(N)             BinaryOpsBegin = N,
        -:  775:#define HANDLE_BINARY_INST(N, OPC, CLASS) OPC = N,
        -:  776:#define   LAST_BINARY_INST(N)             BinaryOpsEnd = N+1
        -:  777:#include "llvm/IR/Instruction.def"
        -:  778:  };
        -:  779:
        -:  780:  enum MemoryOps {
        -:  781:#define  FIRST_MEMORY_INST(N)             MemoryOpsBegin = N,
        -:  782:#define HANDLE_MEMORY_INST(N, OPC, CLASS) OPC = N,
        -:  783:#define   LAST_MEMORY_INST(N)             MemoryOpsEnd = N+1
        -:  784:#include "llvm/IR/Instruction.def"
        -:  785:  };
        -:  786:
        -:  787:  enum CastOps {
        -:  788:#define  FIRST_CAST_INST(N)             CastOpsBegin = N,
        -:  789:#define HANDLE_CAST_INST(N, OPC, CLASS) OPC = N,
        -:  790:#define   LAST_CAST_INST(N)             CastOpsEnd = N+1
        -:  791:#include "llvm/IR/Instruction.def"
        -:  792:  };
        -:  793:
        -:  794:  enum FuncletPadOps {
        -:  795:#define  FIRST_FUNCLETPAD_INST(N)             FuncletPadOpsBegin = N,
        -:  796:#define HANDLE_FUNCLETPAD_INST(N, OPC, CLASS) OPC = N,
        -:  797:#define   LAST_FUNCLETPAD_INST(N)             FuncletPadOpsEnd = N+1
        -:  798:#include "llvm/IR/Instruction.def"
        -:  799:  };
        -:  800:
        -:  801:  enum OtherOps {
        -:  802:#define  FIRST_OTHER_INST(N)             OtherOpsBegin = N,
        -:  803:#define HANDLE_OTHER_INST(N, OPC, CLASS) OPC = N,
        -:  804:#define   LAST_OTHER_INST(N)             OtherOpsEnd = N+1
        -:  805:#include "llvm/IR/Instruction.def"
        -:  806:  };
        -:  807:
        -:  808:private:
        -:  809:  friend class SymbolTableListTraits<Instruction>;
        -:  810:  friend class BasicBlock; // For renumbering.
        -:  811:
        -:  812:  // Shadow Value::setValueSubclassData with a private forwarding method so that
        -:  813:  // subclasses cannot accidentally use it.
    #####:  814:  void setValueSubclassData(unsigned short D) {
    #####:  815:    Value::setValueSubclassData(D);
        -:  816:  }
        -:  817:
    #####:  818:  unsigned short getSubclassDataFromValue() const {
    #####:  819:    return Value::getSubclassDataFromValue();
        -:  820:  }
        -:  821:
        -:  822:  void setParent(BasicBlock *P);
        -:  823:
        -:  824:protected:
        -:  825:  // Instruction subclasses can stick up to 15 bits of stuff into the
        -:  826:  // SubclassData field of instruction with these members.
        -:  827:
        -:  828:  template <typename BitfieldElement>
    #####:  829:  typename BitfieldElement::Type getSubclassData() const {
branch  0 never executed
branch  1 never executed
        -:  830:    static_assert(
        -:  831:        std::is_same<BitfieldElement, HasMetadataField>::value ||
        -:  832:            !Bitfield::isOverlapping<BitfieldElement, HasMetadataField>(),
        -:  833:        "Must not overlap with the metadata bit");
    #####:  834:    return Bitfield::get<BitfieldElement>(getSubclassDataFromValue());
branch  0 never executed
branch  1 never executed
        -:  835:  }
        -:  836:
        -:  837:  template <typename BitfieldElement>
    #####:  838:  void setSubclassData(typename BitfieldElement::Type Value) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  839:    static_assert(
        -:  840:        std::is_same<BitfieldElement, HasMetadataField>::value ||
        -:  841:            !Bitfield::isOverlapping<BitfieldElement, HasMetadataField>(),
        -:  842:        "Must not overlap with the metadata bit");
    #####:  843:    auto Storage = getSubclassDataFromValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  844:    Bitfield::set<BitfieldElement>(Storage, Value);
call    0 never executed
    #####:  845:    setValueSubclassData(Storage);
call    0 never executed
        -:  846:  }
        -:  847:
        -:  848:  Instruction(Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
        -:  849:              Instruction *InsertBefore = nullptr);
        -:  850:  Instruction(Type *Ty, unsigned iType, Use *Ops, unsigned NumOps,
        -:  851:              BasicBlock *InsertAtEnd);
        -:  852:
        -:  853:private:
        -:  854:  /// Create a copy of this instruction.
        -:  855:  Instruction *cloneImpl() const;
        -:  856:};
        -:  857:
        -:  858:inline void ilist_alloc_traits<Instruction>::deleteNode(Instruction *V) {
        -:  859:  V->deleteValue();
        -:  860:}
        -:  861:
        -:  862:} // end namespace llvm
        -:  863:
        -:  864:#endif // LLVM_IR_INSTRUCTION_H
