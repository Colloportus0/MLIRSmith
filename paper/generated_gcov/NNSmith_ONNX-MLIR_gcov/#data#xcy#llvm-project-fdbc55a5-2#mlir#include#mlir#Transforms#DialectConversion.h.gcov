        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/Transforms/DialectConversion.h
        -:    0:Graph:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/DialectConversion.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/DialectConversion.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- DialectConversion.h - MLIR dialect conversion pass -------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file declares a generic pass for converting between MLIR dialects.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef MLIR_TRANSFORMS_DIALECTCONVERSION_H_
        -:   14:#define MLIR_TRANSFORMS_DIALECTCONVERSION_H_
        -:   15:
        -:   16:#include "mlir/Rewrite/FrozenRewritePatternSet.h"
        -:   17:#include "llvm/ADT/MapVector.h"
        -:   18:#include "llvm/ADT/StringMap.h"
        -:   19:#include <type_traits>
        -:   20:
        -:   21:namespace mlir {
        -:   22:
        -:   23:// Forward declarations.
        -:   24:class Block;
        -:   25:class ConversionPatternRewriter;
        -:   26:class MLIRContext;
        -:   27:class Operation;
        -:   28:class Type;
        -:   29:class Value;
        -:   30:
        -:   31://===----------------------------------------------------------------------===//
        -:   32:// Type Conversion
        -:   33://===----------------------------------------------------------------------===//
        -:   34:
        -:   35:/// Type conversion class. Specific conversions and materializations can be
        -:   36:/// registered using addConversion and addMaterialization, respectively.
        -:   37:class TypeConverter {
        -:   38:public:
        -:   39:  /// This class provides all of the information necessary to convert a type
        -:   40:  /// signature.
        -:   41:  class SignatureConversion {
        -:   42:  public:
    #####:   43:    SignatureConversion(unsigned numOrigInputs)
    #####:   44:        : remappedInputs(numOrigInputs) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   45:
        -:   46:    /// This struct represents a range of new types or a single value that
        -:   47:    /// remaps an existing signature input.
        -:   48:    struct InputMapping {
        -:   49:      size_t inputNo, size;
        -:   50:      Value replacementValue;
        -:   51:    };
        -:   52:
        -:   53:    /// Return the argument types for the new signature.
    #####:   54:    ArrayRef<Type> getConvertedTypes() const { return argTypes; }
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   55:
        -:   56:    /// Get the input mapping for the given argument.
function _ZNK4mlir13TypeConverter19SignatureConversion15getInputMappingEj called 0 returned 0% blocks executed 0%
    #####:   57:    Optional<InputMapping> getInputMapping(unsigned input) const {
    #####:   58:      return remappedInputs[input];
branch  0 never executed
branch  1 never executed
        -:   59:    }
        -:   60:
        -:   61:    //===------------------------------------------------------------------===//
        -:   62:    // Conversion Hooks
        -:   63:    //===------------------------------------------------------------------===//
        -:   64:
        -:   65:    /// Remap an input of the original signature with a new set of types. The
        -:   66:    /// new types are appended to the new signature conversion.
        -:   67:    void addInputs(unsigned origInputNo, ArrayRef<Type> types);
        -:   68:
        -:   69:    /// Append new input types to the signature conversion, this should only be
        -:   70:    /// used if the new types are not intended to remap an existing input.
        -:   71:    void addInputs(ArrayRef<Type> types);
        -:   72:
        -:   73:    /// Remap an input of the original signature to another `replacement`
        -:   74:    /// value. This drops the original argument.
        -:   75:    void remapInput(unsigned origInputNo, Value replacement);
        -:   76:
        -:   77:  private:
        -:   78:    /// Remap an input of the original signature with a range of types in the
        -:   79:    /// new signature.
        -:   80:    void remapInput(unsigned origInputNo, unsigned newInputNo,
        -:   81:                    unsigned newInputCount = 1);
        -:   82:
        -:   83:    /// The remapping information for each of the original arguments.
        -:   84:    SmallVector<Optional<InputMapping>, 4> remappedInputs;
        -:   85:
        -:   86:    /// The set of new argument types.
        -:   87:    SmallVector<Type, 4> argTypes;
        -:   88:  };
        -:   89:
        -:   90:  /// Register a conversion function. A conversion function must be convertible
        -:   91:  /// to any of the following forms(where `T` is a class derived from `Type`:
        -:   92:  ///   * Optional<Type>(T)
        -:   93:  ///     - This form represents a 1-1 type conversion. It should return nullptr
        -:   94:  ///       or `llvm::None` to signify failure. If `llvm::None` is returned, the
        -:   95:  ///       converter is allowed to try another conversion function to perform
        -:   96:  ///       the conversion.
        -:   97:  ///   * Optional<LogicalResult>(T, SmallVectorImpl<Type> &)
        -:   98:  ///     - This form represents a 1-N type conversion. It should return
        -:   99:  ///       `failure` or `llvm::None` to signify a failed conversion. If the new
        -:  100:  ///       set of types is empty, the type is removed and any usages of the
        -:  101:  ///       existing value are expected to be removed during conversion. If
        -:  102:  ///       `llvm::None` is returned, the converter is allowed to try another
        -:  103:  ///       conversion function to perform the conversion.
        -:  104:  ///   * Optional<LogicalResult>(T, SmallVectorImpl<Type> &, ArrayRef<Type>)
        -:  105:  ///     - This form represents a 1-N type conversion supporting recursive
        -:  106:  ///       types. The first two arguments and the return value are the same as
        -:  107:  ///       for the regular 1-N form. The third argument is contains is the
        -:  108:  ///       "call stack" of the recursive conversion: it contains the list of
        -:  109:  ///       types currently being converted, with the current type being the
        -:  110:  ///       last one. If it is present more than once in the list, the
        -:  111:  ///       conversion concerns a recursive type.
        -:  112:  /// Note: When attempting to convert a type, e.g. via 'convertType', the
        -:  113:  ///       mostly recently added conversions will be invoked first.
        -:  114:  template <typename FnT, typename T = typename llvm::function_traits<
        -:  115:                              std::decay_t<FnT>>::template arg_t<0>>
        -:  116:  void addConversion(FnT &&callback) {
        -:  117:    registerConversion(wrapCallback<T>(std::forward<FnT>(callback)));
        -:  118:  }
        -:  119:
        -:  120:  /// Register a materialization function, which must be convertible to the
        -:  121:  /// following form:
        -:  122:  ///   `Optional<Value>(OpBuilder &, T, ValueRange, Location)`,
        -:  123:  /// where `T` is any subclass of `Type`. This function is responsible for
        -:  124:  /// creating an operation, using the OpBuilder and Location provided, that
        -:  125:  /// "casts" a range of values into a single value of the given type `T`. It
        -:  126:  /// must return a Value of the converted type on success, an `llvm::None` if
        -:  127:  /// it failed but other materialization can be attempted, and `nullptr` on
        -:  128:  /// unrecoverable failure. It will only be called for (sub)types of `T`.
        -:  129:  /// Materialization functions must be provided when a type conversion may
        -:  130:  /// persist after the conversion has finished.
        -:  131:  ///
        -:  132:  /// This method registers a materialization that will be called when
        -:  133:  /// converting an illegal block argument type, to a legal type.
        -:  134:  template <typename FnT, typename T = typename llvm::function_traits<
        -:  135:                              std::decay_t<FnT>>::template arg_t<1>>
        -:  136:  void addArgumentMaterialization(FnT &&callback) {
        -:  137:    argumentMaterializations.emplace_back(
        -:  138:        wrapMaterialization<T>(std::forward<FnT>(callback)));
        -:  139:  }
        -:  140:  /// This method registers a materialization that will be called when
        -:  141:  /// converting a legal type to an illegal source type. This is used when
        -:  142:  /// conversions to an illegal type must persist beyond the main conversion.
        -:  143:  template <typename FnT, typename T = typename llvm::function_traits<
        -:  144:                              std::decay_t<FnT>>::template arg_t<1>>
        -:  145:  void addSourceMaterialization(FnT &&callback) {
        -:  146:    sourceMaterializations.emplace_back(
        -:  147:        wrapMaterialization<T>(std::forward<FnT>(callback)));
        -:  148:  }
        -:  149:  /// This method registers a materialization that will be called when
        -:  150:  /// converting type from an illegal, or source, type to a legal type.
        -:  151:  template <typename FnT, typename T = typename llvm::function_traits<
        -:  152:                              std::decay_t<FnT>>::template arg_t<1>>
        -:  153:  void addTargetMaterialization(FnT &&callback) {
        -:  154:    targetMaterializations.emplace_back(
        -:  155:        wrapMaterialization<T>(std::forward<FnT>(callback)));
        -:  156:  }
        -:  157:
        -:  158:  /// Convert the given type. This function should return failure if no valid
        -:  159:  /// conversion exists, success otherwise. If the new set of types is empty,
        -:  160:  /// the type is removed and any usages of the existing value are expected to
        -:  161:  /// be removed during conversion.
        -:  162:  LogicalResult convertType(Type t, SmallVectorImpl<Type> &results);
        -:  163:
        -:  164:  /// This hook simplifies defining 1-1 type conversions. This function returns
        -:  165:  /// the type to convert to on success, and a null type on failure.
        -:  166:  Type convertType(Type t);
        -:  167:
        -:  168:  /// Convert the given set of types, filling 'results' as necessary. This
        -:  169:  /// returns failure if the conversion of any of the types fails, success
        -:  170:  /// otherwise.
        -:  171:  LogicalResult convertTypes(TypeRange types, SmallVectorImpl<Type> &results);
        -:  172:
        -:  173:  /// Return true if the given type is legal for this type converter, i.e. the
        -:  174:  /// type converts to itself.
        -:  175:  bool isLegal(Type type);
        -:  176:  /// Return true if all of the given types are legal for this type converter.
        -:  177:  template <typename RangeT>
        -:  178:  std::enable_if_t<!std::is_convertible<RangeT, Type>::value &&
        -:  179:                       !std::is_convertible<RangeT, Operation *>::value,
        -:  180:                   bool>
    #####:  181:  isLegal(RangeT &&range) {
    #####:  182:    return llvm::all_of(range, [this](Type type) { return isLegal(type); });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
branch 17 never executed
branch 18 never executed
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
        -:  183:  }
        -:  184:  /// Return true if the given operation has legal operand and result types.
        -:  185:  bool isLegal(Operation *op);
        -:  186:
        -:  187:  /// Return true if the types of block arguments within the region are legal.
        -:  188:  bool isLegal(Region *region);
        -:  189:
        -:  190:  /// Return true if the inputs and outputs of the given function type are
        -:  191:  /// legal.
        -:  192:  bool isSignatureLegal(FunctionType ty);
        -:  193:
        -:  194:  /// This method allows for converting a specific argument of a signature. It
        -:  195:  /// takes as inputs the original argument input number, type.
        -:  196:  /// On success, it populates 'result' with any new mappings.
        -:  197:  LogicalResult convertSignatureArg(unsigned inputNo, Type type,
        -:  198:                                    SignatureConversion &result);
        -:  199:  LogicalResult convertSignatureArgs(TypeRange types,
        -:  200:                                     SignatureConversion &result,
        -:  201:                                     unsigned origInputOffset = 0);
        -:  202:
        -:  203:  /// This function converts the type signature of the given block, by invoking
        -:  204:  /// 'convertSignatureArg' for each argument. This function should return a
        -:  205:  /// valid conversion for the signature on success, None otherwise.
        -:  206:  Optional<SignatureConversion> convertBlockSignature(Block *block);
        -:  207:
        -:  208:  /// Materialize a conversion from a set of types into one result type by
        -:  209:  /// generating a cast sequence of some kind. See the respective
        -:  210:  /// `add*Materialization` for more information on the context for these
        -:  211:  /// methods.
    #####:  212:  Value materializeArgumentConversion(OpBuilder &builder, Location loc,
        -:  213:                                      Type resultType, ValueRange inputs) {
    #####:  214:    return materializeConversion(argumentMaterializations, builder, loc,
    #####:  215:                                 resultType, inputs);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  216:  }
        -:  217:  Value materializeSourceConversion(OpBuilder &builder, Location loc,
        -:  218:                                    Type resultType, ValueRange inputs) {
        -:  219:    return materializeConversion(sourceMaterializations, builder, loc,
        -:  220:                                 resultType, inputs);
        -:  221:  }
    #####:  222:  Value materializeTargetConversion(OpBuilder &builder, Location loc,
        -:  223:                                    Type resultType, ValueRange inputs) {
    #####:  224:    return materializeConversion(targetMaterializations, builder, loc,
    #####:  225:                                 resultType, inputs);
call    0 never executed
        -:  226:  }
        -:  227:
        -:  228:private:
        -:  229:  /// The signature of the callback used to convert a type. If the new set of
        -:  230:  /// types is empty, the type is removed and any usages of the existing value
        -:  231:  /// are expected to be removed during conversion.
        -:  232:  using ConversionCallbackFn = std::function<Optional<LogicalResult>(
        -:  233:      Type, SmallVectorImpl<Type> &, ArrayRef<Type>)>;
        -:  234:
        -:  235:  /// The signature of the callback used to materialize a conversion.
        -:  236:  using MaterializationCallbackFn =
        -:  237:      std::function<Optional<Value>(OpBuilder &, Type, ValueRange, Location)>;
        -:  238:
        -:  239:  /// Attempt to materialize a conversion using one of the provided
        -:  240:  /// materialization functions.
        -:  241:  Value materializeConversion(
        -:  242:      MutableArrayRef<MaterializationCallbackFn> materializations,
        -:  243:      OpBuilder &builder, Location loc, Type resultType, ValueRange inputs);
        -:  244:
        -:  245:  /// Generate a wrapper for the given callback. This allows for accepting
        -:  246:  /// different callback forms, that all compose into a single version.
        -:  247:  /// With callback of form: `Optional<Type>(T)`
        -:  248:  template <typename T, typename FnT>
        -:  249:  std::enable_if_t<std::is_invocable_v<FnT, T>, ConversionCallbackFn>
        -:  250:  wrapCallback(FnT &&callback) {
        -:  251:    return wrapCallback<T>(
        -:  252:        [callback = std::forward<FnT>(callback)](
        -:  253:            T type, SmallVectorImpl<Type> &results, ArrayRef<Type>) {
        -:  254:          if (Optional<Type> resultOpt = callback(type)) {
        -:  255:            bool wasSuccess = static_cast<bool>(resultOpt.value());
        -:  256:            if (wasSuccess)
        -:  257:              results.push_back(resultOpt.value());
        -:  258:            return Optional<LogicalResult>(success(wasSuccess));
        -:  259:          }
        -:  260:          return Optional<LogicalResult>();
        -:  261:        });
        -:  262:  }
        -:  263:  /// With callback of form: `Optional<LogicalResult>(T, SmallVectorImpl<Type>
        -:  264:  /// &)`
        -:  265:  template <typename T, typename FnT>
        -:  266:  std::enable_if_t<std::is_invocable_v<FnT, T, SmallVectorImpl<Type> &>,
        -:  267:                   ConversionCallbackFn>
        -:  268:  wrapCallback(FnT &&callback) {
        -:  269:    return wrapCallback<T>(
        -:  270:        [callback = std::forward<FnT>(callback)](
        -:  271:            T type, SmallVectorImpl<Type> &results, ArrayRef<Type>) {
        -:  272:          return callback(type, results);
        -:  273:        });
        -:  274:  }
        -:  275:  /// With callback of form: `Optional<LogicalResult>(T, SmallVectorImpl<Type>
        -:  276:  /// &, ArrayRef<Type>)`.
        -:  277:  template <typename T, typename FnT>
        -:  278:  std::enable_if_t<
        -:  279:      std::is_invocable_v<FnT, T, SmallVectorImpl<Type> &, ArrayRef<Type>>,
        -:  280:      ConversionCallbackFn>
        -:  281:  wrapCallback(FnT &&callback) {
        -:  282:    return [callback = std::forward<FnT>(callback)](
        -:  283:               Type type, SmallVectorImpl<Type> &results,
        -:  284:               ArrayRef<Type> callStack) -> Optional<LogicalResult> {
        -:  285:      T derivedType = type.dyn_cast<T>();
        -:  286:      if (!derivedType)
        -:  287:        return llvm::None;
        -:  288:      return callback(derivedType, results, callStack);
        -:  289:    };
        -:  290:  }
        -:  291:
        -:  292:  /// Register a type conversion.
        -:  293:  void registerConversion(ConversionCallbackFn callback) {
        -:  294:    conversions.emplace_back(std::move(callback));
        -:  295:    cachedDirectConversions.clear();
        -:  296:    cachedMultiConversions.clear();
        -:  297:  }
        -:  298:
        -:  299:  /// Generate a wrapper for the given materialization callback. The callback
        -:  300:  /// may take any subclass of `Type` and the wrapper will check for the target
        -:  301:  /// type to be of the expected class before calling the callback.
        -:  302:  template <typename T, typename FnT>
        -:  303:  MaterializationCallbackFn wrapMaterialization(FnT &&callback) {
        -:  304:    return [callback = std::forward<FnT>(callback)](
        -:  305:               OpBuilder &builder, Type resultType, ValueRange inputs,
        -:  306:               Location loc) -> Optional<Value> {
        -:  307:      if (T derivedType = resultType.dyn_cast<T>())
        -:  308:        return callback(builder, derivedType, inputs, loc);
        -:  309:      return llvm::None;
        -:  310:    };
        -:  311:  }
        -:  312:
        -:  313:  /// The set of registered conversion functions.
        -:  314:  SmallVector<ConversionCallbackFn, 4> conversions;
        -:  315:
        -:  316:  /// The list of registered materialization functions.
        -:  317:  SmallVector<MaterializationCallbackFn, 2> argumentMaterializations;
        -:  318:  SmallVector<MaterializationCallbackFn, 2> sourceMaterializations;
        -:  319:  SmallVector<MaterializationCallbackFn, 2> targetMaterializations;
        -:  320:
        -:  321:  /// A set of cached conversions to avoid recomputing in the common case.
        -:  322:  /// Direct 1-1 conversions are the most common, so this cache stores the
        -:  323:  /// successful 1-1 conversions as well as all failed conversions.
        -:  324:  DenseMap<Type, Type> cachedDirectConversions;
        -:  325:  /// This cache stores the successful 1->N conversions, where N != 1.
        -:  326:  DenseMap<Type, SmallVector<Type, 2>> cachedMultiConversions;
        -:  327:
        -:  328:  /// Stores the types that are being converted in the case when convertType
        -:  329:  /// is being called recursively to convert nested types.
        -:  330:  SmallVector<Type, 2> conversionCallStack;
        -:  331:};
        -:  332:
        -:  333://===----------------------------------------------------------------------===//
        -:  334:// Conversion Patterns
        -:  335://===----------------------------------------------------------------------===//
        -:  336:
        -:  337:/// Base class for the conversion patterns. This pattern class enables type
        -:  338:/// conversions, and other uses specific to the conversion framework. As such,
        -:  339:/// patterns of this type can only be used with the 'apply*' methods below.
        -:  340:class ConversionPattern : public RewritePattern {
        -:  341:public:
        -:  342:  /// Hook for derived classes to implement rewriting. `op` is the (first)
        -:  343:  /// operation matched by the pattern, `operands` is a list of the rewritten
        -:  344:  /// operand values that are passed to `op`, `rewriter` can be used to emit the
        -:  345:  /// new operations. This function should not fail. If some specific cases of
        -:  346:  /// the operation are not supported, these cases should not be matched.
function _ZNK4mlir17ConversionPattern7rewriteEPNS_9OperationEN4llvm8ArrayRefINS_5ValueEEERNS_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  347:  virtual void rewrite(Operation *op, ArrayRef<Value> operands,
        -:  348:                       ConversionPatternRewriter &rewriter) const {
    #####:  349:    llvm_unreachable("unimplemented rewrite");
        -:  350:  }
        -:  351:
        -:  352:  /// Hook for derived classes to implement combined matching and rewriting.
        -:  353:  virtual LogicalResult
function _ZNK4mlir17ConversionPattern15matchAndRewriteEPNS_9OperationEN4llvm8ArrayRefINS_5ValueEEERNS_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  354:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  355:                  ConversionPatternRewriter &rewriter) const {
    #####:  356:    if (failed(match(op)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  357:      return failure();
    #####:  358:    rewrite(op, operands, rewriter);
call    0 never executed
    #####:  359:    return success();
        -:  360:  }
        -:  361:
        -:  362:  /// Attempt to match and rewrite the IR root at the specified operation.
        -:  363:  LogicalResult matchAndRewrite(Operation *op,
        -:  364:                                PatternRewriter &rewriter) const final;
        -:  365:
        -:  366:  /// Return the type converter held by this pattern, or nullptr if the pattern
        -:  367:  /// does not require type conversion.
    #####:  368:  TypeConverter *getTypeConverter() const { return typeConverter; }
call    0 never executed
        -:  369:
        -:  370:  template <typename ConverterTy>
        -:  371:  std::enable_if_t<std::is_base_of<TypeConverter, ConverterTy>::value,
        -:  372:                   ConverterTy *>
        -:  373:  getTypeConverter() const {
        -:  374:    return static_cast<ConverterTy *>(typeConverter);
        -:  375:  }
        -:  376:
        -:  377:protected:
        -:  378:  /// See `RewritePattern::RewritePattern` for information on the other
        -:  379:  /// available constructors.
        -:  380:  using RewritePattern::RewritePattern;
        -:  381:  /// Construct a conversion pattern with the given converter, and forward the
        -:  382:  /// remaining arguments to RewritePattern.
        -:  383:  template <typename... Args>
function _ZN4mlir17ConversionPatternC2IJRN4llvm9StringRefEiRPNS_11MLIRContextEEEERNS_13TypeConverterEDpOT_ called 4155 returned 100% blocks executed 100%
     4155:  384:  ConversionPattern(TypeConverter &typeConverter, Args &&...args)
     4155:  385:      : RewritePattern(std::forward<Args>(args)...),
call    0 returned 100%
call    1 returned 100%
     4155:  386:        typeConverter(&typeConverter) {}
call    0 returned 100%
call    1 returned 100%
        -:  387:
        -:  388:protected:
        -:  389:  /// An optional type converter for use by this pattern.
        -:  390:  TypeConverter *typeConverter = nullptr;
        -:  391:
        -:  392:private:
        -:  393:  using RewritePattern::rewrite;
        -:  394:};
        -:  395:
        -:  396:/// OpConversionPattern is a wrapper around ConversionPattern that allows for
        -:  397:/// matching and rewriting against an instance of a derived operation class as
        -:  398:/// opposed to a raw Operation.
        -:  399:template <typename SourceOp>
        -:  400:class OpConversionPattern : public ConversionPattern {
        -:  401:public:
        -:  402:  using OpAdaptor = typename SourceOp::Adaptor;
        -:  403:
        -:  404:  OpConversionPattern(MLIRContext *context, PatternBenefit benefit = 1)
        -:  405:      : ConversionPattern(SourceOp::getOperationName(), benefit, context) {}
        -:  406:  OpConversionPattern(TypeConverter &typeConverter, MLIRContext *context,
        -:  407:                      PatternBenefit benefit = 1)
        -:  408:      : ConversionPattern(typeConverter, SourceOp::getOperationName(), benefit,
        -:  409:                          context) {}
        -:  410:
        -:  411:  /// Wrappers around the ConversionPattern methods that pass the derived op
        -:  412:  /// type.
        -:  413:  LogicalResult match(Operation *op) const final {
        -:  414:    return match(cast<SourceOp>(op));
        -:  415:  }
        -:  416:  void rewrite(Operation *op, ArrayRef<Value> operands,
        -:  417:               ConversionPatternRewriter &rewriter) const final {
        -:  418:    rewrite(cast<SourceOp>(op), OpAdaptor(operands, op->getAttrDictionary()),
        -:  419:            rewriter);
        -:  420:  }
        -:  421:  LogicalResult
        -:  422:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  423:                  ConversionPatternRewriter &rewriter) const final {
        -:  424:    return matchAndRewrite(cast<SourceOp>(op),
        -:  425:                           OpAdaptor(operands, op->getAttrDictionary()),
        -:  426:                           rewriter);
        -:  427:  }
        -:  428:
        -:  429:  /// Rewrite and Match methods that operate on the SourceOp type. These must be
        -:  430:  /// overridden by the derived pattern class.
        -:  431:  virtual LogicalResult match(SourceOp op) const {
        -:  432:    llvm_unreachable("must override match or matchAndRewrite");
        -:  433:  }
        -:  434:  virtual void rewrite(SourceOp op, OpAdaptor adaptor,
        -:  435:                       ConversionPatternRewriter &rewriter) const {
        -:  436:    llvm_unreachable("must override matchAndRewrite or a rewrite method");
        -:  437:  }
        -:  438:  virtual LogicalResult
        -:  439:  matchAndRewrite(SourceOp op, OpAdaptor adaptor,
        -:  440:                  ConversionPatternRewriter &rewriter) const {
        -:  441:    if (failed(match(op)))
        -:  442:      return failure();
        -:  443:    rewrite(op, adaptor, rewriter);
        -:  444:    return success();
        -:  445:  }
        -:  446:
        -:  447:private:
        -:  448:  using ConversionPattern::matchAndRewrite;
        -:  449:};
        -:  450:
        -:  451:/// OpInterfaceConversionPattern is a wrapper around ConversionPattern that
        -:  452:/// allows for matching and rewriting against an instance of an OpInterface
        -:  453:/// class as opposed to a raw Operation.
        -:  454:template <typename SourceOp>
        -:  455:class OpInterfaceConversionPattern : public ConversionPattern {
        -:  456:public:
        -:  457:  OpInterfaceConversionPattern(MLIRContext *context, PatternBenefit benefit = 1)
        -:  458:      : ConversionPattern(Pattern::MatchInterfaceOpTypeTag(),
        -:  459:                          SourceOp::getInterfaceID(), benefit, context) {}
        -:  460:  OpInterfaceConversionPattern(TypeConverter &typeConverter,
        -:  461:                               MLIRContext *context, PatternBenefit benefit = 1)
        -:  462:      : ConversionPattern(typeConverter, Pattern::MatchInterfaceOpTypeTag(),
        -:  463:                          SourceOp::getInterfaceID(), benefit, context) {}
        -:  464:
        -:  465:  /// Wrappers around the ConversionPattern methods that pass the derived op
        -:  466:  /// type.
        -:  467:  void rewrite(Operation *op, ArrayRef<Value> operands,
        -:  468:               ConversionPatternRewriter &rewriter) const final {
        -:  469:    rewrite(cast<SourceOp>(op), operands, rewriter);
        -:  470:  }
        -:  471:  LogicalResult
        -:  472:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  473:                  ConversionPatternRewriter &rewriter) const final {
        -:  474:    return matchAndRewrite(cast<SourceOp>(op), operands, rewriter);
        -:  475:  }
        -:  476:
        -:  477:  /// Rewrite and Match methods that operate on the SourceOp type. These must be
        -:  478:  /// overridden by the derived pattern class.
        -:  479:  virtual void rewrite(SourceOp op, ArrayRef<Value> operands,
        -:  480:                       ConversionPatternRewriter &rewriter) const {
        -:  481:    llvm_unreachable("must override matchAndRewrite or a rewrite method");
        -:  482:  }
        -:  483:  virtual LogicalResult
        -:  484:  matchAndRewrite(SourceOp op, ArrayRef<Value> operands,
        -:  485:                  ConversionPatternRewriter &rewriter) const {
        -:  486:    if (failed(match(op)))
        -:  487:      return failure();
        -:  488:    rewrite(op, operands, rewriter);
        -:  489:    return success();
        -:  490:  }
        -:  491:
        -:  492:private:
        -:  493:  using ConversionPattern::matchAndRewrite;
        -:  494:};
        -:  495:
        -:  496:/// Add a pattern to the given pattern list to convert the signature of a
        -:  497:/// FunctionOpInterface op with the given type converter. This only supports
        -:  498:/// ops which use FunctionType to represent their type.
        -:  499:void populateFunctionOpInterfaceTypeConversionPattern(
        -:  500:    StringRef functionLikeOpName, RewritePatternSet &patterns,
        -:  501:    TypeConverter &converter);
        -:  502:
        -:  503:template <typename FuncOpT>
        -:  504:void populateFunctionOpInterfaceTypeConversionPattern(
        -:  505:    RewritePatternSet &patterns, TypeConverter &converter) {
        -:  506:  populateFunctionOpInterfaceTypeConversionPattern(FuncOpT::getOperationName(),
        -:  507:                                                   patterns, converter);
        -:  508:}
        -:  509:
        -:  510://===----------------------------------------------------------------------===//
        -:  511:// Conversion PatternRewriter
        -:  512://===----------------------------------------------------------------------===//
        -:  513:
        -:  514:namespace detail {
        -:  515:struct ConversionPatternRewriterImpl;
        -:  516:} // namespace detail
        -:  517:
        -:  518:/// This class implements a pattern rewriter for use with ConversionPatterns. It
        -:  519:/// extends the base PatternRewriter and provides special conversion specific
        -:  520:/// hooks.
   71452*:  521:class ConversionPatternRewriter final : public PatternRewriter {
------------------
_ZN4mlir25ConversionPatternRewriterD0Ev:
function _ZN4mlir25ConversionPatternRewriterD0Ev called 0 returned 0% blocks executed 0%
    #####:  521:class ConversionPatternRewriter final : public PatternRewriter {
call    0 never executed
call    1 never executed
------------------
_ZN4mlir25ConversionPatternRewriterD2Ev:
function _ZN4mlir25ConversionPatternRewriterD2Ev called 35726 returned 100% blocks executed 100%
    71452:  521:class ConversionPatternRewriter final : public PatternRewriter {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
------------------
        -:  522:public:
        -:  523:  explicit ConversionPatternRewriter(MLIRContext *ctx);
        -:  524:  ~ConversionPatternRewriter() override;
        -:  525:
        -:  526:  /// Apply a signature conversion to the entry block of the given region. This
        -:  527:  /// replaces the entry block with a new block containing the updated
        -:  528:  /// signature. The new entry block to the region is returned for convenience.
        -:  529:  ///
        -:  530:  /// If provided, `converter` will be used for any materializations.
        -:  531:  Block *
        -:  532:  applySignatureConversion(Region *region,
        -:  533:                           TypeConverter::SignatureConversion &conversion,
        -:  534:                           TypeConverter *converter = nullptr);
        -:  535:
        -:  536:  /// Convert the types of block arguments within the given region. This
        -:  537:  /// replaces each block with a new block containing the updated signature. The
        -:  538:  /// entry block may have a special conversion if `entryConversion` is
        -:  539:  /// provided. On success, the new entry block to the region is returned for
        -:  540:  /// convenience. Otherwise, failure is returned.
        -:  541:  FailureOr<Block *> convertRegionTypes(
        -:  542:      Region *region, TypeConverter &converter,
        -:  543:      TypeConverter::SignatureConversion *entryConversion = nullptr);
        -:  544:
        -:  545:  /// Convert the types of block arguments within the given region except for
        -:  546:  /// the entry region. This replaces each non-entry block with a new block
        -:  547:  /// containing the updated signature.
        -:  548:  ///
        -:  549:  /// If special conversion behavior is needed for the non-entry blocks (for
        -:  550:  /// example, we need to convert only a subset of a BB arguments), such
        -:  551:  /// behavior can be specified in blockConversions.
        -:  552:  LogicalResult convertNonEntryRegionTypes(
        -:  553:      Region *region, TypeConverter &converter,
        -:  554:      ArrayRef<TypeConverter::SignatureConversion> blockConversions);
        -:  555:
        -:  556:  /// Replace all the uses of the block argument `from` with value `to`.
        -:  557:  void replaceUsesOfBlockArgument(BlockArgument from, Value to);
        -:  558:
        -:  559:  /// Return the converted value of 'key' with a type defined by the type
        -:  560:  /// converter of the currently executing pattern. Return nullptr in the case
        -:  561:  /// of failure, the remapped value otherwise.
        -:  562:  Value getRemappedValue(Value key);
        -:  563:
        -:  564:  /// Return the converted values that replace 'keys' with types defined by the
        -:  565:  /// type converter of the currently executing pattern. Returns failure if the
        -:  566:  /// remap failed, success otherwise.
        -:  567:  LogicalResult getRemappedValues(ValueRange keys,
        -:  568:                                  SmallVectorImpl<Value> &results);
        -:  569:
        -:  570:  //===--------------------------------------------------------------------===//
        -:  571:  // PatternRewriter Hooks
        -:  572:  //===--------------------------------------------------------------------===//
        -:  573:
        -:  574:  /// PatternRewriter hook for replacing the results of an operation when the
        -:  575:  /// given functor returns true.
        -:  576:  void replaceOpWithIf(
        -:  577:      Operation *op, ValueRange newValues, bool *allUsesReplaced,
        -:  578:      llvm::unique_function<bool(OpOperand &) const> functor) override;
        -:  579:
        -:  580:  /// PatternRewriter hook for replacing the results of an operation.
        -:  581:  void replaceOp(Operation *op, ValueRange newValues) override;
        -:  582:  using PatternRewriter::replaceOp;
        -:  583:
        -:  584:  /// PatternRewriter hook for erasing a dead operation. The uses of this
        -:  585:  /// operation *must* be made dead by the end of the conversion process,
        -:  586:  /// otherwise an assert will be issued.
        -:  587:  void eraseOp(Operation *op) override;
        -:  588:
        -:  589:  /// PatternRewriter hook for erase all operations in a block. This is not yet
        -:  590:  /// implemented for dialect conversion.
        -:  591:  void eraseBlock(Block *block) override;
        -:  592:
        -:  593:  /// PatternRewriter hook creating a new block.
        -:  594:  void notifyBlockCreated(Block *block) override;
        -:  595:
        -:  596:  /// PatternRewriter hook for splitting a block into two parts.
        -:  597:  Block *splitBlock(Block *block, Block::iterator before) override;
        -:  598:
        -:  599:  /// PatternRewriter hook for merging a block into another.
        -:  600:  void mergeBlocks(Block *source, Block *dest, ValueRange argValues) override;
        -:  601:
        -:  602:  /// PatternRewriter hook for moving blocks out of a region.
        -:  603:  void inlineRegionBefore(Region &region, Region &parent,
        -:  604:                          Region::iterator before) override;
        -:  605:  using PatternRewriter::inlineRegionBefore;
        -:  606:
        -:  607:  /// PatternRewriter hook for cloning blocks of one region into another. The
        -:  608:  /// given region to clone *must* not have been modified as part of conversion
        -:  609:  /// yet, i.e. it must be within an operation that is either in the process of
        -:  610:  /// conversion, or has not yet been converted.
        -:  611:  void cloneRegionBefore(Region &region, Region &parent,
        -:  612:                         Region::iterator before,
        -:  613:                         BlockAndValueMapping &mapping) override;
        -:  614:  using PatternRewriter::cloneRegionBefore;
        -:  615:
        -:  616:  /// PatternRewriter hook for inserting a new operation.
        -:  617:  void notifyOperationInserted(Operation *op) override;
        -:  618:
        -:  619:  /// PatternRewriter hook for updating the root operation in-place.
        -:  620:  /// Note: These methods only track updates to the top-level operation itself,
        -:  621:  /// and not nested regions. Updates to regions will still require notification
        -:  622:  /// through other more specific hooks above.
        -:  623:  void startRootUpdate(Operation *op) override;
        -:  624:
        -:  625:  /// PatternRewriter hook for updating the root operation in-place.
        -:  626:  void finalizeRootUpdate(Operation *op) override;
        -:  627:
        -:  628:  /// PatternRewriter hook for updating the root operation in-place.
        -:  629:  void cancelRootUpdate(Operation *op) override;
        -:  630:
        -:  631:  /// PatternRewriter hook for notifying match failure reasons.
        -:  632:  LogicalResult
        -:  633:  notifyMatchFailure(Location loc,
        -:  634:                     function_ref<void(Diagnostic &)> reasonCallback) override;
        -:  635:  using PatternRewriter::notifyMatchFailure;
        -:  636:
        -:  637:  /// Return a reference to the internal implementation.
        -:  638:  detail::ConversionPatternRewriterImpl &getImpl();
        -:  639:
        -:  640:private:
        -:  641:  std::unique_ptr<detail::ConversionPatternRewriterImpl> impl;
        -:  642:};
        -:  643:
        -:  644://===----------------------------------------------------------------------===//
        -:  645:// ConversionTarget
        -:  646://===----------------------------------------------------------------------===//
        -:  647:
        -:  648:/// This class describes a specific conversion target.
        -:  649:class ConversionTarget {
        -:  650:public:
        -:  651:  /// This enumeration corresponds to the specific action to take when
        -:  652:  /// considering an operation legal for this conversion target.
        -:  653:  enum class LegalizationAction {
        -:  654:    /// The target supports this operation.
        -:  655:    Legal,
        -:  656:
        -:  657:    /// This operation has dynamic legalization constraints that must be checked
        -:  658:    /// by the target.
        -:  659:    Dynamic,
        -:  660:
        -:  661:    /// The target explicitly does not support this operation.
        -:  662:    Illegal,
        -:  663:  };
        -:  664:
        -:  665:  /// A structure containing additional information describing a specific legal
        -:  666:  /// operation instance.
        -:  667:  struct LegalOpDetails {
        -:  668:    /// A flag that indicates if this operation is 'recursively' legal. This
        -:  669:    /// means that if an operation is legal, either statically or dynamically,
        -:  670:    /// all of the operations nested within are also considered legal.
        -:  671:    bool isRecursivelyLegal = false;
        -:  672:  };
        -:  673:
        -:  674:  /// The signature of the callback used to determine if an operation is
        -:  675:  /// dynamically legal on the target.
        -:  676:  using DynamicLegalityCallbackFn = std::function<Optional<bool>(Operation *)>;
        -:  677:
        -:  678:  ConversionTarget(MLIRContext &ctx) : ctx(ctx) {}
        -:  679:  virtual ~ConversionTarget() = default;
        -:  680:
        -:  681:  //===--------------------------------------------------------------------===//
        -:  682:  // Legality Registration
        -:  683:  //===--------------------------------------------------------------------===//
        -:  684:
        -:  685:  /// Register a legality action for the given operation.
        -:  686:  void setOpAction(OperationName op, LegalizationAction action);
        -:  687:  template <typename OpT>
        -:  688:  void setOpAction(LegalizationAction action) {
        -:  689:    setOpAction(OperationName(OpT::getOperationName(), &ctx), action);
        -:  690:  }
        -:  691:
        -:  692:  /// Register the given operations as legal.
        -:  693:  void addLegalOp(OperationName op) {
        -:  694:    setOpAction(op, LegalizationAction::Legal);
        -:  695:  }
        -:  696:  template <typename OpT>
        -:  697:  void addLegalOp() {
        -:  698:    addLegalOp(OperationName(OpT::getOperationName(), &ctx));
        -:  699:  }
        -:  700:  template <typename OpT, typename OpT2, typename... OpTs>
        -:  701:  void addLegalOp() {
        -:  702:    addLegalOp<OpT>();
        -:  703:    addLegalOp<OpT2, OpTs...>();
        -:  704:  }
        -:  705:
        -:  706:  /// Register the given operation as dynamically legal and set the dynamic
        -:  707:  /// legalization callback to the one provided.
        -:  708:  void addDynamicallyLegalOp(OperationName op,
        -:  709:                             const DynamicLegalityCallbackFn &callback) {
        -:  710:    setOpAction(op, LegalizationAction::Dynamic);
        -:  711:    setLegalityCallback(op, callback);
        -:  712:  }
        -:  713:  template <typename OpT>
        -:  714:  void addDynamicallyLegalOp(const DynamicLegalityCallbackFn &callback) {
        -:  715:    addDynamicallyLegalOp(OperationName(OpT::getOperationName(), &ctx),
        -:  716:                          callback);
        -:  717:  }
        -:  718:  template <typename OpT, typename OpT2, typename... OpTs>
        -:  719:  void addDynamicallyLegalOp(const DynamicLegalityCallbackFn &callback) {
        -:  720:    addDynamicallyLegalOp<OpT>(callback);
        -:  721:    addDynamicallyLegalOp<OpT2, OpTs...>(callback);
        -:  722:  }
        -:  723:  template <typename OpT, class Callable>
        -:  724:  std::enable_if_t<!std::is_invocable_v<Callable, Operation *>>
        -:  725:  addDynamicallyLegalOp(Callable &&callback) {
        -:  726:    addDynamicallyLegalOp<OpT>(
        -:  727:        [=](Operation *op) { return callback(cast<OpT>(op)); });
        -:  728:  }
        -:  729:
        -:  730:  /// Register the given operation as illegal, i.e. this operation is known to
        -:  731:  /// not be supported by this target.
        -:  732:  void addIllegalOp(OperationName op) {
        -:  733:    setOpAction(op, LegalizationAction::Illegal);
        -:  734:  }
        -:  735:  template <typename OpT>
        -:  736:  void addIllegalOp() {
        -:  737:    addIllegalOp(OperationName(OpT::getOperationName(), &ctx));
        -:  738:  }
        -:  739:  template <typename OpT, typename OpT2, typename... OpTs>
        -:  740:  void addIllegalOp() {
        -:  741:    addIllegalOp<OpT>();
        -:  742:    addIllegalOp<OpT2, OpTs...>();
        -:  743:  }
        -:  744:
        -:  745:  /// Mark an operation, that *must* have either been set as `Legal` or
        -:  746:  /// `DynamicallyLegal`, as being recursively legal. This means that in
        -:  747:  /// addition to the operation itself, all of the operations nested within are
        -:  748:  /// also considered legal. An optional dynamic legality callback may be
        -:  749:  /// provided to mark subsets of legal instances as recursively legal.
        -:  750:  void markOpRecursivelyLegal(OperationName name,
        -:  751:                              const DynamicLegalityCallbackFn &callback);
        -:  752:  template <typename OpT>
        -:  753:  void markOpRecursivelyLegal(const DynamicLegalityCallbackFn &callback = {}) {
        -:  754:    OperationName opName(OpT::getOperationName(), &ctx);
        -:  755:    markOpRecursivelyLegal(opName, callback);
        -:  756:  }
        -:  757:  template <typename OpT, typename OpT2, typename... OpTs>
        -:  758:  void markOpRecursivelyLegal(const DynamicLegalityCallbackFn &callback = {}) {
        -:  759:    markOpRecursivelyLegal<OpT>(callback);
        -:  760:    markOpRecursivelyLegal<OpT2, OpTs...>(callback);
        -:  761:  }
        -:  762:  template <typename OpT, class Callable>
        -:  763:  std::enable_if_t<!std::is_invocable_v<Callable, Operation *>>
        -:  764:  markOpRecursivelyLegal(Callable &&callback) {
        -:  765:    markOpRecursivelyLegal<OpT>(
        -:  766:        [=](Operation *op) { return callback(cast<OpT>(op)); });
        -:  767:  }
        -:  768:
        -:  769:  /// Register a legality action for the given dialects.
        -:  770:  void setDialectAction(ArrayRef<StringRef> dialectNames,
        -:  771:                        LegalizationAction action);
        -:  772:
        -:  773:  /// Register the operations of the given dialects as legal.
        -:  774:  template <typename... Names>
        -:  775:  void addLegalDialect(StringRef name, Names... names) {
        -:  776:    SmallVector<StringRef, 2> dialectNames({name, names...});
        -:  777:    setDialectAction(dialectNames, LegalizationAction::Legal);
        -:  778:  }
        -:  779:  template <typename... Args>
        -:  780:  void addLegalDialect() {
        -:  781:    SmallVector<StringRef, 2> dialectNames({Args::getDialectNamespace()...});
        -:  782:    setDialectAction(dialectNames, LegalizationAction::Legal);
        -:  783:  }
        -:  784:
        -:  785:  /// Register the operations of the given dialects as dynamically legal, i.e.
        -:  786:  /// requiring custom handling by the callback.
        -:  787:  template <typename... Names>
        -:  788:  void addDynamicallyLegalDialect(const DynamicLegalityCallbackFn &callback,
        -:  789:                                  StringRef name, Names... names) {
        -:  790:    SmallVector<StringRef, 2> dialectNames({name, names...});
        -:  791:    setDialectAction(dialectNames, LegalizationAction::Dynamic);
        -:  792:    setLegalityCallback(dialectNames, callback);
        -:  793:  }
        -:  794:  template <typename... Args>
        -:  795:  void addDynamicallyLegalDialect(DynamicLegalityCallbackFn callback) {
        -:  796:    addDynamicallyLegalDialect(std::move(callback),
        -:  797:                               Args::getDialectNamespace()...);
        -:  798:  }
        -:  799:
        -:  800:  /// Register unknown operations as dynamically legal. For operations(and
        -:  801:  /// dialects) that do not have a set legalization action, treat them as
        -:  802:  /// dynamically legal and invoke the given callback.
        -:  803:  void markUnknownOpDynamicallyLegal(const DynamicLegalityCallbackFn &fn) {
        -:  804:    setLegalityCallback(fn);
        -:  805:  }
        -:  806:
        -:  807:  /// Register the operations of the given dialects as illegal, i.e.
        -:  808:  /// operations of this dialect are not supported by the target.
        -:  809:  template <typename... Names>
        -:  810:  void addIllegalDialect(StringRef name, Names... names) {
        -:  811:    SmallVector<StringRef, 2> dialectNames({name, names...});
        -:  812:    setDialectAction(dialectNames, LegalizationAction::Illegal);
        -:  813:  }
        -:  814:  template <typename... Args>
        -:  815:  void addIllegalDialect() {
        -:  816:    SmallVector<StringRef, 2> dialectNames({Args::getDialectNamespace()...});
        -:  817:    setDialectAction(dialectNames, LegalizationAction::Illegal);
        -:  818:  }
        -:  819:
        -:  820:  //===--------------------------------------------------------------------===//
        -:  821:  // Legality Querying
        -:  822:  //===--------------------------------------------------------------------===//
        -:  823:
        -:  824:  /// Get the legality action for the given operation.
        -:  825:  Optional<LegalizationAction> getOpAction(OperationName op) const;
        -:  826:
        -:  827:  /// If the given operation instance is legal on this target, a structure
        -:  828:  /// containing legality information is returned. If the operation is not
        -:  829:  /// legal, None is returned. Also returns None is operation legality wasn't
        -:  830:  /// registered by user or dynamic legality callbacks returned None.
        -:  831:  ///
        -:  832:  /// Note: Legality is actually a 4-state: Legal(recursive=true),
        -:  833:  /// Legal(recursive=false), Illegal or Unknown, where Unknown is treated
        -:  834:  /// either as Legal or Illegal depending on context.
        -:  835:  Optional<LegalOpDetails> isLegal(Operation *op) const;
        -:  836:
        -:  837:  /// Returns true is operation instance is illegal on this target. Returns
        -:  838:  /// false if operation is legal, operation legality wasn't registered by user
        -:  839:  /// or dynamic legality callbacks returned None.
        -:  840:  bool isIllegal(Operation *op) const;
        -:  841:
        -:  842:private:
        -:  843:  /// Set the dynamic legality callback for the given operation.
        -:  844:  void setLegalityCallback(OperationName name,
        -:  845:                           const DynamicLegalityCallbackFn &callback);
        -:  846:
        -:  847:  /// Set the dynamic legality callback for the given dialects.
        -:  848:  void setLegalityCallback(ArrayRef<StringRef> dialects,
        -:  849:                           const DynamicLegalityCallbackFn &callback);
        -:  850:
        -:  851:  /// Set the dynamic legality callback for the unknown ops.
        -:  852:  void setLegalityCallback(const DynamicLegalityCallbackFn &callback);
        -:  853:
        -:  854:  /// The set of information that configures the legalization of an operation.
48279194*:  855:  struct LegalizationInfo {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 61% (fallthrough)
branch  6 taken 39%
branch  7 taken 1% (fallthrough)
branch  8 taken 100%
branch  9 never executed
branch 10 never executed
branch 11 taken 21% (fallthrough)
branch 12 taken 79%
branch 13 taken 27% (fallthrough)
branch 14 taken 73%
        -:  856:    /// The legality action this operation was given.
        -:  857:    LegalizationAction action = LegalizationAction::Illegal;
        -:  858:
        -:  859:    /// If some legal instances of this operation may also be recursively legal.
        -:  860:    bool isRecursivelyLegal = false;
        -:  861:
        -:  862:    /// The legality callback if this operation is dynamically legal.
        -:  863:    DynamicLegalityCallbackFn legalityFn;
        -:  864:  };
        -:  865:
        -:  866:  /// Get the legalization information for the given operation.
        -:  867:  Optional<LegalizationInfo> getOpInfo(OperationName op) const;
        -:  868:
        -:  869:  /// A deterministic mapping of operation name and its respective legality
        -:  870:  /// information.
        -:  871:  llvm::MapVector<OperationName, LegalizationInfo> legalOperations;
        -:  872:
        -:  873:  /// A set of legality callbacks for given operation names that are used to
        -:  874:  /// check if an operation instance is recursively legal.
        -:  875:  DenseMap<OperationName, DynamicLegalityCallbackFn> opRecursiveLegalityFns;
        -:  876:
        -:  877:  /// A deterministic mapping of dialect name to the specific legality action to
        -:  878:  /// take.
        -:  879:  llvm::StringMap<LegalizationAction> legalDialects;
        -:  880:
        -:  881:  /// A set of dynamic legality callbacks for given dialect names.
        -:  882:  llvm::StringMap<DynamicLegalityCallbackFn> dialectLegalityFns;
        -:  883:
        -:  884:  /// An optional legality callback for unknown operations.
        -:  885:  DynamicLegalityCallbackFn unknownLegalityFn;
        -:  886:
        -:  887:  /// The current context this target applies to.
        -:  888:  MLIRContext &ctx;
        -:  889:};
        -:  890:
        -:  891://===----------------------------------------------------------------------===//
        -:  892:// Op Conversion Entry Points
        -:  893://===----------------------------------------------------------------------===//
        -:  894:
        -:  895:/// Below we define several entry points for operation conversion. It is
        -:  896:/// important to note that the patterns provided to the conversion framework may
        -:  897:/// have additional constraints. See the `PatternRewriter Hooks` section of the
        -:  898:/// ConversionPatternRewriter, to see what additional constraints are imposed on
        -:  899:/// the use of the PatternRewriter.
        -:  900:
        -:  901:/// Apply a partial conversion on the given operations and all nested
        -:  902:/// operations. This method converts as many operations to the target as
        -:  903:/// possible, ignoring operations that failed to legalize. This method only
        -:  904:/// returns failure if there ops explicitly marked as illegal. If an
        -:  905:/// `unconvertedOps` set is provided, all operations that are found not to be
        -:  906:/// legalizable to the given `target` are placed within that set. (Note that if
        -:  907:/// there is an op explicitly marked as illegal, the conversion terminates and
        -:  908:/// the `unconvertedOps` set will not necessarily be complete.)
        -:  909:LogicalResult
        -:  910:applyPartialConversion(ArrayRef<Operation *> ops, ConversionTarget &target,
        -:  911:                       const FrozenRewritePatternSet &patterns,
        -:  912:                       DenseSet<Operation *> *unconvertedOps = nullptr);
        -:  913:LogicalResult
        -:  914:applyPartialConversion(Operation *op, ConversionTarget &target,
        -:  915:                       const FrozenRewritePatternSet &patterns,
        -:  916:                       DenseSet<Operation *> *unconvertedOps = nullptr);
        -:  917:
        -:  918:/// Apply a complete conversion on the given operations, and all nested
        -:  919:/// operations. This method returns failure if the conversion of any operation
        -:  920:/// fails, or if there are unreachable blocks in any of the regions nested
        -:  921:/// within 'ops'.
        -:  922:LogicalResult applyFullConversion(ArrayRef<Operation *> ops,
        -:  923:                                  ConversionTarget &target,
        -:  924:                                  const FrozenRewritePatternSet &patterns);
        -:  925:LogicalResult applyFullConversion(Operation *op, ConversionTarget &target,
        -:  926:                                  const FrozenRewritePatternSet &patterns);
        -:  927:
        -:  928:/// Apply an analysis conversion on the given operations, and all nested
        -:  929:/// operations. This method analyzes which operations would be successfully
        -:  930:/// converted to the target if a conversion was applied. All operations that
        -:  931:/// were found to be legalizable to the given 'target' are placed within the
        -:  932:/// provided 'convertedOps' set; note that no actual rewrites are applied to the
        -:  933:/// operations on success and only pre-existing operations are added to the set.
        -:  934:/// This method only returns failure if there are unreachable blocks in any of
        -:  935:/// the regions nested within 'ops'. There's an additional argument
        -:  936:/// `notifyCallback` which is used for collecting match failure diagnostics
        -:  937:/// generated during the conversion. Diagnostics are only reported to this
        -:  938:/// callback may only be available in debug mode.
        -:  939:LogicalResult applyAnalysisConversion(
        -:  940:    ArrayRef<Operation *> ops, ConversionTarget &target,
        -:  941:    const FrozenRewritePatternSet &patterns,
        -:  942:    DenseSet<Operation *> &convertedOps,
        -:  943:    function_ref<void(Diagnostic &)> notifyCallback = nullptr);
        -:  944:LogicalResult applyAnalysisConversion(
        -:  945:    Operation *op, ConversionTarget &target,
        -:  946:    const FrozenRewritePatternSet &patterns,
        -:  947:    DenseSet<Operation *> &convertedOps,
        -:  948:    function_ref<void(Diagnostic &)> notifyCallback = nullptr);
        -:  949:} // namespace mlir
        -:  950:
        -:  951:#endif // MLIR_TRANSFORMS_DIALECTCONVERSION_H_
