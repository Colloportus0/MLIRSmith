        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/PDLToPDLInterp/PredicateTree.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/PDLToPDLInterp/CMakeFiles/obj.MLIRPDLToPDLInterp.dir/PredicateTree.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/PDLToPDLInterp/CMakeFiles/obj.MLIRPDLToPDLInterp.dir/PredicateTree.cpp.gcda
        -:    0:Runs:128636
        -:    1://===- PredicateTree.cpp - Predicate tree merging -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "PredicateTree.h"
        -:   10:#include "RootOrdering.h"
        -:   11:
        -:   12:#include "mlir/Dialect/PDL/IR/PDL.h"
        -:   13:#include "mlir/Dialect/PDL/IR/PDLTypes.h"
        -:   14:#include "mlir/Dialect/PDLInterp/IR/PDLInterp.h"
        -:   15:#include "mlir/IR/BuiltinOps.h"
        -:   16:#include "mlir/Interfaces/InferTypeOpInterface.h"
        -:   17:#include "llvm/ADT/MapVector.h"
        -:   18:#include "llvm/ADT/TypeSwitch.h"
        -:   19:#include "llvm/Support/Debug.h"
        -:   20:#include <queue>
        -:   21:
        -:   22:#define DEBUG_TYPE "pdl-predicate-tree"
        -:   23:
        -:   24:using namespace mlir;
        -:   25:using namespace mlir::pdl_to_pdl_interp;
        -:   26:
        -:   27://===----------------------------------------------------------------------===//
        -:   28:// Predicate List Building
        -:   29://===----------------------------------------------------------------------===//
        -:   30:
        -:   31:static void getTreePredicates(std::vector<PositionalPredicate> &predList,
        -:   32:                              Value val, PredicateBuilder &builder,
        -:   33:                              DenseMap<Value, Position *> &inputs,
        -:   34:                              Position *pos);
        -:   35:
        -:   36:/// Compares the depths of two positions.
function _ZL15comparePosDepthPN4mlir17pdl_to_pdl_interp8PositionES2_ called 0 returned 0% blocks executed 0%
    #####:   37:static bool comparePosDepth(Position *lhs, Position *rhs) {
    #####:   38:  return lhs->getOperationDepth() < rhs->getOperationDepth();
call    0 never executed
call    1 never executed
        -:   39:}
        -:   40:
        -:   41:/// Returns the number of non-range elements within `values`.
function _ZL20getNumNonRangeValuesN4mlir10ValueRangeE called 2048 returned 100% blocks executed 100%
     2048:   42:static unsigned getNumNonRangeValues(ValueRange values) {
     2048:   43:  return llvm::count_if(values.getTypes(),
call    0 returned 100%
call    1 returned 100%
     2048:   44:                        [](Type type) { return !type.isa<pdl::RangeType>(); });
        -:   45:}
        -:   46:
function _ZL17getTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEEPNS1_17AttributePositionE called 0 returned 0% blocks executed 0%
    #####:   47:static void getTreePredicates(std::vector<PositionalPredicate> &predList,
        -:   48:                              Value val, PredicateBuilder &builder,
        -:   49:                              DenseMap<Value, Position *> &inputs,
        -:   50:                              AttributePosition *pos) {
    #####:   51:  assert(val.getType().isa<pdl::AttributeType>() && "expected attribute type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   52:  pdl::AttributeOp attr = cast<pdl::AttributeOp>(val.getDefiningOp());
call    0 never executed
call    1 never executed
    #####:   53:  predList.emplace_back(pos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   54:
        -:   55:  // If the attribute has a type or value, add a constraint.
    #####:   56:  if (Value type = attr.getValueType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   57:    getTreePredicates(predList, type, builder, inputs, builder.getType(pos));
call    0 never executed
call    1 never executed
    #####:   58:  else if (Attribute value = attr.getValueAttr())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   59:    predList.emplace_back(pos, builder.getAttributeConstraint(value));
call    0 never executed
call    1 never executed
    #####:   60:}
        -:   61:
        -:   62:/// Collect all of the predicates for the given operand position.
function _ZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ called 1024 returned 100% blocks executed 100%
     1024:   63:static void getOperandTreePredicates(std::vector<PositionalPredicate> &predList,
        -:   64:                                     Value val, PredicateBuilder &builder,
        -:   65:                                     DenseMap<Value, Position *> &inputs,
        -:   66:                                     Position *pos) {
     1024:   67:  Type valueType = val.getType();
call    0 returned 100%
     1024:   68:  bool isVariadic = valueType.isa<pdl::RangeType>();
call    0 returned 100%
        -:   69:
        -:   70:  // If this is a typed operand, add a type constraint.
     1024:   71:  TypeSwitch<Operation *>(val.getDefiningOp())
call    0 returned 100%
call    1 returned 100%
    1024*:   72:      .Case<pdl::OperandOp, pdl::OperandsOp>([&](auto op) {
        -:   73:        // Prevent traversal into a null value if the operand has a proper
        -:   74:        // index.
     1024:   75:        if (std::is_same<pdl::OperandOp, decltype(op)>::value ||
    1024*:   76:            cast<OperandGroupPosition>(pos)->getOperandGroupNumber())
    #####:   77:          predList.emplace_back(pos, builder.getIsNotNull());
        -:   78:
    1024*:   79:        if (Value type = op.getValueType())
    #####:   80:          getTreePredicates(predList, type, builder, inputs,
        -:   81:                            builder.getType(pos));
    2048*:   82:      })
call    0 returned 100%
------------------
_ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E_clINS0_3pdl10OperandsOpEEEDaSK_:
function _ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E_clINS0_3pdl10OperandsOpEEEDaSK_ called 1024 returned 100% blocks executed 50%
     1024:   72:      .Case<pdl::OperandOp, pdl::OperandsOp>([&](auto op) {
        -:   73:        // Prevent traversal into a null value if the operand has a proper
        -:   74:        // index.
     1024:   75:        if (std::is_same<pdl::OperandOp, decltype(op)>::value ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    1024*:   76:            cast<OperandGroupPosition>(pos)->getOperandGroupNumber())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   77:          predList.emplace_back(pos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   78:
     1024:   79:        if (Value type = op.getValueType())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   80:          getTreePredicates(predList, type, builder, inputs,
call    0 never executed
call    1 never executed
        -:   81:                            builder.getType(pos));
     1024:   82:      })
------------------
_ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E_clINS0_3pdl9OperandOpEEEDaSK_:
function _ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E_clINS0_3pdl9OperandOpEEEDaSK_ called 0 returned 0% blocks executed 0%
    #####:   72:      .Case<pdl::OperandOp, pdl::OperandsOp>([&](auto op) {
        -:   73:        // Prevent traversal into a null value if the operand has a proper
        -:   74:        // index.
        -:   75:        if (std::is_same<pdl::OperandOp, decltype(op)>::value ||
    #####:   76:            cast<OperandGroupPosition>(pos)->getOperandGroupNumber())
    #####:   77:          predList.emplace_back(pos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   78:
    #####:   79:        if (Value type = op.getValueType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   80:          getTreePredicates(predList, type, builder, inputs,
call    0 never executed
call    1 never executed
        -:   81:                            builder.getType(pos));
    #####:   82:      })
------------------
    #####:   83:      .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto op) {
    #####:   84:        Optional<unsigned> index = op.getIndex();
        -:   85:
        -:   86:        // Prevent traversal into a null value if the result has a proper index.
    #####:   87:        if (index)
    #####:   88:          predList.emplace_back(pos, builder.getIsNotNull());
        -:   89:
        -:   90:        // Get the parent operation of this operand.
    #####:   91:        OperationPosition *parentPos = builder.getOperandDefiningOp(pos);
    #####:   92:        predList.emplace_back(parentPos, builder.getIsNotNull());
        -:   93:
        -:   94:        // Ensure that the operands match the corresponding results of the
        -:   95:        // parent operation.
    #####:   96:        Position *resultPos = nullptr;
        -:   97:        if (std::is_same<pdl::ResultOp, decltype(op)>::value)
    #####:   98:          resultPos = builder.getResult(parentPos, *index);
        -:   99:        else
    #####:  100:          resultPos = builder.getResultGroup(parentPos, index, isVariadic);
    #####:  101:        predList.emplace_back(resultPos, builder.getEqualTo(pos));
        -:  102:
        -:  103:        // Collect the predicates of the parent operation.
    #####:  104:        getTreePredicates(predList, op.getParent(), builder, inputs,
        -:  105:                          (Position *)parentPos);
    1024*:  106:      });
call    0 returned 100%
------------------
_ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E0_clINS0_3pdl9ResultsOpEEEDaSK_:
function _ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E0_clINS0_3pdl9ResultsOpEEEDaSK_ called 0 returned 0% blocks executed 0%
    #####:   83:      .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto op) {
    #####:   84:        Optional<unsigned> index = op.getIndex();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   85:
        -:   86:        // Prevent traversal into a null value if the result has a proper index.
    #####:   87:        if (index)
branch  0 never executed
branch  1 never executed
    #####:   88:          predList.emplace_back(pos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   89:
        -:   90:        // Get the parent operation of this operand.
    #####:   91:        OperationPosition *parentPos = builder.getOperandDefiningOp(pos);
call    0 never executed
    #####:   92:        predList.emplace_back(parentPos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   93:
        -:   94:        // Ensure that the operands match the corresponding results of the
        -:   95:        // parent operation.
    #####:   96:        Position *resultPos = nullptr;
        -:   97:        if (std::is_same<pdl::ResultOp, decltype(op)>::value)
        -:   98:          resultPos = builder.getResult(parentPos, *index);
        -:   99:        else
    #####:  100:          resultPos = builder.getResultGroup(parentPos, index, isVariadic);
call    0 never executed
    #####:  101:        predList.emplace_back(resultPos, builder.getEqualTo(pos));
call    0 never executed
call    1 never executed
        -:  102:
        -:  103:        // Collect the predicates of the parent operation.
    #####:  104:        getTreePredicates(predList, op.getParent(), builder, inputs,
call    0 never executed
call    1 never executed
        -:  105:                          (Position *)parentPos);
    #####:  106:      });
------------------
_ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E0_clINS0_3pdl8ResultOpEEEDaSK_:
function _ZZL24getOperandTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlT_E0_clINS0_3pdl8ResultOpEEEDaSK_ called 0 returned 0% blocks executed 0%
    #####:   83:      .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto op) {
    #####:   84:        Optional<unsigned> index = op.getIndex();
call    0 never executed
call    1 never executed
        -:   85:
        -:   86:        // Prevent traversal into a null value if the result has a proper index.
    #####:   87:        if (index)
    #####:   88:          predList.emplace_back(pos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   89:
        -:   90:        // Get the parent operation of this operand.
    #####:   91:        OperationPosition *parentPos = builder.getOperandDefiningOp(pos);
call    0 never executed
    #####:   92:        predList.emplace_back(parentPos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:   93:
        -:   94:        // Ensure that the operands match the corresponding results of the
        -:   95:        // parent operation.
    #####:   96:        Position *resultPos = nullptr;
call    0 never executed
        -:   97:        if (std::is_same<pdl::ResultOp, decltype(op)>::value)
    #####:   98:          resultPos = builder.getResult(parentPos, *index);
call    0 never executed
        -:   99:        else
        -:  100:          resultPos = builder.getResultGroup(parentPos, index, isVariadic);
    #####:  101:        predList.emplace_back(resultPos, builder.getEqualTo(pos));
call    0 never executed
call    1 never executed
        -:  102:
        -:  103:        // Collect the predicates of the parent operation.
    #####:  104:        getTreePredicates(predList, op.getParent(), builder, inputs,
call    0 never executed
call    1 never executed
        -:  105:                          (Position *)parentPos);
    #####:  106:      });
------------------
     1024:  107:}
        -:  108:
        -:  109:static void getTreePredicates(std::vector<PositionalPredicate> &predList,
        -:  110:                              Value val, PredicateBuilder &builder,
        -:  111:                              DenseMap<Value, Position *> &inputs,
        -:  112:                              OperationPosition *pos,
        -:  113:                              Optional<unsigned> ignoreOperand = llvm::None) {
        -:  114:  assert(val.getType().isa<pdl::OperationType>() && "expected operation");
        -:  115:  pdl::OperationOp op = cast<pdl::OperationOp>(val.getDefiningOp());
        -:  116:  OperationPosition *opPos = cast<OperationPosition>(pos);
        -:  117:
        -:  118:  // Ensure getDefiningOp returns a non-null operation.
        -:  119:  if (!opPos->isRoot())
        -:  120:    predList.emplace_back(pos, builder.getIsNotNull());
        -:  121:
        -:  122:  // Check that this is the correct root operation.
        -:  123:  if (Optional<StringRef> opName = op.getOpName())
        -:  124:    predList.emplace_back(pos, builder.getOperationName(*opName));
        -:  125:
        -:  126:  // Check that the operation has the proper number of operands. If there are
        -:  127:  // any variable length operands, we check a minimum instead of an exact count.
        -:  128:  OperandRange operands = op.getOperandValues();
        -:  129:  unsigned minOperands = getNumNonRangeValues(operands);
        -:  130:  if (minOperands != operands.size()) {
        -:  131:    if (minOperands)
        -:  132:      predList.emplace_back(pos, builder.getOperandCountAtLeast(minOperands));
        -:  133:  } else {
        -:  134:    predList.emplace_back(pos, builder.getOperandCount(minOperands));
        -:  135:  }
        -:  136:
        -:  137:  // Check that the operation has the proper number of results. If there are
        -:  138:  // any variable length results, we check a minimum instead of an exact count.
        -:  139:  OperandRange types = op.getTypeValues();
        -:  140:  unsigned minResults = getNumNonRangeValues(types);
        -:  141:  if (minResults == types.size())
        -:  142:    predList.emplace_back(pos, builder.getResultCount(types.size()));
        -:  143:  else if (minResults)
        -:  144:    predList.emplace_back(pos, builder.getResultCountAtLeast(minResults));
        -:  145:
        -:  146:  // Recurse into any attributes, operands, or results.
        -:  147:  for (auto [attrName, attr] :
        -:  148:       llvm::zip(op.getAttributeValueNames(), op.getAttributeValues())) {
        -:  149:    getTreePredicates(
        -:  150:        predList, attr, builder, inputs,
        -:  151:        builder.getAttribute(opPos, attrName.cast<StringAttr>().getValue()));
        -:  152:  }
        -:  153:
        -:  154:  // Process the operands and results of the operation. For all values up to
        -:  155:  // the first variable length value, we use the concrete operand/result
        -:  156:  // number. After that, we use the "group" given that we can't know the
        -:  157:  // concrete indices until runtime. If there is only one variadic operand
        -:  158:  // group, we treat it as all of the operands/results of the operation.
        -:  159:  /// Operands.
        -:  160:  if (operands.size() == 1 && operands[0].getType().isa<pdl::RangeType>()) {
        -:  161:    // Ignore the operands if we are performing an upward traversal (in that
        -:  162:    // case, they have already been visited).
        -:  163:    if (opPos->isRoot() || opPos->isOperandDefiningOp())
        -:  164:      getTreePredicates(predList, operands.front(), builder, inputs,
        -:  165:                        builder.getAllOperands(opPos));
        -:  166:  } else {
        -:  167:    bool foundVariableLength = false;
        -:  168:    for (const auto &operandIt : llvm::enumerate(operands)) {
        -:  169:      bool isVariadic = operandIt.value().getType().isa<pdl::RangeType>();
        -:  170:      foundVariableLength |= isVariadic;
        -:  171:
        -:  172:      // Ignore the specified operand, usually because this position was
        -:  173:      // visited in an upward traversal via an iterative choice.
        -:  174:      if (ignoreOperand && *ignoreOperand == operandIt.index())
        -:  175:        continue;
        -:  176:
        -:  177:      Position *pos =
        -:  178:          foundVariableLength
        -:  179:              ? builder.getOperandGroup(opPos, operandIt.index(), isVariadic)
        -:  180:              : builder.getOperand(opPos, operandIt.index());
        -:  181:      getTreePredicates(predList, operandIt.value(), builder, inputs, pos);
        -:  182:    }
        -:  183:  }
        -:  184:  /// Results.
        -:  185:  if (types.size() == 1 && types[0].getType().isa<pdl::RangeType>()) {
        -:  186:    getTreePredicates(predList, types.front(), builder, inputs,
        -:  187:                      builder.getType(builder.getAllResults(opPos)));
        -:  188:  } else {
        -:  189:    bool foundVariableLength = false;
        -:  190:    for (auto &resultIt : llvm::enumerate(types)) {
        -:  191:      bool isVariadic = resultIt.value().getType().isa<pdl::RangeType>();
        -:  192:      foundVariableLength |= isVariadic;
        -:  193:
        -:  194:      auto *resultPos =
        -:  195:          foundVariableLength
        -:  196:              ? builder.getResultGroup(pos, resultIt.index(), isVariadic)
        -:  197:              : builder.getResult(pos, resultIt.index());
        -:  198:      predList.emplace_back(resultPos, builder.getIsNotNull());
        -:  199:      getTreePredicates(predList, resultIt.value(), builder, inputs,
        -:  200:                        builder.getType(resultPos));
        -:  201:    }
        -:  202:  }
        -:  203:}
        -:  204:
        -:  205:static void getTreePredicates(std::vector<PositionalPredicate> &predList,
        -:  206:                              Value val, PredicateBuilder &builder,
        -:  207:                              DenseMap<Value, Position *> &inputs,
        -:  208:                              TypePosition *pos) {
        -:  209:  // Check for a constraint on a constant type.
        -:  210:  if (pdl::TypeOp typeOp = val.getDefiningOp<pdl::TypeOp>()) {
        -:  211:    if (Attribute type = typeOp.getConstantTypeAttr())
        -:  212:      predList.emplace_back(pos, builder.getTypeConstraint(type));
        -:  213:  } else if (pdl::TypesOp typeOp = val.getDefiningOp<pdl::TypesOp>()) {
        -:  214:    if (Attribute typeAttr = typeOp.getConstantTypesAttr())
        -:  215:      predList.emplace_back(pos, builder.getTypeConstraint(typeAttr));
        -:  216:  }
        -:  217:}
        -:  218:
        -:  219:/// Collect the tree predicates anchored at the given value.
function _ZL17getTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ called 3072 returned 100% blocks executed 45%
     3072:  220:static void getTreePredicates(std::vector<PositionalPredicate> &predList,
        -:  221:                              Value val, PredicateBuilder &builder,
        -:  222:                              DenseMap<Value, Position *> &inputs,
        -:  223:                              Position *pos) {
        -:  224:  // Make sure this input value is accessible to the rewrite.
     3072:  225:  auto it = inputs.try_emplace(val, pos);
call    0 returned 100%
     3072:  226:  if (!it.second) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  227:    // If this is an input value that has been visited in the tree, add a
        -:  228:    // constraint to ensure that both instances refer to the same value.
    #####:  229:    if (isa<pdl::AttributeOp, pdl::OperandOp, pdl::OperandsOp, pdl::OperationOp,
    #####:  230:            pdl::TypeOp>(val.getDefiningOp())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  231:      auto minMaxPositions =
    #####:  232:          std::minmax(pos, it.first->second, comparePosDepth);
call    0 never executed
call    1 never executed
    #####:  233:      predList.emplace_back(minMaxPositions.second,
    #####:  234:                            builder.getEqualTo(minMaxPositions.first));
call    0 never executed
call    1 never executed
        -:  235:    }
    #####:  236:    return;
        -:  237:  }
        -:  238:
     3072:  239:  TypeSwitch<Position *>(pos)
call    0 returned 100%
function _ZZL17getTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlPT_E_clINS1_17OperationPositionEEEDaSL_ called 1024 returned 100% blocks executed 100%
    1024*:  240:      .Case<AttributePosition, OperationPosition, TypePosition>([&](auto *pos) {
call    0 returned 100%
    2048*:  241:        getTreePredicates(predList, val, builder, inputs, pos);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
     3072:  242:      })
call    0 returned 100%
    1024*:  243:      .Case<OperandPosition, OperandGroupPosition>([&](auto *pos) {
    1024*:  244:        getOperandTreePredicates(predList, val, builder, inputs, pos);
call    0 returned 100%
call    1 never executed
     6144:  245:      })
call    0 returned 100%
function _ZZL17getTreePredicatesRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EENS0_5ValueERNS1_16PredicateBuilderERN4llvm8DenseMapIS6_PNS1_8PositionENS9_12DenseMapInfoIS6_vEENS9_6detail12DenseMapPairIS6_SC_EEEESC_ENKUlPT_E1_clISB_EEDaSL_.isra.0 called 0 returned 0% blocks executed 0%
    3072*:  246:      .Default([](auto *) { llvm_unreachable("unexpected position kind"); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  247:}
        -:  248:
        -:  249:static void getAttributePredicates(pdl::AttributeOp op,
        -:  250:                                   std::vector<PositionalPredicate> &predList,
        -:  251:                                   PredicateBuilder &builder,
        -:  252:                                   DenseMap<Value, Position *> &inputs) {
        -:  253:  Position *&attrPos = inputs[op];
        -:  254:  if (attrPos)
        -:  255:    return;
        -:  256:  Attribute value = op.getValueAttr();
        -:  257:  assert(value && "expected non-tree `pdl.attribute` to contain a value");
        -:  258:  attrPos = builder.getAttributeLiteral(value);
        -:  259:}
        -:  260:
function _ZL23getConstraintPredicatesN4mlir3pdl23ApplyNativeConstraintOpERSt6vectorINS_17pdl_to_pdl_interp19PositionalPredicateESaIS4_EERNS3_16PredicateBuilderERN4llvm8DenseMapINS_5ValueEPNS3_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEE called 512 returned 100% blocks executed 82%
      512:  261:static void getConstraintPredicates(pdl::ApplyNativeConstraintOp op,
        -:  262:                                    std::vector<PositionalPredicate> &predList,
        -:  263:                                    PredicateBuilder &builder,
        -:  264:                                    DenseMap<Value, Position *> &inputs) {
      512:  265:  OperandRange arguments = op.getArgs();
call    0 returned 100%
        -:  266:
      512:  267:  std::vector<Position *> allPositions;
call    0 returned 100%
      512:  268:  allPositions.reserve(arguments.size());
call    0 returned 100%
     1024:  269:  for (Value arg : arguments)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
     1024:  270:    allPositions.push_back(inputs.lookup(arg));
call    0 returned 100%
call    1 returned 100%
        -:  271:
        -:  272:  // Push the constraint to the furthest position.
      512:  273:  Position *pos = *std::max_element(allPositions.begin(), allPositions.end(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1024:  274:                                    comparePosDepth);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
      512:  275:  PredicateBuilder::Predicate pred =
call    0 returned 100%
      512:  276:      builder.getConstraint(op.getName(), allPositions);
call    0 returned 100%
call    1 returned 100%
      512:  277:  predList.emplace_back(pos, pred);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      512:  278:}
        -:  279:
function _ZL19getResultPredicatesN4mlir3pdl8ResultOpERSt6vectorINS_17pdl_to_pdl_interp19PositionalPredicateESaIS4_EERNS3_16PredicateBuilderERN4llvm8DenseMapINS_5ValueEPNS3_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEE called 0 returned 0% blocks executed 0%
    #####:  280:static void getResultPredicates(pdl::ResultOp op,
        -:  281:                                std::vector<PositionalPredicate> &predList,
        -:  282:                                PredicateBuilder &builder,
        -:  283:                                DenseMap<Value, Position *> &inputs) {
    #####:  284:  Position *&resultPos = inputs[op];
call    0 never executed
    #####:  285:  if (resultPos)
branch  0 never executed
branch  1 never executed
        -:  286:    return;
        -:  287:
        -:  288:  // Ensure that the result isn't null.
    #####:  289:  auto *parentPos = cast<OperationPosition>(inputs.lookup(op.getParent()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  290:  resultPos = builder.getResult(parentPos, op.getIndex());
call    0 never executed
call    1 never executed
    #####:  291:  predList.emplace_back(resultPos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:  292:}
        -:  293:
function _ZL19getResultPredicatesN4mlir3pdl9ResultsOpERSt6vectorINS_17pdl_to_pdl_interp19PositionalPredicateESaIS4_EERNS3_16PredicateBuilderERN4llvm8DenseMapINS_5ValueEPNS3_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEE called 0 returned 0% blocks executed 0%
    #####:  294:static void getResultPredicates(pdl::ResultsOp op,
        -:  295:                                std::vector<PositionalPredicate> &predList,
        -:  296:                                PredicateBuilder &builder,
        -:  297:                                DenseMap<Value, Position *> &inputs) {
    #####:  298:  Position *&resultPos = inputs[op];
call    0 never executed
    #####:  299:  if (resultPos)
branch  0 never executed
branch  1 never executed
    #####:  300:    return;
        -:  301:
        -:  302:  // Ensure that the result isn't null if the result has an index.
    #####:  303:  auto *parentPos = cast<OperationPosition>(inputs.lookup(op.getParent()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  304:  bool isVariadic = op.getType().isa<pdl::RangeType>();
call    0 never executed
call    1 never executed
    #####:  305:  Optional<unsigned> index = op.getIndex();
call    0 never executed
    #####:  306:  resultPos = builder.getResultGroup(parentPos, index, isVariadic);
call    0 never executed
    #####:  307:  if (index)
branch  0 never executed
branch  1 never executed
    #####:  308:    predList.emplace_back(resultPos, builder.getIsNotNull());
call    0 never executed
call    1 never executed
        -:  309:}
        -:  310:
function _ZL17getTypePredicatesN4mlir5ValueEN4llvm12function_refIFNS_9AttributeEvEEERNS_17pdl_to_pdl_interp16PredicateBuilderERNS1_8DenseMapIS0_PNS6_8PositionENS1_12DenseMapInfoIS0_vEENS1_6detail12DenseMapPairIS0_SB_EEEE called 1024 returned 100% blocks executed 38%
     1024:  311:static void getTypePredicates(Value typeValue,
        -:  312:                              function_ref<Attribute()> typeAttrFn,
        -:  313:                              PredicateBuilder &builder,
        -:  314:                              DenseMap<Value, Position *> &inputs) {
     1024:  315:  Position *&typePos = inputs[typeValue];
call    0 returned 100%
     1024:  316:  if (typePos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1024:  317:    return;
    #####:  318:  Attribute typeAttr = typeAttrFn();
call    0 never executed
    #####:  319:  assert(typeAttr &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  320:         "expected non-tree `pdl.type`/`pdl.types` to contain a value");
    #####:  321:  typePos = builder.getTypeLiteral(typeAttr);
call    0 never executed
        -:  322:}
        -:  323:
        -:  324:/// Collect all of the predicates that cannot be determined via walking the
        -:  325:/// tree.
function _ZL20getNonTreePredicatesN4mlir3pdl9PatternOpERSt6vectorINS_17pdl_to_pdl_interp19PositionalPredicateESaIS4_EERNS3_16PredicateBuilderERN4llvm8DenseMapINS_5ValueEPNS3_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEE called 1024 returned 100% blocks executed 100%
     1024:  326:static void getNonTreePredicates(pdl::PatternOp pattern,
        -:  327:                                 std::vector<PositionalPredicate> &predList,
        -:  328:                                 PredicateBuilder &builder,
        -:  329:                                 DenseMap<Value, Position *> &inputs) {
     5632:  330:  for (Operation &op : pattern.getBodyRegion().getOps()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
     4608:  331:    TypeSwitch<Operation *>(&op)
call    0 returned 100%
    #####:  332:        .Case([&](pdl::AttributeOp attrOp) {
    #####:  333:          getAttributePredicates(attrOp, predList, builder, inputs);
call    0 never executed
     4608:  334:        })
call    0 returned 100%
      512:  335:        .Case<pdl::ApplyNativeConstraintOp>([&](auto constraintOp) {
      512:  336:          getConstraintPredicates(constraintOp, predList, builder, inputs);
call    0 returned 100%
     4608:  337:        })
call    0 returned 100%
    #####:  338:        .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto resultOp) {
    #####:  339:          getResultPredicates(resultOp, predList, builder, inputs);
call    0 never executed
call    1 never executed
     4608:  340:        })
call    0 returned 100%
    #####:  341:        .Case([&](pdl::TypeOp typeOp) {
    #####:  342:          getTypePredicates(
call    0 never executed
    #####:  343:              typeOp, [&] { return typeOp.getConstantTypeAttr(); }, builder,
call    0 never executed
        -:  344:              inputs);
     4608:  345:        })
call    0 returned 100%
     1024:  346:        .Case([&](pdl::TypesOp typeOp) {
     1024:  347:          getTypePredicates(
call    0 returned 100%
    #####:  348:              typeOp, [&] { return typeOp.getConstantTypesAttr(); }, builder,
call    0 never executed
        -:  349:              inputs);
     4608:  350:        });
call    0 returned 100%
call    1 returned 100%
        -:  351:  }
     1024:  352:}
        -:  353:
        -:  354:namespace {
        -:  355:
        -:  356:/// An op accepting a value at an optional index.
    #####:  357:struct OpIndex {
        -:  358:  Value parent;
        -:  359:  Optional<unsigned> index;
        -:  360:};
        -:  361:
        -:  362:/// The parent and operand index of each operation for each root, stored
        -:  363:/// as a nested map [root][operation].
        -:  364:using ParentMaps = DenseMap<Value, DenseMap<Value, OpIndex>>;
        -:  365:
        -:  366:} // namespace
        -:  367:
        -:  368:/// Given a pattern, determines the set of roots present in this pattern.
        -:  369:/// These are the operations whose results are not consumed by other operations.
function _ZL11detectRootsN4mlir3pdl9PatternOpE called 1024 returned 100% blocks executed 100%
     1024:  370:static SmallVector<Value> detectRoots(pdl::PatternOp pattern) {
        -:  371:  // First, collect all the operations that are used as operands
        -:  372:  // to other operations. These are not roots by default.
     1024:  373:  DenseSet<Value> used;
call    0 returned 100%
     2048:  374:  for (auto operationOp : pattern.getBodyRegion().getOps<pdl::OperationOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
     2048:  375:    for (Value operand : operationOp.getOperandValues())
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
call    4 returned 100%
     1024:  376:      TypeSwitch<Operation *>(operand.getDefiningOp())
call    0 returned 100%
call    1 returned 100%
        -:  377:          .Case<pdl::ResultOp, pdl::ResultsOp>(
    2048*:  378:              [&used](auto resultOp) { used.insert(resultOp.getParent()); });
call    0 returned 100%
------------------
_ZZL11detectRootsN4mlir3pdl9PatternOpEENKUlT_E_clINS0_9ResultsOpEEEDaS2_.isra.0:
function _ZZL11detectRootsN4mlir3pdl9PatternOpEENKUlT_E_clINS0_9ResultsOpEEEDaS2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  378:              [&used](auto resultOp) { used.insert(resultOp.getParent()); });
call    0 never executed
call    1 never executed
------------------
_ZZL11detectRootsN4mlir3pdl9PatternOpEENKUlT_E_clINS0_8ResultOpEEEDaS2_.isra.0:
function _ZZL11detectRootsN4mlir3pdl9PatternOpEENKUlT_E_clINS0_8ResultOpEEEDaS2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  378:              [&used](auto resultOp) { used.insert(resultOp.getParent()); });
call    0 never executed
call    1 never executed
------------------
        -:  379:  }
        -:  380:
        -:  381:  // Remove the specified root from the use set, so that we can
        -:  382:  // always select it as a root, even if it is used by other operations.
     1024:  383:  if (Value root = pattern.getRewriter().getRoot())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1024:  384:    used.erase(root);
call    0 returned 100%
        -:  385:
        -:  386:  // Finally, collect all the unused operations.
     1024:  387:  SmallVector<Value> roots;
call    0 returned 100%
     3072:  388:  for (Value operationOp : pattern.getBodyRegion().getOps<pdl::OperationOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
     1024:  389:    if (!used.contains(operationOp))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1024:  390:      roots.push_back(operationOp);
call    0 returned 100%
        -:  391:
     1024:  392:  return roots;
call    0 returned 100%
        -:  393:}
        -:  394:
        -:  395:/// Given a list of candidate roots, builds the cost graph for connecting them.
        -:  396:/// The graph is formed by traversing the DAG of operations starting from each
        -:  397:/// root and marking the depth of each connector value (operand). Then we join
        -:  398:/// the candidate roots based on the common connector values, taking the one
        -:  399:/// with the minimum depth. Along the way, we compute, for each candidate root,
        -:  400:/// a mapping from each operation (in the DAG underneath this root) to its
        -:  401:/// parent operation and the corresponding operand index.
function _ZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEE called 1024 returned 100% blocks executed 60%
     1024:  402:static void buildCostGraph(ArrayRef<Value> roots, RootOrderingGraph &graph,
        -:  403:                           ParentMaps &parentMaps) {
        -:  404:
        -:  405:  // The entry of a queue. The entry consists of the following items:
        -:  406:  // * the value in the DAG underneath the root;
        -:  407:  // * the parent of the value;
        -:  408:  // * the operand index of the value in its parent;
        -:  409:  // * the depth of the visited value.
     1024:  410:  struct Entry {
    1024*:  411:    Entry(Value value, Value parent, Optional<unsigned> index, unsigned depth)
    1024*:  412:        : value(value), parent(parent), index(index), depth(depth) {}
        -:  413:
        -:  414:    Value value;
        -:  415:    Value parent;
        -:  416:    Optional<unsigned> index;
        -:  417:    unsigned depth;
        -:  418:  };
        -:  419:
        -:  420:  // A root of a value and its depth (distance from root to the value).
     1024:  421:  struct RootDepth {
        -:  422:    Value root;
        -:  423:    unsigned depth = 0;
        -:  424:  };
        -:  425:
        -:  426:  // Map from candidate connector values to their roots and depths. Using a
        -:  427:  // small vector with 1 entry because most values belong to a single root.
     1024:  428:  llvm::MapVector<Value, SmallVector<RootDepth, 1>> connectorsRootsDepths;
call    0 returned 100%
        -:  429:
        -:  430:  // Perform a breadth-first traversal of the op DAG rooted at each root.
     2048:  431:  for (Value root : roots) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  432:    // The queue of visited values. A value may be present multiple times in
        -:  433:    // the queue, for multiple parents. We only accept the first occurrence,
        -:  434:    // which is guaranteed to have the lowest depth.
     2048:  435:    std::queue<Entry> toVisit;
call    0 returned 100%
     1024:  436:    toVisit.emplace(root, Value(), 0, 0);
call    0 returned 100%
        -:  437:
        -:  438:    // The map from value to its parent for the current root.
     1024:  439:    DenseMap<Value, OpIndex> &parentMap = parentMaps[root];
call    0 returned 100%
        -:  440:
     3072:  441:    while (!toVisit.empty()) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
     2048:  442:      Entry entry = toVisit.front();
call    0 returned 100%
     2048:  443:      toVisit.pop();
call    0 returned 100%
        -:  444:      // Skip if already visited.
    2048*:  445:      if (!parentMap.insert({entry.value, {entry.parent, entry.index}}).second)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  446:        continue;
        -:  447:
        -:  448:      // Mark the root and depth of the value.
     2048:  449:      connectorsRootsDepths[entry.value].push_back({root, entry.depth});
call    0 returned 100%
call    1 returned 100%
        -:  450:
        -:  451:      // Traverse the operands of an operation and result ops.
        -:  452:      // We intentionally do not traverse attributes and types, because those
        -:  453:      // are expensive to join on.
     2048:  454:      TypeSwitch<Operation *>(entry.value.getDefiningOp())
call    0 returned 100%
call    1 returned 100%
function _ZZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEEENKUlT_E_clINS1_3pdl11OperationOpEEEDaSN_.isra.0 called 1024 returned 100% blocks executed 50%
     1024:  455:          .Case<pdl::OperationOp>([&](auto operationOp) {
     1024:  456:            OperandRange operands = operationOp.getOperandValues();
call    0 returned 100%
        -:  457:            // Special case when we pass all the operands in one range.
        -:  458:            // For those, the index is empty.
     1024:  459:            if (operands.size() == 1 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    1024*:  460:                operands[0].getType().isa<pdl::RangeType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    2048*:  461:              toVisit.emplace(operands[0], entry.value, llvm::None,
     1024:  462:                              entry.depth + 1);
call    0 returned 100%
     1024:  463:              return;
        -:  464:            }
        -:  465:
        -:  466:            // Default case: visit all the operands.
    #####:  467:            for (const auto &p :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  468:                 llvm::enumerate(operationOp.getOperandValues()))
call    0 never executed
    #####:  469:              toVisit.emplace(p.value(), entry.value, p.index(),
    #####:  470:                              entry.depth + 1);
call    0 never executed
call    1 never executed
     2048:  471:          })
call    0 returned 100%
    #####:  472:          .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto resultOp) {
    #####:  473:            toVisit.emplace(resultOp.getParent(), entry.value,
    #####:  474:                            resultOp.getIndex(), entry.depth);
    4096*:  475:          });
call    0 returned 100%
------------------
_ZZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEEENKUlT_E0_clINS1_3pdl9ResultsOpEEEDaSN_.isra.0:
function _ZZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEEENKUlT_E0_clINS1_3pdl9ResultsOpEEEDaSN_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  472:          .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto resultOp) {
    #####:  473:            toVisit.emplace(resultOp.getParent(), entry.value,
call    0 never executed
call    1 never executed
    #####:  474:                            resultOp.getIndex(), entry.depth);
call    0 never executed
    #####:  475:          });
------------------
_ZZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEEENKUlT_E0_clINS1_3pdl8ResultOpEEEDaSN_.isra.0:
function _ZZL14buildCostGraphN4llvm8ArrayRefIN4mlir5ValueEEERNS_8DenseMapIS2_NS4_IS2_NS1_17pdl_to_pdl_interp17RootOrderingEntryENS_12DenseMapInfoIS2_vEENS_6detail12DenseMapPairIS2_S6_EEEES8_NSA_IS2_SC_EEEERNS4_IS2_NS4_IS2_N12_GLOBAL__N_17OpIndexES8_NSA_IS2_SH_EEEES8_NSA_IS2_SJ_EEEEENKUlT_E0_clINS1_3pdl8ResultOpEEEDaSN_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  472:          .Case<pdl::ResultOp, pdl::ResultsOp>([&](auto resultOp) {
    #####:  473:            toVisit.emplace(resultOp.getParent(), entry.value,
call    0 never executed
call    1 never executed
    #####:  474:                            resultOp.getIndex(), entry.depth);
call    0 never executed
    #####:  475:          });
------------------
        -:  476:    }
        -:  477:  }
        -:  478:
        -:  479:  // Now build the cost graph.
        -:  480:  // This is simply a minimum over all depths for the target root.
     1024:  481:  unsigned nextID = 0;
     3072:  482:  for (const auto &connectorRootsDepths : connectorsRootsDepths) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2048:  483:    Value value = connectorRootsDepths.first;
     2048:  484:    ArrayRef<RootDepth> rootsDepths = connectorRootsDepths.second;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  485:    // If there is only one root for this value, this will not trigger
        -:  486:    // any edges in the cost graph (a perf optimization).
     2048:  487:    if (rootsDepths.size() == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2048:  488:      continue;
        -:  489:
    #####:  490:    for (const RootDepth &p : rootsDepths) {
branch  0 never executed
branch  1 never executed
    #####:  491:      for (const RootDepth &q : rootsDepths) {
branch  0 never executed
branch  1 never executed
    #####:  492:        if (&p == &q)
branch  0 never executed
branch  1 never executed
    #####:  493:          continue;
        -:  494:        // Insert or retrieve the property of edge from p to q.
    #####:  495:        RootOrderingEntry &entry = graph[q.root][p.root];
call    0 never executed
call    1 never executed
    #####:  496:        if (!entry.connector /* new edge */ || entry.cost.first > q.depth) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  497:          if (!entry.connector)
branch  0 never executed
branch  1 never executed
    #####:  498:            entry.cost.second = nextID++;
    #####:  499:          entry.cost.first = q.depth;
    #####:  500:          entry.connector = value;
        -:  501:        }
        -:  502:      }
        -:  503:    }
        -:  504:  }
        -:  505:
    2048*:  506:  assert((llvm::hasSingleElement(roots) || graph.size() == roots.size()) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 returned 100%
        -:  507:         "the pattern contains a candidate root disconnected from the others");
     1024:  508:}
        -:  509:
        -:  510:/// Returns true if the operand at the given index needs to be queried using an
        -:  511:/// operand group, i.e., if it is variadic itself or follows a variadic operand.
function _ZL15useOperandGroupN4mlir3pdl11OperationOpEj called 0 returned 0% blocks executed 0%
    #####:  512:static bool useOperandGroup(pdl::OperationOp op, unsigned index) {
    #####:  513:  OperandRange operands = op.getOperandValues();
call    0 never executed
    #####:  514:  assert(index < operands.size() && "operand index out of range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  515:  for (unsigned i = 0; i <= index; ++i)
branch  0 never executed
branch  1 never executed
    #####:  516:    if (operands[i].getType().isa<pdl::RangeType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  517:      return true;
        -:  518:  return false;
        -:  519:}
        -:  520:
        -:  521:/// Visit a node during upward traversal.
function _ZL11visitUpwardRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EEN12_GLOBAL__N_17OpIndexERNS1_16PredicateBuilderERN4llvm8DenseMapINS0_5ValueEPNS1_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEERSE_j called 0 returned 0% blocks executed 0%
    #####:  522:static void visitUpward(std::vector<PositionalPredicate> &predList,
        -:  523:                        OpIndex opIndex, PredicateBuilder &builder,
        -:  524:                        DenseMap<Value, Position *> &valueToPosition,
        -:  525:                        Position *&pos, unsigned rootID) {
    #####:  526:  Value value = opIndex.parent;
    #####:  527:  TypeSwitch<Operation *>(value.getDefiningOp())
call    0 never executed
call    1 never executed
function _ZZL11visitUpwardRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EEN12_GLOBAL__N_17OpIndexERNS1_16PredicateBuilderERN4llvm8DenseMapINS0_5ValueEPNS1_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEERSE_jENKUlT_E_clINS0_3pdl11OperationOpEEEDaSN_ called 0 returned 0% blocks executed 0%
    #####:  528:      .Case<pdl::OperationOp>([&](auto operationOp) {
    #####:  529:        LLVM_DEBUG(llvm::dbgs() << "  * Value: " << value << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  530:
        -:  531:        // Get users and iterate over them.
    #####:  532:        Position *usersPos = builder.getUsers(pos, /*useRepresentative=*/true);
call    0 never executed
    #####:  533:        Position *foreachPos = builder.getForEach(usersPos, rootID);
call    0 never executed
    #####:  534:        OperationPosition *opPos = builder.getPassthroughOp(foreachPos);
call    0 never executed
        -:  535:
        -:  536:        // Compare the operand(s) of the user against the input value(s).
        -:  537:        Position *operandPos;
    #####:  538:        if (!opIndex.index) {
branch  0 never executed
branch  1 never executed
        -:  539:          // We are querying all the operands of the operation.
    #####:  540:          operandPos = builder.getAllOperands(opPos);
call    0 never executed
    #####:  541:        } else if (useOperandGroup(operationOp, *opIndex.index)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  542:          // We are querying an operand group.
    #####:  543:          Type type = operationOp.getOperandValues()[*opIndex.index].getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  544:          bool variadic = type.isa<pdl::RangeType>();
    #####:  545:          operandPos = builder.getOperandGroup(opPos, opIndex.index, variadic);
call    0 never executed
        -:  546:        } else {
        -:  547:          // We are querying an individual operand.
    #####:  548:          operandPos = builder.getOperand(opPos, *opIndex.index);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  549:        }
    #####:  550:        predList.emplace_back(operandPos, builder.getEqualTo(pos));
call    0 never executed
call    1 never executed
        -:  551:
        -:  552:        // Guard against duplicate upward visits. These are not possible,
        -:  553:        // because if this value was already visited, it would have been
        -:  554:        // cheaper to start the traversal at this value rather than at the
        -:  555:        // `connector`, violating the optimality of our spanning tree.
    #####:  556:        bool inserted = valueToPosition.try_emplace(value, opPos).second;
call    0 never executed
        -:  557:        (void)inserted;
    #####:  558:        assert(inserted && "duplicate upward visit");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  559:
        -:  560:        // Obtain the tree predicates at the current value.
    #####:  561:        getTreePredicates(predList, value, builder, valueToPosition, opPos,
call    0 never executed
        -:  562:                          opIndex.index);
        -:  563:
        -:  564:        // Update the position
    #####:  565:        pos = opPos;
    #####:  566:      })
call    0 never executed
function _ZZL11visitUpwardRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EEN12_GLOBAL__N_17OpIndexERNS1_16PredicateBuilderERN4llvm8DenseMapINS0_5ValueEPNS1_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEERSE_jENKUlT_E0_clINS0_3pdl8ResultOpEEEDaSN_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  567:      .Case<pdl::ResultOp>([&](auto resultOp) {
        -:  568:        // Traverse up an individual result.
    #####:  569:        auto *opPos = dyn_cast<OperationPosition>(pos);
branch  0 never executed
branch  1 never executed
    #####:  570:        assert(opPos && "operations and results must be interleaved");
call    0 never executed
    #####:  571:        pos = builder.getResult(opPos, *opIndex.index);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  572:
        -:  573:        // Insert the result position in case we have not visited it yet.
    #####:  574:        valueToPosition.try_emplace(value, pos);
call    0 never executed
    #####:  575:      })
call    0 never executed
function _ZZL11visitUpwardRSt6vectorIN4mlir17pdl_to_pdl_interp19PositionalPredicateESaIS2_EEN12_GLOBAL__N_17OpIndexERNS1_16PredicateBuilderERN4llvm8DenseMapINS0_5ValueEPNS1_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEERSE_jENKUlT_E1_clINS0_3pdl9ResultsOpEEEDaSN_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  576:      .Case<pdl::ResultsOp>([&](auto resultOp) {
        -:  577:        // Traverse up a group of results.
    #####:  578:        auto *opPos = dyn_cast<OperationPosition>(pos);
branch  0 never executed
branch  1 never executed
    #####:  579:        assert(opPos && "operations and results must be interleaved");
call    0 never executed
    #####:  580:        bool isVariadic = value.getType().isa<pdl::RangeType>();
call    0 never executed
    #####:  581:        if (opIndex.index)
branch  0 never executed
branch  1 never executed
    #####:  582:          pos = builder.getResultGroup(opPos, opIndex.index, isVariadic);
call    0 never executed
        -:  583:        else
    #####:  584:          pos = builder.getAllResults(opPos);
call    0 never executed
        -:  585:
        -:  586:        // Insert the result position in case we have not visited it yet.
    #####:  587:        valueToPosition.try_emplace(value, pos);
call    0 never executed
    #####:  588:      });
call    0 never executed
    #####:  589:}
        -:  590:
        -:  591:/// Given a pattern operation, build the set of matcher predicates necessary to
        -:  592:/// match this pattern.
function _ZL18buildPredicateListN4mlir3pdl9PatternOpERNS_17pdl_to_pdl_interp16PredicateBuilderERSt6vectorINS2_19PositionalPredicateESaIS6_EERN4llvm8DenseMapINS_5ValueEPNS2_8PositionENSA_12DenseMapInfoISC_vEENSA_6detail12DenseMapPairISC_SE_EEEE called 1024 returned 100% blocks executed 21%
     1024:  593:static Value buildPredicateList(pdl::PatternOp pattern,
        -:  594:                                PredicateBuilder &builder,
        -:  595:                                std::vector<PositionalPredicate> &predList,
        -:  596:                                DenseMap<Value, Position *> &valueToPosition) {
     1024:  597:  SmallVector<Value> roots = detectRoots(pattern);
call    0 returned 100%
        -:  598:
        -:  599:  // Build the root ordering graph and compute the parent maps.
     2048:  600:  RootOrderingGraph graph;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1024:  601:  ParentMaps parentMaps;
call    0 returned 100%
     1024:  602:  buildCostGraph(roots, graph, parentMaps);
call    0 returned 100%
    1024*:  603:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
        -:  604:    llvm::dbgs() << "Graph:\n";
        -:  605:    for (auto &target : graph) {
        -:  606:      llvm::dbgs() << "  * " << target.first.getLoc() << " " << target.first
        -:  607:                   << "\n";
        -:  608:      for (auto &source : target.second) {
        -:  609:        RootOrderingEntry &entry = source.second;
        -:  610:        llvm::dbgs() << "      <- " << source.first << ": " << entry.cost.first
        -:  611:                     << ":" << entry.cost.second << " via "
        -:  612:                     << entry.connector.getLoc() << "\n";
        -:  613:      }
        -:  614:    }
        -:  615:  });
        -:  616:
        -:  617:  // Solve the optimal branching problem for each candidate root, or use the
        -:  618:  // provided one.
     1024:  619:  Value bestRoot = pattern.getRewriter().getRoot();
call    0 returned 100%
call    1 returned 100%
     2048:  620:  OptimalBranching::EdgeList bestEdges;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
     1024:  621:  if (!bestRoot) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  622:    unsigned bestCost = 0;
    #####:  623:    LLVM_DEBUG(llvm::dbgs() << "Candidate roots:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  624:    for (Value root : roots) {
branch  0 never executed
branch  1 never executed
    #####:  625:      OptimalBranching solver(graph, root);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  626:      unsigned cost = solver.solve();
call    0 never executed
    #####:  627:      LLVM_DEBUG(llvm::dbgs() << "  * " << root << ": " << cost << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
    #####:  628:      if (!bestRoot || bestCost > cost) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  629:        bestCost = cost;
    #####:  630:        bestRoot = root;
    #####:  631:        bestEdges = solver.preOrderTraversal(roots);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  632:      }
        -:  633:    }
        -:  634:  } else {
     2048:  635:    OptimalBranching solver(graph, bestRoot);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1024:  636:    solver.solve();
call    0 returned 100%
     1024:  637:    bestEdges = solver.preOrderTraversal(roots);
call    0 returned 100%
call    1 returned 100%
        -:  638:  }
        -:  639:
        -:  640:  // Print the best solution.
    1024*:  641:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
        -:  642:    llvm::dbgs() << "Best tree:\n";
        -:  643:    for (const std::pair<Value, Value> &edge : bestEdges) {
        -:  644:      llvm::dbgs() << "  * " << edge.first;
        -:  645:      if (edge.second)
        -:  646:        llvm::dbgs() << " <- " << edge.second;
        -:  647:      llvm::dbgs() << "\n";
        -:  648:    }
        -:  649:  });
        -:  650:
    1024*:  651:  LLVM_DEBUG(llvm::dbgs() << "Calling key getTreePredicates:\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    1024*:  652:  LLVM_DEBUG(llvm::dbgs() << "  * Value: " << bestRoot << "\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  653:
        -:  654:  // The best root is the starting point for the traversal. Get the tree
        -:  655:  // predicates for the DAG rooted at bestRoot.
     1024:  656:  getTreePredicates(predList, bestRoot, builder, valueToPosition,
call    0 returned 100%
call    1 returned 100%
        -:  657:                    builder.getRoot());
        -:  658:
        -:  659:  // Traverse the selected optimal branching. For all edges in order, traverse
        -:  660:  // up starting from the connector, until the candidate root is reached, and
        -:  661:  // call getTreePredicates at every node along the way.
     2048:  662:  for (const auto &it : llvm::enumerate(bestEdges)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1024:  663:    Value target = it.value().first;
call    0 returned 100%
     1024:  664:    Value source = it.value().second;
        -:  665:
        -:  666:    // Check if we already visited the target root. This happens in two cases:
        -:  667:    // 1) the initial root (bestRoot);
        -:  668:    // 2) a root that is dominated by (contained in the subtree rooted at) an
        -:  669:    //    already visited root.
    1024*:  670:    if (valueToPosition.count(target))
call    0 returned 100%
     1024:  671:      continue;
        -:  672:
        -:  673:    // Determine the connector.
    #####:  674:    Value connector = graph[target][source].connector;
call    0 never executed
call    1 never executed
    #####:  675:    assert(connector && "invalid edge");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  676:    LLVM_DEBUG(llvm::dbgs() << "  * Connector: " << connector.getLoc() << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
    #####:  677:    DenseMap<Value, OpIndex> parentMap = parentMaps.lookup(target);
call    0 never executed
    #####:  678:    Position *pos = valueToPosition.lookup(connector);
call    0 never executed
    #####:  679:    assert(pos && "connector has not been traversed yet");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  680:
        -:  681:    // Traverse from the connector upwards towards the target root.
    #####:  682:    for (Value value = connector; value != target;) {
branch  0 never executed
branch  1 never executed
    #####:  683:      OpIndex opIndex = parentMap.lookup(value);
call    0 never executed
    #####:  684:      assert(opIndex.parent && "missing parent");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  685:      visitUpward(predList, opIndex, builder, valueToPosition, pos, it.index());
call    0 never executed
    #####:  686:      value = opIndex.parent;
        -:  687:    }
        -:  688:  }
        -:  689:
     1024:  690:  getNonTreePredicates(pattern, predList, builder, valueToPosition);
call    0 returned 100%
        -:  691:
     1024:  692:  return bestRoot;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  693:}
        -:  694:
        -:  695://===----------------------------------------------------------------------===//
        -:  696:// Pattern Predicate Tree Merging
        -:  697://===----------------------------------------------------------------------===//
        -:  698:
        -:  699:namespace {
        -:  700:
        -:  701:/// This class represents a specific predicate applied to a position, and
        -:  702:/// provides hashing and ordering operators. This class allows for computing a
        -:  703:/// frequence sum and ordering predicates based on a cost model.
   35840*:  704:struct OrderedPredicate {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
    2560*:  705:  OrderedPredicate(const std::pair<Position *, Qualifier *> &ip)
call    0 never executed
call    1 returned 100%
call    2 returned 100%
    3072*:  706:      : position(ip.first), question(ip.second) {}
call    0 never executed
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2048:  707:  OrderedPredicate(const PositionalPredicate &ip)
     4096:  708:      : position(ip.position), question(ip.question) {}
        -:  709:
        -:  710:  /// The position this predicate is applied to.
        -:  711:  Position *position;
        -:  712:
        -:  713:  /// The question that is applied by this predicate onto the position.
        -:  714:  Qualifier *question;
        -:  715:
        -:  716:  /// The first and second order benefit sums.
        -:  717:  /// The primary sum is the number of occurrences of this predicate among all
        -:  718:  /// of the patterns.
        -:  719:  unsigned primary = 0;
        -:  720:  /// The secondary sum is a squared summation of the primary sum of all of the
        -:  721:  /// predicates within each pattern that contains this predicate. This allows
        -:  722:  /// for favoring predicates that are more commonly shared within a pattern, as
        -:  723:  /// opposed to those shared across patterns.
        -:  724:  unsigned secondary = 0;
        -:  725:
        -:  726:  /// The tie breaking ID, used to preserve a deterministic (insertion) order
        -:  727:  /// among all the predicates with the same priority, depth, and position /
        -:  728:  /// predicate dependency.
        -:  729:  unsigned id = 0;
        -:  730:
        -:  731:  /// A map between a pattern operation and the answer to the predicate question
        -:  732:  /// within that pattern.
        -:  733:  DenseMap<Operation *, Qualifier *> patternToAnswer;
        -:  734:
        -:  735:  /// Returns true if this predicate is ordered before `rhs`, based on the cost
        -:  736:  /// model.
function _ZNK12_GLOBAL__N_116OrderedPredicateltERKS0_ called 773 returned 100% blocks executed 100%
      773:  737:  bool operator<(const OrderedPredicate &rhs) const {
        -:  738:    // Sort by:
        -:  739:    // * higher first and secondary order sums
        -:  740:    // * lower depth
        -:  741:    // * lower position dependency
        -:  742:    // * lower predicate dependency
        -:  743:    // * lower tie breaking ID
      773:  744:    auto *rhsPos = rhs.position;
      773:  745:    return std::make_tuple(primary, secondary, rhsPos->getOperationDepth(),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      773:  746:                           rhsPos->getKind(), rhs.question->getKind(), rhs.id) >
call    0 returned 100%
      773:  747:           std::make_tuple(rhs.primary, rhs.secondary,
call    0 returned 100%
      773:  748:                           position->getOperationDepth(), position->getKind(),
call    0 returned 100%
      773:  749:                           question->getKind(), id);
call    0 returned 100%
        -:  750:  }
        -:  751:};
        -:  752:
        -:  753:/// A DenseMapInfo for OrderedPredicate based solely on the position and
        -:  754:/// question.
        -:  755:struct OrderedPredicateDenseInfo {
        -:  756:  using Base = DenseMapInfo<std::pair<Position *, Qualifier *>>;
        -:  757:
    3072*:  758:  static OrderedPredicate getEmptyKey() { return Base::getEmptyKey(); }
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
    2560*:  759:  static OrderedPredicate getTombstoneKey() { return Base::getTombstoneKey(); }
call    0 never executed
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
   39990*:  760:  static bool isEqual(const OrderedPredicate &lhs,
        -:  761:                      const OrderedPredicate &rhs) {
   37942*:  762:    return lhs.position == rhs.position && lhs.question == rhs.question;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 never executed
branch 11 never executed
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
branch 14 never executed
branch 15 never executed
branch 16 taken 50% (fallthrough)
branch 17 taken 50%
branch 18 taken 2% (fallthrough)
branch 19 taken 98%
branch 20 taken 98% (fallthrough)
branch 21 taken 2%
branch 22 taken 0% (fallthrough)
branch 23 taken 100%
branch 24 taken 0% (fallthrough)
branch 25 taken 100%
branch 26 never executed
branch 27 never executed
call   28 returned 100%
        -:  763:  }
     2048:  764:  static unsigned getHashValue(const OrderedPredicate &p) {
     2048:  765:    return llvm::hash_combine(p.position, p.question);
call    0 returned 100%
        -:  766:  }
        -:  767:};
        -:  768:
        -:  769:/// This class wraps a set of ordered predicates that are used within a specific
        -:  770:/// pattern operation.
    2048*:  771:struct OrderedPredicateList {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 returned 100%
     1024:  772:  OrderedPredicateList(pdl::PatternOp pattern, Value root)
     2048:  773:      : pattern(pattern), root(root) {}
        -:  774:
        -:  775:  pdl::PatternOp pattern;
        -:  776:  Value root;
        -:  777:  DenseSet<OrderedPredicate *> predicates;
        -:  778:};
        -:  779:} // namespace
        -:  780:
        -:  781:/// Returns true if the given matcher refers to the same predicate as the given
        -:  782:/// ordered predicate. This means that the position and questions of the two
        -:  783:/// match.
     1536:  784:static bool isSamePredicate(MatcherNode *node, OrderedPredicate *predicate) {
     1536:  785:  return node->getPosition() == predicate->position &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     1536:  786:         node->getQuestion() == predicate->question;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  787:}
        -:  788:
        -:  789:/// Get or insert a child matcher for the given parent switch node, given a
        -:  790:/// predicate and parent pattern.
function _Z16getOrCreateChildPN4mlir17pdl_to_pdl_interp10SwitchNodeEPN12_GLOBAL__N_116OrderedPredicateENS_3pdl9PatternOpE called 1024 returned 100% blocks executed 71%
     1024:  791:std::unique_ptr<MatcherNode> &getOrCreateChild(SwitchNode *node,
        -:  792:                                               OrderedPredicate *predicate,
        -:  793:                                               pdl::PatternOp pattern) {
    1024*:  794:  assert(isSamePredicate(node, predicate) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        -:  795:         "expected matcher to equal the given predicate");
        -:  796:
     1024:  797:  auto it = predicate->patternToAnswer.find(pattern);
call    0 returned 100%
    1024*:  798:  assert(it != predicate->patternToAnswer.end() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
call    4 never executed
        -:  799:         "expected pattern to exist in predicate");
     1024:  800:  return node->getChildren().insert({it->second, nullptr}).first->second;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  801:}
        -:  802:
        -:  803:/// Build the matcher CFG by "pushing" patterns through by sorted predicate
        -:  804:/// order. A pattern will traverse as far as possible using common predicates
        -:  805:/// and then either diverge from the CFG or reach the end of a branch and start
        -:  806:/// creating new nodes.
function _ZL16propagatePatternRSt10unique_ptrIN4mlir17pdl_to_pdl_interp11MatcherNodeESt14default_deleteIS2_EERN12_GLOBAL__N_120OrderedPredicateListEN9__gnu_cxx17__normal_iteratorIPPNS7_16OrderedPredicateESt6vectorISD_SaISD_EEEESI_ called 3584 returned 100% blocks executed 70%
     3584:  807:static void propagatePattern(std::unique_ptr<MatcherNode> &node,
        -:  808:                             OrderedPredicateList &list,
        -:  809:                             std::vector<OrderedPredicate *>::iterator current,
        -:  810:                             std::vector<OrderedPredicate *>::iterator end) {
     3584:  811:  if (current == end) {
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        -:  812:    // We've hit the end of a pattern, so create a successful result node.
     1024:  813:    node =
call    0 returned 100%
     1024:  814:        std::make_unique<SuccessNode>(list.pattern, list.root, std::move(node));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  815:
        -:  816:    // If the pattern doesn't contain this predicate, ignore it.
     2560:  817:  } else if (list.predicates.find(*current) == list.predicates.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
     1024:  818:    propagatePattern(node, list, std::next(current), end);
call    0 returned 100%
        -:  819:
        -:  820:    // If the current matcher node is invalid, create a new one for this
        -:  821:    // position and continue propagation.
     1536:  822:  } else if (!node) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  823:    // Create a new node at this position and continue
     1024:  824:    node = std::make_unique<SwitchNode>((*current)->position,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2048:  825:                                        (*current)->question);
call    0 returned 100%
call    1 returned 100%
     1024:  826:    propagatePattern(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1024:  827:        getOrCreateChild(cast<SwitchNode>(&*node), *current, list.pattern),
call    0 returned 100%
        -:  828:        list, std::next(current), end);
        -:  829:
        -:  830:    // If the matcher has already been created, and it is for this predicate we
        -:  831:    // continue propagation to the child.
     512*:  832:  } else if (isSamePredicate(node.get(), *current)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  833:    propagatePattern(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  834:        getOrCreateChild(cast<SwitchNode>(&*node), *current, list.pattern),
call    0 never executed
        -:  835:        list, std::next(current), end);
        -:  836:
        -:  837:    // If the matcher doesn't match the current predicate, insert a branch as
        -:  838:    // the common set of matchers has diverged.
        -:  839:  } else {
      512:  840:    propagatePattern(node->getFailureNode(), list, current, end);
call    0 returned 100%
        -:  841:  }
     3584:  842:}
        -:  843:
        -:  844:/// Fold any switch nodes nested under `node` to boolean nodes when possible.
        -:  845:/// `node` is updated in-place if it is a switch.
function _ZL16foldSwitchToBoolRSt10unique_ptrIN4mlir17pdl_to_pdl_interp11MatcherNodeESt14default_deleteIS2_EE called 4122 returned 100% blocks executed 86%
     4122:  846:static void foldSwitchToBool(std::unique_ptr<MatcherNode> &node) {
     4122:  847:  if (!node)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  848:    return;
        -:  849:
     2048:  850:  if (SwitchNode *switchNode = dyn_cast<SwitchNode>(&*node)) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
     1024:  851:    SwitchNode::ChildMapT &children = switchNode->getChildren();
     2048:  852:    for (auto &it : children)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1024:  853:      foldSwitchToBool(it.second);
call    0 returned 100%
        -:  854:
        -:  855:    // If the node only contains one child, collapse it into a boolean predicate
        -:  856:    // node.
     1024:  857:    if (children.size() == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1024:  858:      auto childIt = children.begin();
call    0 returned 100%
     1024:  859:      node = std::make_unique<BoolNode>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     2048:  860:          node->getPosition(), node->getQuestion(), childIt->first,
call    0 returned 100%
     2048:  861:          std::move(childIt->second), std::move(node->getFailureNode()));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  862:    }
     1024:  863:  } else if (BoolNode *boolNode = dyn_cast<BoolNode>(&*node)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  864:    foldSwitchToBool(boolNode->getSuccessNode());
call    0 never executed
        -:  865:  }
        -:  866:
     2048:  867:  foldSwitchToBool(node->getFailureNode());
call    0 returned 100%
        -:  868:}
        -:  869:
        -:  870:/// Insert an exit node at the end of the failure path of the `root`.
function _ZL14insertExitNodePSt10unique_ptrIN4mlir17pdl_to_pdl_interp11MatcherNodeESt14default_deleteIS2_EE called 1050 returned 100% blocks executed 64%
     1050:  871:static void insertExitNode(std::unique_ptr<MatcherNode> *root) {
     2074:  872:  while (*root)
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
     1024:  873:    root = &(*root)->getFailureNode();
     1050:  874:  *root = std::make_unique<ExitNode>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     1050:  875:}
        -:  876:
        -:  877:/// Given a module containing PDL pattern operations, generate a matcher tree
        -:  878:/// using the patterns within the given module and return the root matcher node.
        -:  879:std::unique_ptr<MatcherNode>
function _ZN4mlir17pdl_to_pdl_interp11MatcherNode19generateMatcherTreeENS_8ModuleOpERNS0_16PredicateBuilderERN4llvm8DenseMapINS_5ValueEPNS0_8PositionENS5_12DenseMapInfoIS7_vEENS5_6detail12DenseMapPairIS7_S9_EEEE called 1050 returned 100% blocks executed 97%
     1050:  880:MatcherNode::generateMatcherTree(ModuleOp module, PredicateBuilder &builder,
        -:  881:                                 DenseMap<Value, Position *> &valueToPosition) {
        -:  882:  // The set of predicates contained within the pattern operations of the
        -:  883:  // module.
    2048*:  884:  struct PatternPredicates {
branch  0 never executed
branch  1 never executed
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    1024*:  885:    PatternPredicates(pdl::PatternOp pattern, Value root,
        -:  886:                      std::vector<PositionalPredicate> predicates)
    1024*:  887:        : pattern(pattern), root(root), predicates(std::move(predicates)) {}
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  888:
        -:  889:    /// A pattern.
        -:  890:    pdl::PatternOp pattern;
        -:  891:
        -:  892:    /// A root of the pattern chosen among the candidate roots in pdl.rewrite.
        -:  893:    Value root;
        -:  894:
        -:  895:    /// The extracted predicates for this pattern and root.
        -:  896:    std::vector<PositionalPredicate> predicates;
        -:  897:  };
        -:  898:
     1050:  899:  SmallVector<PatternPredicates, 16> patternsAndPredicates;
call    0 returned 100%
     2074:  900:  for (pdl::PatternOp pattern : module.getOps<pdl::PatternOp>()) {
call    0 returned 100%
branch  1 taken 49% (fallthrough)
branch  2 taken 51%
call    3 returned 100%
     2048:  901:    std::vector<PositionalPredicate> predicateList;
call    0 returned 100%
call    1 returned 100%
     1024:  902:    Value root =
     1024:  903:        buildPredicateList(pattern, builder, predicateList, valueToPosition);
call    0 returned 100%
     1024:  904:    patternsAndPredicates.emplace_back(pattern, root, std::move(predicateList));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  905:  }
        -:  906:
        -:  907:  // Associate a pattern result with each unique predicate.
     2100:  908:  DenseSet<OrderedPredicate, OrderedPredicateDenseInfo> uniqued;
call    0 returned 100%
call    1 returned 100%
     2074:  909:  for (auto &patternAndPredList : patternsAndPredicates) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
     2048:  910:    for (auto &predicate : patternAndPredList.predicates) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1024:  911:      auto it = uniqued.insert(predicate);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1024:  912:      it.first->patternToAnswer.try_emplace(patternAndPredList.pattern,
call    0 returned 100%
     1024:  913:                                            predicate.answer);
call    0 returned 100%
        -:  914:      // Mark the insertion order (0-based indexing).
     1024:  915:      if (it.second)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1024:  916:        it.first->id = uniqued.size() - 1;
call    0 returned 100%
        -:  917:    }
        -:  918:  }
        -:  919:
        -:  920:  // Associate each pattern to a set of its ordered predicates for later lookup.
     2100:  921:  std::vector<OrderedPredicateList> lists;
call    0 returned 100%
call    1 returned 100%
     1050:  922:  lists.reserve(patternsAndPredicates.size());
call    0 returned 100%
     2074:  923:  for (auto &patternAndPredList : patternsAndPredicates) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
     1024:  924:    OrderedPredicateList list(patternAndPredList.pattern,
call    0 returned 100%
     1024:  925:                              patternAndPredList.root);
     2048:  926:    for (auto &predicate : patternAndPredList.predicates) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1024:  927:      OrderedPredicate *orderedPredicate = &*uniqued.find(predicate);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1024:  928:      list.predicates.insert(orderedPredicate);
call    0 returned 100%
        -:  929:
        -:  930:      // Increment the primary sum for each reference to a particular predicate.
     1024:  931:      ++orderedPredicate->primary;
        -:  932:    }
     1024:  933:    lists.push_back(std::move(list));
call    0 returned 100%
call    1 returned 100%
        -:  934:  }
        -:  935:
        -:  936:  // For a particular pattern, get the total primary sum and add it to the
        -:  937:  // secondary sum of each predicate. Square the primary sums to emphasize
        -:  938:  // shared predicates within rather than across patterns.
     2074:  939:  for (auto &list : lists) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
call    2 returned 100%
     1024:  940:    unsigned total = 0;
     2048:  941:    for (auto *predicate : list.predicates)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
     1024:  942:      total += predicate->primary * predicate->primary;
call    0 returned 100%
     2048:  943:    for (auto *predicate : list.predicates)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
     1024:  944:      predicate->secondary += total;
call    0 returned 100%
        -:  945:  }
        -:  946:
        -:  947:  // Sort the set of predicates now that the cost primary and secondary sums
        -:  948:  // have been computed.
     2100:  949:  std::vector<OrderedPredicate *> ordered;
call    0 returned 100%
call    1 returned 100%
     1050:  950:  ordered.reserve(uniqued.size());
call    0 returned 100%
     2074:  951:  for (auto &ip : uniqued)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 49% (fallthrough)
branch  4 taken 51%
     1024:  952:    ordered.push_back(&ip);
call    0 returned 100%
call    1 returned 100%
     1050:  953:  llvm::sort(ordered, [](OrderedPredicate *lhs, OrderedPredicate *rhs) {
call    0 returned 100%
        -:  954:    return *lhs < *rhs;
        -:  955:  });
        -:  956:
        -:  957:  // Build the matchers for each of the pattern predicate lists.
     1050:  958:  std::unique_ptr<MatcherNode> root;
     2074:  959:  for (OrderedPredicateList &list : lists)
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
call    2 returned 100%
     1024:  960:    propagatePattern(root, list, ordered.begin(), ordered.end());
call    0 returned 100%
        -:  961:
        -:  962:  // Collapse the graph and insert the exit node.
     1050:  963:  foldSwitchToBool(root);
call    0 returned 100%
     1050:  964:  insertExitNode(&root);
call    0 returned 100%
     1050:  965:  return root;
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  966:}
        -:  967:
        -:  968://===----------------------------------------------------------------------===//
        -:  969:// MatcherNode
        -:  970://===----------------------------------------------------------------------===//
        -:  971:
function _ZN4mlir17pdl_to_pdl_interp11MatcherNodeC2ENS_6TypeIDEPNS0_8PositionEPNS0_9QualifierESt10unique_ptrIS1_St14default_deleteIS1_EE called 0 returned 0% blocks executed 0%
    4122*:  972:MatcherNode::MatcherNode(TypeID matcherTypeID, Position *p, Qualifier *q,
    4122*:  973:                         std::unique_ptr<MatcherNode> failureNode)
    1024*:  974:    : position(p), question(q), failureNode(std::move(failureNode)),
call    0 returned 100%
    4122*:  975:      matcherTypeID(matcherTypeID) {}
        -:  976:
        -:  977://===----------------------------------------------------------------------===//
        -:  978:// BoolNode
        -:  979://===----------------------------------------------------------------------===//
        -:  980:
function _ZN4mlir17pdl_to_pdl_interp8BoolNodeC2EPNS0_8PositionEPNS0_9QualifierES5_St10unique_ptrINS0_11MatcherNodeESt14default_deleteIS7_EESA_ called 0 returned 0% blocks executed 0%
    1024*:  981:BoolNode::BoolNode(Position *position, Qualifier *question, Qualifier *answer,
        -:  982:                   std::unique_ptr<MatcherNode> successNode,
    1024*:  983:                   std::unique_ptr<MatcherNode> failureNode)
        -:  984:    : MatcherNode(TypeID::get<BoolNode>(), position, question,
    1024*:  985:                  std::move(failureNode)),
call    0 returned 100%
call    1 never executed
    1024*:  986:      answer(answer), successNode(std::move(successNode)) {}
call    0 returned 100%
call    1 never executed
        -:  987:
        -:  988://===----------------------------------------------------------------------===//
        -:  989:// SuccessNode
        -:  990://===----------------------------------------------------------------------===//
        -:  991:
function _ZN4mlir17pdl_to_pdl_interp11SuccessNodeC2ENS_3pdl9PatternOpENS_5ValueESt10unique_ptrINS0_11MatcherNodeESt14default_deleteIS6_EE called 0 returned 0% blocks executed 0%
    1024*:  992:SuccessNode::SuccessNode(pdl::PatternOp pattern, Value root,
    1024*:  993:                         std::unique_ptr<MatcherNode> failureNode)
        -:  994:    : MatcherNode(TypeID::get<SuccessNode>(), /*position=*/nullptr,
    1024*:  995:                  /*question=*/nullptr, std::move(failureNode)),
call    0 returned 100%
call    1 never executed
    1024*:  996:      pattern(pattern), root(root) {}
call    0 returned 100%
call    1 never executed
        -:  997:
        -:  998://===----------------------------------------------------------------------===//
        -:  999:// SwitchNode
        -: 1000://===----------------------------------------------------------------------===//
        -: 1001:
function _ZN4mlir17pdl_to_pdl_interp10SwitchNodeC2EPNS0_8PositionEPNS0_9QualifierE called 1024 returned 100% blocks executed 100%
     1024: 1002:SwitchNode::SwitchNode(Position *position, Qualifier *question)
     1024: 1003:    : MatcherNode(TypeID::get<SwitchNode>(), position, question) {}
call    0 returned 100%
call    1 returned 100%
